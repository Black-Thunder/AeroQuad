   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 4
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"AeroQuadMain.cpp"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.timer_set_compare,"ax",%progbits
  20              		.align	1
  21              		.thumb
  22              		.thumb_func
  24              	timer_set_compare:
  25              	.LFB30:
  26              		.file 1 "../Libmaple/libmaple/libmaple/timer.h"
   1:../Libmaple/libmaple/libmaple/timer.h **** /******************************************************************************
   2:../Libmaple/libmaple/libmaple/timer.h ****  * The MIT License
   3:../Libmaple/libmaple/libmaple/timer.h ****  *
   4:../Libmaple/libmaple/libmaple/timer.h ****  * Copyright (c) 2011 LeafLabs, LLC.
   5:../Libmaple/libmaple/libmaple/timer.h ****  *
   6:../Libmaple/libmaple/libmaple/timer.h ****  * Permission is hereby granted, free of charge, to any person
   7:../Libmaple/libmaple/libmaple/timer.h ****  * obtaining a copy of this software and associated documentation
   8:../Libmaple/libmaple/libmaple/timer.h ****  * files (the "Software"), to deal in the Software without
   9:../Libmaple/libmaple/libmaple/timer.h ****  * restriction, including without limitation the rights to use, copy,
  10:../Libmaple/libmaple/libmaple/timer.h ****  * modify, merge, publish, distribute, sublicense, and/or sell copies
  11:../Libmaple/libmaple/libmaple/timer.h ****  * of the Software, and to permit persons to whom the Software is
  12:../Libmaple/libmaple/libmaple/timer.h ****  * furnished to do so, subject to the following conditions:
  13:../Libmaple/libmaple/libmaple/timer.h ****  *
  14:../Libmaple/libmaple/libmaple/timer.h ****  * The above copyright notice and this permission notice shall be
  15:../Libmaple/libmaple/libmaple/timer.h ****  * included in all copies or substantial portions of the Software.
  16:../Libmaple/libmaple/libmaple/timer.h ****  *
  17:../Libmaple/libmaple/libmaple/timer.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  18:../Libmaple/libmaple/libmaple/timer.h ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  19:../Libmaple/libmaple/libmaple/timer.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20:../Libmaple/libmaple/libmaple/timer.h ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  21:../Libmaple/libmaple/libmaple/timer.h ****  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  22:../Libmaple/libmaple/libmaple/timer.h ****  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  23:../Libmaple/libmaple/libmaple/timer.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  24:../Libmaple/libmaple/libmaple/timer.h ****  * SOFTWARE.
  25:../Libmaple/libmaple/libmaple/timer.h ****  *****************************************************************************/
  26:../Libmaple/libmaple/libmaple/timer.h **** 
  27:../Libmaple/libmaple/libmaple/timer.h **** /**
  28:../Libmaple/libmaple/libmaple/timer.h ****  * @file   timer.h
  29:../Libmaple/libmaple/libmaple/timer.h ****  * @author Marti Bolivar <mbolivar@leaflabs.com>
  30:../Libmaple/libmaple/libmaple/timer.h ****  * @brief  New-style timer interface.
  31:../Libmaple/libmaple/libmaple/timer.h ****  *
  32:../Libmaple/libmaple/libmaple/timer.h ****  * Replaces old timers.h implementation.
  33:../Libmaple/libmaple/libmaple/timer.h ****  */
  34:../Libmaple/libmaple/libmaple/timer.h **** 
  35:../Libmaple/libmaple/libmaple/timer.h **** #ifndef _TIMERS_H_
  36:../Libmaple/libmaple/libmaple/timer.h **** #define _TIMERS_H_
  37:../Libmaple/libmaple/libmaple/timer.h **** 
  38:../Libmaple/libmaple/libmaple/timer.h **** #include "libmaple.h"
  39:../Libmaple/libmaple/libmaple/timer.h **** #include "rcc.h"
  40:../Libmaple/libmaple/libmaple/timer.h **** #include "nvic.h"
  41:../Libmaple/libmaple/libmaple/timer.h **** #include "bitband.h"
  42:../Libmaple/libmaple/libmaple/timer.h **** 
  43:../Libmaple/libmaple/libmaple/timer.h **** #ifdef __cplusplus
  44:../Libmaple/libmaple/libmaple/timer.h **** extern "C"{
  45:../Libmaple/libmaple/libmaple/timer.h **** #endif
  46:../Libmaple/libmaple/libmaple/timer.h **** 
  47:../Libmaple/libmaple/libmaple/timer.h **** /*
  48:../Libmaple/libmaple/libmaple/timer.h ****  * Register maps and devices
  49:../Libmaple/libmaple/libmaple/timer.h ****  */
  50:../Libmaple/libmaple/libmaple/timer.h **** 
  51:../Libmaple/libmaple/libmaple/timer.h **** /** Advanced control timer register map type */
  52:../Libmaple/libmaple/libmaple/timer.h **** typedef struct timer_adv_reg_map {
  53:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR1;            /**< Control register 1 */
  54:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR2;            /**< Control register 2 */
  55:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 SMCR;           /**< Slave mode control register */
  56:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DIER;           /**< DMA/Interrupt enable register */
  57:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 SR;             /**< Status register */
  58:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 EGR;            /**< Event generation register  */
  59:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCMR1;          /**< Capture/compare mode register 1 */
  60:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCMR2;          /**< Capture/compare mode register 2 */
  61:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCER;           /**< Capture/compare enable register */
  62:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CNT;            /**< Counter */
  63:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 PSC;            /**< Prescaler */
  64:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 ARR;            /**< Auto-reload register */
  65:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 RCR;            /**< Repetition counter register */
  66:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR1;           /**< Capture/compare register 1 */
  67:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR2;           /**< Capture/compare register 2 */
  68:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR3;           /**< Capture/compare register 3 */
  69:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR4;           /**< Capture/compare register 4 */
  70:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 BDTR;           /**< Break and dead-time register */
  71:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DCR;            /**< DMA control register */
  72:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DMAR;           /**< DMA address for full transfer */
  73:../Libmaple/libmaple/libmaple/timer.h **** } timer_adv_reg_map;
  74:../Libmaple/libmaple/libmaple/timer.h **** 
  75:../Libmaple/libmaple/libmaple/timer.h **** /** General purpose timer register map type */
  76:../Libmaple/libmaple/libmaple/timer.h **** typedef struct timer_gen_reg_map {
  77:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR1;            /**< Control register 1 */
  78:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR2;            /**< Control register 2 */
  79:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 SMCR;           /**< Slave mode control register */
  80:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DIER;           /**< DMA/Interrupt enable register */
  81:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 SR;             /**< Status register */
  82:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 EGR;            /**< Event generation register  */
  83:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCMR1;          /**< Capture/compare mode register 1 */
  84:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCMR2;          /**< Capture/compare mode register 2 */
  85:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCER;           /**< Capture/compare enable register */
  86:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CNT;            /**< Counter */
  87:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 PSC;            /**< Prescaler */
  88:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 ARR;            /**< Auto-reload register */
  89:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED1;     /**< Reserved */
  90:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR1;           /**< Capture/compare register 1 */
  91:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR2;           /**< Capture/compare register 2 */
  92:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR3;           /**< Capture/compare register 3 */
  93:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR4;           /**< Capture/compare register 4 */
  94:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED2;     /**< Reserved */
  95:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DCR;            /**< DMA control register */
  96:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DMAR;           /**< DMA address for full transfer */
  97:../Libmaple/libmaple/libmaple/timer.h **** } timer_gen_reg_map;
  98:../Libmaple/libmaple/libmaple/timer.h **** 
  99:../Libmaple/libmaple/libmaple/timer.h **** /** Basic timer register map type */
 100:../Libmaple/libmaple/libmaple/timer.h **** typedef struct timer_bas_reg_map {
 101:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR1;            /**< Control register 1 */
 102:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR2;            /**< Control register 2 */
 103:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED1;     /**< Reserved */
 104:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DIER;           /**< DMA/Interrupt enable register */
 105:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 SR;             /**< Status register */
 106:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 EGR;            /**< Event generation register  */
 107:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED2;     /**< Reserved */
 108:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED3;     /**< Reserved */
 109:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED4;     /**< Reserved */
 110:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CNT;            /**< Counter */
 111:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 PSC;            /**< Prescaler */
 112:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 ARR;            /**< Auto-reload register */
 113:../Libmaple/libmaple/libmaple/timer.h **** } timer_bas_reg_map;
 114:../Libmaple/libmaple/libmaple/timer.h **** 
 115:../Libmaple/libmaple/libmaple/timer.h **** 
 116:../Libmaple/libmaple/libmaple/timer.h **** #ifdef STM32F2
 117:../Libmaple/libmaple/libmaple/timer.h ****   /** Timer 1 register map base pointer */
 118:../Libmaple/libmaple/libmaple/timer.h ****   #define TIMER1_BASE        ((struct timer_adv_reg_map*)0x40010000)
 119:../Libmaple/libmaple/libmaple/timer.h **** #else
 120:../Libmaple/libmaple/libmaple/timer.h ****   /** Timer 1 register map base pointer */
 121:../Libmaple/libmaple/libmaple/timer.h ****   #define TIMER1_BASE        ((struct timer_adv_reg_map*)0x40012C00)
 122:../Libmaple/libmaple/libmaple/timer.h **** #endif
 123:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 2 register map base pointer */
 124:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER2_BASE        ((struct timer_gen_reg_map*)0x40000000)
 125:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 3 register map base pointer */
 126:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER3_BASE        ((struct timer_gen_reg_map*)0x40000400)
 127:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 4 register map base pointer */
 128:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER4_BASE        ((struct timer_gen_reg_map*)0x40000800)
 129:../Libmaple/libmaple/libmaple/timer.h **** #ifdef STM32_HIGH_DENSITY
 130:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 5 register map base pointer */
 131:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER5_BASE        ((struct timer_gen_reg_map*)0x40000C00)
 132:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 6 register map base pointer */
 133:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER6_BASE        ((struct timer_bas_reg_map*)0x40001000)
 134:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 7 register map base pointer */
 135:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER7_BASE        ((struct timer_bas_reg_map*)0x40001400)
 136:../Libmaple/libmaple/libmaple/timer.h **** 
 137:../Libmaple/libmaple/libmaple/timer.h **** #ifdef STM32F2
 138:../Libmaple/libmaple/libmaple/timer.h ****   /** Timer 8 register map base pointer */
 139:../Libmaple/libmaple/libmaple/timer.h ****   #define TIMER8_BASE        ((struct timer_adv_reg_map*)0x40010400)
 140:../Libmaple/libmaple/libmaple/timer.h **** #else
 141:../Libmaple/libmaple/libmaple/timer.h ****   /** Timer 8 register map base pointer */
 142:../Libmaple/libmaple/libmaple/timer.h ****   #define TIMER8_BASE        ((struct timer_adv_reg_map*)0x40013400)
 143:../Libmaple/libmaple/libmaple/timer.h **** #endif
 144:../Libmaple/libmaple/libmaple/timer.h **** #endif
 145:../Libmaple/libmaple/libmaple/timer.h **** 
 146:../Libmaple/libmaple/libmaple/timer.h **** /*
 147:../Libmaple/libmaple/libmaple/timer.h ****  * Timer devices
 148:../Libmaple/libmaple/libmaple/timer.h ****  */
 149:../Libmaple/libmaple/libmaple/timer.h **** 
 150:../Libmaple/libmaple/libmaple/timer.h **** /**
 151:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Timer register map type.
 152:../Libmaple/libmaple/libmaple/timer.h ****  *
 153:../Libmaple/libmaple/libmaple/timer.h ****  * Just holds a pointer to the correct type of register map, based on
 154:../Libmaple/libmaple/libmaple/timer.h ****  * the timer's type.
 155:../Libmaple/libmaple/libmaple/timer.h ****  */
 156:../Libmaple/libmaple/libmaple/timer.h **** typedef union timer_reg_map {
 157:../Libmaple/libmaple/libmaple/timer.h ****     timer_adv_reg_map *adv;     /**< Advanced register map */
 158:../Libmaple/libmaple/libmaple/timer.h ****     timer_gen_reg_map *gen;     /**< General purpose register map */
 159:../Libmaple/libmaple/libmaple/timer.h ****     timer_bas_reg_map *bas;     /**< Basic register map */
 160:../Libmaple/libmaple/libmaple/timer.h **** } timer_reg_map;
 161:../Libmaple/libmaple/libmaple/timer.h **** 
 162:../Libmaple/libmaple/libmaple/timer.h **** /**
 163:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Timer type
 164:../Libmaple/libmaple/libmaple/timer.h ****  *
 165:../Libmaple/libmaple/libmaple/timer.h ****  * Type marker for timer_dev.
 166:../Libmaple/libmaple/libmaple/timer.h ****  *
 167:../Libmaple/libmaple/libmaple/timer.h ****  * @see timer_dev
 168:../Libmaple/libmaple/libmaple/timer.h ****  */
 169:../Libmaple/libmaple/libmaple/timer.h **** typedef enum timer_type {
 170:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_ADVANCED,             /**< Advanced type */
 171:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_GENERAL,              /**< General purpose type */
 172:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_BASIC                 /**< Basic type */
 173:../Libmaple/libmaple/libmaple/timer.h **** } timer_type;
 174:../Libmaple/libmaple/libmaple/timer.h **** 
 175:../Libmaple/libmaple/libmaple/timer.h **** /** Timer device type */
 176:../Libmaple/libmaple/libmaple/timer.h **** typedef struct timer_dev {
 177:../Libmaple/libmaple/libmaple/timer.h ****     timer_reg_map regs;         /**< Register map */
 178:../Libmaple/libmaple/libmaple/timer.h ****     rcc_clk_id clk_id;          /**< RCC clock information */
 179:../Libmaple/libmaple/libmaple/timer.h ****     timer_type type;            /**< Timer's type */
 180:../Libmaple/libmaple/libmaple/timer.h ****     voidFuncPtr handlers[];     /**< User IRQ handlers */
 181:../Libmaple/libmaple/libmaple/timer.h **** } timer_dev;
 182:../Libmaple/libmaple/libmaple/timer.h **** 
 183:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER1;
 184:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER2;
 185:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER3;
 186:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER4;
 187:../Libmaple/libmaple/libmaple/timer.h **** #ifdef STM32_HIGH_DENSITY
 188:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER5;
 189:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER6;
 190:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER7;
 191:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER8;
 192:../Libmaple/libmaple/libmaple/timer.h **** #endif
 193:../Libmaple/libmaple/libmaple/timer.h **** 
 194:../Libmaple/libmaple/libmaple/timer.h **** /*
 195:../Libmaple/libmaple/libmaple/timer.h ****  * Register bit definitions
 196:../Libmaple/libmaple/libmaple/timer.h ****  */
 197:../Libmaple/libmaple/libmaple/timer.h **** 
 198:../Libmaple/libmaple/libmaple/timer.h **** /* Control register 1 (CR1) */
 199:../Libmaple/libmaple/libmaple/timer.h **** 
 200:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_ARPE_BIT              7
 201:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_DIR_BIT               4
 202:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_OPM_BIT               3
 203:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_URS_BIT               2
 204:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_UDIS_BIT              1
 205:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CEN_BIT               0
 206:../Libmaple/libmaple/libmaple/timer.h **** 
 207:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD                   (0x3 << 8)
 208:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_1TCKINT           (0x0 << 8)
 209:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_2TCKINT           (0x1 << 8)
 210:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_4TICKINT          (0x2 << 8)
 211:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_ARPE                  BIT(TIMER_CR1_ARPE_BIT)
 212:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_CMS               (0x3 << 5)
 213:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_CMS_EDGE          (0x0 << 5)
 214:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_CMS_CENTER1       (0x1 << 5)
 215:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_CMS_CENTER2       (0x2 << 5)
 216:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_CMS_CENTER3       (0x3 << 5)
 217:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_DIR                   BIT(TIMER_CR1_DIR_BIT)
 218:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_OPM                   BIT(TIMER_CR1_OPM_BIT)
 219:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_URS                   BIT(TIMER_CR1_URS_BIT)
 220:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_UDIS                  BIT(TIMER_CR1_UDIS_BIT)
 221:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CEN                   BIT(TIMER_CR1_CEN_BIT)
 222:../Libmaple/libmaple/libmaple/timer.h **** 
 223:../Libmaple/libmaple/libmaple/timer.h **** /* Control register 2 (CR2) */
 224:../Libmaple/libmaple/libmaple/timer.h **** 
 225:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS4_BIT              14
 226:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS3N_BIT             13
 227:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS3_BIT              12
 228:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS2N_BIT             11
 229:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS2_BIT              10
 230:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS1N_BIT             9
 231:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS1_BIT              8
 232:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_TI1S_BIT              7 /* tills? yikes */
 233:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCDS_BIT              3
 234:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCUS_BIT              2
 235:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCPC_BIT              0
 236:../Libmaple/libmaple/libmaple/timer.h **** 
 237:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS4                  BIT(TIMER_CR2_OIS4_BIT)
 238:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS3N                 BIT(TIMER_CR2_OIS3N_BIT)
 239:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS3                  BIT(TIMER_CR2_OIS3_BIT)
 240:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS2N                 BIT(TIMER_CR2_OIS2N_BIT)
 241:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS2                  BIT(TIMER_CR2_OIS2_BIT)
 242:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS1N                 BIT(TIMER_CR2_OIS1N_BIT)
 243:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS1                  BIT(TIMER_CR2_OIS1_BIT)
 244:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_TI1S                  BIT(TIMER_CR2_TI1S_BIT)
 245:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS                   (0x7 << 4)
 246:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_RESET             (0x0 << 4)
 247:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_ENABLE            (0x1 << 4)
 248:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_UPDATE            (0x2 << 4)
 249:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_COMPARE_PULSE     (0x3 << 4)
 250:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_COMPARE_OC1REF    (0x4 << 4)
 251:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_COMPARE_OC2REF    (0x5 << 4)
 252:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_COMPARE_OC3REF    (0x6 << 4)
 253:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_COMPARE_OC4REF    (0x7 << 4)
 254:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCDS                  BIT(TIMER_CR2_CCDS_BIT)
 255:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCUS                  BIT(TIMER_CR2_CCUS_BIT)
 256:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCPC                  BIT(TIMER_CR2_CCPC_BIT)
 257:../Libmaple/libmaple/libmaple/timer.h **** 
 258:../Libmaple/libmaple/libmaple/timer.h **** /* Slave mode control register (SMCR) */
 259:../Libmaple/libmaple/libmaple/timer.h **** 
 260:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETP_BIT              15
 261:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ECE_BIT              14
 262:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_MSM_BIT              7
 263:../Libmaple/libmaple/libmaple/timer.h **** 
 264:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETP                  BIT(TIMER_SMCR_ETP_BIT)
 265:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ECE                  BIT(TIMER_SMCR_ECE_BIT)
 266:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETPS                 (0x3 << 12)
 267:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETPS_OFF             (0x0 << 12)
 268:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETPS_DIV2            (0x1 << 12)
 269:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETPS_DIV4            (0x2 << 12)
 270:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETPS_DIV8            (0x3 << 12)
 271:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETF                  (0xF << 12)
 272:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_MSM                  BIT(TIMER_SMCR_MSM_BIT)
 273:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS                   (0x3 << 4)
 274:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_ITR0              (0x0 << 4)
 275:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_ITR1              (0x1 << 4)
 276:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_ITR2              (0x2 << 4)
 277:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_ITR3              (0x3 << 4)
 278:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_TI1F_ED           (0x4 << 4)
 279:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_TI1FP1            (0x5 << 4)
 280:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_TI2FP2            (0x6 << 4)
 281:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_ETRF              (0x7 << 4)
 282:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS                  0x3
 283:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_DISABLED         0x0
 284:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_ENCODER1         0x1
 285:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_ENCODER2         0x2
 286:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_ENCODER3         0x3
 287:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_RESET            0x4
 288:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_GATED            0x5
 289:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_TRIGGER          0x6
 290:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_EXTERNAL         0x7
 291:../Libmaple/libmaple/libmaple/timer.h **** 
 292:../Libmaple/libmaple/libmaple/timer.h **** /* DMA/Interrupt enable register (DIER) */
 293:../Libmaple/libmaple/libmaple/timer.h **** 
 294:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_TDE_BIT              14
 295:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC4DE_BIT            12
 296:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC3DE_BIT            11
 297:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC2DE_BIT            10
 298:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC1DE_BIT            9
 299:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_UDE_BIT              8
 300:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_TIE_BIT              6
 301:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC4IE_BIT            4
 302:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC3IE_BIT            3
 303:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC2IE_BIT            2
 304:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC1IE_BIT            1
 305:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_UIE_BIT              0
 306:../Libmaple/libmaple/libmaple/timer.h **** 
 307:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_TDE                  BIT(TIMER_DIER_TDE_BIT)
 308:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC4DE                BIT(TIMER_DIER_CC4DE_BIT)
 309:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC3DE                BIT(TIMER_DIER_CC3DE_BIT)
 310:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC2DE                BIT(TIMER_DIER_CC2DE_BIT)
 311:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC1DE                BIT(TIMER_DIER_CC1DE_BIT)
 312:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_UDE                  BIT(TIMER_DIER_UDE_BIT)
 313:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_TIE                  BIT(TIMER_DIER_TIE_BIT)
 314:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC4IE                BIT(TIMER_DIER_CC4IE_BIT)
 315:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC3IE                BIT(TIMER_DIER_CC3IE_BIT)
 316:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC2IE                BIT(TIMER_DIER_CC2IE_BIT)
 317:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC1IE                BIT(TIMER_DIER_CC1IE_BIT)
 318:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_UIE                  BIT(TIMER_DIER_UIE_BIT)
 319:../Libmaple/libmaple/libmaple/timer.h **** 
 320:../Libmaple/libmaple/libmaple/timer.h **** /* Status register (SR) */
 321:../Libmaple/libmaple/libmaple/timer.h **** 
 322:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC4OF_BIT              12
 323:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC3OF_BIT              11
 324:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC2OF_BIT              10
 325:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC1OF_BIT              9
 326:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_BIF_BIT                7
 327:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_TIF_BIT                6
 328:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_COMIF_BIT              5
 329:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC4IF_BIT              4
 330:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC3IF_BIT              3
 331:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC2IF_BIT              2
 332:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC1IF_BIT              1
 333:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_UIF_BIT                0
 334:../Libmaple/libmaple/libmaple/timer.h **** 
 335:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC4OF                  BIT(TIMER_SR_CC4OF_BIT)
 336:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC3OF                  BIT(TIMER_SR_CC3OF_BIT)
 337:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC2OF                  BIT(TIMER_SR_CC2OF_BIT)
 338:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC1OF                  BIT(TIMER_SR_CC1OF_BIT)
 339:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_BIF                    BIT(TIMER_SR_BIF_BIT)
 340:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_TIF                    BIT(TIMER_SR_TIF_BIT)
 341:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_COMIF                  BIT(TIMER_SR_COMIF_BIT)
 342:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC4IF                  BIT(TIMER_SR_CC4IF_BIT)
 343:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC3IF                  BIT(TIMER_SR_CC3IF_BIT)
 344:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC2IF                  BIT(TIMER_SR_CC2IF_BIT)
 345:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC1IF                  BIT(TIMER_SR_CC1IF_BIT)
 346:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_UIF                    BIT(TIMER_SR_UIF_BIT)
 347:../Libmaple/libmaple/libmaple/timer.h **** 
 348:../Libmaple/libmaple/libmaple/timer.h **** /* Event generation register (EGR) */
 349:../Libmaple/libmaple/libmaple/timer.h **** 
 350:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_TG_BIT                6
 351:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC4G_BIT              4
 352:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC3G_BIT              3
 353:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC2G_BIT              2
 354:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC1G_BIT              1
 355:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_UG_BIT                0
 356:../Libmaple/libmaple/libmaple/timer.h **** 
 357:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_TG                    BIT(TIMER_EGR_TG_BIT)
 358:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC4G                  BIT(TIMER_EGR_CC4G_BIT)
 359:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC3G                  BIT(TIMER_EGR_CC3G_BIT)
 360:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC2G                  BIT(TIMER_EGR_CC2G_BIT)
 361:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC1G                  BIT(TIMER_EGR_CC1G_BIT)
 362:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_UG                    BIT(TIMER_EGR_UG_BIT)
 363:../Libmaple/libmaple/libmaple/timer.h **** 
 364:../Libmaple/libmaple/libmaple/timer.h **** /* Capture/compare mode registers, common values */
 365:../Libmaple/libmaple/libmaple/timer.h **** 
 366:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR_CCS_OUTPUT           0x0
 367:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR_CCS_INPUT_TI1        0x1
 368:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR_CCS_INPUT_TI2        0x2
 369:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR_CCS_INPUT_TRC        0x3
 370:../Libmaple/libmaple/libmaple/timer.h **** 
 371:../Libmaple/libmaple/libmaple/timer.h **** /* Capture/compare mode register 1 (CCMR1) */
 372:../Libmaple/libmaple/libmaple/timer.h **** 
 373:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2CE_BIT           15
 374:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2PE_BIT           11
 375:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2FE_BIT           10
 376:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1CE_BIT           7
 377:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1PE_BIT           3
 378:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1FE_BIT           2
 379:../Libmaple/libmaple/libmaple/timer.h **** 
 380:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2CE               BIT(TIMER_CCMR1_OC2CE_BIT)
 381:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2M                (0x3 << 12)
 382:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_IC2F                (0xF << 12)
 383:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2PE               BIT(TIMER_CCMR1_OC2PE_BIT)
 384:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2FE               BIT(TIMER_CCMR1_OC2FE_BIT)
 385:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_IC2PSC              (0x3 << 10)
 386:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC2S                (0x3 << 8)
 387:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC2S_OUTPUT         (TIMER_CCMR_CCS_OUTPUT << 8)
 388:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC2S_INPUT_TI1      (TIMER_CCMR_CCS_INPUT_TI1 << 8)
 389:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC2S_INPUT_TI2      (TIMER_CCMR_CCS_INPUT_TI2 << 8)
 390:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC2S_INPUT_TRC      (TIMER_CCMR_CCS_INPUT_TRC << 8)
 391:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1CE               BIT(TIMER_CCMR1_OC1CE_BIT)
 392:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1M                (0x3 << 4)
 393:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_IC1F                (0xF << 4)
 394:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1PE               BIT(TIMER_CCMR1_OC1PE_BIT)
 395:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1FE               BIT(TIMER_CCMR1_OC1FE_BIT)
 396:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_IC1PSC              (0x3 << 2)
 397:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC1S                0x3
 398:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC1S_OUTPUT         TIMER_CCMR_CCS_OUTPUT
 399:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC1S_INPUT_TI1      TIMER_CCMR_CCS_INPUT_TI1
 400:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC1S_INPUT_TI2      TIMER_CCMR_CCS_INPUT_TI2
 401:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC1S_INPUT_TRC      TIMER_CCMR_CCS_INPUT_TRC
 402:../Libmaple/libmaple/libmaple/timer.h **** 
 403:../Libmaple/libmaple/libmaple/timer.h **** /* Capture/compare mode register 2 (CCMR2) */
 404:../Libmaple/libmaple/libmaple/timer.h **** 
 405:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4CE_BIT           15
 406:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4PE_BIT           11
 407:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4FE_BIT           10
 408:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3CE_BIT           7
 409:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3PE_BIT           3
 410:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3FE_BIT           2
 411:../Libmaple/libmaple/libmaple/timer.h **** 
 412:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4CE               BIT(TIMER_CCMR2_OC4CE_BIT)
 413:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4M                (0x3 << 12)
 414:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_IC2F                (0xF << 12)
 415:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4PE               BIT(TIMER_CCMR2_OC4PE_BIT)
 416:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4FE               BIT(TIMER_CCMR2_OC4FE_BIT)
 417:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_IC2PSC              (0x3 << 10)
 418:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_CC4S                (0x3 << 8)
 419:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC4S_OUTPUT         (TIMER_CCMR_CCS_OUTPUT << 8)
 420:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC4S_INPUT_TI1      (TIMER_CCMR_CCS_INPUT_TI1 << 8)
 421:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC4S_INPUT_TI2      (TIMER_CCMR_CCS_INPUT_TI2 << 8)
 422:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC4S_INPUT_TRC      (TIMER_CCMR_CCS_INPUT_TRC << 8)
 423:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3CE               BIT(TIMER_CCMR2_OC3CE_BIT)
 424:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3M                (0x3 << 4)
 425:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_IC1F                (0xF << 4)
 426:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3PE               BIT(TIMER_CCMR2_OC3PE_BIT)
 427:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3FE               BIT(TIMER_CCMR2_OC3FE_BIT)
 428:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_IC1PSC              (0x3 << 2)
 429:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_CC3S                0x3
 430:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC3S_OUTPUT         TIMER_CCMR_CCS_OUTPUT
 431:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC3S_INPUT_TI1      TIMER_CCMR_CCS_INPUT_TI1
 432:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC3S_INPUT_TI2      TIMER_CCMR_CCS_INPUT_TI2
 433:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC3S_INPUT_TRC      TIMER_CCMR_CCS_INPUT_TRC
 434:../Libmaple/libmaple/libmaple/timer.h **** 
 435:../Libmaple/libmaple/libmaple/timer.h **** /* Capture/compare enable register (CCER) */
 436:../Libmaple/libmaple/libmaple/timer.h **** 
 437:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC4P_BIT             13
 438:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC4E_BIT             12
 439:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC3P_BIT             9
 440:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC3E_BIT             8
 441:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC2P_BIT             5
 442:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC2E_BIT             4
 443:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC1P_BIT             1
 444:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC1E_BIT             0
 445:../Libmaple/libmaple/libmaple/timer.h **** 
 446:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC4P                 BIT(TIMER_CCER_CC4P_BIT)
 447:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC4E                 BIT(TIMER_CCER_CC4E_BIT)
 448:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC3P                 BIT(TIMER_CCER_CC3P_BIT)
 449:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC3E                 BIT(TIMER_CCER_CC3E_BIT)
 450:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC2P                 BIT(TIMER_CCER_CC2P_BIT)
 451:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC2E                 BIT(TIMER_CCER_CC2E_BIT)
 452:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC1P                 BIT(TIMER_CCER_CC1P_BIT)
 453:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC1E                 BIT(TIMER_CCER_CC1E_BIT)
 454:../Libmaple/libmaple/libmaple/timer.h **** 
 455:../Libmaple/libmaple/libmaple/timer.h **** /* Break and dead-time register (BDTR) */
 456:../Libmaple/libmaple/libmaple/timer.h **** 
 457:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_MOE_BIT              15
 458:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_AOE_BIT              14
 459:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_BKP_BIT              13
 460:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_BKE_BIT              12
 461:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_OSSR_BIT             11
 462:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_OSSI_BIT             10
 463:../Libmaple/libmaple/libmaple/timer.h **** 
 464:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_MOE                  BIT(TIMER_BDTR_MOE_BIT)
 465:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_AOE                  BIT(TIMER_BDTR_AOE_BIT)
 466:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_BKP                  BIT(TIMER_BDTR_BKP_BIT)
 467:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_BKE                  BIT(TIMER_BDTR_BKE_BIT)
 468:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_OSSR                 BIT(TIMER_BDTR_OSSR_BIT)
 469:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_OSSI                 BIT(TIMER_BDTR_OSSI_BIT)
 470:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_LOCK                 (0x3 << 8)
 471:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_LOCK_OFF             (0x0 << 8)
 472:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_LOCK_LEVEL1          (0x1 << 8)
 473:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_LOCK_LEVEL2          (0x2 << 8)
 474:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_LOCK_LEVEL3          (0x3 << 8)
 475:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_DTG                  0xFF
 476:../Libmaple/libmaple/libmaple/timer.h **** 
 477:../Libmaple/libmaple/libmaple/timer.h **** /* DMA control register (DCR) */
 478:../Libmaple/libmaple/libmaple/timer.h **** 
 479:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL                   (0x1F << 8)
 480:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_1BYTE             (0x0 << 8)
 481:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_2BYTE             (0x1 << 8)
 482:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_3BYTE             (0x2 << 8)
 483:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_4BYTE             (0x3 << 8)
 484:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_5BYTE             (0x4 << 8)
 485:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_6BYTE             (0x5 << 8)
 486:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_7BYTE             (0x6 << 8)
 487:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_8BYTE             (0x7 << 8)
 488:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_9BYTE             (0x8 << 8)
 489:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_10BYTE            (0x9 << 8)
 490:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_11BYTE            (0xA << 8)
 491:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_12BYTE            (0xB << 8)
 492:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_13BYTE            (0xC << 8)
 493:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_14BYTE            (0xD << 8)
 494:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_15BYTE            (0xE << 8)
 495:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_16BYTE            (0xF << 8)
 496:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_17BYTE            (0x10 << 8)
 497:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_18BYTE            (0x11 << 8)
 498:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA                   0x1F
 499:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CR1               0x0
 500:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CR2               0x1
 501:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_SMCR              0x2
 502:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_DIER              0x3
 503:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_SR                0x4
 504:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_EGR               0x5
 505:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCMR1             0x6
 506:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCMR2             0x7
 507:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCER              0x8
 508:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CNT               0x9
 509:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_PSC               0xA
 510:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_ARR               0xB
 511:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_RCR               0xC
 512:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCR1              0xD
 513:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCR2              0xE
 514:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCR3              0xF
 515:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCR4              0x10
 516:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_BDTR              0x11
 517:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_DCR               0x12
 518:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_DMAR              0x13
 519:../Libmaple/libmaple/libmaple/timer.h **** 
 520:../Libmaple/libmaple/libmaple/timer.h **** /*
 521:../Libmaple/libmaple/libmaple/timer.h ****  * Convenience routines
 522:../Libmaple/libmaple/libmaple/timer.h ****  */
 523:../Libmaple/libmaple/libmaple/timer.h **** 
 524:../Libmaple/libmaple/libmaple/timer.h **** /**
 525:../Libmaple/libmaple/libmaple/timer.h ****  * Used to configure the behavior of a timer channel.  Note that not
 526:../Libmaple/libmaple/libmaple/timer.h ****  * all timers can be configured in every mode.
 527:../Libmaple/libmaple/libmaple/timer.h ****  */
 528:../Libmaple/libmaple/libmaple/timer.h **** /* TODO TIMER_PWM_CENTER_ALIGNED, TIMER_INPUT_CAPTURE, TIMER_ONE_PULSE */
 529:../Libmaple/libmaple/libmaple/timer.h **** typedef enum timer_mode {
 530:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_DISABLED, /**< In this mode, the timer stops counting,
 531:../Libmaple/libmaple/libmaple/timer.h ****                          channel interrupts are detached, and no state
 532:../Libmaple/libmaple/libmaple/timer.h ****                          changes are output. */
 533:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_PWM, /**< PWM output mode. This is the default mode for pins
 534:../Libmaple/libmaple/libmaple/timer.h ****                     after initialization. */
 535:../Libmaple/libmaple/libmaple/timer.h ****     /* TIMER_PWM_CENTER_ALIGNED, /\**< Center-aligned PWM output mode. *\/ */
 536:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_OUTPUT_COMPARE, /**< In this mode, the timer counts from 0
 537:../Libmaple/libmaple/libmaple/timer.h ****                                to its reload value repeatedly; every
 538:../Libmaple/libmaple/libmaple/timer.h ****                                time the counter value reaches one of
 539:../Libmaple/libmaple/libmaple/timer.h ****                                the channel compare values, the
 540:../Libmaple/libmaple/libmaple/timer.h ****                                corresponding interrupt is fired. */
 541:../Libmaple/libmaple/libmaple/timer.h ****     /* TIMER_INPUT_CAPTURE, /\**< In this mode, the timer can measure the */
 542:../Libmaple/libmaple/libmaple/timer.h ****     /*                           pulse lengths of input signals. *\/ */
 543:../Libmaple/libmaple/libmaple/timer.h ****     /* TIMER_ONE_PULSE /\**< In this mode, the timer can generate a single */
 544:../Libmaple/libmaple/libmaple/timer.h ****     /*                      pulse on a GPIO pin for a specified amount of */
 545:../Libmaple/libmaple/libmaple/timer.h ****     /*                      time. *\/ */
 546:../Libmaple/libmaple/libmaple/timer.h **** } timer_mode;
 547:../Libmaple/libmaple/libmaple/timer.h **** 
 548:../Libmaple/libmaple/libmaple/timer.h **** /** Timer channel numbers */
 549:../Libmaple/libmaple/libmaple/timer.h **** typedef enum timer_channel {
 550:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CH1 = 1, /**< Channel 1 */
 551:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CH2 = 2, /**< Channel 2 */
 552:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CH3 = 3, /**< Channel 3 */
 553:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CH4 = 4  /**< Channel 4 */
 554:../Libmaple/libmaple/libmaple/timer.h **** } timer_channel;
 555:../Libmaple/libmaple/libmaple/timer.h **** 
 556:../Libmaple/libmaple/libmaple/timer.h **** /*
 557:../Libmaple/libmaple/libmaple/timer.h ****  * Note: Don't require timer_channel arguments! We want to be able to say
 558:../Libmaple/libmaple/libmaple/timer.h ****  *
 559:../Libmaple/libmaple/libmaple/timer.h ****  * for (int channel = 1; channel <= 4; channel++) {
 560:../Libmaple/libmaple/libmaple/timer.h ****  *    ...
 561:../Libmaple/libmaple/libmaple/timer.h ****  * }
 562:../Libmaple/libmaple/libmaple/timer.h ****  *
 563:../Libmaple/libmaple/libmaple/timer.h ****  * without the compiler yelling at us.
 564:../Libmaple/libmaple/libmaple/timer.h ****  */
 565:../Libmaple/libmaple/libmaple/timer.h **** 
 566:../Libmaple/libmaple/libmaple/timer.h **** void timer_init(timer_dev *dev);
 567:../Libmaple/libmaple/libmaple/timer.h **** void timer_disable(timer_dev *dev);
 568:../Libmaple/libmaple/libmaple/timer.h **** void timer_set_mode(timer_dev *dev, uint8 channel, timer_mode mode);
 569:../Libmaple/libmaple/libmaple/timer.h **** void timer_foreach(void (*fn)(timer_dev*));
 570:../Libmaple/libmaple/libmaple/timer.h **** 
 571:../Libmaple/libmaple/libmaple/timer.h **** /**
 572:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Timer interrupt number.
 573:../Libmaple/libmaple/libmaple/timer.h ****  *
 574:../Libmaple/libmaple/libmaple/timer.h ****  * Not all timers support all of these values; see the descriptions
 575:../Libmaple/libmaple/libmaple/timer.h ****  * for each value.
 576:../Libmaple/libmaple/libmaple/timer.h ****  */
 577:../Libmaple/libmaple/libmaple/timer.h **** typedef enum timer_interrupt_id {
 578:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_UPDATE_INTERRUPT, /**< Update interrupt, available on all timers. */
 579:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CC1_INTERRUPT, /**< Capture/compare 1 interrupt, available
 580:../Libmaple/libmaple/libmaple/timer.h ****                               on general and advanced timers only. */
 581:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CC2_INTERRUPT, /**< Capture/compare 2 interrupt, general and
 582:../Libmaple/libmaple/libmaple/timer.h ****                               advanced timers only. */
 583:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CC3_INTERRUPT, /**< Capture/compare 3 interrupt, general and
 584:../Libmaple/libmaple/libmaple/timer.h ****                               advanced timers only. */
 585:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CC4_INTERRUPT, /**< Capture/compare 4 interrupt, general and
 586:../Libmaple/libmaple/libmaple/timer.h ****                               advanced timers only. */
 587:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_COM_INTERRUPT, /**< COM interrupt, advanced timers only */
 588:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_TRG_INTERRUPT, /**< Trigger interrupt, general and advanced
 589:../Libmaple/libmaple/libmaple/timer.h ****                               timers only */
 590:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_BREAK_INTERRUPT /**< Break interrupt, advanced timers only. */
 591:../Libmaple/libmaple/libmaple/timer.h **** } timer_interrupt_id;
 592:../Libmaple/libmaple/libmaple/timer.h **** 
 593:../Libmaple/libmaple/libmaple/timer.h **** void timer_attach_interrupt(timer_dev *dev,
 594:../Libmaple/libmaple/libmaple/timer.h ****                             uint8 interrupt,
 595:../Libmaple/libmaple/libmaple/timer.h ****                             voidFuncPtr handler);
 596:../Libmaple/libmaple/libmaple/timer.h **** void timer_detach_interrupt(timer_dev *dev, uint8 interrupt);
 597:../Libmaple/libmaple/libmaple/timer.h **** 
 598:../Libmaple/libmaple/libmaple/timer.h **** /**
 599:../Libmaple/libmaple/libmaple/timer.h ****  * Initialize all timer devices on the chip.
 600:../Libmaple/libmaple/libmaple/timer.h ****  */
 601:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_init_all(void) {
 602:../Libmaple/libmaple/libmaple/timer.h ****     timer_foreach(timer_init);
 603:../Libmaple/libmaple/libmaple/timer.h **** }
 604:../Libmaple/libmaple/libmaple/timer.h **** 
 605:../Libmaple/libmaple/libmaple/timer.h **** /**
 606:../Libmaple/libmaple/libmaple/timer.h ****  * Disables all timers on the device.
 607:../Libmaple/libmaple/libmaple/timer.h ****  */
 608:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_disable_all(void) {
 609:../Libmaple/libmaple/libmaple/timer.h ****     timer_foreach(timer_disable);
 610:../Libmaple/libmaple/libmaple/timer.h **** }
 611:../Libmaple/libmaple/libmaple/timer.h **** 
 612:../Libmaple/libmaple/libmaple/timer.h **** /**
 613:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Stop a timer's counter from changing.
 614:../Libmaple/libmaple/libmaple/timer.h ****  *
 615:../Libmaple/libmaple/libmaple/timer.h ****  * Does not affect the timer's mode or other settings.
 616:../Libmaple/libmaple/libmaple/timer.h ****  *
 617:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Device whose counter to pause.
 618:../Libmaple/libmaple/libmaple/timer.h ****  */
 619:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_pause(timer_dev *dev) {
 620:../Libmaple/libmaple/libmaple/timer.h ****     *bb_perip(&(dev->regs).bas->CR1, TIMER_CR1_CEN_BIT) = 0;
 621:../Libmaple/libmaple/libmaple/timer.h **** }
 622:../Libmaple/libmaple/libmaple/timer.h **** 
 623:../Libmaple/libmaple/libmaple/timer.h **** /**
 624:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Start a timer's counter.
 625:../Libmaple/libmaple/libmaple/timer.h ****  *
 626:../Libmaple/libmaple/libmaple/timer.h ****  * Does not affect the timer's mode or other settings.
 627:../Libmaple/libmaple/libmaple/timer.h ****  *
 628:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Device whose counter to resume
 629:../Libmaple/libmaple/libmaple/timer.h ****  */
 630:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_resume(timer_dev *dev) {
 631:../Libmaple/libmaple/libmaple/timer.h ****     *bb_perip(&(dev->regs).bas->CR1, TIMER_CR1_CEN_BIT) = 1;
 632:../Libmaple/libmaple/libmaple/timer.h **** }
 633:../Libmaple/libmaple/libmaple/timer.h **** 
 634:../Libmaple/libmaple/libmaple/timer.h **** /**
 635:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Returns the timer's counter value.
 636:../Libmaple/libmaple/libmaple/timer.h ****  *
 637:../Libmaple/libmaple/libmaple/timer.h ****  * This value is likely to be inaccurate if the counter is running
 638:../Libmaple/libmaple/libmaple/timer.h ****  * with a low prescaler.
 639:../Libmaple/libmaple/libmaple/timer.h ****  *
 640:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose counter to return
 641:../Libmaple/libmaple/libmaple/timer.h ****  */
 642:../Libmaple/libmaple/libmaple/timer.h **** static inline uint16 timer_get_count(timer_dev *dev) {
 643:../Libmaple/libmaple/libmaple/timer.h ****     return (uint16)(dev->regs).bas->CNT;
 644:../Libmaple/libmaple/libmaple/timer.h **** }
 645:../Libmaple/libmaple/libmaple/timer.h **** 
 646:../Libmaple/libmaple/libmaple/timer.h **** /**
 647:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Sets the counter value for the given timer.
 648:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose counter to set
 649:../Libmaple/libmaple/libmaple/timer.h ****  * @param value New counter value
 650:../Libmaple/libmaple/libmaple/timer.h ****  */
 651:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_set_count(timer_dev *dev, uint16 value) {
 652:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->CNT = value;
 653:../Libmaple/libmaple/libmaple/timer.h **** }
 654:../Libmaple/libmaple/libmaple/timer.h **** 
 655:../Libmaple/libmaple/libmaple/timer.h **** /**
 656:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Returns the given timer's prescaler.
 657:../Libmaple/libmaple/libmaple/timer.h ****  *
 658:../Libmaple/libmaple/libmaple/timer.h ****  * Note that if the timer's prescaler is set (e.g. via
 659:../Libmaple/libmaple/libmaple/timer.h ****  * timer_set_prescaler() or accessing a TIMx_PSC register), the value
 660:../Libmaple/libmaple/libmaple/timer.h ****  * returned by this function will reflect the new setting, but the
 661:../Libmaple/libmaple/libmaple/timer.h ****  * timer's counter will only reflect the new prescaler at the next
 662:../Libmaple/libmaple/libmaple/timer.h ****  * update event.
 663:../Libmaple/libmaple/libmaple/timer.h ****  *
 664:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose prescaler to return
 665:../Libmaple/libmaple/libmaple/timer.h ****  * @see timer_generate_update()
 666:../Libmaple/libmaple/libmaple/timer.h ****  */
 667:../Libmaple/libmaple/libmaple/timer.h **** static inline uint16 timer_get_prescaler(timer_dev *dev) {
 668:../Libmaple/libmaple/libmaple/timer.h ****     return (uint16)(dev->regs).bas->PSC;
 669:../Libmaple/libmaple/libmaple/timer.h **** }
 670:../Libmaple/libmaple/libmaple/timer.h **** 
 671:../Libmaple/libmaple/libmaple/timer.h **** /**
 672:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Set a timer's prescale value.
 673:../Libmaple/libmaple/libmaple/timer.h ****  *
 674:../Libmaple/libmaple/libmaple/timer.h ****  * Divides the input clock by (PSC+1).  The new value will not take
 675:../Libmaple/libmaple/libmaple/timer.h ****  * effect until the next update event.
 676:../Libmaple/libmaple/libmaple/timer.h ****  *
 677:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose prescaler to set
 678:../Libmaple/libmaple/libmaple/timer.h ****  * @param psc New prescaler value
 679:../Libmaple/libmaple/libmaple/timer.h ****  * @see timer_generate_update()
 680:../Libmaple/libmaple/libmaple/timer.h ****  */
 681:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_set_prescaler(timer_dev *dev, uint16 psc) {
 682:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->PSC = psc;
 683:../Libmaple/libmaple/libmaple/timer.h **** }
 684:../Libmaple/libmaple/libmaple/timer.h **** 
 685:../Libmaple/libmaple/libmaple/timer.h **** /**
 686:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Returns a timer's reload value.
 687:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose reload value to return
 688:../Libmaple/libmaple/libmaple/timer.h ****  */
 689:../Libmaple/libmaple/libmaple/timer.h **** static inline uint16 timer_get_reload(timer_dev *dev) {
 690:../Libmaple/libmaple/libmaple/timer.h ****     return (uint16)(dev->regs).bas->ARR;
 691:../Libmaple/libmaple/libmaple/timer.h **** }
 692:../Libmaple/libmaple/libmaple/timer.h **** 
 693:../Libmaple/libmaple/libmaple/timer.h **** /**
 694:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Set a timer's reload value.
 695:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose reload value to set
 696:../Libmaple/libmaple/libmaple/timer.h ****  * @param arr New reload value to use.  Takes effect at next update event.
 697:../Libmaple/libmaple/libmaple/timer.h ****  * @see timer_generate_update()
 698:../Libmaple/libmaple/libmaple/timer.h ****  */
 699:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_set_reload(timer_dev *dev, uint16 arr) {
 700:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->ARR = arr;
 701:../Libmaple/libmaple/libmaple/timer.h **** }
 702:../Libmaple/libmaple/libmaple/timer.h **** 
 703:../Libmaple/libmaple/libmaple/timer.h **** /**
 704:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Get the compare value for the given timer channel.
 705:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer device, must have type TIMER_ADVANCED or TIMER_GENERAL.
 706:../Libmaple/libmaple/libmaple/timer.h ****  * @param channel Channel whose compare value to get.
 707:../Libmaple/libmaple/libmaple/timer.h ****  */
 708:../Libmaple/libmaple/libmaple/timer.h **** static inline uint16 timer_get_compare(timer_dev *dev, uint8 channel) {
 709:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 *ccr = &(dev->regs).gen->CCR1 + (channel - 1);
 710:../Libmaple/libmaple/libmaple/timer.h ****     return *ccr;
 711:../Libmaple/libmaple/libmaple/timer.h **** }
 712:../Libmaple/libmaple/libmaple/timer.h **** 
 713:../Libmaple/libmaple/libmaple/timer.h **** /**
 714:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Set the compare value for the given timer channel.
 715:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer device, must have type TIMER_ADVANCED or TIMER_GENERAL.
 716:../Libmaple/libmaple/libmaple/timer.h ****  * @param channel Channel whose compare value to set.
 717:../Libmaple/libmaple/libmaple/timer.h ****  * @param value   New compare value.
 718:../Libmaple/libmaple/libmaple/timer.h ****  */
 719:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_set_compare(timer_dev *dev,
 720:../Libmaple/libmaple/libmaple/timer.h ****                                      uint8 channel,
 721:../Libmaple/libmaple/libmaple/timer.h ****                                      uint16 value) {
  27              		.loc 1 721 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32              	.LVL0:
  33              	.LBB2:
 722:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 *ccr = &(dev->regs).gen->CCR1 + (channel - 1);
  34              		.loc 1 722 0
  35 0000 0368     		ldr	r3, [r0, #0]
  36 0002 0139     		subs	r1, r1, #1
  37              	.LVL1:
  38 0004 3433     		adds	r3, r3, #52
  39              	.LVL2:
 723:../Libmaple/libmaple/libmaple/timer.h ****     *ccr = value;
  40              		.loc 1 723 0
  41 0006 43F82120 		str	r2, [r3, r1, lsl #2]
  42              	.LBE2:
 724:../Libmaple/libmaple/libmaple/timer.h **** }
  43              		.loc 1 724 0
  44 000a 7047     		bx	lr
  45              		.cfi_endproc
  46              	.LFE30:
  48              		.section	.text._ZL6millisv,"ax",%progbits
  49              		.align	1
  50              		.thumb
  51              		.thumb_func
  53              	_ZL6millisv:
  54              	.LFB55:
  55              		.file 2 "../Libmaple/libmaple/wirish/wirish_time.h"
   1:../Libmaple/libmaple/wirish/wirish_time.h **** /******************************************************************************
   2:../Libmaple/libmaple/wirish/wirish_time.h ****  * The MIT License
   3:../Libmaple/libmaple/wirish/wirish_time.h ****  *
   4:../Libmaple/libmaple/wirish/wirish_time.h ****  * Copyright (c) 2010 Perry Hung.
   5:../Libmaple/libmaple/wirish/wirish_time.h ****  *
   6:../Libmaple/libmaple/wirish/wirish_time.h ****  * Permission is hereby granted, free of charge, to any person
   7:../Libmaple/libmaple/wirish/wirish_time.h ****  * obtaining a copy of this software and associated documentation
   8:../Libmaple/libmaple/wirish/wirish_time.h ****  * files (the "Software"), to deal in the Software without
   9:../Libmaple/libmaple/wirish/wirish_time.h ****  * restriction, including without limitation the rights to use, copy,
  10:../Libmaple/libmaple/wirish/wirish_time.h ****  * modify, merge, publish, distribute, sublicense, and/or sell copies
  11:../Libmaple/libmaple/wirish/wirish_time.h ****  * of the Software, and to permit persons to whom the Software is
  12:../Libmaple/libmaple/wirish/wirish_time.h ****  * furnished to do so, subject to the following conditions:
  13:../Libmaple/libmaple/wirish/wirish_time.h ****  *
  14:../Libmaple/libmaple/wirish/wirish_time.h ****  * The above copyright notice and this permission notice shall be
  15:../Libmaple/libmaple/wirish/wirish_time.h ****  * included in all copies or substantial portions of the Software.
  16:../Libmaple/libmaple/wirish/wirish_time.h ****  *
  17:../Libmaple/libmaple/wirish/wirish_time.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  18:../Libmaple/libmaple/wirish/wirish_time.h ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  19:../Libmaple/libmaple/wirish/wirish_time.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20:../Libmaple/libmaple/wirish/wirish_time.h ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  21:../Libmaple/libmaple/wirish/wirish_time.h ****  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  22:../Libmaple/libmaple/wirish/wirish_time.h ****  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  23:../Libmaple/libmaple/wirish/wirish_time.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  24:../Libmaple/libmaple/wirish/wirish_time.h ****  * SOFTWARE.
  25:../Libmaple/libmaple/wirish/wirish_time.h ****  *****************************************************************************/
  26:../Libmaple/libmaple/wirish/wirish_time.h **** 
  27:../Libmaple/libmaple/wirish/wirish_time.h **** /**
  28:../Libmaple/libmaple/wirish/wirish_time.h ****  * @file wirish_time.h
  29:../Libmaple/libmaple/wirish/wirish_time.h ****  * @brief Timing and delay functions.
  30:../Libmaple/libmaple/wirish/wirish_time.h ****  */
  31:../Libmaple/libmaple/wirish/wirish_time.h **** 
  32:../Libmaple/libmaple/wirish/wirish_time.h **** #ifndef __WIRISH_TIME_H_
  33:../Libmaple/libmaple/wirish/wirish_time.h **** #define __WIRISH_TIME_H_
  34:../Libmaple/libmaple/wirish/wirish_time.h **** 
  35:../Libmaple/libmaple/wirish/wirish_time.h **** #include "libmaple.h"
  36:../Libmaple/libmaple/wirish/wirish_time.h **** #include "nvic.h"
  37:../Libmaple/libmaple/wirish/wirish_time.h **** #include "systick.h"
  38:../Libmaple/libmaple/wirish/wirish_time.h **** #include "boards.h"
  39:../Libmaple/libmaple/wirish/wirish_time.h **** 
  40:../Libmaple/libmaple/wirish/wirish_time.h **** #define US_PER_MS               1000
  41:../Libmaple/libmaple/wirish/wirish_time.h **** 
  42:../Libmaple/libmaple/wirish/wirish_time.h **** /**
  43:../Libmaple/libmaple/wirish/wirish_time.h ****  * Returns time (in milliseconds) since the beginning of program
  44:../Libmaple/libmaple/wirish/wirish_time.h ****  * execution. On overflow, restarts at 0.
  45:../Libmaple/libmaple/wirish/wirish_time.h ****  * @see micros()
  46:../Libmaple/libmaple/wirish/wirish_time.h ****  */
  47:../Libmaple/libmaple/wirish/wirish_time.h **** static inline uint32 millis(void) {
  56              		.loc 2 47 0
  57              		.cfi_startproc
  58              		@ args = 0, pretend = 0, frame = 0
  59              		@ frame_needed = 0, uses_anonymous_args = 0
  60              		@ link register save eliminated.
  61              	.LBB5:
  62              	.LBB6:
  63              		.file 3 "../Libmaple/libmaple/libmaple/systick.h"
   1:../Libmaple/libmaple/libmaple/systick.h **** /******************************************************************************
   2:../Libmaple/libmaple/libmaple/systick.h ****  * The MIT License
   3:../Libmaple/libmaple/libmaple/systick.h ****  *
   4:../Libmaple/libmaple/libmaple/systick.h ****  * Copyright (c) 2010 Perry Hung.
   5:../Libmaple/libmaple/libmaple/systick.h ****  *
   6:../Libmaple/libmaple/libmaple/systick.h ****  * Permission is hereby granted, free of charge, to any person
   7:../Libmaple/libmaple/libmaple/systick.h ****  * obtaining a copy of this software and associated documentation
   8:../Libmaple/libmaple/libmaple/systick.h ****  * files (the "Software"), to deal in the Software without
   9:../Libmaple/libmaple/libmaple/systick.h ****  * restriction, including without limitation the rights to use, copy,
  10:../Libmaple/libmaple/libmaple/systick.h ****  * modify, merge, publish, distribute, sublicense, and/or sell copies
  11:../Libmaple/libmaple/libmaple/systick.h ****  * of the Software, and to permit persons to whom the Software is
  12:../Libmaple/libmaple/libmaple/systick.h ****  * furnished to do so, subject to the following conditions:
  13:../Libmaple/libmaple/libmaple/systick.h ****  *
  14:../Libmaple/libmaple/libmaple/systick.h ****  * The above copyright notice and this permission notice shall be
  15:../Libmaple/libmaple/libmaple/systick.h ****  * included in all copies or substantial portions of the Software.
  16:../Libmaple/libmaple/libmaple/systick.h ****  *
  17:../Libmaple/libmaple/libmaple/systick.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  18:../Libmaple/libmaple/libmaple/systick.h ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  19:../Libmaple/libmaple/libmaple/systick.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20:../Libmaple/libmaple/libmaple/systick.h ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  21:../Libmaple/libmaple/libmaple/systick.h ****  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  22:../Libmaple/libmaple/libmaple/systick.h ****  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  23:../Libmaple/libmaple/libmaple/systick.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  24:../Libmaple/libmaple/libmaple/systick.h ****  * SOFTWARE.
  25:../Libmaple/libmaple/libmaple/systick.h ****  *****************************************************************************/
  26:../Libmaple/libmaple/libmaple/systick.h **** 
  27:../Libmaple/libmaple/libmaple/systick.h **** /**
  28:../Libmaple/libmaple/libmaple/systick.h ****  * @file systick.h
  29:../Libmaple/libmaple/libmaple/systick.h ****  *
  30:../Libmaple/libmaple/libmaple/systick.h ****  * @brief Various system timer definitions
  31:../Libmaple/libmaple/libmaple/systick.h ****  */
  32:../Libmaple/libmaple/libmaple/systick.h **** 
  33:../Libmaple/libmaple/libmaple/systick.h **** #ifndef _SYSTICK_H_
  34:../Libmaple/libmaple/libmaple/systick.h **** #define _SYSTICK_H_
  35:../Libmaple/libmaple/libmaple/systick.h **** 
  36:../Libmaple/libmaple/libmaple/systick.h **** #include "libmaple_types.h"
  37:../Libmaple/libmaple/libmaple/systick.h **** #include "util.h"
  38:../Libmaple/libmaple/libmaple/systick.h **** 
  39:../Libmaple/libmaple/libmaple/systick.h **** #ifdef __cplusplus
  40:../Libmaple/libmaple/libmaple/systick.h **** extern "C"{
  41:../Libmaple/libmaple/libmaple/systick.h **** #endif
  42:../Libmaple/libmaple/libmaple/systick.h **** 
  43:../Libmaple/libmaple/libmaple/systick.h **** /** SysTick register map type */
  44:../Libmaple/libmaple/libmaple/systick.h **** typedef struct systick_reg_map {
  45:../Libmaple/libmaple/libmaple/systick.h ****     __io uint32 CSR;            /**< Control and status register */
  46:../Libmaple/libmaple/libmaple/systick.h ****     __io uint32 RVR;            /**< Reload value register */
  47:../Libmaple/libmaple/libmaple/systick.h ****     __io uint32 CNT;            /**< Current value register ("count") */
  48:../Libmaple/libmaple/libmaple/systick.h ****     __io uint32 CVR;            /**< Calibration value register */
  49:../Libmaple/libmaple/libmaple/systick.h **** } systick_reg_map;
  50:../Libmaple/libmaple/libmaple/systick.h **** 
  51:../Libmaple/libmaple/libmaple/systick.h **** /** SysTick register map base pointer */
  52:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_BASE                    ((struct systick_reg_map*)0xE000E010)
  53:../Libmaple/libmaple/libmaple/systick.h **** 
  54:../Libmaple/libmaple/libmaple/systick.h **** /*
  55:../Libmaple/libmaple/libmaple/systick.h ****  * Register bit definitions.
  56:../Libmaple/libmaple/libmaple/systick.h ****  */
  57:../Libmaple/libmaple/libmaple/systick.h **** 
  58:../Libmaple/libmaple/libmaple/systick.h **** /* Control and status register */
  59:../Libmaple/libmaple/libmaple/systick.h **** 
  60:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_COUNTFLAG           BIT(16)
  61:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_CLKSOURCE           BIT(2)
  62:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_CLKSOURCE_EXTERNAL  0
  63:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_CLKSOURCE_CORE      BIT(2)
  64:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_TICKINT             BIT(1)
  65:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_TICKINT_PEND        BIT(1)
  66:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_TICKINT_NO_PEND     0
  67:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_ENABLE              BIT(0)
  68:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_ENABLE_MULTISHOT    BIT(0)
  69:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_ENABLE_DISABLED     0
  70:../Libmaple/libmaple/libmaple/systick.h **** 
  71:../Libmaple/libmaple/libmaple/systick.h **** /* Calibration value register */
  72:../Libmaple/libmaple/libmaple/systick.h **** 
  73:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CVR_NOREF               BIT(31)
  74:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CVR_SKEW                BIT(30)
  75:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CVR_TENMS               0xFFFFFF
  76:../Libmaple/libmaple/libmaple/systick.h **** 
  77:../Libmaple/libmaple/libmaple/systick.h **** /** System elapsed time, in milliseconds */
  78:../Libmaple/libmaple/libmaple/systick.h **** extern volatile uint32 systick_uptime_millis;
  79:../Libmaple/libmaple/libmaple/systick.h **** 
  80:../Libmaple/libmaple/libmaple/systick.h **** /**
  81:../Libmaple/libmaple/libmaple/systick.h ****  * @brief Returns the system uptime, in milliseconds.
  82:../Libmaple/libmaple/libmaple/systick.h ****  */
  83:../Libmaple/libmaple/libmaple/systick.h **** static inline uint32 systick_uptime(void) {
  84:../Libmaple/libmaple/libmaple/systick.h ****     return systick_uptime_millis;
  64              		.loc 3 84 0
  65 0000 014B     		ldr	r3, .L3
  66 0002 1868     		ldr	r0, [r3, #0]
  67              	.LBE6:
  68              	.LBE5:
  48:../Libmaple/libmaple/wirish/wirish_time.h ****     return systick_uptime();
  49:../Libmaple/libmaple/wirish/wirish_time.h **** }
  69              		.loc 2 49 0
  70 0004 7047     		bx	lr
  71              	.L4:
  72 0006 00BF     		.align	2
  73              	.L3:
  74 0008 00000000 		.word	systick_uptime_millis
  75              		.cfi_endproc
  76              	.LFE55:
  78              		.section	.text._ZL6microsv,"ax",%progbits
  79              		.align	1
  80              		.thumb
  81              		.thumb_func
  83              	_ZL6microsv:
  84              	.LFB56:
  50:../Libmaple/libmaple/wirish/wirish_time.h **** 
  51:../Libmaple/libmaple/wirish/wirish_time.h **** /**
  52:../Libmaple/libmaple/wirish/wirish_time.h ****  * Returns time (in microseconds) since the beginning of program
  53:../Libmaple/libmaple/wirish/wirish_time.h ****  * execution.  On overflow, restarts at 0.
  54:../Libmaple/libmaple/wirish/wirish_time.h ****  * @see millis()
  55:../Libmaple/libmaple/wirish/wirish_time.h ****  */
  56:../Libmaple/libmaple/wirish/wirish_time.h **** static inline uint32 micros(void) {
  85              		.loc 2 56 0
  86              		.cfi_startproc
  87              		@ args = 0, pretend = 0, frame = 0
  88              		@ frame_needed = 0, uses_anonymous_args = 0
  89 0000 38B5     		push	{r3, r4, r5, lr}
  90              	.LCFI0:
  91              		.cfi_def_cfa_offset 16
  92              		.cfi_offset 14, -4
  93              		.cfi_offset 5, -8
  94              		.cfi_offset 4, -12
  95              		.cfi_offset 3, -16
  96              	.L6:
  97              	.LBB10:
  57:../Libmaple/libmaple/wirish/wirish_time.h ****     uint32 ms;
  58:../Libmaple/libmaple/wirish/wirish_time.h ****     uint32 cycle_cnt;
  59:../Libmaple/libmaple/wirish/wirish_time.h ****     uint32 res;
  60:../Libmaple/libmaple/wirish/wirish_time.h **** 
  61:../Libmaple/libmaple/wirish/wirish_time.h ****     do {
  62:../Libmaple/libmaple/wirish/wirish_time.h ****         ms = millis();
  98              		.loc 2 62 0 discriminator 1
  99 0002 FFF7FEFF 		bl	_ZL6millisv
 100              	.LBB11:
 101              	.LBB12:
  85:../Libmaple/libmaple/libmaple/systick.h **** }
  86:../Libmaple/libmaple/libmaple/systick.h **** 
  87:../Libmaple/libmaple/libmaple/systick.h **** 
  88:../Libmaple/libmaple/libmaple/systick.h **** void systick_init(uint32 reload_val);
  89:../Libmaple/libmaple/libmaple/systick.h **** void systick_disable();
  90:../Libmaple/libmaple/libmaple/systick.h **** void systick_enable();
  91:../Libmaple/libmaple/libmaple/systick.h **** 
  92:../Libmaple/libmaple/libmaple/systick.h **** /**
  93:../Libmaple/libmaple/libmaple/systick.h ****  * @brief Returns the current value of the SysTick counter.
  94:../Libmaple/libmaple/libmaple/systick.h ****  */
  95:../Libmaple/libmaple/libmaple/systick.h **** static inline uint32 systick_get_count(void) {
  96:../Libmaple/libmaple/libmaple/systick.h ****     return SYSTICK_BASE->CNT;
 102              		.loc 3 96 0 discriminator 1
 103 0006 094B     		ldr	r3, .L8
 104              	.LBE12:
 105              	.LBE11:
 106              		.loc 2 62 0 discriminator 1
 107 0008 0446     		mov	r4, r0
 108              	.LVL3:
 109              	.LBB14:
 110              	.LBB13:
 111              		.loc 3 96 0 discriminator 1
 112 000a 9D68     		ldr	r5, [r3, #8]
 113              	.LBE13:
 114              	.LBE14:
  63:../Libmaple/libmaple/wirish/wirish_time.h ****         cycle_cnt = systick_get_count();
  64:../Libmaple/libmaple/wirish/wirish_time.h ****     } while (ms != millis());
 115              		.loc 2 64 0 discriminator 1
 116 000c FFF7FEFF 		bl	_ZL6millisv
 117              	.LVL4:
  61:../Libmaple/libmaple/wirish/wirish_time.h ****     do {
 118              		.loc 2 61 0 discriminator 1
 119 0010 8442     		cmp	r4, r0
 120 0012 F6D1     		bne	.L6
 121              	.LVL5:
  65:../Libmaple/libmaple/wirish/wirish_time.h **** 
  66:../Libmaple/libmaple/wirish/wirish_time.h ****     /* SYSTICK_RELOAD_VAL is 1 less than the number of cycles it
  67:../Libmaple/libmaple/wirish/wirish_time.h ****        actually takes to complete a SysTick reload */
  68:../Libmaple/libmaple/wirish/wirish_time.h ****     res = (ms * US_PER_MS) +
  69:../Libmaple/libmaple/wirish/wirish_time.h ****         (SYSTICK_RELOAD_VAL + 1 - cycle_cnt) / CYCLES_PER_MICROSECOND;
 122              		.loc 2 69 0
 123 0014 C5F52435 		rsb	r5, r5, #167936
 124              	.LVL6:
 125 0018 4035     		adds	r5, r5, #64
 126 001a A821     		movs	r1, #168
 127 001c B5FBF1F5 		udiv	r5, r5, r1
 128              	.LBE10:
  70:../Libmaple/libmaple/wirish/wirish_time.h **** 
  71:../Libmaple/libmaple/wirish/wirish_time.h ****     return res;
  72:../Libmaple/libmaple/wirish/wirish_time.h **** }
 129              		.loc 2 72 0
 130 0020 4FF47A70 		mov	r0, #1000
 131 0024 00FB0450 		mla	r0, r0, r4, r5
 132 0028 38BD     		pop	{r3, r4, r5, pc}
 133              	.L9:
 134 002a 00BF     		.align	2
 135              	.L8:
 136 002c 10E000E0 		.word	-536813552
 137              		.cfi_endproc
 138              	.LFE56:
 140              		.section	.text._Z9FrqChangev,"ax",%progbits
 141              		.align	1
 142              		.global	_Z9FrqChangev
 143              		.thumb
 144              		.thumb_func
 146              	_Z9FrqChangev:
 147              	.LFB171:
 148              		.file 4 "../Libraries/AQ_Receiver/Receiver_STM32PPM.h"
   1:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** /*
   2:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Copyright (c) 2012 kha.  All rights reserved.
   3:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
   4:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   STM32 PPM receiver by kha based on 
   5:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   STM32 receiver class by ala42 using time input capture
   6:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   for use with AeroQuad software and Maple library
   7:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   V 1.0 Jun 14 2012
   8:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
   9:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Define the pin numbers used for the receiver in receiverPin[]
  10:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  11:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Timer and timer channels are accessed using the Maple PIN_MAP array.
  12:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Make sure libmaple and this receiver class are compiled using the
  13:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   same structure alignment mode. When in doubt, change the stm32_pin_info
  14:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   declaration in wirish_types.h to align the size to a multiple of 4 byte
  15:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   by adding a filler byte at the end of the structure declaration.
  16:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** */
  17:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  18:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #ifndef _AEROQUAD_RECEIVER_STM32PPM_H_
  19:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #define _AEROQUAD_RECEIVER_STM32PPM_H_
  20:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  21:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #if defined(AeroQuadSTM32)
  22:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  23:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #include "Receiver.h"
  24:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #include "wirish.h"
  25:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  26:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** //#define STM32_TIMER_DEBUG // enable debug messages
  27:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  28:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** ///////////////////////////////////////////////////////////////////////////////
  29:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** // configuration part starts here
  30:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** // definition of pins used for PWM receiver input
  31:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  32:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #ifdef BOARD_aeroquad32
  33:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** static byte receiverPin = Port2Pin('D', 15);
  34:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #endif
  35:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  36:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #ifdef BOARD_aeroquad32mini
  37:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** static byte receiverPin = 2; // PB7
  38:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #endif
  39:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  40:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #ifdef BOARD_freeflight
  41:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** static byte receiverPin = Port2Pin('A',  0);
  42:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #endif
  43:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  44:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #ifdef BOARD_discovery_f4
  45:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** static byte receiverPin = Port2Pin('E',  9);
  46:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #endif
  47:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  48:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  49:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #define SERIAL_SUM_PPM_1         1,2,3,0,4,5,6,7 // PITCH,YAW,THR,ROLL... For Graupner/Spektrum
  50:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #define SERIAL_SUM_PPM_2         0,1,3,2,4,5,6,7 // ROLL,PITCH,THR,YAW... For Robe/Hitec/Futaba
  51:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #define SERIAL_SUM_PPM_3         1,0,3,2,4,5,6,7 // PITCH,ROLL,THR,YAW... For some Hitec/Sanwa/Othe
  52:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  53:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #if defined (SKETCH_SERIAL_SUM_PPM)
  54:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   #define SERIAL_SUM_PPM SKETCH_SERIAL_SUM_PPM
  55:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #else
  56:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   #define SERIAL_SUM_PPM SERIAL_SUM_PPM_1
  57:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #endif
  58:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  59:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** static byte ReceiverChannelMap[] = {SERIAL_SUM_PPM};
  60:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  61:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** uint16 rawChannelValue[8] =  {1500,1500,1500,1500,1500,1500,1500,1500};
  62:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** byte   currentChannel;
  63:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  64:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  65:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** ///////////////////////////////////////////////////////////////////////////////
  66:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** // implementation part starts here.
  67:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  68:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** typedef struct {
  69:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer_dev   *TimerDev;
  70:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer_gen_reg_map *TimerRegs;
  71:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   __io uint32	*Timer_ccr;
  72:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   uint16		RiseTime;
  73:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   int			TimerChannel;
  74:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   int			PolarityMask;
  75:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** } tFrqData;
  76:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  77:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** volatile tFrqData FrqData;
  78:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  79:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** void FrqInit(int aDefault, timer_dev *aTimer, int aTimerChannel)
  80:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** {
  81:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   aTimerChannel--;  // transform timer channel numbering from 1-4 to 0-3
  82:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  83:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.TimerDev     = aTimer;
  84:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer_gen_reg_map *timer = aTimer->regs.gen;
  85:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.TimerRegs    = timer;
  86:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   
  87:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.Timer_ccr    = &timer->CCR1 + aTimerChannel;
  88:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.TimerChannel = aTimerChannel;
  89:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   
  90:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   int TimerEnable = (1 << (4*aTimerChannel));
  91:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.PolarityMask = TimerEnable << 1;
  92:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   
  93:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   uint32 clock_speed = rcc_dev_timer_clk_speed(FrqData.TimerDev->clk_id);
  94:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->PSC	= (clock_speed/1000000)-1;
  95:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->ARR	= 0xffff;
  96:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CR1	= 0;
  97:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->DIER &= ~(1);
  98:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   
  99:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CCER &= ~TimerEnable; // Disable timer
 100:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CCER &= ~(FrqData.PolarityMask);
 101:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   
 102:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #ifdef STM32_TIMER_DEBUG
 103:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Serial.print("  clk ");
 104:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Serial.print(clock_speed/1000000, 10);
 105:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Serial.print("MHz ");
 106:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   
 107:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Serial.print(" CCMR0 ");
 108:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Serial.print(timer->CCMR1, 16);
 109:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #endif
 110:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   
 111:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   volatile uint32 *mr;
 112:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   if(aTimerChannel < 2) {
 113:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     mr = &(timer->CCMR1);
 114:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   } else {
 115:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     mr = &(timer->CCMR2);
 116:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   }
 117:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   *mr &= ~(0xFF << (8*(aTimerChannel&1)));	// prescaler 1
 118:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   *mr |= 0x61 << (8*(aTimerChannel&1));		// 0x61 -> 6=filter, 1=inputs 1,2,3,4
 119:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   
 120:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CCER |= TimerEnable; // Enable
 121:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CR1 = 1;
 122:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   
 123:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #ifdef STM32_TIMER_DEBUG
 124:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Serial.print(" CCER ");
 125:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Serial.print(timer->CCER, 16);
 126:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Serial.print(" CCMR1 ");
 127:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Serial.print(timer->CCMR1, 16);
 128:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Serial.println();
 129:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #endif
 130:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** }
 131:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 132:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** void FrqChange()
 133:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** {
 149              		.loc 4 133 0
 150              		.cfi_startproc
 151              		@ args = 0, pretend = 0, frame = 0
 152              		@ frame_needed = 0, uses_anonymous_args = 0
 153              	.LBB15:
 134:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer_gen_reg_map *timer = FrqData.TimerRegs;
 154              		.loc 4 134 0
 155 0000 174B     		ldr	r3, .L16
 156              	.LBE15:
 133:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** {
 157              		.loc 4 133 0
 158 0002 30B5     		push	{r4, r5, lr}
 159              	.LCFI1:
 160              		.cfi_def_cfa_offset 12
 161              		.cfi_offset 14, -4
 162              		.cfi_offset 5, -8
 163              		.cfi_offset 4, -12
 164              	.LBB18:
 165              		.loc 4 134 0
 166 0004 5868     		ldr	r0, [r3, #4]
 167              	.LVL7:
 135:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   uint16_t c = *(FrqData.Timer_ccr);
 168              		.loc 4 135 0
 169 0006 9C68     		ldr	r4, [r3, #8]
 170 0008 2468     		ldr	r4, [r4, #0]
 171              	.LVL8:
 136:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   bool rising = (timer->CCER & FrqData.PolarityMask) == 0;
 172              		.loc 4 136 0
 173 000a 026A     		ldr	r2, [r0, #32]
 174 000c 5969     		ldr	r1, [r3, #20]
 175              	.LVL9:
 176              	.LBB16:
 137:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 138:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   if(rising) {
 177              		.loc 4 138 0
 178 000e 11EA0200 		ands	r0, r1, r2
 179              	.LVL10:
 180 0012 1DD1     		bne	.L11
 181              	.LBB17:
 139:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     uint16_t diffTime = c - FrqData.RiseTime;
 182              		.loc 4 139 0
 183 0014 9D89     		ldrh	r5, [r3, #12]
 184 0016 611B     		subs	r1, r4, r5
 185              	.LVL11:
 186 0018 89B2     		uxth	r1, r1
 187              	.LVL12:
 140:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     if ((diffTime>900) && (diffTime<2100)) {
 188              		.loc 4 140 0
 189 001a A1F56072 		sub	r2, r1, #896
 190 001e 551F     		subs	r5, r2, #5
 191 0020 1FFA85FC 		uxth	ip, r5
 192 0024 40F2AE45 		movw	r5, #1198
 193 0028 AC45     		cmp	ip, r5
 194 002a 0E4A     		ldr	r2, .L16+4
 195 002c 07D8     		bhi	.L12
 141:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****       if (currentChannel<8) {
 196              		.loc 4 141 0
 197 002e 1078     		ldrb	r0, [r2, #0]	@ zero_extendqisi2
 198 0030 0728     		cmp	r0, #7
 199 0032 0CD8     		bhi	.L13
 142:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 	rawChannelValue[currentChannel]=diffTime;
 200              		.loc 4 142 0
 201 0034 0C4D     		ldr	r5, .L16+8
 202 0036 25F81010 		strh	r1, [r5, r0, lsl #1]	@ movhi
 143:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 	currentChannel++;
 203              		.loc 4 143 0
 204 003a 0130     		adds	r0, r0, #1
 205 003c 03E0     		b	.L15
 206              	.L12:
 144:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****       }
 145:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     } else if (diffTime>2500) {
 207              		.loc 4 145 0
 208 003e 40F6C415 		movw	r5, #2500
 209 0042 A942     		cmp	r1, r5
 210 0044 01D9     		bls	.L14
 211              	.L15:
 146:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****       currentChannel=0;
 212              		.loc 4 146 0
 213 0046 1070     		strb	r0, [r2, #0]
 214 0048 01E0     		b	.L13
 215              	.L14:
 147:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     } else {
 148:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****       // glitch stop and wait next round
 149:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****       currentChannel=9;
 216              		.loc 4 149 0
 217 004a 0920     		movs	r0, #9
 218 004c 1070     		strb	r0, [r2, #0]
 219              	.L13:
 150:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     }
 151:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     //    Serial.print(highTime);
 152:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     //    Serial.println();
 153:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     FrqData.RiseTime = c;
 220              		.loc 4 153 0
 221 004e 9C81     		strh	r4, [r3, #12]	@ movhi
 222              	.LVL13:
 223              	.L11:
 224              	.LBE17:
 225              	.LBE16:
 154:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   }
 155:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.TimerRegs->CCER ^= FrqData.PolarityMask; // invert polarity
 226              		.loc 4 155 0
 227 0050 5A68     		ldr	r2, [r3, #4]
 228 0052 116A     		ldr	r1, [r2, #32]
 229 0054 5869     		ldr	r0, [r3, #20]
 230 0056 80EA0103 		eor	r3, r0, r1
 231 005a 1362     		str	r3, [r2, #32]
 232              	.LBE18:
 156:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** }
 233              		.loc 4 156 0
 234 005c 30BD     		pop	{r4, r5, pc}
 235              	.L17:
 236 005e 00BF     		.align	2
 237              	.L16:
 238 0060 00000000 		.word	.LANCHOR0
 239 0064 00000000 		.word	.LANCHOR1
 240 0068 00000000 		.word	.LANCHOR2
 241              		.cfi_endproc
 242              	.LFE171:
 244              		.section	.text._ZL16hottV4SendBinaryPh,"ax",%progbits
 245              		.align	1
 246              		.thumb
 247              		.thumb_func
 249              	_ZL16hottV4SendBinaryPh:
 250              	.LFB216:
 251              		.file 5 "../Libraries/AQ_HoTT/HoTT_Telemetry.h"
   1:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /*
   2:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   www.AeroQuad.com
   4:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  
   7:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   (at your option) any later version. 
  11:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  12:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  17:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** */
  20:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  21:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #ifndef _AEROQUAD_HOTT_TELEMETRY_H_
  22:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #define _AEROQUAD_HOTT_TELEMETRY_H_
  23:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  24:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #include "HoTT.h"
  25:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #include <stdio.h>
  26:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  27:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** HardwareSerial *hottV4Serial;
  28:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  29:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static uint8_t minutes = 0;
  30:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static uint16_t milliseconds = 0;
  31:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static signed int maxAltitude = 500;
  32:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static signed int minAltitude = 500;
  33:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** volatile unsigned int CountMilliseconds = 0;
  34:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** unsigned char SpeakHoTT = HoTTv4NotificationMicrocopter;
  35:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  36:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /* ##################################################################### *
  37:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  *                HoTTv4 Common Serial                                   *
  38:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * ##################################################################### */
  39:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  40:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  41:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
  42:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Writes out given data to data register.
  43:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
  44:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static void hottV4SerialWrite(uint8_t data) {
  45:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4Serial->write(data);
  46:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
  47:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  48:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
  49:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Clears input buffer
  50:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
  51:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** void hottV4SerialClearInput() {
  52:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	while(hottV4Serial->available() > 0) {
  53:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		hottV4Serial->read();
  54:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	}
  55:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
  56:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  57:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
  58:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Reads last byte from input buffer
  59:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
  60:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** int hottV4SerialRead() {
  61:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	while(hottV4Serial->available() > 1) {
  62:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		hottV4Serial->read();
  63:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	}
  64:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     if(hottV4Serial->available()) {
  65:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     	return hottV4Serial->read();
  66:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     } else {
  67:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     	return 0xff;
  68:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     }
  69:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
  70:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  71:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  72:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  73:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #define hottV4TelemetryBufferSize 45
  74:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static uint8_t  hottV4TelemetryBuffer[hottV4TelemetryBufferSize];
  75:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static byte  hottV4TelemetryBufferIndex;
  76:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  77:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
  78:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Buffer telemetry data
  79:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
  80:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static void hottV4SendBinary(uint8_t *data) {
 252              		.loc 5 80 0
 253              		.cfi_startproc
 254              		@ args = 0, pretend = 0, frame = 0
 255              		@ frame_needed = 0, uses_anonymous_args = 0
 256              	.LVL14:
 257 0000 10B5     		push	{r4, lr}
 258              	.LCFI2:
 259              		.cfi_def_cfa_offset 8
 260              		.cfi_offset 14, -4
 261              		.cfi_offset 4, -8
 262              		.loc 5 80 0
 263 0002 0023     		movs	r3, #0
  81:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint16_t crc = 0;
 264              		.loc 5 81 0
 265 0004 1A46     		mov	r2, r3
 266              	.LVL15:
 267              	.L19:
 268              	.LBB19:
 269              	.LBB20:
  82:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  83:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   for (uint8_t index = 0; index < hottV4TelemetryBufferSize-1; index++) {
  84:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     crc = crc + data[index];
 270              		.loc 5 84 0 discriminator 2
 271 0006 C45C     		ldrb	r4, [r0, r3]	@ zero_extendqisi2
  85:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     hottV4TelemetryBuffer[index] = data[index];
 272              		.loc 5 85 0 discriminator 2
 273 0008 0649     		ldr	r1, .L21
 274 000a 5C54     		strb	r4, [r3, r1]
 275 000c 0133     		adds	r3, r3, #1
  84:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     crc = crc + data[index];
 276              		.loc 5 84 0 discriminator 2
 277 000e A218     		adds	r2, r4, r2
  83:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   for (uint8_t index = 0; index < hottV4TelemetryBufferSize-1; index++) {
 278              		.loc 5 83 0 discriminator 2
 279 0010 2C2B     		cmp	r3, #44
  84:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     crc = crc + data[index];
 280              		.loc 5 84 0 discriminator 2
 281 0012 92B2     		uxth	r2, r2
 282              	.LVL16:
  83:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   for (uint8_t index = 0; index < hottV4TelemetryBufferSize-1; index++) {
 283              		.loc 5 83 0 discriminator 2
 284 0014 F7D1     		bne	.L19
 285              	.LVL17:
 286              	.LBE20:
  86:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****    }
  87:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  88:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint8_t crcVal = crc & 0xFF;
  89:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4TelemetryBuffer[hottV4TelemetryBufferSize-1] = crcVal;
  90:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  91:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4TelemetryBufferIndex = 0;
 287              		.loc 5 91 0
 288 0016 044B     		ldr	r3, .L21+4
  88:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint8_t crcVal = crc & 0xFF;
 289              		.loc 5 88 0
 290 0018 81F82C20 		strb	r2, [r1, #44]
 291              		.loc 5 91 0
 292 001c 0020     		movs	r0, #0
 293              	.LVL18:
 294 001e 1870     		strb	r0, [r3, #0]
 295              	.LBE19:
  92:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 296              		.loc 5 92 0
 297 0020 10BD     		pop	{r4, pc}
 298              	.L22:
 299 0022 00BF     		.align	2
 300              	.L21:
 301 0024 00000000 		.word	.LANCHOR3
 302 0028 00000000 		.word	.LANCHOR4
 303              		.cfi_endproc
 304              	.LFE216:
 306              		.section	.text._ZL20hottv4UpdateAltVariov,"ax",%progbits
 307              		.align	1
 308              		.thumb
 309              		.thumb_func
 311              	_ZL20hottv4UpdateAltVariov:
 312              	.LFB223:
  93:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  94:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  95:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /* ##################################################################### *
  96:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  *                HoTTv4 Module specific Update functions                *
  97:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * ##################################################################### */
  98:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  99:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #if defined(HOTTV4DIR)
 100:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
 101:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Updates current direction related on compass information.
 102:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
 103:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static int hottV4UpdateDirection() {
 104:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	return 180;
 105:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	return ((int)(trueNorthHeading / M_PI * 180.0) + 360) % 360;
 106:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	}
 107:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #endif
 108:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 109:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static void HoTTInvertDisplay(uint8_t *data) {
 110:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     data[4] = 0x80; // Inverts MikroKopter Telemetry Display for Voltage
 111:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 112:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 113:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #if defined(BattMonitor)
 114:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
 115:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Updates battery voltage telemetry data with given value.
 116:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Resolution is in 0,1V, e.g. 0x7E == 12,6V.
 117:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * If value is below batteryWarning, telemetry alarm is triggered
 118:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
 119:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static short hottv4UpdateBattery(uint8_t *data) {
 120:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	short voltage = batteryData[0].voltage/10;
 121:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 122:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryWarning || batteryAlarm) {
 123:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		HoTTInvertDisplay(data);
 124:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	}
 125:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 126:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	return voltage;
 127:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 128:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 129:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static short hottv4UpdateCurrent() {
 130:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryData[0].cPin != BM_NOPIN) return batteryData[0].current/100;
 131:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	return 0;
 132:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 133:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 134:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static long hottv4UpdateCapacity() {
 135:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryData[0].cPin != BM_NOPIN) return batteryData[0].usedCapacity/1000;
 136:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	return 0;
 137:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 138:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #endif
 139:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 140:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 141:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #if defined(AltitudeHoldBaro) || defined(AltitudeHoldRangeFinder)
 142:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
 143:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Current relative altitude based on baro or ultrasonic values. 
 144:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Result is displayed in meter.
 145:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  *
 146:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * @param data Pointer to telemetry data frame
 147:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * @param lowByteIndex Index for the low byte that represents the altitude in telemetry data frame
 148:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
 149:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static int32_t hottv4UpdateAlt() {
 150:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   int32_t alt = 0;
 151:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   
 152:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #if defined AltitudeHoldBaro
 153:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   alt = (int)getBaroAltitude() + 500;
 154:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #endif 
 155:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 156:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #if defined AltitudeHoldRangeFinder
 157:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if (isOnRangerRange(rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX])) {
 158:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	alt = (int)rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX] + 500;
 159:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   }
 160:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #endif
 161:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   
 162:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(alt > maxAltitude) maxAltitude = alt;
 163:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   else if(alt < minAltitude) minAltitude = alt;
 164:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 165:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   return alt;
 166:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 167:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 168:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 169:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static unsigned int hottv4UpdateAltVario() {
 313              		.loc 5 169 0
 314              		.cfi_startproc
 315              		@ args = 0, pretend = 0, frame = 0
 316              		@ frame_needed = 0, uses_anonymous_args = 0
 317              	.LVL19:
 318 0000 10B5     		push	{r4, lr}
 319              	.LCFI3:
 320              		.cfi_def_cfa_offset 8
 321              		.cfi_offset 14, -4
 322              		.cfi_offset 4, -8
 323              	.LBB21:
 170:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	unsigned int varioSound = 30000;
 171:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 172:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if(altitudeHoldState == ON)
 324              		.loc 5 172 0
 325 0002 0E48     		ldr	r0, .L28
 326 0004 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 327 0006 012B     		cmp	r3, #1
 328 0008 12D1     		bne	.L25
 173:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	{
 174:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		if((receiverCommand[THROTTLE] > (altitudeHoldThrottle + altitudeHoldBump))) varioSound = 30100;
 329              		.loc 5 174 0
 330 000a 0D48     		ldr	r0, .L28+4
 331 000c 0D4A     		ldr	r2, .L28+8
 332 000e 0E4B     		ldr	r3, .L28+12
 333 0010 0068     		ldr	r0, [r0, #0]
 334 0012 1268     		ldr	r2, [r2, #0]
 335 0014 DB68     		ldr	r3, [r3, #12]
 336 0016 8118     		adds	r1, r0, r2
 337 0018 8B42     		cmp	r3, r1
 338 001a 0CDC     		bgt	.L26
 175:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		else if((receiverCommand[THROTTLE] < (altitudeHoldThrottle - altitudeHoldBump))) varioSound = 299
 339              		.loc 5 175 0
 340 001c 821A     		subs	r2, r0, r2
 170:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	unsigned int varioSound = 30000;
 341              		.loc 5 170 0
 342 001e 47F2305C 		movw	ip, #30000
 343 0022 47F2CC44 		movw	r4, #29900
 344 0026 9342     		cmp	r3, r2
 345 0028 B4BF     		ite	lt
 346 002a 2046     		movlt	r0, r4
 347 002c 6046     		movge	r0, ip
 348 002e 10BD     		pop	{r4, pc}
 349              	.L25:
 350 0030 47F23050 		movw	r0, #30000
 351 0034 10BD     		pop	{r4, pc}
 352              	.L26:
 174:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		if((receiverCommand[THROTTLE] > (altitudeHoldThrottle + altitudeHoldBump))) varioSound = 30100;
 353              		.loc 5 174 0
 354 0036 47F29450 		movw	r0, #30100
 355              	.LVL20:
 356              	.LBE21:
 176:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	}
 177:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 178:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	return varioSound;
 179:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 357              		.loc 5 179 0
 358 003a 10BD     		pop	{r4, pc}
 359              	.L29:
 360              		.align	2
 361              	.L28:
 362 003c 00000000 		.word	.LANCHOR5
 363 0040 00000000 		.word	.LANCHOR7
 364 0044 00000000 		.word	.LANCHOR8
 365 0048 00000000 		.word	.LANCHOR6
 366              		.cfi_endproc
 367              	.LFE223:
 369              		.section	.text.startup._Z7premainv,"ax",%progbits
 370              		.align	1
 371              		.global	_Z7premainv
 372              		.thumb
 373              		.thumb_func
 375              	_Z7premainv:
 376              	.LFB113:
 377              		.file 6 "C:/MinGW/msys/1.0/home/ang/AeroQuad32/AeroQuadMain.cpp"
   1:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp **** #include <SerialMapping.h>
   2:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp **** #include <WProgram.h>
   3:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp **** 
   4:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp **** __attribute__(( constructor )) void premain() {
 378              		.loc 6 4 0
 379              		.cfi_startproc
 380              		@ args = 0, pretend = 0, frame = 0
 381              		@ frame_needed = 0, uses_anonymous_args = 0
 382              		@ link register save eliminated.
   5:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp ****     init();
   6:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp **** }
 383              		.loc 6 6 0
   5:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp ****     init();
 384              		.loc 6 5 0
 385 0000 FFF7FEBF 		b	_Z4initv
 386              		.cfi_endproc
 387              	.LFE113:
 389              		.section	.init_array,"aw",%init_array
 390              		.align	2
 391 0000 00000000 		.word	_Z7premainv(target1)
 392              		.section	.text._Z23initializeReceiverParami,"ax",%progbits
 393              		.align	1
 394              		.global	_Z23initializeReceiverParami
 395              		.thumb
 396              		.thumb_func
 398              	_Z23initializeReceiverParami:
 399              	.LFB121:
 400              		.file 7 "../Libraries/AQ_Receiver/Receiver.h"
   1:../Libraries/AQ_Receiver/Receiver.h **** /*
   2:../Libraries/AQ_Receiver/Receiver.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Receiver/Receiver.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Receiver/Receiver.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Receiver/Receiver.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Receiver/Receiver.h ****  
   7:../Libraries/AQ_Receiver/Receiver.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Receiver/Receiver.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Receiver/Receiver.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Receiver/Receiver.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Receiver/Receiver.h **** 
  12:../Libraries/AQ_Receiver/Receiver.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Receiver/Receiver.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Receiver/Receiver.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Receiver/Receiver.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Receiver/Receiver.h **** 
  17:../Libraries/AQ_Receiver/Receiver.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Receiver/Receiver.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Receiver/Receiver.h **** */
  20:../Libraries/AQ_Receiver/Receiver.h **** 
  21:../Libraries/AQ_Receiver/Receiver.h **** #ifndef _AEROQUAD_RECEIVER_H_
  22:../Libraries/AQ_Receiver/Receiver.h **** #define _AEROQUAD_RECEIVER_H_
  23:../Libraries/AQ_Receiver/Receiver.h **** 
  24:../Libraries/AQ_Receiver/Receiver.h **** #include "Arduino.h"
  25:../Libraries/AQ_Receiver/Receiver.h **** 
  26:../Libraries/AQ_Receiver/Receiver.h **** #define PWM2RAD 0.002 //  Based upon 5RAD for full stick movement, you take this times the RAD to g
  27:../Libraries/AQ_Receiver/Receiver.h **** 
  28:../Libraries/AQ_Receiver/Receiver.h **** // Receiver variables
  29:../Libraries/AQ_Receiver/Receiver.h **** #define TIMEOUT 25000
  30:../Libraries/AQ_Receiver/Receiver.h **** #define MINCOMMAND 1000
  31:../Libraries/AQ_Receiver/Receiver.h **** #define MIDCOMMAND 1500
  32:../Libraries/AQ_Receiver/Receiver.h **** #define MAXCOMMAND 2000
  33:../Libraries/AQ_Receiver/Receiver.h **** #define MINDELTA 200
  34:../Libraries/AQ_Receiver/Receiver.h **** #define MINCHECK MINCOMMAND + 100
  35:../Libraries/AQ_Receiver/Receiver.h **** #define MAXCHECK MAXCOMMAND - 100
  36:../Libraries/AQ_Receiver/Receiver.h **** #define MINTHROTTLE MINCOMMAND + 100
  37:../Libraries/AQ_Receiver/Receiver.h **** #define LEVELOFF 100
  38:../Libraries/AQ_Receiver/Receiver.h **** #define MAX_NB_CHANNEL 8
  39:../Libraries/AQ_Receiver/Receiver.h **** 
  40:../Libraries/AQ_Receiver/Receiver.h **** int lastReceiverChannel = 0;
  41:../Libraries/AQ_Receiver/Receiver.h **** 
  42:../Libraries/AQ_Receiver/Receiver.h **** float receiverXmitFactor = 0.0;
  43:../Libraries/AQ_Receiver/Receiver.h **** int receiverData[MAX_NB_CHANNEL] = {0,0,0,0,0,0,0,0};
  44:../Libraries/AQ_Receiver/Receiver.h **** int receiverZero[3] = {0,0,0};
  45:../Libraries/AQ_Receiver/Receiver.h **** int receiverCommand[MAX_NB_CHANNEL] = {0,0,0,0,0,0,0,0};
  46:../Libraries/AQ_Receiver/Receiver.h **** int receiverCommandSmooth[MAX_NB_CHANNEL] = {0,0,0,0,0,0,0,0};
  47:../Libraries/AQ_Receiver/Receiver.h **** float receiverSlope[MAX_NB_CHANNEL] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
  48:../Libraries/AQ_Receiver/Receiver.h **** float receiverOffset[MAX_NB_CHANNEL] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
  49:../Libraries/AQ_Receiver/Receiver.h **** float receiverSmoothFactor[MAX_NB_CHANNEL] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
  50:../Libraries/AQ_Receiver/Receiver.h **** int channelCal;
  51:../Libraries/AQ_Receiver/Receiver.h **** 
  52:../Libraries/AQ_Receiver/Receiver.h **** void initializeReceiverParam(int nbChannel = 6) {
 401              		.loc 7 52 0
 402              		.cfi_startproc
 403              		@ args = 0, pretend = 0, frame = 0
 404              		@ frame_needed = 0, uses_anonymous_args = 0
 405              		@ link register save eliminated.
 406              	.LVL21:
 407              	.LBB22:
  53:../Libraries/AQ_Receiver/Receiver.h ****   
  54:../Libraries/AQ_Receiver/Receiver.h ****   lastReceiverChannel = nbChannel;
 408              		.loc 7 54 0
 409 0000 244A     		ldr	r2, .L40
  55:../Libraries/AQ_Receiver/Receiver.h **** 
  56:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[XAXIS] = 1500;
 410              		.loc 7 56 0
 411 0002 254B     		ldr	r3, .L40+4
  54:../Libraries/AQ_Receiver/Receiver.h ****   lastReceiverChannel = nbChannel;
 412              		.loc 7 54 0
 413 0004 1060     		str	r0, [r2, #0]
 414              		.loc 7 56 0
 415 0006 40F2DC51 		movw	r1, #1500
  57:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[YAXIS] = 1500;
  58:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[ZAXIS] = 1500;
  59:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[THROTTLE] = 1000;
 416              		.loc 7 59 0
 417 000a 4FF47A72 		mov	r2, #1000
  56:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[XAXIS] = 1500;
 418              		.loc 7 56 0
 419 000e 1960     		str	r1, [r3, #0]
  57:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[YAXIS] = 1500;
 420              		.loc 7 57 0
 421 0010 5960     		str	r1, [r3, #4]
  58:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[ZAXIS] = 1500;
 422              		.loc 7 58 0
 423 0012 9960     		str	r1, [r3, #8]
 424              		.loc 7 59 0
 425 0014 DA60     		str	r2, [r3, #12]
  60:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[MODE] = 1000;
 426              		.loc 7 60 0
 427 0016 1A61     		str	r2, [r3, #16]
  61:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[AUX1] = 1000;
 428              		.loc 7 61 0
 429 0018 5A61     		str	r2, [r3, #20]
  62:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[AUX2] = 1000;
 430              		.loc 7 62 0
 431 001a 9A61     		str	r2, [r3, #24]
  63:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[AUX3] = 1000;
 432              		.loc 7 63 0
 433 001c DA61     		str	r2, [r3, #28]
 434              	.LVL22:
 435              	.LBB23:
  64:../Libraries/AQ_Receiver/Receiver.h ****   
  65:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 436              		.loc 7 65 0
 437 001e 0023     		movs	r3, #0
 438 0020 07E0     		b	.L32
 439              	.LVL23:
 440              	.L33:
  66:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = 1.0;
 441              		.loc 7 66 0 discriminator 2
 442 0022 0121     		movs	r1, #1
 443 0024 1D4A     		ldr	r2, .L40+8
  65:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 444              		.loc 7 65 0 discriminator 2
 445 0026 03EB010C 		add	ip, r3, r1
 446              		.loc 7 66 0 discriminator 2
 447 002a 42F82310 		str	r1, [r2, r3, lsl #2]
  65:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 448              		.loc 7 65 0 discriminator 2
 449 002e 5FFA8CF3 		uxtb	r3, ip
 450              	.LVL24:
 451              	.L32:
  65:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 452              		.loc 7 65 0 is_stmt 0 discriminator 1
 453 0032 8342     		cmp	r3, r0
 454 0034 F5DB     		blt	.L33
 455              	.LVL25:
 456              	.LBE23:
 457              	.LBB24:
  67:../Libraries/AQ_Receiver/Receiver.h ****   }
  68:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < THROTTLE; channel++) {
  69:../Libraries/AQ_Receiver/Receiver.h ****     receiverZero[channel] = 1500;
 458              		.loc 7 69 0 is_stmt 1 discriminator 1
 459 0036 1A4B     		ldr	r3, .L40+12
 460              	.LVL26:
 461 0038 40F2DC51 		movw	r1, #1500
 462 003c 1960     		str	r1, [r3, #0]
 463              	.LVL27:
 464 003e 5960     		str	r1, [r3, #4]
 465              	.LVL28:
 466 0040 9960     		str	r1, [r3, #8]
 467              	.LVL29:
 468 0042 0023     		movs	r3, #0
 469 0044 08E0     		b	.L34
 470              	.LVL30:
 471              	.L35:
 472              	.LBE24:
 473              	.LBB25:
  70:../Libraries/AQ_Receiver/Receiver.h ****   }
  71:../Libraries/AQ_Receiver/Receiver.h **** 	
  72:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
  73:../Libraries/AQ_Receiver/Receiver.h ****     receiverSlope[channel] = 1;
 474              		.loc 7 73 0 discriminator 2
 475 0046 174A     		ldr	r2, .L40+16
 476 0048 02EB8301 		add	r1, r2, r3, lsl #2
 477 004c 4FF07E5C 		mov	ip, #1065353216
  72:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 478              		.loc 7 72 0 discriminator 2
 479 0050 5A1C     		adds	r2, r3, #1
 480              		.loc 7 73 0 discriminator 2
 481 0052 C1F800C0 		str	ip, [r1, #0]	@ float
  72:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 482              		.loc 7 72 0 discriminator 2
 483 0056 D3B2     		uxtb	r3, r2
 484              	.LVL31:
 485              	.L34:
  72:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 486              		.loc 7 72 0 is_stmt 0 discriminator 1
 487 0058 8342     		cmp	r3, r0
 488 005a F4DB     		blt	.L35
  72:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 489              		.loc 7 72 0
 490 005c 0023     		movs	r3, #0
 491              	.LVL32:
 492 005e 08E0     		b	.L36
 493              	.LVL33:
 494              	.L37:
 495              	.LBE25:
 496              	.LBB26:
  74:../Libraries/AQ_Receiver/Receiver.h ****   }	
  75:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
  76:../Libraries/AQ_Receiver/Receiver.h ****     receiverOffset[channel] = 1;
 497              		.loc 7 76 0 is_stmt 1 discriminator 2
 498 0060 114A     		ldr	r2, .L40+20
 499 0062 02EB8301 		add	r1, r2, r3, lsl #2
 500 0066 4FF07E5C 		mov	ip, #1065353216
  75:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 501              		.loc 7 75 0 discriminator 2
 502 006a 0133     		adds	r3, r3, #1
 503              	.LVL34:
 504              		.loc 7 76 0 discriminator 2
 505 006c C1F800C0 		str	ip, [r1, #0]	@ float
  75:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 506              		.loc 7 75 0 discriminator 2
 507 0070 DBB2     		uxtb	r3, r3
 508              	.LVL35:
 509              	.L36:
  75:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 510              		.loc 7 75 0 is_stmt 0 discriminator 1
 511 0072 8342     		cmp	r3, r0
 512 0074 F4DB     		blt	.L37
  75:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 513              		.loc 7 75 0
 514 0076 0023     		movs	r3, #0
 515              	.LVL36:
 516 0078 08E0     		b	.L38
 517              	.LVL37:
 518              	.L39:
 519              	.LBE26:
 520              	.LBB27:
  77:../Libraries/AQ_Receiver/Receiver.h ****   }
  78:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
  79:../Libraries/AQ_Receiver/Receiver.h ****     receiverSmoothFactor[channel] = 1; 
 521              		.loc 7 79 0 is_stmt 1 discriminator 2
 522 007a 0C4A     		ldr	r2, .L40+24
 523 007c 02EB8301 		add	r1, r2, r3, lsl #2
 524 0080 4FF07E5C 		mov	ip, #1065353216
  78:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 525              		.loc 7 78 0 discriminator 2
 526 0084 0133     		adds	r3, r3, #1
 527              	.LVL38:
 528              		.loc 7 79 0 discriminator 2
 529 0086 C1F800C0 		str	ip, [r1, #0]	@ float
  78:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 530              		.loc 7 78 0 discriminator 2
 531 008a DBB2     		uxtb	r3, r3
 532              	.LVL39:
 533              	.L38:
  78:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 534              		.loc 7 78 0 is_stmt 0 discriminator 1
 535 008c 8342     		cmp	r3, r0
 536 008e F4DB     		blt	.L39
 537              	.LBE27:
 538              	.LBE22:
  80:../Libraries/AQ_Receiver/Receiver.h ****   }
  81:../Libraries/AQ_Receiver/Receiver.h **** }
 539              		.loc 7 81 0 is_stmt 1
 540 0090 7047     		bx	lr
 541              	.L41:
 542 0092 00BF     		.align	2
 543              	.L40:
 544 0094 00000000 		.word	.LANCHOR9
 545 0098 00000000 		.word	.LANCHOR6
 546 009c 00000000 		.word	.LANCHOR10
 547 00a0 00000000 		.word	.LANCHOR11
 548 00a4 00000000 		.word	.LANCHOR12
 549 00a8 00000000 		.word	.LANCHOR13
 550 00ac 00000000 		.word	.LANCHOR14
 551              		.cfi_endproc
 552              	.LFE121:
 554              		.section	.text._Z17getReceiverSIDatah,"ax",%progbits
 555              		.align	1
 556              		.global	_Z17getReceiverSIDatah
 557              		.thumb
 558              		.thumb_func
 560              	_Z17getReceiverSIDatah:
 561              	.LFB123:
  82:../Libraries/AQ_Receiver/Receiver.h ****   
  83:../Libraries/AQ_Receiver/Receiver.h **** int getRawChannelValue(byte channel);  
  84:../Libraries/AQ_Receiver/Receiver.h **** void readReceiver();
  85:../Libraries/AQ_Receiver/Receiver.h ****   
  86:../Libraries/AQ_Receiver/Receiver.h **** void readReceiver()
  87:../Libraries/AQ_Receiver/Receiver.h **** {
  88:../Libraries/AQ_Receiver/Receiver.h ****   for(byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
  89:../Libraries/AQ_Receiver/Receiver.h **** 
  90:../Libraries/AQ_Receiver/Receiver.h ****     // Apply receiver calibration adjustment
  91:../Libraries/AQ_Receiver/Receiver.h ****     receiverData[channel] = (receiverSlope[channel] * getRawChannelValue(channel)) + receiverOffset
  92:../Libraries/AQ_Receiver/Receiver.h ****     // Smooth the flight control receiver inputs
  93:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = filterSmooth(receiverData[channel], receiverCommandSmooth[chan
  94:../Libraries/AQ_Receiver/Receiver.h ****   }
  95:../Libraries/AQ_Receiver/Receiver.h ****   
  96:../Libraries/AQ_Receiver/Receiver.h ****   // Reduce receiver commands using receiverXmitFactor and center around 1500
  97:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < THROTTLE; channel++) {
  98:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommand[channel] = ((receiverCommandSmooth[channel] - receiverZero[channel]) * receiver
  99:../Libraries/AQ_Receiver/Receiver.h ****   }	
 100:../Libraries/AQ_Receiver/Receiver.h ****   // No xmitFactor reduction applied for throttle, mode and AUX
 101:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = THROTTLE; channel < lastReceiverChannel; channel++) {
 102:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommand[channel] = receiverCommandSmooth[channel];
 103:../Libraries/AQ_Receiver/Receiver.h ****   }
 104:../Libraries/AQ_Receiver/Receiver.h **** }
 105:../Libraries/AQ_Receiver/Receiver.h **** 
 106:../Libraries/AQ_Receiver/Receiver.h **** 
 107:../Libraries/AQ_Receiver/Receiver.h **** void setChannelValue(byte channel,int value);
 108:../Libraries/AQ_Receiver/Receiver.h ****   
 109:../Libraries/AQ_Receiver/Receiver.h **** // return the smoothed & scaled number of radians/sec in stick movement - zero centered
 110:../Libraries/AQ_Receiver/Receiver.h **** const float getReceiverSIData(byte channel) {
 562              		.loc 7 110 0
 563              		.cfi_startproc
 564              		@ args = 0, pretend = 0, frame = 0
 565              		@ frame_needed = 0, uses_anonymous_args = 0
 566              		@ link register save eliminated.
 567              	.LVL40:
 111:../Libraries/AQ_Receiver/Receiver.h ****   return ((receiverCommand[channel] - receiverZero[channel]) * (2.5 * PWM2RAD));  // +/- 2.5RPS 50%
 568              		.loc 7 111 0
 569 0000 0849     		ldr	r1, .L43
 570 0002 094B     		ldr	r3, .L43+4
 571 0004 51F82020 		ldr	r2, [r1, r0, lsl #2]
 572 0008 53F82010 		ldr	r1, [r3, r0, lsl #2]
 573 000c 531A     		subs	r3, r2, r1
 574 000e 00EE103A 		fmsr	s0, r3	@ int
 112:../Libraries/AQ_Receiver/Receiver.h **** }
 575              		.loc 7 112 0
 576 0012 DFED067A 		flds	s15, .L43+8
 111:../Libraries/AQ_Receiver/Receiver.h ****   return ((receiverCommand[channel] - receiverZero[channel]) * (2.5 * PWM2RAD));  // +/- 2.5RPS 50%
 577              		.loc 7 111 0
 578 0016 B8EEC07A 		fsitos	s14, s0
 579              		.loc 7 112 0
 580 001a 67EE276A 		fmuls	s13, s14, s15
 581 001e 16EE900A 		fmrs	r0, s13
 582              	.LVL41:
 583 0022 7047     		bx	lr
 584              	.L44:
 585              		.align	2
 586              	.L43:
 587 0024 00000000 		.word	.LANCHOR6
 588 0028 00000000 		.word	.LANCHOR11
 589 002c 0BD7A33B 		.word	1000593163
 590              		.cfi_endproc
 591              	.LFE123:
 593              		.section	.text._Z9updatePIDffP7PIDdata,"ax",%progbits
 594              		.align	1
 595              		.global	_Z9updatePIDffP7PIDdata
 596              		.thumb
 597              		.thumb_func
 599              	_Z9updatePIDffP7PIDdata:
 600              	.LFB124:
 601              		.file 8 "C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad/PID.h"
   1:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** /*
   2:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   AeroQuad v3.0.1 - February 2012
   3:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   www.AeroQuad.com
   4:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   An Open Source Arduino based multicopter.
   6:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****  
   7:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   This program is free software: you can redistribute it and/or modify 
   8:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   it under the terms of the GNU General Public License as published by 
   9:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   (at your option) any later version. 
  11:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** 
  12:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   This program is distributed in the hope that it will be useful, 
  13:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   GNU General Public License for more details. 
  16:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** 
  17:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   You should have received a copy of the GNU General Public License 
  18:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** */
  20:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** 
  21:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** #ifndef _AQ_PID_H_
  22:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** #define _AQ_PID_H_
  23:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** 
  24:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** enum {
  25:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   RATE_XAXIS_PID_IDX = 0,
  26:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   RATE_YAXIS_PID_IDX,
  27:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   ZAXIS_PID_IDX,
  28:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   ATTITUDE_XAXIS_PID_IDX,
  29:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   ATTITUDE_YAXIS_PID_IDX,
  30:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   HEADING_HOLD_PID_IDX,
  31:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   ATTITUDE_GYRO_XAXIS_PID_IDX,
  32:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   ATTITUDE_GYRO_YAXIS_PID_IDX,
  33:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
  34:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     BARO_ALTITUDE_HOLD_PID_IDX,
  35:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     ZDAMPENING_PID_IDX,
  36:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   #endif
  37:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   #if defined AltitudeHoldRangeFinder
  38:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     SONAR_ALTITUDE_HOLD_PID_IDX,
  39:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   #endif
  40:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   #if defined UseGPSNavigator
  41:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     GPSPITCH_PID_IDX,
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     GPSROLL_PID_IDX,
  43:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     GPSYAW_PID_IDX,
  44:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   #endif    
  45:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** 
  46:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   LAST_PID_IDX  // keep this definition at the end of this enum
  47:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** };
  48:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** 
  49:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** //// PID Variables
  50:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** struct PIDdata {
  51:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   float P, I, D;
  52:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   float lastError;
  53:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   // AKA experiments with PID
  54:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   float previousPIDTime;
  55:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   float integratedError;
  56:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   float windupGuard; // Thinking about having individual wind up guards for each PID
  57:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** } PID[LAST_PID_IDX];
  58:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** 
  59:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** // This struct above declares the variable PID[] to hold each of the PID values for various functio
  60:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** // The following constants are declared in AeroQuad.h
  61:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** // ROLL = 0, PITCH = 1, YAW = 2 (used for Arcobatic Mode, gyros only)
  62:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** // ROLLLEVEL = 3, PITCHLEVEL = 4, LEVELGYROROLL = 6, LEVELGYROPITCH = 7 (used for Stable Mode, acce
  63:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** // HEADING = 5 (used for heading hold)
  64:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** // ALTITUDE = 8 (used for altitude hold)
  65:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** // ZDAMPENING = 9 (used in altitude hold to dampen vertical accelerations)
  66:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** float windupGuard; // Read in from EEPROM
  67:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** //// Modified from http://www.arduino.cc/playground/Main/BarebonesPIDForEspresso
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** float updatePID(float targetPosition, float currentPosition, struct PIDdata *PIDparameters) {
 602              		.loc 8 68 0
 603              		.cfi_startproc
 604              		@ args = 0, pretend = 0, frame = 0
 605              		@ frame_needed = 0, uses_anonymous_args = 0
 606              		@ link register save eliminated.
 607              	.LVL42:
 608              	.LBB28:
  69:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** 
  70:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   // AKA PID experiments
  71:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   const float deltaPIDTime = (currentTime - PIDparameters->previousPIDTime) / 1000000.0;
 609              		.loc 8 71 0
 610 0000 2A4B     		ldr	r3, .L52
 611              	.LBE28:
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** float updatePID(float targetPosition, float currentPosition, struct PIDdata *PIDparameters) {
 612              		.loc 8 68 0
 613 0002 07EE101A 		fmsr	s14, r1
 614              	.LBB29:
 615              		.loc 8 71 0
 616 0006 1968     		ldr	r1, [r3, #0]
 617              	.LVL43:
 618 0008 01EE101A 		fmsr	s2, r1	@ int
 619 000c D2ED040A 		flds	s1, [r2, #16]
 620 0010 B8EE410A 		fuitos	s0, s2
  72:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** 
  73:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   PIDparameters->previousPIDTime = currentTime;  // AKA PID experiments
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   float error = targetPosition - currentPosition;
 621              		.loc 8 74 0
 622 0014 07EE900A 		fmsr	s15, r0
  75:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** 
  76:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   if (inFlight) {
 623              		.loc 8 76 0
 624 0018 2548     		ldr	r0, .L52+4
 625              	.LVL44:
  71:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   const float deltaPIDTime = (currentTime - PIDparameters->previousPIDTime) / 1000000.0;
 626              		.loc 8 71 0
 627 001a 30EE606A 		fsubs	s12, s0, s1
 628 001e DFED256A 		flds	s13, .L52+8
 629              		.loc 8 76 0
 630 0022 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
  71:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   const float deltaPIDTime = (currentTime - PIDparameters->previousPIDTime) / 1000000.0;
 631              		.loc 8 71 0
 632 0024 86EE265A 		fdivs	s10, s12, s13
 633              	.LVL45:
  73:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   PIDparameters->previousPIDTime = currentTime;  // AKA PID experiments
 634              		.loc 8 73 0
 635 0028 82ED040A 		fsts	s0, [r2, #16]
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   float error = targetPosition - currentPosition;
 636              		.loc 8 74 0
 637 002c 77EEC75A 		fsubs	s11, s15, s14
 638              	.LVL46:
 639              		.loc 8 76 0
 640 0030 33B1     		cbz	r3, .L46
  77:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     PIDparameters->integratedError += error * deltaPIDTime;
 641              		.loc 8 77 0
 642 0032 D2ED051A 		flds	s3, [r2, #20]
 643 0036 45EE851A 		fmacs	s3, s11, s10
 644 003a C2ED051A 		fsts	s3, [r2, #20]
 645 003e 01E0     		b	.L47
 646              	.L46:
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   }
  79:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   else {
  80:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     PIDparameters->integratedError = 0.0;
 647              		.loc 8 80 0
 648 0040 0020     		movs	r0, #0
 649 0042 5061     		str	r0, [r2, #20]	@ float
 650              	.L47:
  81:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   }
  82:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   PIDparameters->integratedError = constrain(PIDparameters->integratedError, -PIDparameters->windup
 651              		.loc 8 82 0
 652 0044 D2ED066A 		flds	s13, [r2, #24]
 653 0048 92ED056A 		flds	s12, [r2, #20]
 654 004c F1EE667A 		fnegs	s15, s13
 655              	.LVL47:
 656 0050 B4EEE76A 		fcmpes	s12, s15
 657 0054 F1EE10FA 		fmstat
 658 0058 08D4     		bmi	.L48
 659              		.loc 8 82 0 is_stmt 0 discriminator 2
 660 005a B4EE666A 		fcmps	s12, s13
 661 005e F1EE10FA 		fmstat
 662 0062 CCBF     		ite	gt
 663 0064 F0EE667A 		fcpysgt	s15, s13
 664 0068 F0EE467A 		fcpysle	s15, s12
 665              	.L48:
  83:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   float dTerm = PIDparameters->D * (currentPosition - PIDparameters->lastError) / (deltaPIDTime * 1
 666              		.loc 8 83 0 is_stmt 1 discriminator 6
 667 006c D2ED034A 		flds	s9, [r2, #12]
 668 0070 92ED024A 		flds	s8, [r2, #8]
 669 0074 77EE643A 		fsubs	s7, s14, s9
 670 0078 DFED0F2A 		flds	s5, .L52+12
 671 007c 63EE843A 		fmuls	s7, s7, s8
 672 0080 65EE222A 		fmuls	s5, s10, s5
  84:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   PIDparameters->lastError = currentPosition;
  85:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** 
  86:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   return (PIDparameters->P * error) + (PIDparameters->I * PIDparameters->integratedError) + dTerm;
 673              		.loc 8 86 0 discriminator 6
 674 0084 92ED013A 		flds	s6, [r2, #4]
  83:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   float dTerm = PIDparameters->D * (currentPosition - PIDparameters->lastError) / (deltaPIDTime * 1
 675              		.loc 8 83 0 discriminator 6
 676 0088 C3EEA22A 		fdivs	s5, s7, s5
 677              	.LVL48:
  84:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   PIDparameters->lastError = currentPosition;
 678              		.loc 8 84 0 discriminator 6
 679 008c 82ED037A 		fsts	s14, [r2, #12]
 680              		.loc 8 86 0 discriminator 6
 681 0090 92ED007A 		flds	s14, [r2, #0]
 682              	.LVL49:
  82:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   PIDparameters->integratedError = constrain(PIDparameters->integratedError, -PIDparameters->windup
 683              		.loc 8 82 0 discriminator 6
 684 0094 C2ED057A 		fsts	s15, [r2, #20]
 685              		.loc 8 86 0 discriminator 6
 686 0098 67EE837A 		fmuls	s15, s15, s6
 687 009c 45EE877A 		fmacs	s15, s11, s14
 688              	.LBE29:
  87:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** }
 689              		.loc 8 87 0 discriminator 6
 690 00a0 37EEA22A 		fadds	s4, s15, s5
 691 00a4 12EE100A 		fmrs	r0, s4
 692 00a8 7047     		bx	lr
 693              	.L53:
 694 00aa 00BF     		.align	2
 695              	.L52:
 696 00ac 00000000 		.word	.LANCHOR15
 697 00b0 00000000 		.word	.LANCHOR16
 698 00b4 00247449 		.word	1232348160
 699 00b8 0000C842 		.word	1120403456
 700              		.cfi_endproc
 701              	.LFE124:
 703              		.section	.text._Z17zeroIntegralErrorv,"ax",%progbits
 704              		.align	1
 705              		.global	_Z17zeroIntegralErrorv
 706              		.thumb
 707              		.thumb_func
 709              	_Z17zeroIntegralErrorv:
 710              	.LFB125:
  88:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** 
  89:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** void zeroIntegralError() __attribute__ ((noinline));
  90:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** void zeroIntegralError() {
 711              		.loc 8 90 0
 712              		.cfi_startproc
 713              		@ args = 0, pretend = 0, frame = 0
 714              		@ frame_needed = 0, uses_anonymous_args = 0
 715              		@ link register save eliminated.
 716              	.LVL50:
 717              	.LBB30:
  91:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   for (byte axis = 0; axis <= ATTITUDE_YAXIS_PID_IDX; axis++) {
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     PID[axis].integratedError = 0;
  93:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     PID[axis].previousPIDTime = currentTime;
 718              		.loc 8 93 0
 719 0000 0C49     		ldr	r1, .L55
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     PID[axis].integratedError = 0;
 720              		.loc 8 92 0
 721 0002 0D4B     		ldr	r3, .L55+4
 722              		.loc 8 93 0
 723 0004 0868     		ldr	r0, [r1, #0]
 724 0006 07EE100A 		fmsr	s14, r0	@ int
 725 000a F8EE477A 		fuitos	s15, s14
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     PID[axis].integratedError = 0;
 726              		.loc 8 92 0
 727 000e 0022     		movs	r2, #0
 728 0010 5A61     		str	r2, [r3, #20]	@ float
 729              		.loc 8 93 0
 730 0012 C3ED047A 		fsts	s15, [r3, #16]
 731              	.LVL51:
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     PID[axis].integratedError = 0;
 732              		.loc 8 92 0
 733 0016 1A63     		str	r2, [r3, #48]	@ float
 734              		.loc 8 93 0
 735 0018 C3ED0B7A 		fsts	s15, [r3, #44]
 736              	.LVL52:
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     PID[axis].integratedError = 0;
 737              		.loc 8 92 0
 738 001c DA64     		str	r2, [r3, #76]	@ float
 739              		.loc 8 93 0
 740 001e C3ED127A 		fsts	s15, [r3, #72]
 741              	.LVL53:
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     PID[axis].integratedError = 0;
 742              		.loc 8 92 0
 743 0022 9A66     		str	r2, [r3, #104]	@ float
 744              		.loc 8 93 0
 745 0024 C3ED197A 		fsts	s15, [r3, #100]
 746              	.LVL54:
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     PID[axis].integratedError = 0;
 747              		.loc 8 92 0
 748 0028 C3F88420 		str	r2, [r3, #132]	@ float
 749              		.loc 8 93 0
 750 002c C3ED207A 		fsts	s15, [r3, #128]
 751              	.LVL55:
 752              	.LBE30:
  94:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   }
  95:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** }
 753              		.loc 8 95 0
 754 0030 7047     		bx	lr
 755              	.L56:
 756 0032 00BF     		.align	2
 757              	.L55:
 758 0034 00000000 		.word	.LANCHOR15
 759 0038 00000000 		.word	.LANCHOR17
 760              		.cfi_endproc
 761              	.LFE125:
 763              		.section	.text._Z18computeFourthOrderfP15fourthOrderData,"ax",%progbits
 764              		.align	1
 765              		.global	_Z18computeFourthOrderfP15fourthOrderData
 766              		.thumb
 767              		.thumb_func
 769              	_Z18computeFourthOrderfP15fourthOrderData:
 770              	.LFB126:
 771              		.file 9 "../Libraries/AQ_Math/FourtOrderFilter.h"
   1:../Libraries/AQ_Math/FourtOrderFilter.h **** /*
   2:../Libraries/AQ_Math/FourtOrderFilter.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Math/FourtOrderFilter.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Math/FourtOrderFilter.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Math/FourtOrderFilter.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Math/FourtOrderFilter.h ****  
   7:../Libraries/AQ_Math/FourtOrderFilter.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Math/FourtOrderFilter.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Math/FourtOrderFilter.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Math/FourtOrderFilter.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  12:../Libraries/AQ_Math/FourtOrderFilter.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Math/FourtOrderFilter.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Math/FourtOrderFilter.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Math/FourtOrderFilter.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  17:../Libraries/AQ_Math/FourtOrderFilter.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Math/FourtOrderFilter.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Math/FourtOrderFilter.h **** */
  20:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  21:../Libraries/AQ_Math/FourtOrderFilter.h **** #ifndef _AQ_FOURTH_ORDER_FILTER_H_
  22:../Libraries/AQ_Math/FourtOrderFilter.h **** #define _AQ_FOURTH_ORDER_FILTER_H_
  23:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  24:../Libraries/AQ_Math/FourtOrderFilter.h **** ////////////////////////////////////////////////////////////////////////////////
  25:../Libraries/AQ_Math/FourtOrderFilter.h **** //
  26:../Libraries/AQ_Math/FourtOrderFilter.h **** //
  27:../Libraries/AQ_Math/FourtOrderFilter.h **** ////////////////////////////////////////////////////////////////////////////////
  28:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  29:../Libraries/AQ_Math/FourtOrderFilter.h **** #include <GlobalDefined.h>
  30:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  31:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  32:../Libraries/AQ_Math/FourtOrderFilter.h **** struct fourthOrderData
  33:../Libraries/AQ_Math/FourtOrderFilter.h **** {
  34:../Libraries/AQ_Math/FourtOrderFilter.h ****   float  inputTm1,  inputTm2,  inputTm3,  inputTm4;
  35:../Libraries/AQ_Math/FourtOrderFilter.h ****   float outputTm1, outputTm2, outputTm3, outputTm4;
  36:../Libraries/AQ_Math/FourtOrderFilter.h **** } fourthOrder[4];
  37:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  38:../Libraries/AQ_Math/FourtOrderFilter.h **** float computeFourthOrder(float currentInput, struct fourthOrderData *filterParameters)
  39:../Libraries/AQ_Math/FourtOrderFilter.h **** {
 772              		.loc 9 39 0
 773              		.cfi_startproc
 774              		@ args = 0, pretend = 0, frame = 0
 775              		@ frame_needed = 0, uses_anonymous_args = 0
 776              		@ link register save eliminated.
 777              	.LVL56:
 778              	.LBB31:
  40:../Libraries/AQ_Math/FourtOrderFilter.h ****   // cheby2(4,60,12.5/50)
  41:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _b0  0.001893594048567
  42:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _b1 -0.002220262954039
  43:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _b2  0.003389066536478
  44:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _b3 -0.002220262954039
  45:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _b4  0.001893594048567
  46:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  47:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _a1 -3.362256889209355
  48:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _a2  4.282608240117919
  49:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _a3 -2.444765517272841
  50:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _a4  0.527149895089809
  51:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  52:../Libraries/AQ_Math/FourtOrderFilter.h ****   float output;
  53:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  54:../Libraries/AQ_Math/FourtOrderFilter.h ****   output = _b0 * currentInput                + 
  55:../Libraries/AQ_Math/FourtOrderFilter.h ****            _b1 * filterParameters->inputTm1  + 
  56:../Libraries/AQ_Math/FourtOrderFilter.h ****            _b2 * filterParameters->inputTm2  +
  57:../Libraries/AQ_Math/FourtOrderFilter.h ****            _b3 * filterParameters->inputTm3  +
  58:../Libraries/AQ_Math/FourtOrderFilter.h ****            _b4 * filterParameters->inputTm4  -
  59:../Libraries/AQ_Math/FourtOrderFilter.h ****            _a1 * filterParameters->outputTm1 -
  60:../Libraries/AQ_Math/FourtOrderFilter.h ****            _a2 * filterParameters->outputTm2 -
  61:../Libraries/AQ_Math/FourtOrderFilter.h ****            _a3 * filterParameters->outputTm3 -
  62:../Libraries/AQ_Math/FourtOrderFilter.h ****            _a4 * filterParameters->outputTm4;
 779              		.loc 9 62 0
 780 0000 91ED005A 		flds	s10, [r1, #0]
 781 0004 9FED203A 		flds	s6, .L58
 782              	.LBE31:
  39:../Libraries/AQ_Math/FourtOrderFilter.h **** {
 783              		.loc 9 39 0
 784 0008 05EE900A 		fmsr	s11, r0
 785              	.LBB32:
 786              		.loc 9 62 0
 787 000c 9FED1F2A 		flds	s4, .L58+4
 788 0010 65EE037A 		fmuls	s15, s10, s6
 789 0014 45EE827A 		fmacs	s15, s11, s4
 790 0018 D1ED014A 		flds	s9, [r1, #4]
 791 001c DFED1C2A 		flds	s5, .L58+8
 792 0020 44EEA27A 		fmacs	s15, s9, s5
 793 0024 91ED024A 		flds	s8, [r1, #8]
 794 0028 44EE037A 		fmacs	s15, s8, s6
 795 002c D1ED031A 		flds	s3, [r1, #12]
 796 0030 41EE827A 		fmacs	s15, s3, s4
 797 0034 91ED047A 		flds	s14, [r1, #16]
 798 0038 9FED161A 		flds	s2, .L58+12
 799 003c 47EE017A 		fmacs	s15, s14, s2
 800 0040 D1ED056A 		flds	s13, [r1, #20]
 801 0044 DFED140A 		flds	s1, .L58+16
 802 0048 46EEE07A 		fnmacs	s15, s13, s1
 803 004c 91ED066A 		flds	s12, [r1, #24]
 804 0050 9FED120A 		flds	s0, .L58+20
 805 0054 46EE007A 		fmacs	s15, s12, s0
 806 0058 91ED073A 		flds	s6, [r1, #28]
 807 005c DFED103A 		flds	s7, .L58+24
 808 0060 43EE637A 		fnmacs	s15, s6, s7
 809              	.LVL57:
  63:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  64:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm4 = filterParameters->inputTm3;
  65:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm3 = filterParameters->inputTm2;
  66:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm2 = filterParameters->inputTm1;
  67:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm1 = currentInput;
 810              		.loc 9 67 0
 811 0064 0860     		str	r0, [r1, #0]	@ float
  64:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm4 = filterParameters->inputTm3;
 812              		.loc 9 64 0
 813 0066 81ED034A 		fsts	s8, [r1, #12]
  65:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm3 = filterParameters->inputTm2;
 814              		.loc 9 65 0
 815 006a C1ED024A 		fsts	s9, [r1, #8]
  66:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm2 = filterParameters->inputTm1;
 816              		.loc 9 66 0
 817 006e 81ED015A 		fsts	s10, [r1, #4]
  68:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  69:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->outputTm4 = filterParameters->outputTm3;
 818              		.loc 9 69 0
 819 0072 81ED076A 		fsts	s12, [r1, #28]
  70:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->outputTm3 = filterParameters->outputTm2;
 820              		.loc 9 70 0
 821 0076 C1ED066A 		fsts	s13, [r1, #24]
  71:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->outputTm2 = filterParameters->outputTm1;
 822              		.loc 9 71 0
 823 007a 81ED057A 		fsts	s14, [r1, #20]
  72:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->outputTm1 = output;
 824              		.loc 9 72 0
 825 007e C1ED047A 		fsts	s15, [r1, #16]
 826              	.LBE32:
  73:../Libraries/AQ_Math/FourtOrderFilter.h ****     
  74:../Libraries/AQ_Math/FourtOrderFilter.h ****   return output;
  75:../Libraries/AQ_Math/FourtOrderFilter.h **** }
 827              		.loc 9 75 0
 828 0082 17EE900A 		fmrs	r0, s15
 829              	.LVL58:
 830 0086 7047     		bx	lr
 831              	.L59:
 832              		.align	2
 833              	.L58:
 834 0088 D58111BB 		.word	-1156480555
 835 008c 7932F83A 		.word	989344377
 836 0090 1A1B5E3B 		.word	996023066
 837 0094 382F5740 		.word	1079455544
 838 0098 200B8940 		.word	1082723104
 839 009c 0A771C40 		.word	1075607306
 840 00a0 4CF3063F 		.word	1057420108
 841              		.cfi_endproc
 842              	.LFE126:
 844              		.section	.text._Z16setupFourthOrderv,"ax",%progbits
 845              		.align	1
 846              		.global	_Z16setupFourthOrderv
 847              		.thumb
 848              		.thumb_func
 850              	_Z16setupFourthOrderv:
 851              	.LFB127:
  76:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  77:../Libraries/AQ_Math/FourtOrderFilter.h **** void setupFourthOrder(void)
  78:../Libraries/AQ_Math/FourtOrderFilter.h **** {
 852              		.loc 9 78 0
 853              		.cfi_startproc
 854              		@ args = 0, pretend = 0, frame = 0
 855              		@ frame_needed = 0, uses_anonymous_args = 0
 856              		@ link register save eliminated.
  79:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm1 = 0.0;
 857              		.loc 9 79 0
 858 0000 0D4B     		ldr	r3, .L61
  80:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm2 = 0.0;
  81:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm3 = 0.0;
  82:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm4 = 0.0;
  83:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  84:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm1 = 0.0;
  85:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm2 = 0.0;
  86:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm3 = 0.0;
  87:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm4 = 0.0;
  88:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  89:../Libraries/AQ_Math/FourtOrderFilter.h ****   //////////
  90:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm1 = 0.0;
  91:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm2 = 0.0;
  92:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm3 = 0.0;
  93:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm4 = 0.0;
  94:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  95:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm1 = 0.0;
  96:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm2 = 0.0;
  97:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm3 = 0.0;
  98:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm4 = 0.0;
  99:../Libraries/AQ_Math/FourtOrderFilter.h ****   
 100:../Libraries/AQ_Math/FourtOrderFilter.h ****   //////////
 101:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].inputTm1 = -9.8065;
 859              		.loc 9 101 0
 860 0002 0E4A     		ldr	r2, .L61+4
  79:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm1 = 0.0;
 861              		.loc 9 79 0
 862 0004 0020     		movs	r0, #0
 863 0006 1860     		str	r0, [r3, #0]	@ float
  80:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm2 = 0.0;
 864              		.loc 9 80 0
 865 0008 5860     		str	r0, [r3, #4]	@ float
  81:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm3 = 0.0;
 866              		.loc 9 81 0
 867 000a 9860     		str	r0, [r3, #8]	@ float
  82:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm4 = 0.0;
 868              		.loc 9 82 0
 869 000c D860     		str	r0, [r3, #12]	@ float
  84:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm1 = 0.0;
 870              		.loc 9 84 0
 871 000e 1861     		str	r0, [r3, #16]	@ float
  85:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm2 = 0.0;
 872              		.loc 9 85 0
 873 0010 5861     		str	r0, [r3, #20]	@ float
  86:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm3 = 0.0;
 874              		.loc 9 86 0
 875 0012 9861     		str	r0, [r3, #24]	@ float
  87:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm4 = 0.0;
 876              		.loc 9 87 0
 877 0014 D861     		str	r0, [r3, #28]	@ float
  90:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm1 = 0.0;
 878              		.loc 9 90 0
 879 0016 1862     		str	r0, [r3, #32]	@ float
  91:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm2 = 0.0;
 880              		.loc 9 91 0
 881 0018 5862     		str	r0, [r3, #36]	@ float
  92:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm3 = 0.0;
 882              		.loc 9 92 0
 883 001a 9862     		str	r0, [r3, #40]	@ float
  93:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm4 = 0.0;
 884              		.loc 9 93 0
 885 001c D862     		str	r0, [r3, #44]	@ float
  95:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm1 = 0.0;
 886              		.loc 9 95 0
 887 001e 1863     		str	r0, [r3, #48]	@ float
  96:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm2 = 0.0;
 888              		.loc 9 96 0
 889 0020 5863     		str	r0, [r3, #52]	@ float
  97:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm3 = 0.0;
 890              		.loc 9 97 0
 891 0022 9863     		str	r0, [r3, #56]	@ float
  98:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm4 = 0.0;
 892              		.loc 9 98 0
 893 0024 D863     		str	r0, [r3, #60]	@ float
 894              		.loc 9 101 0
 895 0026 1A64     		str	r2, [r3, #64]	@ float
 102:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].inputTm2 = -9.8065;
 896              		.loc 9 102 0
 897 0028 5A64     		str	r2, [r3, #68]	@ float
 103:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].inputTm3 = -9.8065;
 898              		.loc 9 103 0
 899 002a 9A64     		str	r2, [r3, #72]	@ float
 104:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].inputTm4 = -9.8065;
 900              		.loc 9 104 0
 901 002c DA64     		str	r2, [r3, #76]	@ float
 105:../Libraries/AQ_Math/FourtOrderFilter.h ****   
 106:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].outputTm1 = -9.8065;
 902              		.loc 9 106 0
 903 002e 1A65     		str	r2, [r3, #80]	@ float
 107:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].outputTm2 = -9.8065;
 904              		.loc 9 107 0
 905 0030 5A65     		str	r2, [r3, #84]	@ float
 108:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].outputTm3 = -9.8065;
 906              		.loc 9 108 0
 907 0032 9A65     		str	r2, [r3, #88]	@ float
 109:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].outputTm4 = -9.8065;
 908              		.loc 9 109 0
 909 0034 DA65     		str	r2, [r3, #92]	@ float
 110:../Libraries/AQ_Math/FourtOrderFilter.h **** }
 910              		.loc 9 110 0
 911 0036 7047     		bx	lr
 912              	.L62:
 913              		.align	2
 914              	.L61:
 915 0038 00000000 		.word	.LANCHOR18
 916 003c 6DE71CC1 		.word	-1055070355
 917              		.cfi_endproc
 918              	.LFE127:
 920              		.section	.text._ZN14HardwareSPIExt5SetCSEi,"axG",%progbits,_ZN14HardwareSPIExt5SetCSEi,comdat
 921              		.align	1
 922              		.weak	_ZN14HardwareSPIExt5SetCSEi
 923              		.thumb
 924              		.thumb_func
 926              	_ZN14HardwareSPIExt5SetCSEi:
 927              	.LFB131:
 928              		.file 10 "../Libraries/AQ_SPI/HardwareSPIExt.h"
   1:../Libraries/AQ_SPI/HardwareSPIExt.h **** #ifndef _AEROQUAD_SPI_HARDWARESPIEXT_H_
   2:../Libraries/AQ_SPI/HardwareSPIExt.h **** #define _AEROQUAD_SPI_HARDWARESPIEXT_H_
   3:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
   4:../Libraries/AQ_SPI/HardwareSPIExt.h **** #if defined(AeroQuadSTM32)
   5:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
   6:../Libraries/AQ_SPI/HardwareSPIExt.h **** // helper class to extend the maple HardwareSPI class
   7:../Libraries/AQ_SPI/HardwareSPIExt.h **** // used by the MPU6000 library
   8:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
   9:../Libraries/AQ_SPI/HardwareSPIExt.h **** #include <HardwareSPI.h>
  10:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  11:../Libraries/AQ_SPI/HardwareSPIExt.h **** #define SPI_READ_FLAG  0x80
  12:../Libraries/AQ_SPI/HardwareSPIExt.h **** #define SPI_MULTI_FLAG 0x40
  13:../Libraries/AQ_SPI/HardwareSPIExt.h **** #define SetPin digitalWrite
  14:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  15:../Libraries/AQ_SPI/HardwareSPIExt.h **** class HardwareSPIExt : public HardwareSPI {
  16:../Libraries/AQ_SPI/HardwareSPIExt.h **** public:
  17:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	HardwareSPIExt(uint32 spiPortNumber) : HardwareSPI(spiPortNumber) {
  18:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetCS(nssPin());
  19:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		fSpiMultiFlag = 0;
  20:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
  21:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  22:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void SetCS(int aCS)
 929              		.loc 10 22 0
 930              		.cfi_startproc
 931              		@ args = 0, pretend = 0, frame = 0
 932              		@ frame_needed = 0, uses_anonymous_args = 0
 933              		@ link register save eliminated.
 934              	.LVL59:
  23:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  24:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		fCS = aCS;
 935              		.loc 10 24 0
 936 0000 4160     		str	r1, [r0, #4]
  25:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 937              		.loc 10 25 0
 938 0002 7047     		bx	lr
 939              		.cfi_endproc
 940              	.LFE131:
 942              		.section	.text._ZN14HardwareSPIExtC2Ej,"axG",%progbits,_ZN14HardwareSPIExtC5Ej,comdat
 943              		.align	1
 944              		.weak	_ZN14HardwareSPIExtC2Ej
 945              		.thumb
 946              		.thumb_func
 948              	_ZN14HardwareSPIExtC2Ej:
 949              	.LFB129:
  17:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	HardwareSPIExt(uint32 spiPortNumber) : HardwareSPI(spiPortNumber) {
 950              		.loc 10 17 0
 951              		.cfi_startproc
 952              		@ args = 0, pretend = 0, frame = 0
 953              		@ frame_needed = 0, uses_anonymous_args = 0
 954              	.LVL60:
 955 0000 10B5     		push	{r4, lr}
 956              	.LCFI4:
 957              		.cfi_def_cfa_offset 8
 958              		.cfi_offset 14, -4
 959              		.cfi_offset 4, -8
  17:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	HardwareSPIExt(uint32 spiPortNumber) : HardwareSPI(spiPortNumber) {
 960              		.loc 10 17 0
 961 0002 0446     		mov	r4, r0
 962              	.LBB33:
 963 0004 FFF7FEFF 		bl	_ZN11HardwareSPIC2Ej
 964              	.LVL61:
  18:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetCS(nssPin());
 965              		.loc 10 18 0
 966 0008 2046     		mov	r0, r4
 967 000a FFF7FEFF 		bl	_ZN11HardwareSPI6nssPinEv
 968 000e 0146     		mov	r1, r0
 969 0010 2046     		mov	r0, r4
 970 0012 FFF7FEFF 		bl	_ZN14HardwareSPIExt5SetCSEi
  19:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		fSpiMultiFlag = 0;
 971              		.loc 10 19 0
 972 0016 0023     		movs	r3, #0
 973 0018 2372     		strb	r3, [r4, #8]
 974              	.LBE33:
  20:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 975              		.loc 10 20 0
 976 001a 2046     		mov	r0, r4
 977 001c 10BD     		pop	{r4, pc}
 978              		.cfi_endproc
 979              	.LFE129:
 981              		.section	.text._ZN14HardwareSPIExt5beginE12SPIFrequencyjj,"axG",%progbits,_ZN14HardwareSPIExt5begi
 982              		.align	1
 983              		.weak	_ZN14HardwareSPIExt5beginE12SPIFrequencyjj
 984              		.thumb
 985              		.thumb_func
 987              	_ZN14HardwareSPIExt5beginE12SPIFrequencyjj:
 988              	.LFB133:
  26:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  27:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void SetMultiFlag() {
  28:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		fSpiMultiFlag = SPI_MULTI_FLAG;
  29:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
  30:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  31:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void begin(SPIFrequency frequency, uint32 bitOrder, uint32 mode)
 989              		.loc 10 31 0
 990              		.cfi_startproc
 991              		@ args = 0, pretend = 0, frame = 0
 992              		@ frame_needed = 0, uses_anonymous_args = 0
 993              	.LVL62:
 994 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 995              	.LCFI5:
 996              		.cfi_def_cfa_offset 24
 997              		.cfi_offset 14, -4
 998              		.cfi_offset 8, -8
 999              		.cfi_offset 7, -12
 1000              		.cfi_offset 6, -16
 1001              		.cfi_offset 5, -20
 1002              		.cfi_offset 4, -24
 1003              		.loc 10 31 0
 1004 0004 0446     		mov	r4, r0
 1005 0006 0D46     		mov	r5, r1
  32:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  33:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
 1006              		.loc 10 33 0
 1007 0008 0079     		ldrb	r0, [r0, #4]	@ zero_extendqisi2
 1008              	.LVL63:
 1009 000a 0121     		movs	r1, #1
 1010              	.LVL64:
  31:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void begin(SPIFrequency frequency, uint32 bitOrder, uint32 mode)
 1011              		.loc 10 31 0
 1012 000c 1746     		mov	r7, r2
 1013 000e 1E46     		mov	r6, r3
 1014              		.loc 10 33 0
 1015 0010 FFF7FEFF 		bl	_Z12digitalWritehh
 1016              	.LVL65:
  34:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		pinMode(fCS, OUTPUT);
 1017              		.loc 10 34 0
 1018 0014 2079     		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 1019 0016 0021     		movs	r1, #0
 1020 0018 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
  35:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  36:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		HardwareSPI::begin(frequency, bitOrder, mode);
 1021              		.loc 10 36 0
 1022 001c 2046     		mov	r0, r4
 1023 001e 2946     		mov	r1, r5
 1024 0020 3A46     		mov	r2, r7
 1025 0022 3346     		mov	r3, r6
  37:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 1026              		.loc 10 37 0
 1027 0024 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
  36:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		HardwareSPI::begin(frequency, bitOrder, mode);
 1028              		.loc 10 36 0
 1029 0028 FFF7FEBF 		b	_ZN11HardwareSPI5beginE12SPIFrequencyjj
 1030              		.cfi_endproc
 1031              	.LFE133:
 1033              		.section	.text._ZN14HardwareSPIExt4ReadEiPhi,"axG",%progbits,_ZN14HardwareSPIExt4ReadEiPhi,comdat
 1034              		.align	1
 1035              		.weak	_ZN14HardwareSPIExt4ReadEiPhi
 1036              		.thumb
 1037              		.thumb_func
 1039              	_ZN14HardwareSPIExt4ReadEiPhi:
 1040              	.LFB134:
  38:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  39:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void Read(int addr, unsigned char *data, int dataLen)
 1041              		.loc 10 39 0
 1042              		.cfi_startproc
 1043              		@ args = 0, pretend = 0, frame = 0
 1044              		@ frame_needed = 0, uses_anonymous_args = 0
 1045              	.LVL66:
 1046 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1047              	.LCFI6:
 1048              		.cfi_def_cfa_offset 24
 1049              		.cfi_offset 14, -4
 1050              		.cfi_offset 7, -8
 1051              		.cfi_offset 6, -12
 1052              		.cfi_offset 5, -16
 1053              		.cfi_offset 4, -20
 1054              		.cfi_offset 3, -24
 1055              		.loc 10 39 0
 1056 0002 0446     		mov	r4, r0
 1057 0004 0D46     		mov	r5, r1
  40:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  41:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 0);
 1058              		.loc 10 41 0
 1059 0006 0079     		ldrb	r0, [r0, #4]	@ zero_extendqisi2
 1060              	.LVL67:
 1061 0008 0021     		movs	r1, #0
 1062              	.LVL68:
  39:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void Read(int addr, unsigned char *data, int dataLen)
 1063              		.loc 10 39 0
 1064 000a 1F46     		mov	r7, r3
 1065 000c 1646     		mov	r6, r2
 1066              		.loc 10 41 0
 1067 000e FFF7FEFF 		bl	_Z12digitalWritehh
 1068              	.LVL69:
  42:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		transfer(addr | SPI_READ_FLAG | fSpiMultiFlag);
 1069              		.loc 10 42 0
 1070 0012 207A     		ldrb	r0, [r4, #8]	@ zero_extendqisi2
 1071 0014 60F07F03 		orn	r3, r0, #127
 1072 0018 1D43     		orrs	r5, r5, r3
 1073              	.LVL70:
 1074 001a E9B2     		uxtb	r1, r5
 1075 001c 2046     		mov	r0, r4
 1076 001e FFF7FEFF 		bl	_ZN11HardwareSPI8transferEh
 1077 0022 3D46     		mov	r5, r7
  43:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		while(dataLen-- > 0) {
 1078              		.loc 10 43 0
 1079 0024 06E0     		b	.L68
 1080              	.LVL71:
 1081              	.L69:
  44:../Libraries/AQ_SPI/HardwareSPIExt.h **** 			*data++ = transfer(0);
 1082              		.loc 10 44 0
 1083 0026 2046     		mov	r0, r4
 1084 0028 0021     		movs	r1, #0
 1085 002a FFF7FEFF 		bl	_ZN11HardwareSPI8transferEh
 1086 002e 06F8010B 		strb	r0, [r6], #1
 1087              	.LVL72:
 1088 0032 013D     		subs	r5, r5, #1
 1089              	.L68:
  43:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		while(dataLen-- > 0) {
 1090              		.loc 10 43 0 discriminator 1
 1091 0034 002D     		cmp	r5, #0
 1092 0036 F6DC     		bgt	.L69
  45:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		}
  46:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
 1093              		.loc 10 46 0
 1094 0038 2079     		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 1095 003a 0121     		movs	r1, #1
  47:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 1096              		.loc 10 47 0
 1097 003c BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
  46:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
 1098              		.loc 10 46 0
 1099 0040 FFF7FEBF 		b	_Z12digitalWritehh
 1100              		.cfi_endproc
 1101              	.LFE134:
 1103              		.section	.text._ZN14HardwareSPIExt4ReadEi,"axG",%progbits,_ZN14HardwareSPIExt4ReadEi,comdat
 1104              		.align	1
 1105              		.weak	_ZN14HardwareSPIExt4ReadEi
 1106              		.thumb
 1107              		.thumb_func
 1109              	_ZN14HardwareSPIExt4ReadEi:
 1110              	.LFB135:
  48:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  49:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	unsigned char Read(int addr)
 1111              		.loc 10 49 0
 1112              		.cfi_startproc
 1113              		@ args = 0, pretend = 0, frame = 8
 1114              		@ frame_needed = 0, uses_anonymous_args = 0
 1115              	.LVL73:
 1116 0000 07B5     		push	{r0, r1, r2, lr}
 1117              	.LCFI7:
 1118              		.cfi_def_cfa_offset 16
 1119              		.cfi_offset 14, -4
 1120              		.cfi_offset 2, -8
 1121              		.cfi_offset 1, -12
 1122              		.cfi_offset 0, -16
 1123              	.LBB34:
  50:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  51:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		unsigned char data;
  52:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		Read(addr, &data, 1);
 1124              		.loc 10 52 0
 1125 0002 0123     		movs	r3, #1
 1126 0004 0DF10702 		add	r2, sp, #7
 1127 0008 FFF7FEFF 		bl	_ZN14HardwareSPIExt4ReadEiPhi
 1128              	.LVL74:
 1129              	.LBE34:
  53:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  54:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		return data;
  55:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 1130              		.loc 10 55 0
 1131 000c 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 1132 0010 0EBD     		pop	{r1, r2, r3, pc}
 1133              		.cfi_endproc
 1134              	.LFE135:
 1136              		.section	.text._ZN14HardwareSPIExt5WriteEiPhi,"axG",%progbits,_ZN14HardwareSPIExt5WriteEiPhi,comda
 1137              		.align	1
 1138              		.weak	_ZN14HardwareSPIExt5WriteEiPhi
 1139              		.thumb
 1140              		.thumb_func
 1142              	_ZN14HardwareSPIExt5WriteEiPhi:
 1143              	.LFB136:
  56:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  57:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void Write(int addr, unsigned char *data, int dataLen)
 1144              		.loc 10 57 0
 1145              		.cfi_startproc
 1146              		@ args = 0, pretend = 0, frame = 0
 1147              		@ frame_needed = 0, uses_anonymous_args = 0
 1148              	.LVL75:
 1149 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1150              	.LCFI8:
 1151              		.cfi_def_cfa_offset 24
 1152              		.cfi_offset 14, -4
 1153              		.cfi_offset 7, -8
 1154              		.cfi_offset 6, -12
 1155              		.cfi_offset 5, -16
 1156              		.cfi_offset 4, -20
 1157              		.cfi_offset 3, -24
 1158              		.loc 10 57 0
 1159 0002 0446     		mov	r4, r0
 1160 0004 0D46     		mov	r5, r1
  58:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  59:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 0);
 1161              		.loc 10 59 0
 1162 0006 0079     		ldrb	r0, [r0, #4]	@ zero_extendqisi2
 1163              	.LVL76:
 1164 0008 0021     		movs	r1, #0
 1165              	.LVL77:
  57:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void Write(int addr, unsigned char *data, int dataLen)
 1166              		.loc 10 57 0
 1167 000a 1F46     		mov	r7, r3
 1168 000c 1646     		mov	r6, r2
 1169              		.loc 10 59 0
 1170 000e FFF7FEFF 		bl	_Z12digitalWritehh
 1171              	.LVL78:
  60:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		transfer(addr | fSpiMultiFlag);
 1172              		.loc 10 60 0
 1173 0012 237A     		ldrb	r3, [r4, #8]	@ zero_extendqisi2
 1174 0014 1D43     		orrs	r5, r5, r3
 1175              	.LVL79:
 1176 0016 E9B2     		uxtb	r1, r5
 1177 0018 2046     		mov	r0, r4
 1178 001a FFF7FEFF 		bl	_ZN11HardwareSPI8transferEh
 1179 001e 3D46     		mov	r5, r7
  61:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		while(dataLen-- > 0) {
 1180              		.loc 10 61 0
 1181 0020 05E0     		b	.L72
 1182              	.LVL80:
 1183              	.L73:
  62:../Libraries/AQ_SPI/HardwareSPIExt.h **** 			transfer(*data++);
 1184              		.loc 10 62 0
 1185 0022 2046     		mov	r0, r4
 1186 0024 16F8011B 		ldrb	r1, [r6], #1	@ zero_extendqisi2
 1187              	.LVL81:
 1188 0028 FFF7FEFF 		bl	_ZN11HardwareSPI8transferEh
 1189 002c 013D     		subs	r5, r5, #1
 1190              	.LVL82:
 1191              	.L72:
  61:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		while(dataLen-- > 0) {
 1192              		.loc 10 61 0 discriminator 1
 1193 002e 002D     		cmp	r5, #0
 1194 0030 F7DC     		bgt	.L73
  63:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		}
  64:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
 1195              		.loc 10 64 0
 1196 0032 2079     		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 1197 0034 0121     		movs	r1, #1
  65:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 1198              		.loc 10 65 0
 1199 0036 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
  64:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
 1200              		.loc 10 64 0
 1201 003a FFF7FEBF 		b	_Z12digitalWritehh
 1202              		.cfi_endproc
 1203              	.LFE136:
 1205              		.section	.text._ZN14HardwareSPIExt5WriteEih,"axG",%progbits,_ZN14HardwareSPIExt5WriteEih,comdat
 1206              		.align	1
 1207              		.weak	_ZN14HardwareSPIExt5WriteEih
 1208              		.thumb
 1209              		.thumb_func
 1211              	_ZN14HardwareSPIExt5WriteEih:
 1212              	.LFB137:
  66:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  67:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void Write(int addr, unsigned char data)
 1213              		.loc 10 67 0
 1214              		.cfi_startproc
 1215              		@ args = 0, pretend = 0, frame = 8
 1216              		@ frame_needed = 0, uses_anonymous_args = 0
 1217              	.LVL83:
 1218 0000 07B5     		push	{r0, r1, r2, lr}
 1219              	.LCFI9:
 1220              		.cfi_def_cfa_offset 16
 1221              		.cfi_offset 14, -4
 1222              		.cfi_offset 2, -8
 1223              		.cfi_offset 1, -12
 1224              		.cfi_offset 0, -16
 1225              	.LVL84:
 1226              		.loc 10 67 0
 1227 0002 02AB     		add	r3, sp, #8
 1228              	.LVL85:
 1229 0004 03F8012D 		strb	r2, [r3, #-1]!
  68:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  69:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		Write(addr, &data, 1);
 1230              		.loc 10 69 0
 1231 0008 1A46     		mov	r2, r3
 1232              	.LVL86:
 1233 000a 0123     		movs	r3, #1
 1234 000c FFF7FEFF 		bl	_ZN14HardwareSPIExt5WriteEiPhi
 1235              	.LVL87:
  70:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 1236              		.loc 10 70 0
 1237 0010 0EBD     		pop	{r1, r2, r3, pc}
 1238              		.cfi_endproc
 1239              	.LFE137:
 1241              		.section	.text._Z19MPU6000_SpiLowSpeedv,"ax",%progbits
 1242              		.align	1
 1243              		.global	_Z19MPU6000_SpiLowSpeedv
 1244              		.thumb
 1245              		.thumb_func
 1247              	_Z19MPU6000_SpiLowSpeedv:
 1248              	.LFB138:
 1249              		.file 11 "../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h"
   1:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** /*
   2:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   AeroQuad v3.0 - May 2011
   3:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   Copyright (c) 2011 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
   7:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   This program is free software: you can redistribute it and/or modify
   8:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   it under the terms of the GNU General Public License as published by
   9:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   the Free Software Foundation, either version 3 of the License, or
  10:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   (at your option) any later version.
  11:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  12:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   This program is distributed in the hope that it will be useful,
  13:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   GNU General Public License for more details.
  16:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  17:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   You should have received a copy of the GNU General Public License
  18:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** */
  20:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  21:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** // parts of the init sequence were taken from AP_InertialSensor_MPU6000.h
  22:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  23:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifndef _AEROQUAD_PLATFORM_MPU6000_H_
  24:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define _AEROQUAD_PLATFORM_MPU6000_H_
  25:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  26:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** // I2C support for MPU6000/6050 is not tested yet
  27:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** //#define MPU6000_I2C
  28:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  29:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #include "Arduino.h"
  30:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #include <SensorsStatus.h>
  31:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  32:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** //#define MPU6000_I2C	// insert this define before #include <Platform_MPU6000.h> when you use a I2C
  33:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  34:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** // MPU 6000 registers
  35:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_WHOAMI			0x75
  36:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_SMPLRT_DIV		0x19
  37:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_CONFIG			0x1A
  38:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_CONFIG		0x1B
  39:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_CONFIG		0x1C
  40:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_FIFO_EN			0x23
  41:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_INT_PIN_CFG		0x37
  42:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_INT_ENABLE		0x38
  43:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_INT_STATUS		0x3A
  44:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_XOUT_H		0x3B
  45:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_XOUT_L		0x3C
  46:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_YOUT_H		0x3D
  47:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_YOUT_L		0x3E
  48:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_ZOUT_H		0x3F
  49:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_ZOUT_L		0x40
  50:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_TEMP_OUT_H		0x41
  51:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_TEMP_OUT_L		0x42
  52:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_XOUT_H		0x43
  53:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_XOUT_L		0x44
  54:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_YOUT_H		0x45
  55:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_YOUT_L		0x46
  56:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_ZOUT_H		0x47
  57:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_ZOUT_L		0x48
  58:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_USER_CTRL		0x6A
  59:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_PWR_MGMT_1		0x6B
  60:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_PWR_MGMT_2		0x6C
  61:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_FIFO_COUNTH		0x72
  62:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_FIFO_COUNTL		0x73
  63:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_FIFO_R_W			0x74
  64:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  65:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  66:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** // Configuration bits
  67:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_SLEEP				0x40
  68:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_H_RESET				0x80
  69:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_CLKSEL				0x07
  70:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPU_CLK_SEL_PLLGYROX	0x01
  71:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPU_CLK_SEL_PLLGYROZ	0x03
  72:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPU_EXT_SYNC_GYROX		0x02
  73:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_FS_250DPS          0x00
  74:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_FS_500DPS          0x08
  75:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_FS_1000DPS         0x10
  76:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_FS_2000DPS         0x18
  77:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_FS_MASK            0x18
  78:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_256HZ_NOLPF2  0x00
  79:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_188HZ         0x01
  80:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_98HZ          0x02
  81:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_42HZ          0x03
  82:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_20HZ          0x04
  83:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_10HZ          0x05
  84:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_5HZ           0x06
  85:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_2100HZ_NOLPF  0x07
  86:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_MASK          0x07
  87:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_INT_ANYRD_2CLEAR    0x10
  88:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_RAW_RDY_EN			0x01
  89:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_I2C_IF_DIS          0x10
  90:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_INT_STATUS_DATA		0x01
  91:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  92:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  93:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** typedef struct {
  94:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	short x;
  95:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	short y;
  96:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	short z;
  97:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** } tAxis;
  98:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  99:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** union uMPU6000 {
 100:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	unsigned char rawByte[];
 101:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	unsigned short rawWord[];
 102:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	struct {
 103:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		tAxis accel;
 104:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		short temperature;
 105:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		tAxis gyro;
 106:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	} data;
 107:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** } MPU6000;
 108:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 109:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 110:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifdef MPU6000_I2C
 111:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	#ifndef MPU6000_I2C_ADDRESS
 112:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		#define MPU6000_I2C_ADDRESS 0x68
 113:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	#endif
 114:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #else
 115:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	#include <HardwareSPIExt.h>
 116:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	HardwareSPIExt spiMPU6000(4);
 117:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #endif
 118:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 119:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void MPU6000_SpiLowSpeed()
 120:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1250              		.loc 11 120 0
 1251              		.cfi_startproc
 1252              		@ args = 0, pretend = 0, frame = 0
 1253              		@ frame_needed = 0, uses_anonymous_args = 0
 1254 0000 08B5     		push	{r3, lr}
 1255              	.LCFI10:
 1256              		.cfi_def_cfa_offset 8
 1257              		.cfi_offset 14, -4
 1258              		.cfi_offset 3, -8
 121:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifndef MPU6000_I2C
 122:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	spiMPU6000.begin(SPI_562_500KHZ, MSBFIRST, 3);
 1259              		.loc 11 122 0
 1260 0002 0348     		ldr	r0, .L76
 1261 0004 0521     		movs	r1, #5
 1262 0006 0122     		movs	r2, #1
 1263 0008 0323     		movs	r3, #3
 1264 000a FFF7FEFF 		bl	_ZN14HardwareSPIExt5beginE12SPIFrequencyjj
 123:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #endif
 124:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1265              		.loc 11 124 0
 1266 000e 08BD     		pop	{r3, pc}
 1267              	.L77:
 1268              		.align	2
 1269              	.L76:
 1270 0010 00000000 		.word	.LANCHOR19
 1271              		.cfi_endproc
 1272              	.LFE138:
 1274              		.section	.text._Z20MPU6000_SpiHighSpeedv,"ax",%progbits
 1275              		.align	1
 1276              		.global	_Z20MPU6000_SpiHighSpeedv
 1277              		.thumb
 1278              		.thumb_func
 1280              	_Z20MPU6000_SpiHighSpeedv:
 1281              	.LFB139:
 125:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 126:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void MPU6000_SpiHighSpeed()
 127:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1282              		.loc 11 127 0
 1283              		.cfi_startproc
 1284              		@ args = 0, pretend = 0, frame = 0
 1285              		@ frame_needed = 0, uses_anonymous_args = 0
 1286 0000 10B5     		push	{r4, lr}
 1287              	.LCFI11:
 1288              		.cfi_def_cfa_offset 8
 1289              		.cfi_offset 14, -4
 1290              		.cfi_offset 4, -8
 128:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifndef MPU6000_I2C
 129:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	spiMPU6000.end();
 1291              		.loc 11 129 0
 1292 0002 054C     		ldr	r4, .L79
 1293 0004 2046     		mov	r0, r4
 1294 0006 FFF7FEFF 		bl	_ZN11HardwareSPI3endEv
 130:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     spiMPU6000.begin(SPI_9MHZ, MSBFIRST, 3);
 1295              		.loc 11 130 0
 1296 000a 0121     		movs	r1, #1
 1297 000c 2046     		mov	r0, r4
 1298 000e 0A46     		mov	r2, r1
 1299 0010 0323     		movs	r3, #3
 1300 0012 FFF7FEFF 		bl	_ZN14HardwareSPIExt5beginE12SPIFrequencyjj
 131:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #endif
 132:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1301              		.loc 11 132 0
 1302 0016 10BD     		pop	{r4, pc}
 1303              	.L80:
 1304              		.align	2
 1305              	.L79:
 1306 0018 00000000 		.word	.LANCHOR19
 1307              		.cfi_endproc
 1308              	.LFE139:
 1310              		.section	.text._Z16MPU6000_WriteRegih,"ax",%progbits
 1311              		.align	1
 1312              		.global	_Z16MPU6000_WriteRegih
 1313              		.thumb
 1314              		.thumb_func
 1316              	_Z16MPU6000_WriteRegih:
 1317              	.LFB140:
 133:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 134:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void MPU6000_WriteReg(int addr, byte data)
 135:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1318              		.loc 11 135 0
 1319              		.cfi_startproc
 1320              		@ args = 0, pretend = 0, frame = 0
 1321              		@ frame_needed = 0, uses_anonymous_args = 0
 1322              	.LVL88:
 1323 0000 08B5     		push	{r3, lr}
 1324              	.LCFI12:
 1325              		.cfi_def_cfa_offset 8
 1326              		.cfi_offset 14, -4
 1327              		.cfi_offset 3, -8
 1328              		.loc 11 135 0
 1329 0002 0346     		mov	r3, r0
 1330 0004 0A46     		mov	r2, r1
 136:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifdef MPU6000_I2C
 137:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	updateRegisterI2C(MPU6000_I2C_ADDRESS, addr, data);
 138:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #else
 139:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	spiMPU6000.Write(addr, data);
 1331              		.loc 11 139 0
 1332 0006 0448     		ldr	r0, .L82
 1333              	.LVL89:
 1334 0008 1946     		mov	r1, r3
 1335              	.LVL90:
 1336 000a FFF7FEFF 		bl	_ZN14HardwareSPIExt5WriteEih
 1337              	.LVL91:
 140:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #endif
 141:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     delay(1);
 1338              		.loc 11 141 0
 1339 000e 0120     		movs	r0, #1
 142:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1340              		.loc 11 142 0
 1341 0010 BDE80840 		pop	{r3, lr}
 141:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     delay(1);
 1342              		.loc 11 141 0
 1343 0014 FFF7FEBF 		b	_Z5delaym
 1344              	.L83:
 1345              		.align	2
 1346              	.L82:
 1347 0018 00000000 		.word	.LANCHOR19
 1348              		.cfi_endproc
 1349              	.LFE140:
 1351              		.section	.text._Z15MPU6000_ReadRegi,"ax",%progbits
 1352              		.align	1
 1353              		.global	_Z15MPU6000_ReadRegi
 1354              		.thumb
 1355              		.thumb_func
 1357              	_Z15MPU6000_ReadRegi:
 1358              	.LFB141:
 143:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 144:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** byte MPU6000_ReadReg(int addr)
 145:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1359              		.loc 11 145 0
 1360              		.cfi_startproc
 1361              		@ args = 0, pretend = 0, frame = 0
 1362              		@ frame_needed = 0, uses_anonymous_args = 0
 1363              	.LVL92:
 1364 0000 10B5     		push	{r4, lr}
 1365              	.LCFI13:
 1366              		.cfi_def_cfa_offset 8
 1367              		.cfi_offset 14, -4
 1368              		.cfi_offset 4, -8
 1369              		.loc 11 145 0
 1370 0002 0146     		mov	r1, r0
 1371              	.LBB35:
 146:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifdef MPU6000_I2C
 147:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	sendByteI2C(MPU6000_I2C_ADDRESS, addr);
 148:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	byte data = readByteI2C(MPU6000_I2C_ADDRESS);
 149:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #else
 150:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	byte data = spiMPU6000.Read(addr);
 1372              		.loc 11 150 0
 1373 0004 0448     		ldr	r0, .L85
 1374              	.LVL93:
 1375 0006 FFF7FEFF 		bl	_ZN14HardwareSPIExt4ReadEi
 1376              	.LVL94:
 1377 000a 0446     		mov	r4, r0
 1378              	.LVL95:
 151:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #endif
 152:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     delay(1);
 1379              		.loc 11 152 0
 1380 000c 0120     		movs	r0, #1
 1381              	.LVL96:
 1382 000e FFF7FEFF 		bl	_Z5delaym
 1383              	.LBE35:
 153:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     return data;
 154:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1384              		.loc 11 154 0
 1385 0012 2046     		mov	r0, r4
 1386 0014 10BD     		pop	{r4, pc}
 1387              	.L86:
 1388 0016 00BF     		.align	2
 1389              	.L85:
 1390 0018 00000000 		.word	.LANCHOR19
 1391              		.cfi_endproc
 1392              	.LFE141:
 1394              		.section	.text._Z24initializeMPU6000Sensorsv,"ax",%progbits
 1395              		.align	1
 1396              		.global	_Z24initializeMPU6000Sensorsv
 1397              		.thumb
 1398              		.thumb_func
 1400              	_Z24initializeMPU6000Sensorsv:
 1401              	.LFB142:
 155:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 156:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** bool initializeMPU6000SensorsDone = false;
 157:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void initializeMPU6000Sensors()
 158:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1402              		.loc 11 158 0
 1403              		.cfi_startproc
 1404              		@ args = 0, pretend = 0, frame = 0
 1405              		@ frame_needed = 0, uses_anonymous_args = 0
 1406              	.LBB36:
 159:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	if(initializeMPU6000SensorsDone) {
 1407              		.loc 11 159 0
 1408 0000 254B     		ldr	r3, .L90
 1409              	.LBE36:
 158:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1410              		.loc 11 158 0
 1411 0002 10B5     		push	{r4, lr}
 1412              	.LCFI14:
 1413              		.cfi_def_cfa_offset 8
 1414              		.cfi_offset 14, -4
 1415              		.cfi_offset 4, -8
 1416              	.LBB37:
 1417              		.loc 11 159 0
 1418 0004 1C78     		ldrb	r4, [r3, #0]	@ zero_extendqisi2
 1419 0006 002C     		cmp	r4, #0
 1420 0008 44D1     		bne	.L87
 160:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		return;
 161:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	}
 162:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	initializeMPU6000SensorsDone = true;
 1421              		.loc 11 162 0
 1422 000a 0122     		movs	r2, #1
 1423 000c 1A70     		strb	r2, [r3, #0]
 163:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 164:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifdef DEBUG_INIT
 165:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	Serial.println("initializeMPU6000Sensors");
 1424              		.loc 11 165 0
 1425 000e 2348     		ldr	r0, .L90+4
 1426 0010 2349     		ldr	r1, .L90+8
 1427 0012 FFF7FEFF 		bl	_ZN5Print7printlnEPKc
 166:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #endif
 167:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	MPU6000_SpiLowSpeed();
 1428              		.loc 11 167 0
 1429 0016 FFF7FEFF 		bl	_Z19MPU6000_SpiLowSpeedv
 168:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 169:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	unsigned char val;
 170:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 171:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	val = MPU6000_ReadReg(MPUREG_WHOAMI);
 1430              		.loc 11 171 0
 1431 001a 7520     		movs	r0, #117
 1432 001c FFF7FEFF 		bl	_Z15MPU6000_ReadRegi
 1433              	.LVL97:
 172:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	if((val&0x7E) == 0x68) {
 1434              		.loc 11 172 0
 1435 0020 00F07E00 		and	r0, r0, #126
 1436              	.LVL98:
 1437 0024 6828     		cmp	r0, #104
 1438 0026 2FD1     		bne	.L89
 173:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		vehicleState |= GYRO_DETECTED;
 174:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		vehicleState |= ACCEL_DETECTED;
 1439              		.loc 11 174 0
 1440 0028 1E4B     		ldr	r3, .L90+12
 1441 002a 1868     		ldr	r0, [r3, #0]
 1442 002c 40F00301 		orr	r1, r0, #3
 1443 0030 1960     		str	r1, [r3, #0]
 175:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifdef DEBUG_INIT
 176:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		Serial.println("MPU6000 found");
 1444              		.loc 11 176 0
 1445 0032 1A48     		ldr	r0, .L90+4
 1446 0034 1C49     		ldr	r1, .L90+16
 1447 0036 FFF7FEFF 		bl	_ZN5Print7printlnEPKc
 177:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #endif
 178:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	} else {
 179:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifdef DEBUG_INIT
 180:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		Serial.println("MPU6000 not found");
 181:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #endif
 182:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		return;
 183:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	}
 184:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 185:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     // Chip reset
 186:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000_WriteReg(MPUREG_PWR_MGMT_1, BIT_H_RESET);
 1448              		.loc 11 186 0
 1449 003a 8021     		movs	r1, #128
 1450 003c 6B20     		movs	r0, #107
 1451 003e FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 187:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     delay(100);  // Startup time delay
 1452              		.loc 11 187 0
 1453 0042 6420     		movs	r0, #100
 1454 0044 FFF7FEFF 		bl	_Z5delaym
 188:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 189:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifndef MPU6000_I2C
 190:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     // Disable I2C bus
 191:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000_WriteReg(MPUREG_USER_CTRL, BIT_I2C_IF_DIS);
 1455              		.loc 11 191 0
 1456 0048 6A20     		movs	r0, #106
 1457 004a 1021     		movs	r1, #16
 1458 004c FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 192:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #endif
 193:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 194:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     // Wake Up device and select GyroZ clock (better performance)
 195:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000_WriteReg(MPUREG_PWR_MGMT_1, MPU_CLK_SEL_PLLGYROZ);
 1459              		.loc 11 195 0
 1460 0050 6B20     		movs	r0, #107
 1461 0052 0321     		movs	r1, #3
 1462 0054 FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 196:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000_WriteReg(MPUREG_PWR_MGMT_2, 0);
 1463              		.loc 11 196 0
 1464 0058 6C20     		movs	r0, #108
 1465 005a 2146     		mov	r1, r4
 1466 005c FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 197:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 198:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 199:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	// SAMPLE RATE
 200:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000_WriteReg(MPUREG_SMPLRT_DIV,0x00);     // Sample rate = 1kHz
 1467              		.loc 11 200 0
 1468 0060 1920     		movs	r0, #25
 1469 0062 2146     		mov	r1, r4
 1470 0064 FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 201:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 202:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	// FS & DLPF   FS=1000/s, DLPF = 42Hz (low pass filter)
 203:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000_WriteReg(MPUREG_CONFIG, BITS_DLPF_CFG_42HZ);
 1471              		.loc 11 203 0
 1472 0068 1A20     		movs	r0, #26
 1473 006a 0321     		movs	r1, #3
 1474 006c FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 204:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000_WriteReg(MPUREG_GYRO_CONFIG,BITS_FS_1000DPS);  // Gyro scale 1000/s
 1475              		.loc 11 204 0
 1476 0070 1B20     		movs	r0, #27
 1477 0072 1021     		movs	r1, #16
 1478 0074 FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 205:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     //Serial.print("MPUREG_GYRO_CONFIG read 0x");
 206:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     //Serial.println(MPU6000_ReadReg(MPUREG_GYRO_CONFIG), 16);
 207:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 208:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000_WriteReg(MPUREG_ACCEL_CONFIG,0x08);   // Accel scale +-4g (4096LSB/g)
 1479              		.loc 11 208 0
 1480 0078 1C20     		movs	r0, #28
 1481 007a 0821     		movs	r1, #8
 1482 007c FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 1483              	.LBE37:
 209:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 210:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     // INT CFG => Interrupt on Data Ready
 211:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     //MPU6000_WriteReg(MPUREG_INT_ENABLE,BIT_RAW_RDY_EN);        // INT: Raw data ready
 212:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     //MPU6000_WriteReg(MPUREG_INT_PIN_CFG,BIT_INT_ANYRD_2CLEAR); // INT: Clear on any read
 213:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 214:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     // switch to high clock rate
 215:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000_SpiHighSpeed();
 216:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** };
 1484              		.loc 11 216 0
 1485 0080 BDE81040 		pop	{r4, lr}
 1486              	.LBB38:
 215:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000_SpiHighSpeed();
 1487              		.loc 11 215 0
 1488 0084 FFF7FEBF 		b	_Z20MPU6000_SpiHighSpeedv
 1489              	.L89:
 180:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		Serial.println("MPU6000 not found");
 1490              		.loc 11 180 0
 1491 0088 0448     		ldr	r0, .L90+4
 1492 008a 0849     		ldr	r1, .L90+20
 1493              	.LBE38:
 1494              		.loc 11 216 0
 1495 008c BDE81040 		pop	{r4, lr}
 1496              	.LBB39:
 180:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		Serial.println("MPU6000 not found");
 1497              		.loc 11 180 0
 1498 0090 FFF7FEBF 		b	_ZN5Print7printlnEPKc
 1499              	.L87:
 1500 0094 10BD     		pop	{r4, pc}
 1501              	.L91:
 1502 0096 00BF     		.align	2
 1503              	.L90:
 1504 0098 00000000 		.word	.LANCHOR20
 1505 009c 00000000 		.word	SerialUSB
 1506 00a0 00000000 		.word	.LC1
 1507 00a4 00000000 		.word	.LANCHOR21
 1508 00a8 19000000 		.word	.LC2
 1509 00ac 27000000 		.word	.LC3
 1510              	.LBE39:
 1511              		.cfi_endproc
 1512              	.LFE142:
 1514              		.section	.text._Z15MPU6000SwapDataPhi,"ax",%progbits
 1515              		.align	1
 1516              		.global	_Z15MPU6000SwapDataPhi
 1517              		.thumb
 1518              		.thumb_func
 1520              	_Z15MPU6000SwapDataPhi:
 1521              	.LFB143:
 217:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 218:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 219:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void MPU6000SwapData(unsigned char *data, int datalen)
 220:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1522              		.loc 11 220 0
 1523              		.cfi_startproc
 1524              		@ args = 0, pretend = 0, frame = 0
 1525              		@ frame_needed = 0, uses_anonymous_args = 0
 1526              		@ link register save eliminated.
 1527              	.LVL99:
 1528              	.LBB40:
 221:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	datalen /= 2;
 1529              		.loc 11 221 0
 1530 0000 01EBD171 		add	r1, r1, r1, lsr #31
 1531              	.LVL100:
 1532 0004 4910     		asrs	r1, r1, #1
 1533              	.LVL101:
 222:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	while(datalen--) {
 1534              		.loc 11 222 0
 1535 0006 04E0     		b	.L93
 1536              	.LVL102:
 1537              	.L94:
 1538              	.LBB41:
 223:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		unsigned char t = data[0];
 1539              		.loc 11 223 0
 1540 0008 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 1541              	.LVL103:
 224:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		data[0] = data[1];
 1542              		.loc 11 224 0
 1543 000a 4278     		ldrb	r2, [r0, #1]	@ zero_extendqisi2
 225:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		data[1] = t;
 1544              		.loc 11 225 0
 1545 000c 4370     		strb	r3, [r0, #1]
 224:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		data[0] = data[1];
 1546              		.loc 11 224 0
 1547 000e 0270     		strb	r2, [r0, #0]
 226:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		data += 2;
 1548              		.loc 11 226 0
 1549 0010 0230     		adds	r0, r0, #2
 1550              	.LVL104:
 1551              	.L93:
 1552              	.LBE41:
 222:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	while(datalen--) {
 1553              		.loc 11 222 0 discriminator 1
 1554 0012 11F1FF31 		adds	r1, r1, #-1
 1555              	.LVL105:
 1556 0016 F7D2     		bcs	.L94
 1557              	.LBE40:
 227:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	}
 228:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1558              		.loc 11 228 0
 1559 0018 7047     		bx	lr
 1560              		.cfi_endproc
 1561              	.LFE143:
 1563              		.section	.text._Z18readMPU6000Sensorsv,"ax",%progbits
 1564              		.align	1
 1565              		.global	_Z18readMPU6000Sensorsv
 1566              		.thumb
 1567              		.thumb_func
 1569              	_Z18readMPU6000Sensorsv:
 1570              	.LFB144:
 229:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 230:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void readMPU6000Sensors()
 231:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1571              		.loc 11 231 0
 1572              		.cfi_startproc
 1573              		@ args = 0, pretend = 0, frame = 0
 1574              		@ frame_needed = 0, uses_anonymous_args = 0
 1575 0000 10B5     		push	{r4, lr}
 1576              	.LCFI15:
 1577              		.cfi_def_cfa_offset 8
 1578              		.cfi_offset 14, -4
 1579              		.cfi_offset 4, -8
 232:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifdef MPU6000_I2C
 233:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	sendByteI2C(MPU6000_I2C_ADDRESS, MPUREG_ACCEL_XOUT_H);
 234:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     Wire.requestFrom(MPU6000_I2C_ADDRESS, sizeof(MPU6000));
 235:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     for(byte i=0; i<sizeof(MPU6000)/sizeof(short); i++) {
 236:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     	MPU6000.rawWord[i] = readWordI2C();
 237:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     }
 238:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #else
 239:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	spiMPU6000.Read(MPUREG_ACCEL_XOUT_H, MPU6000.rawByte, sizeof(MPU6000));
 1580              		.loc 11 239 0
 1581 0002 064C     		ldr	r4, .L96
 1582 0004 0648     		ldr	r0, .L96+4
 1583 0006 3B21     		movs	r1, #59
 1584 0008 2246     		mov	r2, r4
 1585 000a 0E23     		movs	r3, #14
 1586 000c FFF7FEFF 		bl	_ZN14HardwareSPIExt4ReadEiPhi
 240:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	MPU6000SwapData(MPU6000.rawByte, sizeof(MPU6000));
 1587              		.loc 11 240 0
 1588 0010 2046     		mov	r0, r4
 1589 0012 0E21     		movs	r1, #14
 241:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #endif
 242:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1590              		.loc 11 242 0
 1591 0014 BDE81040 		pop	{r4, lr}
 240:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	MPU6000SwapData(MPU6000.rawByte, sizeof(MPU6000));
 1592              		.loc 11 240 0
 1593 0018 FFF7FEBF 		b	_Z15MPU6000SwapDataPhi
 1594              	.L97:
 1595              		.align	2
 1596              	.L96:
 1597 001c 00000000 		.word	.LANCHOR22
 1598 0020 00000000 		.word	.LANCHOR19
 1599              		.cfi_endproc
 1600              	.LFE144:
 1602              		.section	.text._Z16readMPU6000Accelv,"ax",%progbits
 1603              		.align	1
 1604              		.global	_Z16readMPU6000Accelv
 1605              		.thumb
 1606              		.thumb_func
 1608              	_Z16readMPU6000Accelv:
 1609              	.LFB145:
 243:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 244:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** int readMPU6000Count=0;
 245:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** int readMPU6000AccelCount=0;
 246:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** int readMPU6000GyroCount=0;
 247:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 248:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void readMPU6000Accel()
 249:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1610              		.loc 11 249 0
 1611              		.cfi_startproc
 1612              		@ args = 0, pretend = 0, frame = 0
 1613              		@ frame_needed = 0, uses_anonymous_args = 0
 250:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	readMPU6000AccelCount++;
 1614              		.loc 11 250 0
 1615 0000 0748     		ldr	r0, .L100
 249:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1616              		.loc 11 249 0
 1617 0002 10B5     		push	{r4, lr}
 1618              	.LCFI16:
 1619              		.cfi_def_cfa_offset 8
 1620              		.cfi_offset 14, -4
 1621              		.cfi_offset 4, -8
 251:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	if(readMPU6000AccelCount != readMPU6000Count) {
 1622              		.loc 11 251 0
 1623 0004 074C     		ldr	r4, .L100+4
 250:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	readMPU6000AccelCount++;
 1624              		.loc 11 250 0
 1625 0006 0168     		ldr	r1, [r0, #0]
 1626              		.loc 11 251 0
 1627 0008 2268     		ldr	r2, [r4, #0]
 250:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	readMPU6000AccelCount++;
 1628              		.loc 11 250 0
 1629 000a 4B1C     		adds	r3, r1, #1
 1630              		.loc 11 251 0
 1631 000c 9342     		cmp	r3, r2
 250:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	readMPU6000AccelCount++;
 1632              		.loc 11 250 0
 1633 000e 0360     		str	r3, [r0, #0]
 1634              		.loc 11 251 0
 1635 0010 04D0     		beq	.L98
 252:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		readMPU6000Sensors();
 1636              		.loc 11 252 0
 1637 0012 FFF7FEFF 		bl	_Z18readMPU6000Sensorsv
 253:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		readMPU6000Count++;
 1638              		.loc 11 253 0
 1639 0016 2368     		ldr	r3, [r4, #0]
 1640 0018 5A1C     		adds	r2, r3, #1
 1641 001a 2260     		str	r2, [r4, #0]
 1642              	.L98:
 1643 001c 10BD     		pop	{r4, pc}
 1644              	.L101:
 1645 001e 00BF     		.align	2
 1646              	.L100:
 1647 0020 00000000 		.word	.LANCHOR23
 1648 0024 00000000 		.word	.LANCHOR24
 1649              		.cfi_endproc
 1650              	.LFE145:
 1652              		.section	.text._Z15readMPU6000Gyrov,"ax",%progbits
 1653              		.align	1
 1654              		.global	_Z15readMPU6000Gyrov
 1655              		.thumb
 1656              		.thumb_func
 1658              	_Z15readMPU6000Gyrov:
 1659              	.LFB146:
 254:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	}
 255:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 256:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 257:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void readMPU6000Gyro()
 258:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1660              		.loc 11 258 0
 1661              		.cfi_startproc
 1662              		@ args = 0, pretend = 0, frame = 0
 1663              		@ frame_needed = 0, uses_anonymous_args = 0
 1664 0000 10B5     		push	{r4, lr}
 1665              	.LCFI17:
 1666              		.cfi_def_cfa_offset 8
 1667              		.cfi_offset 14, -4
 1668              		.cfi_offset 4, -8
 259:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	readMPU6000GyroCount++;
 1669              		.loc 11 259 0
 1670 0002 074C     		ldr	r4, .L104
 260:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	if(readMPU6000GyroCount != readMPU6000Count) {
 1671              		.loc 11 260 0
 1672 0004 0748     		ldr	r0, .L104+4
 259:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	readMPU6000GyroCount++;
 1673              		.loc 11 259 0
 1674 0006 2168     		ldr	r1, [r4, #0]
 1675              		.loc 11 260 0
 1676 0008 0268     		ldr	r2, [r0, #0]
 259:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	readMPU6000GyroCount++;
 1677              		.loc 11 259 0
 1678 000a 4B1C     		adds	r3, r1, #1
 1679              		.loc 11 260 0
 1680 000c 9342     		cmp	r3, r2
 259:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	readMPU6000GyroCount++;
 1681              		.loc 11 259 0
 1682 000e 2360     		str	r3, [r4, #0]
 1683              		.loc 11 260 0
 1684 0010 04D0     		beq	.L102
 261:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		readMPU6000Sensors();
 1685              		.loc 11 261 0
 1686 0012 FFF7FEFF 		bl	_Z18readMPU6000Sensorsv
 262:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		readMPU6000GyroCount++;
 1687              		.loc 11 262 0
 1688 0016 2368     		ldr	r3, [r4, #0]
 1689 0018 5A1C     		adds	r2, r3, #1
 1690 001a 2260     		str	r2, [r4, #0]
 1691              	.L102:
 1692 001c 10BD     		pop	{r4, pc}
 1693              	.L105:
 1694 001e 00BF     		.align	2
 1695              	.L104:
 1696 0020 00000000 		.word	.LANCHOR25
 1697 0024 00000000 		.word	.LANCHOR24
 1698              		.cfi_endproc
 1699              	.LFE146:
 1701              		.section	.text._Z14initializeGyrov,"ax",%progbits
 1702              		.align	1
 1703              		.global	_Z14initializeGyrov
 1704              		.thumb
 1705              		.thumb_func
 1707              	_Z14initializeGyrov:
 1708              	.LFB147:
 1709              		.file 12 "../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h"
   1:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** /*
   2:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   AeroQuad v3.0 - May 2011
   3:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   Copyright (c) 2011 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
   7:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   This program is free software: you can redistribute it and/or modify
   8:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   it under the terms of the GNU General Public License as published by
   9:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   the Free Software Foundation, either version 3 of the License, or
  10:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   (at your option) any later version.
  11:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  12:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   This program is distributed in the hope that it will be useful,
  13:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   GNU General Public License for more details.
  16:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  17:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   You should have received a copy of the GNU General Public License
  18:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** */
  20:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  21:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** #ifndef _AEROQUAD_GYROSCOPE_MPU6000_COMMON_H_
  22:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** #define _AEROQUAD_GYROSCOPE_MPU6000_COMMON_H_
  23:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  24:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** int gyroRaw[3] = {0,0,0};
  25:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  26:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** #include <Platform_MPU6000.h>
  27:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** #include <Gyroscope.h>
  28:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  29:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void initializeGyro() {
 1710              		.loc 12 29 0
 1711              		.cfi_startproc
 1712              		@ args = 0, pretend = 0, frame = 0
 1713              		@ frame_needed = 0, uses_anonymous_args = 0
 1714              		@ link register save eliminated.
 1715              	.LVL106:
 1716              	.LBB42:
  30:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   float range = 2*1000.0;
  31:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroScaleFactor = radians(range/65536.0);
 1717              		.loc 12 31 0
 1718 0000 024A     		ldr	r2, .L107
 1719 0002 034B     		ldr	r3, .L107+4
 1720 0004 1A60     		str	r2, [r3, #0]	@ float
 1721              	.LBE42:
  32:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  33:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   initializeMPU6000Sensors();
  34:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 1722              		.loc 12 34 0
 1723              	.LBB43:
  33:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   initializeMPU6000Sensors();
 1724              		.loc 12 33 0
 1725 0006 FFF7FEBF 		b	_Z24initializeMPU6000Sensorsv
 1726              	.L108:
 1727 000a 00BF     		.align	2
 1728              	.L107:
 1729 000c 58A00B3A 		.word	973840472
 1730 0010 00000000 		.word	.LANCHOR26
 1731              	.LBE43:
 1732              		.cfi_endproc
 1733              	.LFE147:
 1735              		.section	.text._Z17gyroUpdateHeadingv,"ax",%progbits
 1736              		.align	1
 1737              		.global	_Z17gyroUpdateHeadingv
 1738              		.thumb
 1739              		.thumb_func
 1741              	_Z17gyroUpdateHeadingv:
 1742              	.LFB148:
  35:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  36:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void gyroUpdateHeading()
  37:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** {
 1743              		.loc 12 37 0
 1744              		.cfi_startproc
 1745              		@ args = 0, pretend = 0, frame = 0
 1746              		@ frame_needed = 0, uses_anonymous_args = 0
 1747 0000 08B5     		push	{r3, lr}
 1748              	.LCFI18:
 1749              		.cfi_def_cfa_offset 8
 1750              		.cfi_offset 14, -4
 1751              		.cfi_offset 3, -8
 1752              	.LBB44:
  38:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   long int currentTime = micros();
 1753              		.loc 12 38 0
 1754 0002 FFF7FEFF 		bl	_ZL6microsv
 1755              	.LVL107:
  39:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   if (gyroRate[ZAXIS] > (float)radians(1.0) || gyroRate[ZAXIS] < (float)radians(-1.0)) {
 1756              		.loc 12 39 0
 1757 0006 124B     		ldr	r3, .L113
 1758 0008 DFED127A 		flds	s15, .L113+4
 1759 000c 93ED027A 		flds	s14, [r3, #8]
 1760 0010 B4EEE77A 		fcmpes	s14, s15
 1761 0014 F1EE10FA 		fmstat
 1762 0018 0F4B     		ldr	r3, .L113+8
 1763 001a 06DC     		bgt	.L110
 1764              		.loc 12 39 0 is_stmt 0 discriminator 1
 1765 001c 9FED0F0A 		flds	s0, .L113+12
 1766 0020 B4EEC07A 		fcmpes	s14, s0
 1767 0024 F1EE10FA 		fmstat
 1768 0028 10D5     		bpl	.L111
 1769              	.L110:
  40:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     gyroHeading += gyroRate[ZAXIS] * ((currentTime - gyroLastMesuredTime) / 1000000.0);
 1770              		.loc 12 40 0 is_stmt 1
 1771 002a 1968     		ldr	r1, [r3, #0]
 1772 002c 0C4A     		ldr	r2, .L113+16
 1773 002e 411A     		subs	r1, r0, r1
 1774 0030 01EE901A 		fmsr	s3, r1	@ int
 1775 0034 9FED0B1A 		flds	s2, .L113+20
 1776 0038 F8EE616A 		fuitos	s13, s3
 1777 003c D2ED000A 		flds	s1, [r2, #0]
 1778 0040 C6EE816A 		fdivs	s13, s13, s2
 1779 0044 47EE260A 		fmacs	s1, s14, s13
 1780 0048 C2ED000A 		fsts	s1, [r2, #0]
 1781              	.L111:
  41:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   }
  42:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroLastMesuredTime = currentTime;
 1782              		.loc 12 42 0
 1783 004c 1860     		str	r0, [r3, #0]
 1784              	.LBE44:
  43:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 1785              		.loc 12 43 0
 1786 004e 08BD     		pop	{r3, pc}
 1787              	.L114:
 1788              		.align	2
 1789              	.L113:
 1790 0050 00000000 		.word	.LANCHOR27
 1791 0054 35FA8E3C 		.word	1016003125
 1792 0058 00000000 		.word	.LANCHOR29
 1793 005c 35FA8EBC 		.word	-1131480523
 1794 0060 00000000 		.word	.LANCHOR28
 1795 0064 00247449 		.word	1232348160
 1796              		.cfi_endproc
 1797              	.LFE148:
 1799              		.section	.text._Z11measureGyrov,"ax",%progbits
 1800              		.align	1
 1801              		.global	_Z11measureGyrov
 1802              		.thumb
 1803              		.thumb_func
 1805              	_Z11measureGyrov:
 1806              	.LFB149:
  44:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  45:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void measureGyro() {
 1807              		.loc 12 45 0
 1808              		.cfi_startproc
 1809              		@ args = 0, pretend = 0, frame = 16
 1810              		@ frame_needed = 0, uses_anonymous_args = 0
 1811 0000 30B5     		push	{r4, r5, lr}
 1812              	.LCFI19:
 1813              		.cfi_def_cfa_offset 12
 1814              		.cfi_offset 14, -4
 1815              		.cfi_offset 5, -8
 1816              		.cfi_offset 4, -12
 1817 0002 85B0     		sub	sp, sp, #20
 1818              	.LCFI20:
 1819              		.cfi_def_cfa_offset 32
 1820              	.LBB45:
  46:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   readMPU6000Gyro();
 1821              		.loc 12 46 0
 1822 0004 FFF7FEFF 		bl	_Z15readMPU6000Gyrov
  47:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  48:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   int gyroADC[3];
  49:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroRaw[XAXIS]=MPU6000.data.gyro.x)  - gyroZero[XAXIS];
 1823              		.loc 12 49 0
 1824 0008 1A4A     		ldr	r2, .L116
 1825 000a 1B49     		ldr	r1, .L116+4
 1826 000c B2F90850 		ldrsh	r5, [r2, #8]
 1827 0010 1A4B     		ldr	r3, .L116+8
 1828 0012 0C68     		ldr	r4, [r1, #0]
 1829 0014 1D60     		str	r5, [r3, #0]
 1830 0016 2C1B     		subs	r4, r5, r4
  50:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1831              		.loc 12 50 0
 1832 0018 B2F90A00 		ldrsh	r0, [r2, #10]
 1833 001c 4D68     		ldr	r5, [r1, #4]
  51:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[ZAXIS] = gyroZero[ZAXIS] - (gyroRaw[ZAXIS]=MPU6000.data.gyro.z);
 1834              		.loc 12 51 0
 1835 001e B2F90C20 		ldrsh	r2, [r2, #12]
 1836 0022 8968     		ldr	r1, [r1, #8]
  50:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1837              		.loc 12 50 0
 1838 0024 5860     		str	r0, [r3, #4]
 1839              		.loc 12 51 0
 1840 0026 9A60     		str	r2, [r3, #8]
  50:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1841              		.loc 12 50 0
 1842 0028 281A     		subs	r0, r5, r0
 1843              		.loc 12 51 0
 1844 002a 8A1A     		subs	r2, r1, r2
 1845              	.LBB46:
  52:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  53:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   for (byte axis = 0; axis <= ZAXIS; axis++) {
  54:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     gyroRate[axis] = gyroADC[axis] * gyroScaleFactor;
 1846              		.loc 12 54 0
 1847 002c 01EE904A 		fmsr	s3, r4	@ int
 1848 0030 1349     		ldr	r1, .L116+12
 1849 0032 144B     		ldr	r3, .L116+16
 1850              	.LBE46:
  49:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroRaw[XAXIS]=MPU6000.data.gyro.x)  - gyroZero[XAXIS];
 1851              		.loc 12 49 0
 1852 0034 0194     		str	r4, [sp, #4]
 1853              	.LBB47:
 1854              		.loc 12 54 0
 1855 0036 00EE900A 		fmsr	s1, r0	@ int
 1856 003a 06EE902A 		fmsr	s13, r2	@ int
 1857 003e D1ED007A 		flds	s15, [r1, #0]
 1858 0042 B8EEE11A 		fsitos	s2, s3
 1859 0046 B8EEE00A 		fsitos	s0, s1
 1860 004a B8EEE67A 		fsitos	s14, s13
 1861 004e 21EE271A 		fmuls	s2, s2, s15
 1862 0052 20EE270A 		fmuls	s0, s0, s15
 1863 0056 67EE277A 		fmuls	s15, s14, s15
 1864              	.LBE47:
  50:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1865              		.loc 12 50 0
 1866 005a 0290     		str	r0, [sp, #8]
  51:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[ZAXIS] = gyroZero[ZAXIS] - (gyroRaw[ZAXIS]=MPU6000.data.gyro.z);
 1867              		.loc 12 51 0
 1868 005c 0392     		str	r2, [sp, #12]
 1869              	.LVL108:
 1870              	.LBB48:
 1871              		.loc 12 54 0
 1872 005e 83ED001A 		fsts	s2, [r3, #0]
 1873              	.LVL109:
 1874 0062 83ED010A 		fsts	s0, [r3, #4]
 1875              	.LVL110:
 1876 0066 C3ED027A 		fsts	s15, [r3, #8]
 1877              	.LVL111:
 1878              	.LBE48:
 1879              	.LBE45:
  55:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   }
  56:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  57:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroUpdateHeading();
  58:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 1880              		.loc 12 58 0
 1881 006a 05B0     		add	sp, sp, #20
 1882 006c BDE83040 		pop	{r4, r5, lr}
 1883              	.LBB49:
  57:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroUpdateHeading();
 1884              		.loc 12 57 0
 1885 0070 FFF7FEBF 		b	_Z17gyroUpdateHeadingv
 1886              	.L117:
 1887              		.align	2
 1888              	.L116:
 1889 0074 00000000 		.word	.LANCHOR22
 1890 0078 00000000 		.word	.LANCHOR31
 1891 007c 00000000 		.word	.LANCHOR30
 1892 0080 00000000 		.word	.LANCHOR26
 1893 0084 00000000 		.word	.LANCHOR27
 1894              	.LBE49:
 1895              		.cfi_endproc
 1896              	.LFE149:
 1898              		.section	.text._Z14measureGyroSumv,"ax",%progbits
 1899              		.align	1
 1900              		.global	_Z14measureGyroSumv
 1901              		.thumb
 1902              		.thumb_func
 1904              	_Z14measureGyroSumv:
 1905              	.LFB150:
  59:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  60:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void measureGyroSum() {
 1906              		.loc 12 60 0
 1907              		.cfi_startproc
 1908              		@ args = 0, pretend = 0, frame = 0
 1909              		@ frame_needed = 0, uses_anonymous_args = 0
 1910 0000 10B5     		push	{r4, lr}
 1911              	.LCFI21:
 1912              		.cfi_def_cfa_offset 8
 1913              		.cfi_offset 14, -4
 1914              		.cfi_offset 4, -8
  61:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   readMPU6000Gyro();
 1915              		.loc 12 61 0
 1916 0002 FFF7FEFF 		bl	_Z15readMPU6000Gyrov
  62:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[XAXIS] += (gyroRaw[XAXIS]=MPU6000.data.gyro.x);
 1917              		.loc 12 62 0
 1918 0006 0D4B     		ldr	r3, .L119
 1919 0008 0D49     		ldr	r1, .L119+4
 1920 000a 1C68     		ldr	r4, [r3, #0]
 1921 000c B1F90800 		ldrsh	r0, [r1, #8]
 1922 0010 0C4A     		ldr	r2, .L119+8
 1923 0012 2418     		adds	r4, r4, r0
 1924 0014 1C60     		str	r4, [r3, #0]
 1925 0016 1060     		str	r0, [r2, #0]
  63:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[YAXIS] += (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1926              		.loc 12 63 0
 1927 0018 5C68     		ldr	r4, [r3, #4]
 1928 001a B1F90A00 		ldrsh	r0, [r1, #10]
  64:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[ZAXIS] += (gyroRaw[ZAXIS]=MPU6000.data.gyro.z);
 1929              		.loc 12 64 0
 1930 001e B1F90C10 		ldrsh	r1, [r1, #12]
  63:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[YAXIS] += (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1931              		.loc 12 63 0
 1932 0022 5060     		str	r0, [r2, #4]
 1933 0024 2018     		adds	r0, r4, r0
 1934 0026 5860     		str	r0, [r3, #4]
 1935              		.loc 12 64 0
 1936 0028 9868     		ldr	r0, [r3, #8]
 1937 002a 9160     		str	r1, [r2, #8]
 1938 002c 4118     		adds	r1, r0, r1
 1939 002e 9960     		str	r1, [r3, #8]
  65:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  66:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSampleCount++;
 1940              		.loc 12 66 0
 1941 0030 054B     		ldr	r3, .L119+12
 1942 0032 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 1943 0034 421C     		adds	r2, r0, #1
 1944 0036 1A70     		strb	r2, [r3, #0]
  67:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 1945              		.loc 12 67 0
 1946 0038 10BD     		pop	{r4, pc}
 1947              	.L120:
 1948 003a 00BF     		.align	2
 1949              	.L119:
 1950 003c 00000000 		.word	.LANCHOR32
 1951 0040 00000000 		.word	.LANCHOR22
 1952 0044 00000000 		.word	.LANCHOR30
 1953 0048 00000000 		.word	.LANCHOR33
 1954              		.cfi_endproc
 1955              	.LFE150:
 1957              		.section	.text._Z16evaluateGyroRatev,"ax",%progbits
 1958              		.align	1
 1959              		.global	_Z16evaluateGyroRatev
 1960              		.thumb
 1961              		.thumb_func
 1963              	_Z16evaluateGyroRatev:
 1964              	.LFB151:
  68:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  69:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void evaluateGyroRate() {
 1965              		.loc 12 69 0
 1966              		.cfi_startproc
 1967              		@ args = 0, pretend = 0, frame = 16
 1968              		@ frame_needed = 0, uses_anonymous_args = 0
 1969 0000 7FB5     		push	{r0, r1, r2, r3, r4, r5, r6, lr}
 1970              	.LCFI22:
 1971              		.cfi_def_cfa_offset 32
 1972              		.cfi_offset 14, -4
 1973              		.cfi_offset 6, -8
 1974              		.cfi_offset 5, -12
 1975              		.cfi_offset 4, -16
 1976              		.cfi_offset 3, -20
 1977              		.cfi_offset 2, -24
 1978              		.cfi_offset 1, -28
 1979              		.cfi_offset 0, -32
 1980              	.LBB50:
  70:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   int gyroADC[3];
  71:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroSample[XAXIS] / gyroSampleCount) - gyroZero[XAXIS];
 1981              		.loc 12 71 0
 1982 0002 1F4B     		ldr	r3, .L122
 1983 0004 1F4D     		ldr	r5, .L122+4
 1984 0006 1A68     		ldr	r2, [r3, #0]
 1985 0008 95F800C0 		ldrb	ip, [r5, #0]	@ zero_extendqisi2
  72:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroSample[YAXIS] / gyroSampleCount);
 1986              		.loc 12 72 0
 1987 000c 5968     		ldr	r1, [r3, #4]
  71:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroSample[XAXIS] / gyroSampleCount) - gyroZero[XAXIS];
 1988              		.loc 12 71 0
 1989 000e 92FBFCF4 		sdiv	r4, r2, ip
 1990 0012 1D4A     		ldr	r2, .L122+8
 1991              		.loc 12 72 0
 1992 0014 92E84100 		ldmia	r2, {r0, r6}
  71:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroSample[XAXIS] / gyroSampleCount) - gyroZero[XAXIS];
 1993              		.loc 12 71 0
 1994 0018 241A     		subs	r4, r4, r0
 1995              		.loc 12 72 0
 1996 001a 91FBFCF0 		sdiv	r0, r1, ip
 1997 001e 301A     		subs	r0, r6, r0
  73:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[ZAXIS] = gyroZero[ZAXIS] - (gyroSample[ZAXIS] / gyroSampleCount);
 1998              		.loc 12 73 0
 1999 0020 9E68     		ldr	r6, [r3, #8]
 2000 0022 9168     		ldr	r1, [r2, #8]
  71:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroSample[XAXIS] / gyroSampleCount) - gyroZero[XAXIS];
 2001              		.loc 12 71 0
 2002 0024 0194     		str	r4, [sp, #4]
 2003              		.loc 12 73 0
 2004 0026 96FBFCFC 		sdiv	ip, r6, ip
  74:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  75:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[XAXIS] = 0;
 2005              		.loc 12 75 0
 2006 002a 0022     		movs	r2, #0
  73:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[ZAXIS] = gyroZero[ZAXIS] - (gyroSample[ZAXIS] / gyroSampleCount);
 2007              		.loc 12 73 0
 2008 002c CCEB0101 		rsb	r1, ip, r1
 2009              		.loc 12 75 0
 2010 0030 1A60     		str	r2, [r3, #0]
  76:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[YAXIS] = 0;
 2011              		.loc 12 76 0
 2012 0032 5A60     		str	r2, [r3, #4]
  77:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[ZAXIS] = 0;
 2013              		.loc 12 77 0
 2014 0034 9A60     		str	r2, [r3, #8]
  78:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSampleCount = 0;
 2015              		.loc 12 78 0
 2016 0036 2A70     		strb	r2, [r5, #0]
 2017              	.LVL112:
 2018              	.LBB51:
  79:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  80:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   for (byte axis = 0; axis <= ZAXIS; axis++) {
  81:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     gyroRate[axis] = gyroADC[axis] * gyroScaleFactor;
 2019              		.loc 12 81 0
 2020 0038 01EE904A 		fmsr	s3, r4	@ int
 2021 003c 134A     		ldr	r2, .L122+12
 2022 003e 144B     		ldr	r3, .L122+16
 2023              	.LBE51:
  72:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroSample[YAXIS] / gyroSampleCount);
 2024              		.loc 12 72 0
 2025 0040 0290     		str	r0, [sp, #8]
 2026              	.LBB52:
 2027              		.loc 12 81 0
 2028 0042 00EE900A 		fmsr	s1, r0	@ int
 2029 0046 06EE901A 		fmsr	s13, r1	@ int
 2030 004a D2ED007A 		flds	s15, [r2, #0]
 2031 004e B8EEE11A 		fsitos	s2, s3
 2032 0052 B8EEE00A 		fsitos	s0, s1
 2033 0056 B8EEE67A 		fsitos	s14, s13
 2034 005a 21EE271A 		fmuls	s2, s2, s15
 2035 005e 20EE270A 		fmuls	s0, s0, s15
 2036 0062 67EE277A 		fmuls	s15, s14, s15
 2037              	.LBE52:
  73:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[ZAXIS] = gyroZero[ZAXIS] - (gyroSample[ZAXIS] / gyroSampleCount);
 2038              		.loc 12 73 0
 2039 0066 0391     		str	r1, [sp, #12]
 2040              	.LBB53:
 2041              		.loc 12 81 0
 2042 0068 83ED001A 		fsts	s2, [r3, #0]
 2043              	.LVL113:
 2044 006c 83ED010A 		fsts	s0, [r3, #4]
 2045              	.LVL114:
 2046 0070 C3ED027A 		fsts	s15, [r3, #8]
 2047              	.LVL115:
 2048              	.LBE53:
 2049              	.LBE50:
  82:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   }
  83:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  84:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroUpdateHeading();
  85:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 2050              		.loc 12 85 0
 2051 0074 04B0     		add	sp, sp, #16
 2052 0076 BDE87040 		pop	{r4, r5, r6, lr}
 2053              	.LBB54:
  84:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroUpdateHeading();
 2054              		.loc 12 84 0
 2055 007a FFF7FEBF 		b	_Z17gyroUpdateHeadingv
 2056              	.L123:
 2057 007e 00BF     		.align	2
 2058              	.L122:
 2059 0080 00000000 		.word	.LANCHOR32
 2060 0084 00000000 		.word	.LANCHOR33
 2061 0088 00000000 		.word	.LANCHOR31
 2062 008c 00000000 		.word	.LANCHOR26
 2063 0090 00000000 		.word	.LANCHOR27
 2064              	.LBE54:
 2065              		.cfi_endproc
 2066              	.LFE151:
 2068              		.section	.text._Z13calibrateGyrov,"ax",%progbits
 2069              		.align	1
 2070              		.global	_Z13calibrateGyrov
 2071              		.thumb
 2072              		.thumb_func
 2074              	_Z13calibrateGyrov:
 2075              	.LFB152:
  86:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  87:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  88:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void calibrateGyro() {
 2076              		.loc 12 88 0
 2077              		.cfi_startproc
 2078              		@ args = 0, pretend = 0, frame = 200
 2079              		@ frame_needed = 0, uses_anonymous_args = 0
 2080              	.LVL116:
 2081 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2082              	.LCFI23:
 2083              		.cfi_def_cfa_offset 20
 2084              		.cfi_offset 14, -4
 2085              		.cfi_offset 7, -8
 2086              		.cfi_offset 6, -12
 2087              		.cfi_offset 5, -16
 2088              		.cfi_offset 4, -20
  89:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   int findZero[FINDZERO];
  90:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  91:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   for (byte axis = 0; axis < 3; axis++) {
 2089              		.loc 12 91 0
 2090 0002 124D     		ldr	r5, .L132
  88:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void calibrateGyro() {
 2091              		.loc 12 88 0
 2092 0004 B3B0     		sub	sp, sp, #204
 2093              	.LCFI24:
 2094              		.cfi_def_cfa_offset 224
 2095              		.loc 12 91 0
 2096 0006 0024     		movs	r4, #0
 2097 0008 1CE0     		b	.L125
 2098              	.LVL117:
 2099              	.L129:
 2100              	.LBB55:
 2101              	.LBB56:
 2102              	.LBB57:
 2103              	.LBB58:
 2104              	.LBB59:
  92:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     for (int i=0; i<FINDZERO; i++) {
  93:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       readMPU6000Sensors();
 2105              		.loc 12 93 0
 2106 000a FFF7FEFF 		bl	_Z18readMPU6000Sensorsv
 2107 000e 104B     		ldr	r3, .L132+4
  94:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       short data;
  95:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       if(axis == XAXIS) {
 2108              		.loc 12 95 0
 2109 0010 0CB9     		cbnz	r4, .L126
  96:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     	  data = MPU6000.data.gyro.x;
 2110              		.loc 12 96 0
 2111 0012 1B89     		ldrh	r3, [r3, #8]
 2112              	.LVL118:
 2113 0014 03E0     		b	.L127
 2114              	.LVL119:
 2115              	.L126:
  97:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       } else if(axis == YAXIS) {
 2116              		.loc 12 97 0
 2117 0016 012C     		cmp	r4, #1
  98:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     	  data = MPU6000.data.gyro.y;
 2118              		.loc 12 98 0
 2119 0018 0CBF     		ite	eq
 2120 001a 5B89     		ldrheq	r3, [r3, #10]
 2121              	.LVL120:
  99:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       } else {
 100:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     	  data = MPU6000.data.gyro.z;
 2122              		.loc 12 100 0
 2123 001c 9B89     		ldrhne	r3, [r3, #12]
 2124              	.LVL121:
 2125              	.L127:
 101:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       }
 102:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       findZero[i] = data;
 2126              		.loc 12 102 0
 2127 001e 01AF     		add	r7, sp, #4
 2128 0020 1BB2     		sxth	r3, r3
 2129              	.LVL122:
 2130 0022 F351     		str	r3, [r6, r7]
 103:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       delay(10);
 2131              		.loc 12 103 0
 2132 0024 0A20     		movs	r0, #10
 2133 0026 0436     		adds	r6, r6, #4
 2134 0028 FFF7FEFF 		bl	_Z5delaym
 2135              	.LBE59:
  92:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     for (int i=0; i<FINDZERO; i++) {
 2136              		.loc 12 92 0
 2137 002c C42E     		cmp	r6, #196
 2138 002e ECD1     		bne	.L129
 2139              	.LBE58:
 104:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     }
 105:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     gyroZero[axis] = findMedianInt(findZero, FINDZERO);
 2140              		.loc 12 105 0
 2141 0030 3121     		movs	r1, #49
 2142 0032 3846     		mov	r0, r7
 2143 0034 FFF7FEFF 		bl	_Z13findMedianIntPii
 2144              	.LBE57:
  91:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   for (byte axis = 0; axis < 3; axis++) {
 2145              		.loc 12 91 0
 2146 0038 0134     		adds	r4, r4, #1
 2147 003a E4B2     		uxtb	r4, r4
 2148              	.LVL123:
 2149 003c 032C     		cmp	r4, #3
 2150              	.LBB60:
 2151              		.loc 12 105 0
 2152 003e 45F8040F 		str	r0, [r5, #4]!
 2153              	.LBE60:
  91:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   for (byte axis = 0; axis < 3; axis++) {
 2154              		.loc 12 91 0
 2155 0042 01D0     		beq	.L124
 2156              	.LVL124:
 2157              	.L125:
 2158              	.LBE56:
 2159              	.LBE55:
  88:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void calibrateGyro() {
 2160              		.loc 12 88 0 discriminator 1
 2161 0044 0026     		movs	r6, #0
 2162 0046 E0E7     		b	.L129
 2163              	.LVL125:
 2164              	.L124:
 106:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   }
 107:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 2165              		.loc 12 107 0
 2166 0048 33B0     		add	sp, sp, #204
 2167 004a F0BD     		pop	{r4, r5, r6, r7, pc}
 2168              	.L133:
 2169              		.align	2
 2170              	.L132:
 2171 004c FCFFFFFF 		.word	.LANCHOR31-4
 2172 0050 00000000 		.word	.LANCHOR22
 2173              		.cfi_endproc
 2174              	.LFE152:
 2176              		.section	.text._Z15initializeAccelv,"ax",%progbits
 2177              		.align	1
 2178              		.global	_Z15initializeAccelv
 2179              		.thumb
 2180              		.thumb_func
 2182              	_Z15initializeAccelv:
 2183              	.LFB153:
 2184              		.file 13 "../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h"
   1:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** /*
   2:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   AeroQuad v3.0 - May 2011
   3:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   Copyright (c) 2011 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
   7:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   This program is free software: you can redistribute it and/or modify
   8:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   it under the terms of the GNU General Public License as published by
   9:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   the Free Software Foundation, either version 3 of the License, or
  10:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   (at your option) any later version.
  11:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  12:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   This program is distributed in the hope that it will be useful,
  13:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   GNU General Public License for more details.
  16:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  17:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   You should have received a copy of the GNU General Public License
  18:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** */
  20:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  21:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** #ifndef _AEROQUAD_ACCELEROMETER_MPU6000_COMMON_H_
  22:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** #define _AEROQUAD_ACCELEROMETER_MPU6000_COMMON_H_
  23:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  24:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** #include <Platform_MPU6000.h>
  25:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** #include <Accelerometer.h>
  26:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  27:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void initializeAccel() {
 2185              		.loc 13 27 0
 2186              		.cfi_startproc
 2187              		@ args = 0, pretend = 0, frame = 0
 2188              		@ frame_needed = 0, uses_anonymous_args = 0
 2189              		@ link register save eliminated.
  28:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   initializeMPU6000Sensors();
  29:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** }
 2190              		.loc 13 29 0
  28:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   initializeMPU6000Sensors();
 2191              		.loc 13 28 0
 2192 0000 FFF7FEBF 		b	_Z24initializeMPU6000Sensorsv
 2193              		.cfi_endproc
 2194              	.LFE153:
 2196              		.section	.text._Z12measureAccelv,"ax",%progbits
 2197              		.align	1
 2198              		.global	_Z12measureAccelv
 2199              		.thumb
 2200              		.thumb_func
 2202              	_Z12measureAccelv:
 2203              	.LFB154:
  30:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  31:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  32:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void measureAccel() {
 2204              		.loc 13 32 0
 2205              		.cfi_startproc
 2206              		@ args = 0, pretend = 0, frame = 0
 2207              		@ frame_needed = 0, uses_anonymous_args = 0
 2208 0000 10B5     		push	{r4, lr}
 2209              	.LCFI25:
 2210              		.cfi_def_cfa_offset 8
 2211              		.cfi_offset 14, -4
 2212              		.cfi_offset 4, -8
  33:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   readMPU6000Accel();
 2213              		.loc 13 33 0
 2214 0002 FFF7FEFF 		bl	_Z16readMPU6000Accelv
  34:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  35:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[XAXIS] = MPU6000.data.accel.x * accelScaleFactor[XAXIS] + runTimeAccelBias[XAXIS];
 2215              		.loc 13 35 0
 2216 0006 1748     		ldr	r0, .L136
 2217 0008 1749     		ldr	r1, .L136+4
 2218 000a B0F90040 		ldrsh	r4, [r0, #0]
 2219 000e 174A     		ldr	r2, .L136+8
 2220 0010 174B     		ldr	r3, .L136+12
 2221 0012 04EE104A 		fmsr	s8, r4	@ int
  36:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[YAXIS] = MPU6000.data.accel.y * accelScaleFactor[YAXIS] + runTimeAccelBias[YAXIS];
 2222              		.loc 13 36 0
 2223 0016 B0F90240 		ldrsh	r4, [r0, #2]
  37:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[ZAXIS] = MPU6000.data.accel.z * accelScaleFactor[ZAXIS] + runTimeAccelBias[ZAXIS];
 2224              		.loc 13 37 0
 2225 001a B0F90400 		ldrsh	r0, [r0, #4]
  36:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[YAXIS] = MPU6000.data.accel.y * accelScaleFactor[YAXIS] + runTimeAccelBias[YAXIS];
 2226              		.loc 13 36 0
 2227 001e 02EE104A 		fmsr	s4, r4	@ int
 2228              		.loc 13 37 0
 2229 0022 00EE100A 		fmsr	s0, r0	@ int
  35:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[XAXIS] = MPU6000.data.accel.x * accelScaleFactor[XAXIS] + runTimeAccelBias[XAXIS];
 2230              		.loc 13 35 0
 2231 0026 B8EEC43A 		fsitos	s6, s8
 2232 002a D1ED003A 		flds	s7, [r1, #0]
 2233 002e D2ED002A 		flds	s5, [r2, #0]
  36:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[YAXIS] = MPU6000.data.accel.y * accelScaleFactor[YAXIS] + runTimeAccelBias[YAXIS];
 2234              		.loc 13 36 0
 2235 0032 B8EEC21A 		fsitos	s2, s4
 2236 0036 D1ED011A 		flds	s3, [r1, #4]
 2237 003a D2ED010A 		flds	s1, [r2, #4]
 2238              		.loc 13 37 0
 2239 003e F8EEC06A 		fsitos	s13, s0
 2240 0042 91ED027A 		flds	s14, [r1, #8]
 2241 0046 D2ED027A 		flds	s15, [r2, #8]
  35:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[XAXIS] = MPU6000.data.accel.x * accelScaleFactor[XAXIS] + runTimeAccelBias[XAXIS];
 2242              		.loc 13 35 0
 2243 004a 43EE232A 		fmacs	s5, s6, s7
  36:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[YAXIS] = MPU6000.data.accel.y * accelScaleFactor[YAXIS] + runTimeAccelBias[YAXIS];
 2244              		.loc 13 36 0
 2245 004e 41EE210A 		fmacs	s1, s2, s3
 2246              		.loc 13 37 0
 2247 0052 46EE877A 		fmacs	s15, s13, s14
  35:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[XAXIS] = MPU6000.data.accel.x * accelScaleFactor[XAXIS] + runTimeAccelBias[XAXIS];
 2248              		.loc 13 35 0
 2249 0056 C3ED002A 		fsts	s5, [r3, #0]
  36:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[YAXIS] = MPU6000.data.accel.y * accelScaleFactor[YAXIS] + runTimeAccelBias[YAXIS];
 2250              		.loc 13 36 0
 2251 005a C3ED010A 		fsts	s1, [r3, #4]
 2252              		.loc 13 37 0
 2253 005e C3ED027A 		fsts	s15, [r3, #8]
  38:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** }
 2254              		.loc 13 38 0
 2255 0062 10BD     		pop	{r4, pc}
 2256              	.L137:
 2257              		.align	2
 2258              	.L136:
 2259 0064 00000000 		.word	.LANCHOR22
 2260 0068 00000000 		.word	.LANCHOR35
 2261 006c 00000000 		.word	.LANCHOR36
 2262 0070 00000000 		.word	.LANCHOR34
 2263              		.cfi_endproc
 2264              	.LFE154:
 2266              		.section	.text._Z15measureAccelSumv,"ax",%progbits
 2267              		.align	1
 2268              		.global	_Z15measureAccelSumv
 2269              		.thumb
 2270              		.thumb_func
 2272              	_Z15measureAccelSumv:
 2273              	.LFB155:
  39:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  40:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void measureAccelSum() {
 2274              		.loc 13 40 0
 2275              		.cfi_startproc
 2276              		@ args = 0, pretend = 0, frame = 0
 2277              		@ frame_needed = 0, uses_anonymous_args = 0
 2278 0000 08B5     		push	{r3, lr}
 2279              	.LCFI26:
 2280              		.cfi_def_cfa_offset 8
 2281              		.cfi_offset 14, -4
 2282              		.cfi_offset 3, -8
  41:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   readMPU6000Accel();
 2283              		.loc 13 41 0
 2284 0002 FFF7FEFF 		bl	_Z16readMPU6000Accelv
  42:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSample[XAXIS] += MPU6000.data.accel.x;
 2285              		.loc 13 42 0
 2286 0006 0C4B     		ldr	r3, .L139
 2287 0008 0C4A     		ldr	r2, .L139+4
 2288 000a 1868     		ldr	r0, [r3, #0]
 2289 000c B2F900C0 		ldrsh	ip, [r2, #0]
 2290 0010 00EB0C01 		add	r1, r0, ip
 2291 0014 1960     		str	r1, [r3, #0]
  43:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSample[YAXIS] += MPU6000.data.accel.y;
 2292              		.loc 13 43 0
 2293 0016 5868     		ldr	r0, [r3, #4]
 2294 0018 B2F90210 		ldrsh	r1, [r2, #2]
  44:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSample[ZAXIS] += MPU6000.data.accel.z;
 2295              		.loc 13 44 0
 2296 001c B2F904C0 		ldrsh	ip, [r2, #4]
 2297 0020 9A68     		ldr	r2, [r3, #8]
  43:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSample[YAXIS] += MPU6000.data.accel.y;
 2298              		.loc 13 43 0
 2299 0022 4018     		adds	r0, r0, r1
 2300              		.loc 13 44 0
 2301 0024 02EB0C01 		add	r1, r2, ip
  43:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSample[YAXIS] += MPU6000.data.accel.y;
 2302              		.loc 13 43 0
 2303 0028 5860     		str	r0, [r3, #4]
 2304              		.loc 13 44 0
 2305 002a 9960     		str	r1, [r3, #8]
  45:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  46:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSampleCount++;
 2306              		.loc 13 46 0
 2307 002c 044B     		ldr	r3, .L139+8
 2308 002e 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 2309 0030 421C     		adds	r2, r0, #1
 2310 0032 1A70     		strb	r2, [r3, #0]
  47:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** }
 2311              		.loc 13 47 0
 2312 0034 08BD     		pop	{r3, pc}
 2313              	.L140:
 2314 0036 00BF     		.align	2
 2315              	.L139:
 2316 0038 00000000 		.word	.LANCHOR37
 2317 003c 00000000 		.word	.LANCHOR22
 2318 0040 00000000 		.word	.LANCHOR38
 2319              		.cfi_endproc
 2320              	.LFE155:
 2322              		.section	.text._Z20evaluateMetersPerSecv,"ax",%progbits
 2323              		.align	1
 2324              		.global	_Z20evaluateMetersPerSecv
 2325              		.thumb
 2326              		.thumb_func
 2328              	_Z20evaluateMetersPerSecv:
 2329              	.LFB156:
  48:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  49:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void evaluateMetersPerSec() {
 2330              		.loc 13 49 0
 2331              		.cfi_startproc
 2332              		@ args = 0, pretend = 0, frame = 0
 2333              		@ frame_needed = 0, uses_anonymous_args = 0
 2334              	.LVL126:
 2335 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2336              	.LCFI27:
 2337              		.cfi_def_cfa_offset 20
 2338              		.cfi_offset 14, -4
 2339              		.cfi_offset 7, -8
 2340              		.cfi_offset 6, -12
 2341              		.cfi_offset 5, -16
 2342              		.cfi_offset 4, -20
 2343              	.LBB61:
 2344              	.LBB62:
  50:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
  51:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (accelSample[axis] / accelSampleCount) * accelScaleFactor[axis] + runTim
 2345              		.loc 13 51 0
 2346 0002 114A     		ldr	r2, .L144
 2347 0004 114C     		ldr	r4, .L144+4
 2348 0006 1778     		ldrb	r7, [r2, #0]	@ zero_extendqisi2
 2349 0008 1148     		ldr	r0, .L144+8
 2350 000a 1249     		ldr	r1, .L144+12
 2351 000c 0023     		movs	r3, #0
 2352 000e 1646     		mov	r6, r2
 2353              	.LVL127:
 2354              	.L142:
 2355              		.loc 13 51 0 is_stmt 0 discriminator 2
 2356 0010 114D     		ldr	r5, .L144+16
 2357 0012 5A59     		ldr	r2, [r3, r5]
 2358 0014 92FBF7F2 		sdiv	r2, r2, r7
 2359 0018 00EE102A 		fmsr	s0, r2	@ int
 2360 001c 0434     		adds	r4, r4, #4
 2361 001e 0430     		adds	r0, r0, #4
 2362 0020 F8EEC06A 		fsitos	s13, s0
 2363 0024 94ED007A 		flds	s14, [r4, #0]
 2364 0028 D0ED007A 		flds	s15, [r0, #0]
 2365 002c 46EE877A 		fmacs	s15, s13, s14
  52:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   	accelSample[axis] = 0;
 2366              		.loc 13 52 0 is_stmt 1 discriminator 2
 2367 0030 0022     		movs	r2, #0
  51:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (accelSample[axis] / accelSampleCount) * accelScaleFactor[axis] + runTim
 2368              		.loc 13 51 0 discriminator 2
 2369 0032 17EE90CA 		fmrs	ip, s15
 2370              		.loc 13 52 0 discriminator 2
 2371 0036 5A51     		str	r2, [r3, r5]
 2372 0038 0433     		adds	r3, r3, #4
  50:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 2373              		.loc 13 50 0 discriminator 2
 2374 003a 0C2B     		cmp	r3, #12
  51:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (accelSample[axis] / accelSampleCount) * accelScaleFactor[axis] + runTim
 2375              		.loc 13 51 0 discriminator 2
 2376 003c 41F804CF 		str	ip, [r1, #4]!	@ float
  50:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 2377              		.loc 13 50 0 discriminator 2
 2378 0040 E6D1     		bne	.L142
 2379              	.LBE62:
  53:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   }
  54:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSampleCount = 0;
 2380              		.loc 13 54 0
 2381 0042 3270     		strb	r2, [r6, #0]
 2382              	.LBE61:
  55:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** }
 2383              		.loc 13 55 0
 2384 0044 F0BD     		pop	{r4, r5, r6, r7, pc}
 2385              	.L145:
 2386 0046 00BF     		.align	2
 2387              	.L144:
 2388 0048 00000000 		.word	.LANCHOR38
 2389 004c FCFFFFFF 		.word	.LANCHOR35-4
 2390 0050 FCFFFFFF 		.word	.LANCHOR36-4
 2391 0054 FCFFFFFF 		.word	.LANCHOR34-4
 2392 0058 00000000 		.word	.LANCHOR37
 2393              		.cfi_endproc
 2394              	.LFE156:
 2396              		.section	.text._Z16computeAccelBiasv,"ax",%progbits
 2397              		.align	1
 2398              		.global	_Z16computeAccelBiasv
 2399              		.thumb
 2400              		.thumb_func
 2402              	_Z16computeAccelBiasv:
 2403              	.LFB157:
  56:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  57:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void computeAccelBias() {
 2404              		.loc 13 57 0
 2405              		.cfi_startproc
 2406              		@ args = 0, pretend = 0, frame = 0
 2407              		@ frame_needed = 0, uses_anonymous_args = 0
 2408              	.LVL128:
 2409 0000 10B5     		push	{r4, lr}
 2410              	.LCFI28:
 2411              		.cfi_def_cfa_offset 8
 2412              		.cfi_offset 14, -4
 2413              		.cfi_offset 4, -8
 2414              	.LBB63:
 2415              	.LBB64:
  58:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (int samples = 0; samples < SAMPLECOUNT; samples++) {
 2416              		.loc 13 58 0
 2417 0002 0024     		movs	r4, #0
 2418 0004 08E0     		b	.L147
 2419              	.LVL129:
 2420              	.L148:
  59:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 	readMPU6000Sensors();
 2421              		.loc 13 59 0 discriminator 2
 2422 0006 FFF7FEFF 		bl	_Z18readMPU6000Sensorsv
  60:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     measureAccelSum();
 2423              		.loc 13 60 0 discriminator 2
 2424 000a FFF7FEFF 		bl	_Z15measureAccelSumv
  61:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     delayMicroseconds(2500);
 2425              		.loc 13 61 0 discriminator 2
 2426 000e 40F6C410 		movw	r0, #2500
 2427 0012 FFF7FEFF 		bl	_Z17delayMicrosecondsj
  58:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (int samples = 0; samples < SAMPLECOUNT; samples++) {
 2428              		.loc 13 58 0 discriminator 2
 2429 0016 0134     		adds	r4, r4, #1
 2430              	.LVL130:
 2431              	.L147:
  58:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (int samples = 0; samples < SAMPLECOUNT; samples++) {
 2432              		.loc 13 58 0 is_stmt 0 discriminator 1
 2433 0018 B4F5C87F 		cmp	r4, #400
 2434 001c F3D1     		bne	.L148
  58:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (int samples = 0; samples < SAMPLECOUNT; samples++) {
 2435              		.loc 13 58 0
 2436 001e 2048     		ldr	r0, .L152
 2437 0020 2049     		ldr	r1, .L152+4
 2438 0022 0023     		movs	r3, #0
 2439              	.LVL131:
 2440              	.L149:
 2441              	.LBE64:
 2442              	.LBB65:
  62:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   }
  63:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  64:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = 0; axis < 3; axis++) {
  65:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (float(accelSample[axis])/SAMPLECOUNT) * accelScaleFactor[axis];
 2443              		.loc 13 65 0 is_stmt 1 discriminator 2
 2444 0024 204C     		ldr	r4, .L152+8
 2445 0026 1A59     		ldr	r2, [r3, r4]
 2446 0028 00EE902A 		fmsr	s1, r2	@ int
 2447 002c 9FED1F0A 		flds	s0, .L152+12
 2448 0030 B8EEE07A 		fsitos	s14, s1
 2449 0034 0430     		adds	r0, r0, #4
 2450 0036 87EE007A 		fdivs	s14, s14, s0
 2451 003a D0ED007A 		flds	s15, [r0, #0]
 2452 003e 67EE277A 		fmuls	s15, s14, s15
 2453 0042 17EE902A 		fmrs	r2, s15
 2454 0046 41F8042F 		str	r2, [r1, #4]!	@ float
  66:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     accelSample[axis] = 0;
 2455              		.loc 13 66 0 discriminator 2
 2456 004a 0022     		movs	r2, #0
 2457 004c 1A51     		str	r2, [r3, r4]
 2458 004e 0433     		adds	r3, r3, #4
  64:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = 0; axis < 3; axis++) {
 2459              		.loc 13 64 0 discriminator 2
 2460 0050 0C2B     		cmp	r3, #12
 2461 0052 E7D1     		bne	.L149
 2462              	.LBE65:
  67:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   }
  68:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSampleCount = 0;
  69:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  70:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[XAXIS] = -meterPerSecSec[XAXIS];
 2463              		.loc 13 70 0
 2464 0054 1649     		ldr	r1, .L152+16
  68:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSampleCount = 0;
 2465              		.loc 13 68 0
 2466 0056 174B     		ldr	r3, .L152+20
 2467              		.loc 13 70 0
 2468 0058 1748     		ldr	r0, .L152+24
  68:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSampleCount = 0;
 2469              		.loc 13 68 0
 2470 005a 1A70     		strb	r2, [r3, #0]
  71:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[YAXIS] = -meterPerSecSec[YAXIS];
  72:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[ZAXIS] = -9.8065 - meterPerSecSec[ZAXIS];
 2471              		.loc 13 72 0
 2472 005c 91ED022A 		flds	s4, [r1, #8]
 2473 0060 DFED162A 		flds	s5, .L152+28
 2474 0064 72EEC21A 		fsubs	s3, s5, s4
  70:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[XAXIS] = -meterPerSecSec[XAXIS];
 2475              		.loc 13 70 0
 2476 0068 D1ED004A 		flds	s9, [r1, #0]
  73:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  74:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelOneG = abs(meterPerSecSec[ZAXIS] + runTimeAccelBias[ZAXIS]);
 2477              		.loc 13 74 0
 2478 006c 32EE211A 		fadds	s2, s4, s3
  71:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[YAXIS] = -meterPerSecSec[YAXIS];
 2479              		.loc 13 71 0
 2480 0070 D1ED013A 		flds	s7, [r1, #4]
 2481              		.loc 13 74 0
 2482 0074 B5EEC01A 		fcmpezs	s2
 2483 0078 F1EE10FA 		fmstat
 2484 007c 104B     		ldr	r3, .L152+32
  70:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[XAXIS] = -meterPerSecSec[XAXIS];
 2485              		.loc 13 70 0
 2486 007e B1EE644A 		fnegs	s8, s9
  71:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[YAXIS] = -meterPerSecSec[YAXIS];
 2487              		.loc 13 71 0
 2488 0082 B1EE633A 		fnegs	s6, s7
 2489              		.loc 13 74 0
 2490 0086 D8BF     		it	le
 2491 0088 B1EE411A 		fnegsle	s2, s2
  70:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[XAXIS] = -meterPerSecSec[XAXIS];
 2492              		.loc 13 70 0
 2493 008c 80ED004A 		fsts	s8, [r0, #0]
  71:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[YAXIS] = -meterPerSecSec[YAXIS];
 2494              		.loc 13 71 0
 2495 0090 80ED013A 		fsts	s6, [r0, #4]
  72:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[ZAXIS] = -9.8065 - meterPerSecSec[ZAXIS];
 2496              		.loc 13 72 0
 2497 0094 C0ED021A 		fsts	s3, [r0, #8]
 2498              		.loc 13 74 0
 2499 0098 83ED001A 		fsts	s2, [r3, #0]
 2500              	.LBE63:
  75:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** }
 2501              		.loc 13 75 0
 2502 009c 10BD     		pop	{r4, pc}
 2503              	.L153:
 2504 009e 00BF     		.align	2
 2505              	.L152:
 2506 00a0 FCFFFFFF 		.word	.LANCHOR35-4
 2507 00a4 FCFFFFFF 		.word	.LANCHOR34-4
 2508 00a8 00000000 		.word	.LANCHOR37
 2509 00ac 0000C843 		.word	1137180672
 2510 00b0 00000000 		.word	.LANCHOR34
 2511 00b4 00000000 		.word	.LANCHOR38
 2512 00b8 00000000 		.word	.LANCHOR36
 2513 00bc 6DE71CC1 		.word	-1055070355
 2514 00c0 00000000 		.word	.LANCHOR39
 2515              		.cfi_endproc
 2516              	.LFE157:
 2518              		.section	.text._Z24HardCodedAxisCalibrationv,"ax",%progbits
 2519              		.align	1
 2520              		.global	_Z24HardCodedAxisCalibrationv
 2521              		.thumb
 2522              		.thumb_func
 2524              	_Z24HardCodedAxisCalibrationv:
 2525              	.LFB158:
 2526              		.file 14 "../AeroQuad32/AeroQuad_STM32.h"
   1:../AeroQuad32/AeroQuad_STM32.h **** #define __STM32__
   2:../AeroQuad32/AeroQuad_STM32.h **** #define DEBUG_INIT
   3:../AeroQuad32/AeroQuad_STM32.h **** tSerial &Serial = SERIAL_VAR;
   4:../AeroQuad32/AeroQuad_STM32.h **** 
   5:../AeroQuad32/AeroQuad_STM32.h **** #define ADC_NUMBER_OF_BITS	12
   6:../AeroQuad32/AeroQuad_STM32.h **** 
   7:../AeroQuad32/AeroQuad_STM32.h **** 
   8:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BOARD_aeroquad32
   9:../AeroQuad32/AeroQuad_STM32.h **** 	#define STM32_BOARD_TYPE "aeroquad32"
  10:../AeroQuad32/AeroQuad_STM32.h **** 	#define LED_Green  Port2Pin('E', 6)
  11:../AeroQuad32/AeroQuad_STM32.h **** 	#define LED_Red    Port2Pin('E', 5)
  12:../AeroQuad32/AeroQuad_STM32.h **** 	#define LED_Yellow LED_Red
  13:../AeroQuad32/AeroQuad_STM32.h ****         #define A1       Port2Pin('B',0)
  14:../AeroQuad32/AeroQuad_STM32.h ****         #define A2       Port2Pin('C',4)
  15:../AeroQuad32/AeroQuad_STM32.h ****         #define A3       Port2Pin('B',1)
  16:../AeroQuad32/AeroQuad_STM32.h ****         #define A4       Port2Pin('C',5)
  17:../AeroQuad32/AeroQuad_STM32.h ****         #define A5       Port2Pin('C',2)
  18:../AeroQuad32/AeroQuad_STM32.h ****         #define A6       Port2Pin('C',3)
  19:../AeroQuad32/AeroQuad_STM32.h **** 
  20:../AeroQuad32/AeroQuad_STM32.h **** #endif
  21:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BOARD_aeroquad32mini
  22:../AeroQuad32/AeroQuad_STM32.h **** 	#define STM32_BOARD_TYPE "aeroquad32 mini"
  23:../AeroQuad32/AeroQuad_STM32.h **** 	#define LED_Green  13 // PA3
  24:../AeroQuad32/AeroQuad_STM32.h **** 	#define LED_Red    13
  25:../AeroQuad32/AeroQuad_STM32.h **** 	#define LED_Yellow 13
  26:../AeroQuad32/AeroQuad_STM32.h **** #endif
  27:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BOARD_freeflight
  28:../AeroQuad32/AeroQuad_STM32.h **** 	#define STM32_BOARD_TYPE "Free Flight"
  29:../AeroQuad32/AeroQuad_STM32.h **** 	#define LED_Green  Port2Pin('B', 4)
  30:../AeroQuad32/AeroQuad_STM32.h **** 	#define LED_Red    Port2Pin('B', 3)
  31:../AeroQuad32/AeroQuad_STM32.h **** 	#define LED_Yellow LED_Red
  32:../AeroQuad32/AeroQuad_STM32.h **** 	#define ITG3200_ADDRESS_ALTERNATE
  33:../AeroQuad32/AeroQuad_STM32.h **** #endif
  34:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BOARD_discovery_f4
  35:../AeroQuad32/AeroQuad_STM32.h **** 	#define STM32_BOARD_TYPE "Discovery F4"
  36:../AeroQuad32/AeroQuad_STM32.h **** 	#define LED_Green  Port2Pin('D', 12)
  37:../AeroQuad32/AeroQuad_STM32.h **** 	#define LED_Red    Port2Pin('D', 14)
  38:../AeroQuad32/AeroQuad_STM32.h **** 	#define LED_Yellow Port2Pin('D', 13)
  39:../AeroQuad32/AeroQuad_STM32.h **** #endif
  40:../AeroQuad32/AeroQuad_STM32.h **** 
  41:../AeroQuad32/AeroQuad_STM32.h **** #include <Device_I2C.h>
  42:../AeroQuad32/AeroQuad_STM32.h **** 
  43:../AeroQuad32/AeroQuad_STM32.h **** // Gyroscope declaration
  44:../AeroQuad32/AeroQuad_STM32.h **** #ifdef SENSORBOARD_ALA42
  45:../AeroQuad32/AeroQuad_STM32.h **** 	#include <Gyroscope_ITG3200_ala42.h>
  46:../AeroQuad32/AeroQuad_STM32.h **** #else
  47:../AeroQuad32/AeroQuad_STM32.h **** 	//#include <Gyroscope_ITG3200.h>
  48:../AeroQuad32/AeroQuad_STM32.h **** 	#include <Gyroscope_MPU6000.h>
  49:../AeroQuad32/AeroQuad_STM32.h **** #endif
  50:../AeroQuad32/AeroQuad_STM32.h **** 
  51:../AeroQuad32/AeroQuad_STM32.h **** // Accelerometer declaration
  52:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BOARD_freeflight
  53:../AeroQuad32/AeroQuad_STM32.h ****   #include <Accelerometer_ADXL345_9DOF.h>
  54:../AeroQuad32/AeroQuad_STM32.h **** #else
  55:../AeroQuad32/AeroQuad_STM32.h ****   //#include <Accelerometer_BMA180.h>
  56:../AeroQuad32/AeroQuad_STM32.h ****   //#include <Accelerometer_BMA180_ala42.h>
  57:../AeroQuad32/AeroQuad_STM32.h ****   #include <Accelerometer_MPU6000.h>
  58:../AeroQuad32/AeroQuad_STM32.h **** #endif
  59:../AeroQuad32/AeroQuad_STM32.h **** 
  60:../AeroQuad32/AeroQuad_STM32.h **** // Receiver Declaration
  61:../AeroQuad32/AeroQuad_STM32.h **** #if defined (ReceiverPPM) || defined (ReceiverHWPPM)
  62:../AeroQuad32/AeroQuad_STM32.h ****   #undef ReceiverPPM
  63:../AeroQuad32/AeroQuad_STM32.h ****   #undef ReceiverHWPPM
  64:../AeroQuad32/AeroQuad_STM32.h ****   #define RECEIVER_STM32PPM
  65:../AeroQuad32/AeroQuad_STM32.h **** #else
  66:../AeroQuad32/AeroQuad_STM32.h ****   #define RECEIVER_STM32
  67:../AeroQuad32/AeroQuad_STM32.h **** #endif
  68:../AeroQuad32/AeroQuad_STM32.h **** 
  69:../AeroQuad32/AeroQuad_STM32.h **** // Motor declaration
  70:../AeroQuad32/AeroQuad_STM32.h **** #define MOTOR_STM32
  71:../AeroQuad32/AeroQuad_STM32.h **** 
  72:../AeroQuad32/AeroQuad_STM32.h **** // heading mag hold declaration
  73:../AeroQuad32/AeroQuad_STM32.h **** #ifdef HeadingMagHold
  74:../AeroQuad32/AeroQuad_STM32.h **** 	#ifdef SENSORBOARD_ALA42
  75:../AeroQuad32/AeroQuad_STM32.h **** 		#define HMC5843
  76:../AeroQuad32/AeroQuad_STM32.h **** 	#else
  77:../AeroQuad32/AeroQuad_STM32.h **** 		#define HMC5883L
  78:../AeroQuad32/AeroQuad_STM32.h **** 	#endif
  79:../AeroQuad32/AeroQuad_STM32.h **** #endif
  80:../AeroQuad32/AeroQuad_STM32.h **** 
  81:../AeroQuad32/AeroQuad_STM32.h **** // Altitude declaration
  82:../AeroQuad32/AeroQuad_STM32.h **** #ifdef AltitudeHoldBaro
  83:../AeroQuad32/AeroQuad_STM32.h **** 	#ifdef SENSORBOARD_ALA42
  84:../AeroQuad32/AeroQuad_STM32.h **** 	  #define BMP085
  85:../AeroQuad32/AeroQuad_STM32.h **** 	#else
  86:../AeroQuad32/AeroQuad_STM32.h ****   	#define MS5611
  87:../AeroQuad32/AeroQuad_STM32.h ****   #endif
  88:../AeroQuad32/AeroQuad_STM32.h **** #endif
  89:../AeroQuad32/AeroQuad_STM32.h **** 
  90:../AeroQuad32/AeroQuad_STM32.h **** #ifdef AltitudeHoldRangeFinder
  91:../AeroQuad32/AeroQuad_STM32.h **** 	#define XLMAXSONAR
  92:../AeroQuad32/AeroQuad_STM32.h **** #endif
  93:../AeroQuad32/AeroQuad_STM32.h **** 
  94:../AeroQuad32/AeroQuad_STM32.h **** // Battery Monitor declaration
  95:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BattMonitor
  96:../AeroQuad32/AeroQuad_STM32.h **** 	#define BuzzerPin Port2Pin('A', 0)
  97:../AeroQuad32/AeroQuad_STM32.h **** 
  98:../AeroQuad32/AeroQuad_STM32.h **** 	#define BATT_AREF			3.3		// V
  99:../AeroQuad32/AeroQuad_STM32.h **** 
 100:../AeroQuad32/AeroQuad_STM32.h **** 	#ifdef BOARD_freeflight
 101:../AeroQuad32/AeroQuad_STM32.h **** 		#define BATT_R_HIGH			10.0	// kOhm
 102:../AeroQuad32/AeroQuad_STM32.h **** 		#define BATT_R_LOW			1.0		// kOhm
 103:../AeroQuad32/AeroQuad_STM32.h **** 		#define BATT_ANALOG_INPUT	Port2Pin('A', 4)
 104:../AeroQuad32/AeroQuad_STM32.h **** 		#define BATT_DIODE_LOSS		0.76
 105:../AeroQuad32/AeroQuad_STM32.h **** 	#else
 106:../AeroQuad32/AeroQuad_STM32.h **** 		#define BATT_R_HIGH			10.0	// kOhm
 107:../AeroQuad32/AeroQuad_STM32.h **** 		#define BATT_R_LOW			1.5		// kOhm
 108:../AeroQuad32/AeroQuad_STM32.h **** 		#define BATT_ANALOG_INPUT	Port2Pin('C', 0)
 109:../AeroQuad32/AeroQuad_STM32.h **** 		#define BATT_DIODE_LOSS		0.0
 110:../AeroQuad32/AeroQuad_STM32.h **** 	#endif
 111:../AeroQuad32/AeroQuad_STM32.h ****         #define BattDefaultConfig DEFINE_BATTERY(0, BATT_ANALOG_INPUT, (BATT_AREF * (BATT_R_HIGH + 
 112:../AeroQuad32/AeroQuad_STM32.h **** #endif
 113:../AeroQuad32/AeroQuad_STM32.h **** 
 114:../AeroQuad32/AeroQuad_STM32.h **** #ifdef OSD
 115:../AeroQuad32/AeroQuad_STM32.h **** 	#define MAX7456_OSD
 116:../AeroQuad32/AeroQuad_STM32.h **** #endif
 117:../AeroQuad32/AeroQuad_STM32.h **** 
 118:../AeroQuad32/AeroQuad_STM32.h **** 
 119:../AeroQuad32/AeroQuad_STM32.h **** 
 120:../AeroQuad32/AeroQuad_STM32.h **** /**
 121:../AeroQuad32/AeroQuad_STM32.h ****  * Put AeroQuadSTM32 specific initialization need here
 122:../AeroQuad32/AeroQuad_STM32.h ****  */
 123:../AeroQuad32/AeroQuad_STM32.h **** 
 124:../AeroQuad32/AeroQuad_STM32.h **** void HardCodedAxisCalibration()
 125:../AeroQuad32/AeroQuad_STM32.h **** {
 2527              		.loc 14 125 0
 2528              		.cfi_startproc
 2529              		@ args = 0, pretend = 0, frame = 0
 2530              		@ frame_needed = 0, uses_anonymous_args = 0
 2531              		@ link register save eliminated.
 126:../AeroQuad32/AeroQuad_STM32.h ****   if(   (accelScaleFactor[XAXIS] == 1.0 && accelScaleFactor[YAXIS] == 1.0 && accelScaleFactor[ZAXIS
 2532              		.loc 14 126 0
 2533 0000 184B     		ldr	r3, .L158
 2534 0002 93ED007A 		flds	s14, [r3, #0]
 2535 0006 F7EE007A 		fconsts	s15, #112
 2536 000a B4EE677A 		fcmps	s14, s15
 2537 000e F1EE10FA 		fmstat
 2538 0012 0ED1     		bne	.L155
 2539              		.loc 14 126 0 is_stmt 0 discriminator 1
 2540 0014 93ED017A 		flds	s14, [r3, #4]
 2541 0018 B4EE677A 		fcmps	s14, s15
 2542 001c F1EE10FA 		fmstat
 2543 0020 1FD1     		bne	.L154
 2544              		.loc 14 126 0 discriminator 3
 2545 0022 93ED020A 		flds	s0, [r3, #8]
 2546 0026 B4EE670A 		fcmps	s0, s15
 2547 002a F1EE10FA 		fmstat
 2548 002e 13D0     		beq	.L157
 2549 0030 7047     		bx	lr
 2550              	.L155:
 2551              		.loc 14 126 0 discriminator 2
 2552 0032 B5EE407A 		fcmpzs	s14
 2553 0036 F1EE10FA 		fmstat
 2554 003a 12D1     		bne	.L154
 2555              		.loc 14 126 0 discriminator 4
 2556 003c D3ED017A 		flds	s15, [r3, #4]
 2557 0040 F5EE407A 		fcmpzs	s15
 2558 0044 F1EE10FA 		fmstat
 2559 0048 0BD1     		bne	.L154
 2560              		.loc 14 126 0 discriminator 5
 2561 004a D3ED020A 		flds	s1, [r3, #8]
 2562 004e F5EE400A 		fcmpzs	s1
 2563 0052 F1EE10FA 		fmstat
 2564 0056 04D1     		bne	.L154
 2565              	.L157:
 127:../AeroQuad32/AeroQuad_STM32.h ****      || (accelScaleFactor[XAXIS] == 0.0 && accelScaleFactor[YAXIS] == 0.0 && accelScaleFactor[ZAXIS
 128:../AeroQuad32/AeroQuad_STM32.h ****   ) {
 129:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BOARD_freeflight
 130:../AeroQuad32/AeroQuad_STM32.h ****     accelScaleFactor[XAXIS] = accelScaleFactor[YAXIS] = accelScaleFactor[ZAXIS] = -0.038;
 131:../AeroQuad32/AeroQuad_STM32.h **** #else
 132:../AeroQuad32/AeroQuad_STM32.h ****     #ifdef _AEROQUAD_PLATFORM_MPU6000_H_
 133:../AeroQuad32/AeroQuad_STM32.h ****       accelScaleFactor[XAXIS] = accelScaleFactor[YAXIS] = accelScaleFactor[ZAXIS] = 0.00119;
 134:../AeroQuad32/AeroQuad_STM32.h ****     #else
 135:../AeroQuad32/AeroQuad_STM32.h ****       accelScaleFactor[XAXIS] = accelScaleFactor[YAXIS] = accelScaleFactor[ZAXIS] = 0.0048;
 136:../AeroQuad32/AeroQuad_STM32.h ****     #endif
 137:../AeroQuad32/AeroQuad_STM32.h ****   	accelScaleFactor[YAXIS] *= -1;
 2566              		.loc 14 137 0 is_stmt 1
 2567 0058 034A     		ldr	r2, .L158+4
 133:../AeroQuad32/AeroQuad_STM32.h ****       accelScaleFactor[XAXIS] = accelScaleFactor[YAXIS] = accelScaleFactor[ZAXIS] = 0.00119;
 2568              		.loc 14 133 0
 2569 005a 0448     		ldr	r0, .L158+8
 2570              		.loc 14 137 0
 2571 005c 5A60     		str	r2, [r3, #4]	@ float
 133:../AeroQuad32/AeroQuad_STM32.h ****       accelScaleFactor[XAXIS] = accelScaleFactor[YAXIS] = accelScaleFactor[ZAXIS] = 0.00119;
 2572              		.loc 14 133 0
 2573 005e 1860     		str	r0, [r3, #0]	@ float
 138:../AeroQuad32/AeroQuad_STM32.h ****   	accelScaleFactor[ZAXIS] *= -1;
 2574              		.loc 14 138 0
 2575 0060 9A60     		str	r2, [r3, #8]	@ float
 2576              	.L154:
 2577 0062 7047     		bx	lr
 2578              	.L159:
 2579              		.align	2
 2580              	.L158:
 2581 0064 00000000 		.word	.LANCHOR35
 2582 0068 C6F99BBA 		.word	-1164183098
 2583 006c C6F99B3A 		.word	983300550
 2584              		.cfi_endproc
 2585              	.LFE158:
 2587              		.section	.text._Z12initPlatformv,"ax",%progbits
 2588              		.align	1
 2589              		.global	_Z12initPlatformv
 2590              		.thumb
 2591              		.thumb_func
 2593              	_Z12initPlatformv:
 2594              	.LFB159:
 139:../AeroQuad32/AeroQuad_STM32.h **** #endif
 140:../AeroQuad32/AeroQuad_STM32.h ****   }
 141:../AeroQuad32/AeroQuad_STM32.h **** }
 142:../AeroQuad32/AeroQuad_STM32.h **** 
 143:../AeroQuad32/AeroQuad_STM32.h **** 
 144:../AeroQuad32/AeroQuad_STM32.h **** 
 145:../AeroQuad32/AeroQuad_STM32.h **** void initPlatform() {
 2595              		.loc 14 145 0
 2596              		.cfi_startproc
 2597              		@ args = 0, pretend = 0, frame = 0
 2598              		@ frame_needed = 0, uses_anonymous_args = 0
 2599 0000 10B5     		push	{r4, lr}
 2600              	.LCFI29:
 2601              		.cfi_def_cfa_offset 8
 2602              		.cfi_offset 14, -4
 2603              		.cfi_offset 4, -8
 2604              	.LBB66:
 146:../AeroQuad32/AeroQuad_STM32.h **** 	pinMode(LED_Green, OUTPUT);
 2605              		.loc 14 146 0
 2606 0002 4620     		movs	r0, #70
 2607 0004 0021     		movs	r1, #0
 2608 0006 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 2609              	.LVL132:
 147:../AeroQuad32/AeroQuad_STM32.h **** 	for(byte ledloop=0; ledloop<10; ledloop++) {
 2610              		.loc 14 147 0
 2611 000a 0024     		movs	r4, #0
 2612              	.LVL133:
 2613              	.L161:
 2614              	.LBB67:
 148:../AeroQuad32/AeroQuad_STM32.h **** 		digitalWrite(LED_Green, ledloop & 1);
 2615              		.loc 14 148 0 discriminator 2
 2616 000c 4620     		movs	r0, #70
 2617 000e 04F00101 		and	r1, r4, #1
 147:../AeroQuad32/AeroQuad_STM32.h **** 	for(byte ledloop=0; ledloop<10; ledloop++) {
 2618              		.loc 14 147 0 discriminator 2
 2619 0012 0134     		adds	r4, r4, #1
 2620              		.loc 14 148 0 discriminator 2
 2621 0014 FFF7FEFF 		bl	_Z12digitalWritehh
 147:../AeroQuad32/AeroQuad_STM32.h **** 	for(byte ledloop=0; ledloop<10; ledloop++) {
 2622              		.loc 14 147 0 discriminator 2
 2623 0018 E4B2     		uxtb	r4, r4
 149:../AeroQuad32/AeroQuad_STM32.h **** 		delay(50);
 2624              		.loc 14 149 0 discriminator 2
 2625 001a 3220     		movs	r0, #50
 2626 001c FFF7FEFF 		bl	_Z5delaym
 2627              	.LVL134:
 147:../AeroQuad32/AeroQuad_STM32.h **** 	for(byte ledloop=0; ledloop<10; ledloop++) {
 2628              		.loc 14 147 0 discriminator 2
 2629 0020 0A2C     		cmp	r4, #10
 2630 0022 F3D1     		bne	.L161
 2631              	.LBE67:
 150:../AeroQuad32/AeroQuad_STM32.h **** 	}
 151:../AeroQuad32/AeroQuad_STM32.h **** 
 152:../AeroQuad32/AeroQuad_STM32.h **** 	pinMode(LED_Red, OUTPUT);
 2632              		.loc 14 152 0
 2633 0024 4520     		movs	r0, #69
 2634 0026 0021     		movs	r1, #0
 2635 0028 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 153:../AeroQuad32/AeroQuad_STM32.h **** 	digitalWrite(LED_Red, LOW);
 2636              		.loc 14 153 0
 2637 002c 4520     		movs	r0, #69
 2638 002e 0021     		movs	r1, #0
 2639 0030 FFF7FEFF 		bl	_Z12digitalWritehh
 154:../AeroQuad32/AeroQuad_STM32.h **** 	pinMode(LED_Yellow, OUTPUT);
 2640              		.loc 14 154 0
 2641 0034 4520     		movs	r0, #69
 2642 0036 0021     		movs	r1, #0
 2643 0038 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 155:../AeroQuad32/AeroQuad_STM32.h **** 	digitalWrite(LED_Yellow, LOW);
 2644              		.loc 14 155 0
 2645 003c 4520     		movs	r0, #69
 2646 003e 0021     		movs	r1, #0
 2647 0040 FFF7FEFF 		bl	_Z12digitalWritehh
 156:../AeroQuad32/AeroQuad_STM32.h **** 
 157:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BattMonitor
 158:../AeroQuad32/AeroQuad_STM32.h **** 	pinMode(BATT_ANALOG_INPUT, INPUT_ANALOG);
 2648              		.loc 14 158 0
 2649 0044 2020     		movs	r0, #32
 2650 0046 0321     		movs	r1, #3
 2651 0048 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 159:../AeroQuad32/AeroQuad_STM32.h **** 	pinMode(BuzzerPin, OUTPUT);
 2652              		.loc 14 159 0
 2653 004c 0020     		movs	r0, #0
 2654 004e 0146     		mov	r1, r0
 2655 0050 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 160:../AeroQuad32/AeroQuad_STM32.h **** 	digitalWrite(BuzzerPin, LOW);
 2656              		.loc 14 160 0
 2657 0054 0020     		movs	r0, #0
 2658 0056 0146     		mov	r1, r0
 2659 0058 FFF7FEFF 		bl	_Z12digitalWritehh
 161:../AeroQuad32/AeroQuad_STM32.h **** #endif
 162:../AeroQuad32/AeroQuad_STM32.h **** 
 163:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BOARD_aeroquad32
 164:../AeroQuad32/AeroQuad_STM32.h **** 	pinMode(A1, INPUT_ANALOG);
 2660              		.loc 14 164 0
 2661 005c 1020     		movs	r0, #16
 2662 005e 0321     		movs	r1, #3
 2663 0060 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 165:../AeroQuad32/AeroQuad_STM32.h **** 	pinMode(A2, INPUT_ANALOG);
 2664              		.loc 14 165 0
 2665 0064 2420     		movs	r0, #36
 2666 0066 0321     		movs	r1, #3
 2667 0068 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 166:../AeroQuad32/AeroQuad_STM32.h **** 	pinMode(A3, INPUT_ANALOG);
 2668              		.loc 14 166 0
 2669 006c 1120     		movs	r0, #17
 2670 006e 0321     		movs	r1, #3
 2671 0070 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 167:../AeroQuad32/AeroQuad_STM32.h **** 	pinMode(A4, INPUT_ANALOG);
 2672              		.loc 14 167 0
 2673 0074 2520     		movs	r0, #37
 2674 0076 0321     		movs	r1, #3
 2675 0078 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 168:../AeroQuad32/AeroQuad_STM32.h **** 	pinMode(A5, INPUT_ANALOG);
 2676              		.loc 14 168 0
 2677 007c 2220     		movs	r0, #34
 2678 007e 0321     		movs	r1, #3
 2679 0080 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 169:../AeroQuad32/AeroQuad_STM32.h **** 	pinMode(A6, INPUT_ANALOG);
 2680              		.loc 14 169 0
 2681 0084 2320     		movs	r0, #35
 2682 0086 0321     		movs	r1, #3
 2683 0088 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 170:../AeroQuad32/AeroQuad_STM32.h **** #endif
 171:../AeroQuad32/AeroQuad_STM32.h **** 
 172:../AeroQuad32/AeroQuad_STM32.h **** #ifdef DEBUG_INIT
 173:../AeroQuad32/AeroQuad_STM32.h ****   Serial.println("\r\nAeroQuad STM32, board type " STM32_BOARD_TYPE ", build date " __DATE__ " "__T
 2684              		.loc 14 173 0
 2685 008c 0848     		ldr	r0, .L163
 2686 008e 0949     		ldr	r1, .L163+4
 2687 0090 FFF7FEFF 		bl	_ZN5Print7printlnEPKc
 174:../AeroQuad32/AeroQuad_STM32.h **** #endif
 175:../AeroQuad32/AeroQuad_STM32.h **** 
 176:../AeroQuad32/AeroQuad_STM32.h **** 
 177:../AeroQuad32/AeroQuad_STM32.h **** // I2C setup
 178:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BOARD_aeroquad32
 179:../AeroQuad32/AeroQuad_STM32.h ****   Wire.begin(Port2Pin('B', 7), Port2Pin('B', 6)); // I2C1_SDA PB7, I2C1_SCL PB6
 2688              		.loc 14 179 0
 2689 0094 1721     		movs	r1, #23
 2690 0096 0848     		ldr	r0, .L163+8
 2691 0098 1622     		movs	r2, #22
 2692 009a FFF7FEFF 		bl	_ZN7TwoWire5beginEhh
 180:../AeroQuad32/AeroQuad_STM32.h **** #endif
 181:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BOARD_aeroquad32mini
 182:../AeroQuad32/AeroQuad_STM32.h ****   Wire.begin(16, 17); // I2C2_SDA PB11, I2C2_SCL PB10
 183:../AeroQuad32/AeroQuad_STM32.h **** #endif
 184:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BOARD_freeflight
 185:../AeroQuad32/AeroQuad_STM32.h ****   Wire.begin(Port2Pin('B', 11), Port2Pin('B', 10)); // I2C1_SDA PB11, I2C1_SCL PB10
 186:../AeroQuad32/AeroQuad_STM32.h **** #endif
 187:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BOARD_discovery_f4
 188:../AeroQuad32/AeroQuad_STM32.h ****   Wire.begin(Port2Pin('B', 9), Port2Pin('B', 6)); // I2C1_SDA PB9, I2C1_SCL PB6
 189:../AeroQuad32/AeroQuad_STM32.h **** #endif
 190:../AeroQuad32/AeroQuad_STM32.h **** 
 191:../AeroQuad32/AeroQuad_STM32.h **** 
 192:../AeroQuad32/AeroQuad_STM32.h ****   HardCodedAxisCalibration();
 2693              		.loc 14 192 0
 2694 009e FFF7FEFF 		bl	_Z24HardCodedAxisCalibrationv
 193:../AeroQuad32/AeroQuad_STM32.h **** 
 194:../AeroQuad32/AeroQuad_STM32.h **** #ifdef DEBUG_INIT
 195:../AeroQuad32/AeroQuad_STM32.h ****   Serial.println("STM32 init done\r\n");
 2695              		.loc 14 195 0
 2696 00a2 0348     		ldr	r0, .L163
 2697 00a4 0549     		ldr	r1, .L163+12
 2698              	.LBE66:
 196:../AeroQuad32/AeroQuad_STM32.h **** #endif
 197:../AeroQuad32/AeroQuad_STM32.h **** }
 2699              		.loc 14 197 0
 2700 00a6 BDE81040 		pop	{r4, lr}
 2701              	.LBB68:
 195:../AeroQuad32/AeroQuad_STM32.h ****   Serial.println("STM32 init done\r\n");
 2702              		.loc 14 195 0
 2703 00aa FFF7FEBF 		b	_ZN5Print7printlnEPKc
 2704              	.L164:
 2705 00ae 00BF     		.align	2
 2706              	.L163:
 2707 00b0 00000000 		.word	SerialUSB
 2708 00b4 39000000 		.word	.LC4
 2709 00b8 00000000 		.word	Wire
 2710 00bc 82000000 		.word	.LC5
 2711              	.LBE68:
 2712              		.cfi_endproc
 2713              	.LFE159:
 2715              		.section	.text._Z11SignalAlivei,"ax",%progbits
 2716              		.align	1
 2717              		.global	_Z11SignalAlivei
 2718              		.thumb
 2719              		.thumb_func
 2721              	_Z11SignalAlivei:
 2722              	.LFB160:
 198:../AeroQuad32/AeroQuad_STM32.h **** 
 199:../AeroQuad32/AeroQuad_STM32.h **** 
 200:../AeroQuad32/AeroQuad_STM32.h **** void SignalAlive(int frameCounter) {
 2723              		.loc 14 200 0
 2724              		.cfi_startproc
 2725              		@ args = 0, pretend = 0, frame = 0
 2726              		@ frame_needed = 0, uses_anonymous_args = 0
 2727              		@ link register save eliminated.
 2728              	.LVL135:
 201:../AeroQuad32/AeroQuad_STM32.h ****   digitalWrite(LED_Green, (frameCounter/50) & 1);
 2729              		.loc 14 201 0
 2730 0000 3222     		movs	r2, #50
 2731 0002 90FBF2F1 		sdiv	r1, r0, r2
 2732 0006 01F00101 		and	r1, r1, #1
 2733 000a 4620     		movs	r0, #70
 2734              	.LVL136:
 202:../AeroQuad32/AeroQuad_STM32.h **** }
 2735              		.loc 14 202 0
 201:../AeroQuad32/AeroQuad_STM32.h ****   digitalWrite(LED_Green, (frameCounter/50) & 1);
 2736              		.loc 14 201 0
 2737 000c FFF7FEBF 		b	_Z12digitalWritehh
 2738              		.cfi_endproc
 2739              	.LFE160:
 2741              		.section	.text._Z22measureCriticalSensorsv,"ax",%progbits
 2742              		.align	1
 2743              		.global	_Z22measureCriticalSensorsv
 2744              		.thumb
 2745              		.thumb_func
 2747              	_Z22measureCriticalSensorsv:
 2748              	.LFB161:
 203:../AeroQuad32/AeroQuad_STM32.h **** 
 204:../AeroQuad32/AeroQuad_STM32.h **** unsigned long previousMeasureCriticalSensorsTime = 0;
 205:../AeroQuad32/AeroQuad_STM32.h **** void measureCriticalSensors() {
 2749              		.loc 14 205 0
 2750              		.cfi_startproc
 2751              		@ args = 0, pretend = 0, frame = 0
 2752              		@ frame_needed = 0, uses_anonymous_args = 0
 2753 0000 38B5     		push	{r3, r4, r5, lr}
 2754              	.LCFI30:
 2755              		.cfi_def_cfa_offset 16
 2756              		.cfi_offset 14, -4
 2757              		.cfi_offset 5, -8
 2758              		.cfi_offset 4, -12
 2759              		.cfi_offset 3, -16
 206:../AeroQuad32/AeroQuad_STM32.h ****   // read sensors not faster than every 1 ms
 207:../AeroQuad32/AeroQuad_STM32.h ****   if (currentTime - previousMeasureCriticalSensorsTime >= 1000) {
 2760              		.loc 14 207 0
 2761 0002 094D     		ldr	r5, .L168
 2762 0004 094C     		ldr	r4, .L168+4
 2763 0006 2A68     		ldr	r2, [r5, #0]
 2764 0008 2068     		ldr	r0, [r4, #0]
 2765 000a 131A     		subs	r3, r2, r0
 2766 000c B3F57A7F 		cmp	r3, #1000
 2767 0010 09D3     		bcc	.L166
 208:../AeroQuad32/AeroQuad_STM32.h ****     measureGyroSum();
 2768              		.loc 14 208 0
 2769 0012 FFF7FEFF 		bl	_Z14measureGyroSumv
 209:../AeroQuad32/AeroQuad_STM32.h ****     measureAccelSum();
 2770              		.loc 14 209 0
 2771 0016 FFF7FEFF 		bl	_Z15measureAccelSumv
 210:../AeroQuad32/AeroQuad_STM32.h **** 
 211:../AeroQuad32/AeroQuad_STM32.h ****     SignalAlive(frameCounter);
 2772              		.loc 14 211 0
 2773 001a 054B     		ldr	r3, .L168+8
 2774 001c 1868     		ldr	r0, [r3, #0]
 2775 001e FFF7FEFF 		bl	_Z11SignalAlivei
 212:../AeroQuad32/AeroQuad_STM32.h **** 
 213:../AeroQuad32/AeroQuad_STM32.h ****     previousMeasureCriticalSensorsTime = currentTime;
 2776              		.loc 14 213 0
 2777 0022 2968     		ldr	r1, [r5, #0]
 2778 0024 2160     		str	r1, [r4, #0]
 2779              	.L166:
 2780 0026 38BD     		pop	{r3, r4, r5, pc}
 2781              	.L169:
 2782              		.align	2
 2783              	.L168:
 2784 0028 00000000 		.word	.LANCHOR15
 2785 002c 00000000 		.word	.LANCHOR40
 2786 0030 00000000 		.word	.LANCHOR41
 2787              		.cfi_endproc
 2788              	.LFE161:
 2790              		.section	.text._Z29initializeBaseKinematicsParamv,"ax",%progbits
 2791              		.align	1
 2792              		.global	_Z29initializeBaseKinematicsParamv
 2793              		.thumb
 2794              		.thumb_func
 2796              	_Z29initializeBaseKinematicsParamv:
 2797              	.LFB162:
 2798              		.file 15 "../Libraries/AQ_Kinematics/Kinematics.h"
   1:../Libraries/AQ_Kinematics/Kinematics.h **** /*
   2:../Libraries/AQ_Kinematics/Kinematics.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Kinematics/Kinematics.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Kinematics/Kinematics.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Kinematics/Kinematics.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Kinematics/Kinematics.h ****  
   7:../Libraries/AQ_Kinematics/Kinematics.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Kinematics/Kinematics.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Kinematics/Kinematics.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Kinematics/Kinematics.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Kinematics/Kinematics.h **** 
  12:../Libraries/AQ_Kinematics/Kinematics.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Kinematics/Kinematics.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Kinematics/Kinematics.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Kinematics/Kinematics.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Kinematics/Kinematics.h **** 
  17:../Libraries/AQ_Kinematics/Kinematics.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Kinematics/Kinematics.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Kinematics/Kinematics.h **** */
  20:../Libraries/AQ_Kinematics/Kinematics.h **** 
  21:../Libraries/AQ_Kinematics/Kinematics.h **** #ifndef _AQ_KINEMATICS_
  22:../Libraries/AQ_Kinematics/Kinematics.h **** #define _AQ_KINEMATICS_
  23:../Libraries/AQ_Kinematics/Kinematics.h **** 
  24:../Libraries/AQ_Kinematics/Kinematics.h **** #include "GlobalDefined.h"
  25:../Libraries/AQ_Kinematics/Kinematics.h **** 
  26:../Libraries/AQ_Kinematics/Kinematics.h **** #define CF 0
  27:../Libraries/AQ_Kinematics/Kinematics.h **** #define KF 1
  28:../Libraries/AQ_Kinematics/Kinematics.h **** #define DCM 2
  29:../Libraries/AQ_Kinematics/Kinematics.h **** #define ARG 3
  30:../Libraries/AQ_Kinematics/Kinematics.h **** #define MARG 4
  31:../Libraries/AQ_Kinematics/Kinematics.h **** 
  32:../Libraries/AQ_Kinematics/Kinematics.h **** // This class is responsible for calculating vehicle attitude
  33:../Libraries/AQ_Kinematics/Kinematics.h **** byte kinematicsType = 0;
  34:../Libraries/AQ_Kinematics/Kinematics.h **** float kinematicsAngle[3] = {0.0,0.0,0.0};
  35:../Libraries/AQ_Kinematics/Kinematics.h **** float gyroAngle[2] = {0.0,0.0};
  36:../Libraries/AQ_Kinematics/Kinematics.h **** float correctedRateVector[3] = {0.0,0.0,0.0};
  37:../Libraries/AQ_Kinematics/Kinematics.h **** float earthAccel[3] = {0.0,0.0,0.0};
  38:../Libraries/AQ_Kinematics/Kinematics.h **** 
  39:../Libraries/AQ_Kinematics/Kinematics.h **** float accelCutoff = 0.0;
  40:../Libraries/AQ_Kinematics/Kinematics.h **** 
  41:../Libraries/AQ_Kinematics/Kinematics.h **** void initializeBaseKinematicsParam() {
 2799              		.loc 15 41 0
 2800              		.cfi_startproc
 2801              		@ args = 0, pretend = 0, frame = 0
 2802              		@ frame_needed = 0, uses_anonymous_args = 0
 2803              		@ link register save eliminated.
 2804              	.LVL137:
 2805              	.LBB69:
 2806              	.LBB70:
  42:../Libraries/AQ_Kinematics/Kinematics.h **** 
  43:../Libraries/AQ_Kinematics/Kinematics.h ****   for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
  44:../Libraries/AQ_Kinematics/Kinematics.h ****     kinematicsAngle[axis] = 0.0;
 2807              		.loc 15 44 0
 2808 0000 0448     		ldr	r0, .L171
 2809              	.LBE70:
  45:../Libraries/AQ_Kinematics/Kinematics.h ****   }
  46:../Libraries/AQ_Kinematics/Kinematics.h ****   gyroAngle[XAXIS] = 0;
 2810              		.loc 15 46 0
 2811 0002 054A     		ldr	r2, .L171+4
 2812              	.LBB71:
  44:../Libraries/AQ_Kinematics/Kinematics.h ****     kinematicsAngle[axis] = 0.0;
 2813              		.loc 15 44 0
 2814 0004 0023     		movs	r3, #0
 2815 0006 0360     		str	r3, [r0, #0]	@ float
 2816              	.LVL138:
 2817 0008 4360     		str	r3, [r0, #4]	@ float
 2818              	.LVL139:
 2819 000a 8360     		str	r3, [r0, #8]	@ float
 2820              	.LVL140:
 2821              	.LBE71:
 2822              		.loc 15 46 0
 2823 000c 1360     		str	r3, [r2, #0]	@ float
  47:../Libraries/AQ_Kinematics/Kinematics.h ****   gyroAngle[YAXIS] = 0;
 2824              		.loc 15 47 0
 2825 000e 5360     		str	r3, [r2, #4]	@ float
 2826              	.LBE69:
  48:../Libraries/AQ_Kinematics/Kinematics.h **** }
 2827              		.loc 15 48 0
 2828 0010 7047     		bx	lr
 2829              	.L172:
 2830 0012 00BF     		.align	2
 2831              	.L171:
 2832 0014 00000000 		.word	.LANCHOR42
 2833 0018 00000000 		.word	.LANCHOR43
 2834              		.cfi_endproc
 2835              	.LFE162:
 2837              		.section	.text._Z27kinematicsGetDegreesHeadingh,"ax",%progbits
 2838              		.align	1
 2839              		.global	_Z27kinematicsGetDegreesHeadingh
 2840              		.thumb
 2841              		.thumb_func
 2843              	_Z27kinematicsGetDegreesHeadingh:
 2844              	.LFB163:
  49:../Libraries/AQ_Kinematics/Kinematics.h **** 
  50:../Libraries/AQ_Kinematics/Kinematics.h **** void initializeKinematics(float hdgX, float hdgY);
  51:../Libraries/AQ_Kinematics/Kinematics.h **** void calculateKinematics(float rollRate,           float pitchRate,     float yawRate,       
  52:../Libraries/AQ_Kinematics/Kinematics.h ****                          float longitudinalAccel,  float lateralAccel,  float verticalAccel, 
  53:../Libraries/AQ_Kinematics/Kinematics.h ****                          float G_Dt);
  54:../Libraries/AQ_Kinematics/Kinematics.h **** float getGyroUnbias(byte axis);
  55:../Libraries/AQ_Kinematics/Kinematics.h **** void calibrateKinematics();
  56:../Libraries/AQ_Kinematics/Kinematics.h ****  
  57:../Libraries/AQ_Kinematics/Kinematics.h ****   // returns the kinematicsAngle of a specific axis in SI units (radians)
  58:../Libraries/AQ_Kinematics/Kinematics.h **** //  const float getData(byte axis) {
  59:../Libraries/AQ_Kinematics/Kinematics.h **** //    return kinematicsAngle[axis];
  60:../Libraries/AQ_Kinematics/Kinematics.h **** //  }
  61:../Libraries/AQ_Kinematics/Kinematics.h ****   // return heading as +PI/-PI
  62:../Libraries/AQ_Kinematics/Kinematics.h **** //  const float getHeading(byte axis) {
  63:../Libraries/AQ_Kinematics/Kinematics.h **** //    return(kinematicsAngle[axis]);
  64:../Libraries/AQ_Kinematics/Kinematics.h **** //  }
  65:../Libraries/AQ_Kinematics/Kinematics.h ****   
  66:../Libraries/AQ_Kinematics/Kinematics.h ****   // This really needs to be in Radians to be consistent
  67:../Libraries/AQ_Kinematics/Kinematics.h ****   // I'll fix later - AKA
  68:../Libraries/AQ_Kinematics/Kinematics.h ****   // returns heading in degrees as 0-360
  69:../Libraries/AQ_Kinematics/Kinematics.h **** const float kinematicsGetDegreesHeading(byte axis) {
 2845              		.loc 15 69 0
 2846              		.cfi_startproc
 2847              		@ args = 0, pretend = 0, frame = 0
 2848              		@ frame_needed = 0, uses_anonymous_args = 0
 2849              		@ link register save eliminated.
 2850              	.LVL141:
 2851              	.LBB72:
  70:../Libraries/AQ_Kinematics/Kinematics.h ****   float tDegrees;
  71:../Libraries/AQ_Kinematics/Kinematics.h ****     
  72:../Libraries/AQ_Kinematics/Kinematics.h ****   tDegrees = degrees(kinematicsAngle[axis]);
 2852              		.loc 15 72 0
 2853 0000 0A49     		ldr	r1, .L177
 2854 0002 01EB8003 		add	r3, r1, r0, lsl #2
 2855 0006 93ED007A 		flds	s14, [r3, #0]
 2856 000a DFED097A 		flds	s15, .L177+4
 2857 000e 67EE277A 		fmuls	s15, s14, s15
 2858              	.LVL142:
  73:../Libraries/AQ_Kinematics/Kinematics.h ****   if (tDegrees < 0.0)
 2859              		.loc 15 73 0
 2860 0012 F5EEC07A 		fcmpezs	s15
 2861 0016 F1EE10FA 		fmstat
  74:../Libraries/AQ_Kinematics/Kinematics.h ****     return (tDegrees + 360.0);
 2862              		.loc 15 74 0
 2863 001a 44BF     		itt	mi
 2864 001c 9FED057A 		fldsmi	s14, .L177+8
 2865 0020 77EE877A 		faddsmi	s15, s15, s14
 2866              	.LVL143:
 2867              	.LBE72:
  75:../Libraries/AQ_Kinematics/Kinematics.h ****   else
  76:../Libraries/AQ_Kinematics/Kinematics.h ****     return (tDegrees);
  77:../Libraries/AQ_Kinematics/Kinematics.h **** }
 2868              		.loc 15 77 0
 2869 0024 17EE900A 		fmrs	r0, s15
 2870              	.LVL144:
 2871 0028 7047     		bx	lr
 2872              	.L178:
 2873 002a 00BF     		.align	2
 2874              	.L177:
 2875 002c 00000000 		.word	.LANCHOR42
 2876 0030 E12E6542 		.word	1113927393
 2877 0034 0000B443 		.word	1135869952
 2878              		.cfi_endproc
 2879              	.LFE163:
 2881              		.global	__aeabi_f2d
 2882              		.global	__aeabi_d2f
 2883              		.section	.text._Z9argUpdatefffffff,"ax",%progbits
 2884              		.align	1
 2885              		.global	_Z9argUpdatefffffff
 2886              		.thumb
 2887              		.thumb_func
 2889              	_Z9argUpdatefffffff:
 2890              	.LFB164:
 2891              		.file 16 "../Libraries/AQ_Kinematics/Kinematics_ARG.h"
   1:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** /*
   2:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****  
   7:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  12:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  17:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** */
  20:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  21:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** #ifndef _AQ_KINEMATICS_ARG_
  22:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** #define _AQ_KINEMATICS_ARG_
  23:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  24:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //=================================================================================================
  25:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // IMU.c
  26:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // S.O.H. Madgwick
  27:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // 25th September 2010
  28:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //=================================================================================================
  29:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // Description:
  30:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //
  31:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // Quaternion implementation of the 'DCM filter' [Mayhony et al].
  32:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //
  33:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // User must define 'halfT' as the (sample period / 2), and the filter gains 'Kp' and 'Ki'.
  34:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //
  35:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // Global variables 'q0', 'q1', 'q2', 'q3' are the quaternion elements representing the estimated
  36:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // orientation.  See my report for an overview of the use of quaternions in this application.
  37:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //
  38:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // User must call 'IMUupdate()' every sample period and parse calibrated gyroscope ('gx', 'gy', 'gz
  39:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // and accelerometer ('ax', 'ay', 'ay') data.  Gyroscope units are radians/second, accelerometer 
  40:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // units are irrelevant as the vector is normalised.
  41:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //
  42:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //=================================================================================================
  43:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  44:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  45:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
  46:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // ARG - Accelerometer, Rate Gyro
  47:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
  48:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  49:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  50:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** #include "Kinematics.h"
  51:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  52:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** #include <AQMath.h>
  53:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  54:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float Kp = 0.0;                   					// proportional gain governs rate of convergence to accelero
  55:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float Ki = 0.0;                   					// integral gain governs rate of convergence of gyroscope bi
  56:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float halfT = 0.0;                					// half the sample period
  57:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float q0 = 0.0, q1 = 0.0, q2 = 0.0, q3 = 0.0;       // quaternion elements representing the estimat
  58:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float exInt = 0.0, eyInt = 0.0, ezInt = 0.0;  		// scaled integral error
  59:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
  60:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float previousEx = 0.0;
  61:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float previousEy = 0.0;
  62:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float previousEz = 0.0;
  63:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  64:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
  65:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // argUpdate
  66:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
  67:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void argUpdate(float gx, float gy, float gz, float ax, float ay, float az, float G_Dt) {
 2892              		.loc 16 67 0
 2893              		.cfi_startproc
 2894              		@ args = 12, pretend = 0, frame = 0
 2895              		@ frame_needed = 0, uses_anonymous_args = 0
 2896              	.LVL145:
 2897 0000 2DE9F84F 		push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2898              	.LCFI31:
 2899              		.cfi_def_cfa_offset 40
 2900              		.cfi_offset 14, -4
 2901              		.cfi_offset 11, -8
 2902              		.cfi_offset 10, -12
 2903              		.cfi_offset 9, -16
 2904              		.cfi_offset 8, -20
 2905              		.cfi_offset 7, -24
 2906              		.cfi_offset 6, -28
 2907              		.cfi_offset 5, -32
 2908              		.cfi_offset 4, -36
 2909              		.cfi_offset 3, -40
 2910 0004 2DED068B 		fstmfdd	sp!, {d8, d9, d10}
 2911              	.LCFI32:
 2912              		.cfi_def_cfa_offset 64
 2913              		.cfi_offset 84, -48
 2914              		.cfi_offset 82, -56
 2915              		.cfi_offset 80, -64
 2916              		.loc 16 67 0
 2917 0008 DDED108A 		flds	s17, [sp, #64]
 2918 000c 08EE103A 		fmsr	s16, r3
 2919              	.LBB73:
  68:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
  69:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   float norm;
  70:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   float vx, vy, vz;
  71:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   float q0i, q1i, q2i, q3i;
  72:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   float ex, ey, ez;
  73:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
  74:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   halfT = G_Dt/2;
  75:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
  76:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // normalise the measurements
  77:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(ax*ax + ay*ay + az*az);       
 2920              		.loc 16 77 0
 2921 0010 68EEA82A 		fmuls	s5, s17, s17
 2922 0014 48EE082A 		fmacs	s5, s16, s16
 2923              	.LBE73:
  67:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void argUpdate(float gx, float gy, float gz, float ax, float ay, float az, float G_Dt) {
 2924              		.loc 16 67 0
 2925 0018 9DED119A 		flds	s18, [sp, #68]
 2926              	.LBB74:
  74:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   halfT = G_Dt/2;
 2927              		.loc 16 74 0
 2928 001c DDED127A 		flds	s15, [sp, #72]
 2929              		.loc 16 77 0
 2930 0020 49EE092A 		fmacs	s5, s18, s18
  74:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   halfT = G_Dt/2;
 2931              		.loc 16 74 0
 2932 0024 B6EE003A 		fconsts	s6, #96
 2933 0028 27EE833A 		fmuls	s6, s15, s6
 2934 002c DFF83092 		ldr	r9, .L183+20
  78:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ax = ax / norm;
  79:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ay = ay / norm;
  80:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   az = az / norm;
  81:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****      	
  82:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // estimated direction of gravity and flux (v and w)
  83:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vx = 2*(q1*q3 - q0*q2);
 2935              		.loc 16 83 0
 2936 0030 864C     		ldr	r4, .L183
 2937 0032 874F     		ldr	r7, .L183+4
 2938 0034 874D     		ldr	r5, .L183+8
 2939 0036 884E     		ldr	r6, .L183+12
  84:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vy = 2*(q0*q1 + q2*q3);
  85:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vz = q0*q0 - q1*q1 - q2*q2 + q3*q3;
  86:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
  87:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // error is sum of cross product between reference direction of fields and direction measured by 
  88:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ex = (vy*az - vz*ay);
  89:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ey = (vz*ax - vx*az);
  90:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ez = (vx*ay - vy*ax);
  91:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
  92:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // integral error scaled integral gain
  93:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   exInt = exInt + ex*Ki;
 2940              		.loc 16 93 0
 2941 0038 DFF828A2 		ldr	sl, .L183+24
 2942 003c DFF828B2 		ldr	fp, .L183+28
  94:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   if (isSwitched(previousEx,ex)) {
 2943              		.loc 16 94 0
 2944 0040 DFF82882 		ldr	r8, .L183+32
  74:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   halfT = G_Dt/2;
 2945              		.loc 16 74 0
 2946 0044 89ED003A 		fsts	s6, [r9, #0]
 2947              	.LBE74:
  67:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void argUpdate(float gx, float gy, float gz, float ax, float ay, float az, float G_Dt) {
 2948              		.loc 16 67 0
 2949 0048 09EE900A 		fmsr	s19, r0
 2950              	.LBB75:
  77:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(ax*ax + ay*ay + az*az);       
 2951              		.loc 16 77 0
 2952 004c 12EE900A 		fmrs	r0, s5
 2953              	.LVL146:
 2954              	.LBE75:
  67:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void argUpdate(float gx, float gy, float gz, float ax, float ay, float az, float G_Dt) {
 2955              		.loc 16 67 0
 2956 0050 0AEE902A 		fmsr	s21, r2
 2957 0054 0AEE101A 		fmsr	s20, r1
 2958              	.LBB76:
  77:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(ax*ax + ay*ay + az*az);       
 2959              		.loc 16 77 0
 2960 0058 FFF7FEFF 		bl	__aeabi_f2d
 2961              	.LVL147:
 2962 005c FFF7FEFF 		bl	sqrt
 2963 0060 FFF7FEFF 		bl	__aeabi_d2f
 2964 0064 02EE100A 		fmsr	s4, r0
 2965              	.LVL148:
  79:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ay = ay / norm;
 2966              		.loc 16 79 0
 2967 0068 88EE825A 		fdivs	s10, s17, s4
 2968              		.loc 16 94 0
 2969 006c D8F80000 		ldr	r0, [r8, #0]	@ float
 2970              	.LVL149:
  80:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   az = az / norm;
 2971              		.loc 16 80 0
 2972 0070 C9EE023A 		fdivs	s7, s18, s4
  83:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vx = 2*(q1*q3 - q0*q2);
 2973              		.loc 16 83 0
 2974 0074 D4ED000A 		flds	s1, [r4, #0]
 2975 0078 97ED006A 		flds	s12, [r7, #0]
 2976 007c D5ED006A 		flds	s13, [r5, #0]
 2977 0080 96ED000A 		flds	s0, [r6, #0]
 2978 0084 66EE261A 		fmuls	s3, s12, s13
  84:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vy = 2*(q0*q1 + q2*q3);
 2979              		.loc 16 84 0
 2980 0088 26EEA01A 		fmuls	s2, s13, s1
  83:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vx = 2*(q1*q3 - q0*q2);
 2981              		.loc 16 83 0
 2982 008c 50EE201A 		fmscs	s3, s0, s1
  84:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vy = 2*(q0*q1 + q2*q3);
 2983              		.loc 16 84 0
 2984 0090 06EE001A 		fmacs	s2, s12, s0
  85:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vz = q0*q0 - q1*q1 - q2*q2 + q3*q3;
 2985              		.loc 16 85 0
 2986 0094 20EE000A 		fmuls	s0, s0, s0
 2987 0098 16EE060A 		fmscs	s0, s12, s12
  78:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ax = ax / norm;
 2988              		.loc 16 78 0
 2989 009c 88EE024A 		fdivs	s8, s16, s4
 2990              	.LVL150:
  85:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vz = q0*q0 - q1*q1 - q2*q2 + q3*q3;
 2991              		.loc 16 85 0
 2992 00a0 06EEE60A 		fnmacs	s0, s13, s13
 2993 00a4 00EEA00A 		fmacs	s0, s1, s1
  84:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vy = 2*(q0*q1 + q2*q3);
 2994              		.loc 16 84 0
 2995 00a8 71EE015A 		fadds	s11, s2, s2
  88:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ex = (vy*az - vz*ay);
 2996              		.loc 16 88 0
 2997 00ac 20EE058A 		fmuls	s16, s0, s10
 2998 00b0 15EEA38A 		fmscs	s16, s11, s7
  93:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   exInt = exInt + ex*Ki;
 2999              		.loc 16 93 0
 3000 00b4 DAED007A 		flds	s15, [sl, #0]
 3001 00b8 9BED007A 		flds	s14, [fp, #0]
 3002 00bc 48EE077A 		fmacs	s15, s16, s14
  83:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vx = 2*(q1*q3 - q0*q2);
 3003              		.loc 16 83 0
 3004 00c0 71EEA14A 		fadds	s9, s3, s3
 3005              	.LVL151:
  90:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ez = (vx*ay - vy*ax);
 3006              		.loc 16 90 0
 3007 00c4 25EE849A 		fmuls	s18, s11, s8
  89:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ey = (vz*ax - vx*az);
 3008              		.loc 16 89 0
 3009 00c8 64EEA38A 		fmuls	s17, s9, s7
 3010              		.loc 16 94 0
 3011 00cc 18EE101A 		fmrs	r1, s16
  89:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ey = (vz*ax - vx*az);
 3012              		.loc 16 89 0
 3013 00d0 50EE048A 		fmscs	s17, s0, s8
 3014              	.LVL152:
  90:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ez = (vx*ay - vy*ax);
 3015              		.loc 16 90 0
 3016 00d4 14EE859A 		fmscs	s18, s9, s10
 3017              	.LVL153:
  93:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   exInt = exInt + ex*Ki;
 3018              		.loc 16 93 0
 3019 00d8 CAED007A 		fsts	s15, [sl, #0]
 3020              		.loc 16 94 0
 3021 00dc FFF7FEFF 		bl	_Z10isSwitchedff
 3022              	.LVL154:
 3023 00e0 4346     		mov	r3, r8
 3024 00e2 10B1     		cbz	r0, .L180
  95:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     exInt = 0.0;
 3025              		.loc 16 95 0
 3026 00e4 0022     		movs	r2, #0
 3027 00e6 CAF80020 		str	r2, [sl, #0]	@ float
 3028              	.L180:
  96:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   }
  97:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEx = ex;
  98:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 	
  99:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eyInt = eyInt + ey*Ki;
 3029              		.loc 16 99 0
 3030 00ea DFF88491 		ldr	r9, .L183+36
 100:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   if (isSwitched(previousEy,ey)) {
 3031              		.loc 16 100 0
 3032 00ee DFF88481 		ldr	r8, .L183+40
  99:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eyInt = eyInt + ey*Ki;
 3033              		.loc 16 99 0
 3034 00f2 D9ED004A 		flds	s9, [r9, #0]
 3035 00f6 9BED007A 		flds	s14, [fp, #0]
 3036 00fa 48EE874A 		fmacs	s9, s17, s14
  97:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEx = ex;
 3037              		.loc 16 97 0
 3038 00fe 83ED008A 		fsts	s16, [r3, #0]
  99:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eyInt = eyInt + ey*Ki;
 3039              		.loc 16 99 0
 3040 0102 C9ED004A 		fsts	s9, [r9, #0]
 3041              		.loc 16 100 0
 3042 0106 D8F80000 		ldr	r0, [r8, #0]	@ float
 3043 010a 18EE901A 		fmrs	r1, s17
 3044 010e FFF7FEFF 		bl	_Z10isSwitchedff
 3045 0112 4346     		mov	r3, r8
 3046 0114 10B1     		cbz	r0, .L181
 101:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     eyInt = 0.0;
 3047              		.loc 16 101 0
 3048 0116 0020     		movs	r0, #0
 3049 0118 C9F80000 		str	r0, [r9, #0]	@ float
 3050              	.L181:
 102:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   }
 103:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEy = ey;
 104:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
 105:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ezInt = ezInt + ez*Ki;
 3051              		.loc 16 105 0
 3052 011c DFF85881 		ldr	r8, .L183+44
 3053 0120 9BED004A 		flds	s8, [fp, #0]
 3054 0124 98ED005A 		flds	s10, [r8, #0]
 3055 0128 09EE045A 		fmacs	s10, s18, s8
 106:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   if (isSwitched(previousEz,ez)) {
 3056              		.loc 16 106 0
 3057 012c DFF84CB1 		ldr	fp, .L183+48
 103:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEy = ey;
 3058              		.loc 16 103 0
 3059 0130 C3ED008A 		fsts	s17, [r3, #0]
 105:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ezInt = ezInt + ez*Ki;
 3060              		.loc 16 105 0
 3061 0134 88ED005A 		fsts	s10, [r8, #0]
 3062              		.loc 16 106 0
 3063 0138 DBF80000 		ldr	r0, [fp, #0]	@ float
 3064 013c 19EE101A 		fmrs	r1, s18
 3065 0140 FFF7FEFF 		bl	_Z10isSwitchedff
 3066 0144 4346     		mov	r3, r8
 3067 0146 5A46     		mov	r2, fp
 3068 0148 08B1     		cbz	r0, .L182
 107:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     ezInt = 0.0;
 3069              		.loc 16 107 0
 3070 014a 0021     		movs	r1, #0
 3071 014c 1960     		str	r1, [r3, #0]	@ float
 3072              	.L182:
 108:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   }
 109:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEz = ez;
 3073              		.loc 16 109 0
 3074 014e 82ED009A 		fsts	s18, [r2, #0]
 110:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 	
 111:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // adjusted gyroscope measurements
 112:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gx = gx + Kp*ex + exInt;
 3075              		.loc 16 112 0
 3076 0152 424A     		ldr	r2, .L183+16
 3077 0154 D2ED000A 		flds	s1, [r2, #0]
 113:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gy = gy + Kp*ey + eyInt;
 114:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gz = gz + Kp*ez + ezInt;
 3078              		.loc 16 114 0
 3079 0158 40EE89AA 		fmacs	s21, s1, s18
 3080              	.LVL155:
 112:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gx = gx + Kp*ex + exInt;
 3081              		.loc 16 112 0
 3082 015c 40EE889A 		fmacs	s19, s1, s16
 3083              	.LVL156:
 113:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gy = gy + Kp*ey + eyInt;
 3084              		.loc 16 113 0
 3085 0160 00EEA8AA 		fmacs	s20, s1, s17
 3086              	.LVL157:
 3087              		.loc 16 114 0
 3088 0164 D3ED003A 		flds	s7, [r3, #0]
 113:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gy = gy + Kp*ey + eyInt;
 3089              		.loc 16 113 0
 3090 0168 D9ED006A 		flds	s13, [r9, #0]
 112:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gx = gx + Kp*ex + exInt;
 3091              		.loc 16 112 0
 3092 016c 9AED006A 		flds	s12, [sl, #0]
 3093              		.loc 16 114 0
 3094 0170 7AEEA3AA 		fadds	s21, s21, s7
 115:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
 116:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // integrate quaternion rate and normalise
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 3095              		.loc 16 117 0
 3096 0174 D5ED004A 		flds	s9, [r5, #0]
 113:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gy = gy + Kp*ey + eyInt;
 3097              		.loc 16 113 0
 3098 0178 3AEE26AA 		fadds	s20, s20, s13
 118:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1i = ( q0*gx + q2*gz - q3*gy) * halfT;
 3099              		.loc 16 118 0
 3100 017c 97ED007A 		flds	s14, [r7, #0]
 112:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gx = gx + Kp*ex + exInt;
 3101              		.loc 16 112 0
 3102 0180 79EE869A 		fadds	s19, s19, s12
 3103              	.LVL158:
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 3104              		.loc 16 117 0
 3105 0184 96ED005A 		flds	s10, [r6, #0]
 3106              		.loc 16 118 0
 3107 0188 64EEAA5A 		fmuls	s11, s9, s21
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 3108              		.loc 16 117 0
 3109 018c 24EE8A0A 		fmuls	s0, s9, s20
 3110              		.loc 16 118 0
 3111 0190 47EE295A 		fmacs	s11, s14, s19
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 3112              		.loc 16 117 0
 3113 0194 94ED001A 		flds	s2, [r4, #0]
 3114 0198 15EE690A 		fnmscs	s0, s10, s19
 3115              		.loc 16 118 0
 3116 019c 41EE4A5A 		fnmacs	s11, s2, s20
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 3117              		.loc 16 117 0
 3118 01a0 2F4B     		ldr	r3, .L183+20
 119:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2i = ( q0*gy - q1*gz + q3*gx) * halfT;
 3119              		.loc 16 119 0
 3120 01a2 25EE2A4A 		fmuls	s8, s10, s21
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 3121              		.loc 16 117 0
 3122 01a6 01EE6A0A 		fnmacs	s0, s2, s21
 3123              		.loc 16 119 0
 3124 01aa 17EE0A4A 		fmscs	s8, s14, s20
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 3125              		.loc 16 117 0
 3126 01ae 93ED003A 		flds	s6, [r3, #0]
 3127              	.LVL159:
 120:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3i = ( q0*gz + q1*gy - q2*gx) * halfT;
 121:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 += q0i;
 122:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 += q1i;
 3128              		.loc 16 122 0
 3129 01b2 F0EE452A 		fcpys	s5, s10
 120:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3i = ( q0*gz + q1*gy - q2*gx) * halfT;
 3130              		.loc 16 120 0
 3131 01b6 65EE0A7A 		fmuls	s15, s10, s20
 3132              		.loc 16 122 0
 3133 01ba 45EE832A 		fmacs	s5, s11, s6
 119:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2i = ( q0*gy - q1*gz + q3*gx) * halfT;
 3134              		.loc 16 119 0
 3135 01be 01EE294A 		fmacs	s8, s2, s19
 121:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 += q0i;
 3136              		.loc 16 121 0
 3137 01c2 B0EE472A 		fcpys	s4, s14
 120:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3i = ( q0*gz + q1*gy - q2*gx) * halfT;
 3138              		.loc 16 120 0
 3139 01c6 47EE2A7A 		fmacs	s15, s14, s21
 121:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 += q0i;
 3140              		.loc 16 121 0
 3141 01ca 00EE032A 		fmacs	s4, s0, s6
 123:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 += q2i;
 3142              		.loc 16 123 0
 3143 01ce F0EE641A 		fcpys	s3, s9
 120:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3i = ( q0*gz + q1*gy - q2*gx) * halfT;
 3144              		.loc 16 120 0
 3145 01d2 44EEE97A 		fnmacs	s15, s9, s19
 3146              		.loc 16 123 0
 3147 01d6 44EE031A 		fmacs	s3, s8, s6
 124:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3 += q3i;
 125:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
 126:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // normalise quaternion
 127:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(q0*q0 + q1*q1 + q2*q2 + q3*q3);
 3148              		.loc 16 127 0
 3149 01da 22EEA26A 		fmuls	s12, s5, s5
 3150 01de 02EE026A 		fmacs	s12, s4, s4
 124:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3 += q3i;
 3151              		.loc 16 124 0
 3152 01e2 07EE831A 		fmacs	s2, s15, s6
 3153              		.loc 16 127 0
 3154 01e6 01EEA16A 		fmacs	s12, s3, s3
 3155 01ea 01EE016A 		fmacs	s12, s2, s2
 121:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 += q0i;
 3156              		.loc 16 121 0
 3157 01ee 87ED002A 		fsts	s4, [r7, #0]
 3158              		.loc 16 127 0
 3159 01f2 16EE100A 		fmrs	r0, s12
 122:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 += q1i;
 3160              		.loc 16 122 0
 3161 01f6 C6ED002A 		fsts	s5, [r6, #0]
 123:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 += q2i;
 3162              		.loc 16 123 0
 3163 01fa C5ED001A 		fsts	s3, [r5, #0]
 124:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3 += q3i;
 3164              		.loc 16 124 0
 3165 01fe 84ED001A 		fsts	s2, [r4, #0]
 3166              		.loc 16 127 0
 3167 0202 FFF7FEFF 		bl	__aeabi_f2d
 3168              	.LVL160:
 3169 0206 FFF7FEFF 		bl	sqrt
 3170 020a FFF7FEFF 		bl	__aeabi_d2f
 128:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 = q0 / norm;
 3171              		.loc 16 128 0
 3172 020e D7ED006A 		flds	s13, [r7, #0]
 127:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(q0*q0 + q1*q1 + q2*q2 + q3*q3);
 3173              		.loc 16 127 0
 3174 0212 05EE900A 		fmsr	s11, r0
 3175              	.LVL161:
 129:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 = q1 / norm;
 3176              		.loc 16 129 0
 3177 0216 D6ED000A 		flds	s1, [r6, #0]
 130:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 = q2 / norm;
 3178              		.loc 16 130 0
 3179 021a D5ED003A 		flds	s7, [r5, #0]
 131:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3 = q3 / norm;
 3180              		.loc 16 131 0
 3181 021e 94ED000A 		flds	s0, [r4, #0]
 128:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 = q0 / norm;
 3182              		.loc 16 128 0
 3183 0222 C6EEA56A 		fdivs	s13, s13, s11
 129:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 = q1 / norm;
 3184              		.loc 16 129 0
 3185 0226 C0EEA50A 		fdivs	s1, s1, s11
 130:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 = q2 / norm;
 3186              		.loc 16 130 0
 3187 022a C3EEA53A 		fdivs	s7, s7, s11
 3188              		.loc 16 131 0
 3189 022e C0EE255A 		fdivs	s11, s0, s11
 128:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 = q0 / norm;
 3190              		.loc 16 128 0
 3191 0232 C7ED006A 		fsts	s13, [r7, #0]
 129:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 = q1 / norm;
 3192              		.loc 16 129 0
 3193 0236 C6ED000A 		fsts	s1, [r6, #0]
 130:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 = q2 / norm;
 3194              		.loc 16 130 0
 3195 023a C5ED003A 		fsts	s7, [r5, #0]
 3196              		.loc 16 131 0
 3197 023e C4ED005A 		fsts	s11, [r4, #0]
 3198              	.LBE76:
 132:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** }
 3199              		.loc 16 132 0
 3200 0242 BDEC068B 		fldmfdd	sp!, {d8, d9, d10}
 3201 0246 BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3202              	.L184:
 3203 024a 00BF     		.align	2
 3204              	.L183:
 3205 024c 00000000 		.word	.LANCHOR46
 3206 0250 00000000 		.word	.LANCHOR47
 3207 0254 00000000 		.word	.LANCHOR48
 3208 0258 00000000 		.word	.LANCHOR45
 3209 025c 00000000 		.word	.LANCHOR56
 3210 0260 00000000 		.word	.LANCHOR44
 3211 0264 00000000 		.word	.LANCHOR49
 3212 0268 00000000 		.word	.LANCHOR50
 3213 026c 00000000 		.word	.LANCHOR51
 3214 0270 00000000 		.word	.LANCHOR52
 3215 0274 00000000 		.word	.LANCHOR53
 3216 0278 00000000 		.word	.LANCHOR54
 3217 027c 00000000 		.word	.LANCHOR55
 3218              		.cfi_endproc
 3219              	.LFE164:
 3221              		.section	.text._Z11eulerAnglesv,"ax",%progbits
 3222              		.align	1
 3223              		.global	_Z11eulerAnglesv
 3224              		.thumb
 3225              		.thumb_func
 3227              	_Z11eulerAnglesv:
 3228              	.LFB165:
 133:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
 134:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void eulerAngles()
 135:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** {
 3229              		.loc 16 135 0
 3230              		.cfi_startproc
 3231              		@ args = 0, pretend = 0, frame = 0
 3232              		@ frame_needed = 0, uses_anonymous_args = 0
 3233 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 3234              	.LCFI33:
 3235              		.cfi_def_cfa_offset 32
 3236              		.cfi_offset 14, -4
 3237              		.cfi_offset 9, -8
 3238              		.cfi_offset 8, -12
 3239              		.cfi_offset 7, -16
 3240              		.cfi_offset 6, -20
 3241              		.cfi_offset 5, -24
 3242              		.cfi_offset 4, -28
 3243              		.cfi_offset 3, -32
 136:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[XAXIS]  = atan2(2 * (q0*q1 + q2*q3), 1 - 2 *(q1*q1 + q2*q2));
 3244              		.loc 16 136 0
 3245 0004 3C4C     		ldr	r4, .L186
 3246 0006 3D4E     		ldr	r6, .L186+4
 3247 0008 3D4D     		ldr	r5, .L186+8
 3248 000a 3E4F     		ldr	r7, .L186+12
 135:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** {
 3249              		.loc 16 135 0
 3250 000c 2DED048B 		fstmfdd	sp!, {d8, d9}
 3251              	.LCFI34:
 3252              		.cfi_def_cfa_offset 48
 3253              		.cfi_offset 82, -40
 3254              		.cfi_offset 80, -48
 3255              		.loc 16 136 0
 3256 0010 D4ED005A 		flds	s11, [r4, #0]
 3257 0014 96ED008A 		flds	s16, [r6, #0]
 3258 0018 D5ED007A 		flds	s15, [r5, #0]
 3259 001c D7ED008A 		flds	s17, [r7, #0]
 3260 0020 68EE255A 		fmuls	s11, s16, s11
 3261 0024 48EEA75A 		fmacs	s11, s17, s15
 3262 0028 B7EE009A 		fconsts	s18, #112
 3263 002c 35EEA55A 		fadds	s10, s11, s11
 3264 0030 15EE100A 		fmrs	r0, s10
 3265 0034 FFF7FEFF 		bl	__aeabi_f2d
 3266 0038 68EE084A 		fmuls	s9, s16, s16
 3267 003c 48EEA84A 		fmacs	s9, s17, s17
 3268 0040 8046     		mov	r8, r0
 3269 0042 34EEA44A 		fadds	s8, s9, s9
 3270 0046 8946     		mov	r9, r1
 3271 0048 79EE443A 		fsubs	s7, s18, s8
 3272 004c 13EE900A 		fmrs	r0, s7
 3273 0050 FFF7FEFF 		bl	__aeabi_f2d
 3274 0054 0246     		mov	r2, r0
 3275 0056 0B46     		mov	r3, r1
 3276 0058 4046     		mov	r0, r8
 3277 005a 4946     		mov	r1, r9
 3278 005c FFF7FEFF 		bl	atan2
 3279 0060 FFF7FEFF 		bl	__aeabi_d2f
 137:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[YAXIS] = asin(2 * (q0*q2 - q1*q3));
 3280              		.loc 16 137 0
 3281 0064 97ED006A 		flds	s12, [r7, #0]
 3282 0068 D4ED002A 		flds	s5, [r4, #0]
 3283 006c D5ED006A 		flds	s13, [r5, #0]
 3284 0070 96ED003A 		flds	s6, [r6, #0]
 3285 0074 66EE222A 		fmuls	s5, s12, s5
 3286 0078 56EE832A 		fmscs	s5, s13, s6
 136:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[XAXIS]  = atan2(2 * (q0*q1 + q2*q3), 1 - 2 *(q1*q1 + q2*q2));
 3287              		.loc 16 136 0
 3288 007c DFF88880 		ldr	r8, .L186+16
 3289              		.loc 16 137 0
 3290 0080 32EEA22A 		fadds	s4, s5, s5
 136:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[XAXIS]  = atan2(2 * (q0*q1 + q2*q3), 1 - 2 *(q1*q1 + q2*q2));
 3291              		.loc 16 136 0
 3292 0084 C8F80000 		str	r0, [r8, #0]	@ float
 3293              		.loc 16 137 0
 3294 0088 12EE100A 		fmrs	r0, s4
 3295 008c FFF7FEFF 		bl	__aeabi_f2d
 3296 0090 FFF7FEFF 		bl	asin
 3297 0094 FFF7FEFF 		bl	__aeabi_d2f
 138:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[ZAXIS]   = atan2(2 * (q0*q3 + q1*q2), 1 - 2 *(q2*q2 + q3*q3));
 3298              		.loc 16 138 0
 3299 0098 D6ED008A 		flds	s17, [r6, #0]
 3300 009c D7ED001A 		flds	s3, [r7, #0]
 3301 00a0 95ED007A 		flds	s14, [r5, #0]
 3302 00a4 94ED008A 		flds	s16, [r4, #0]
 3303 00a8 68EEA11A 		fmuls	s3, s17, s3
 3304 00ac 48EE071A 		fmacs	s3, s16, s14
 137:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[YAXIS] = asin(2 * (q0*q2 - q1*q3));
 3305              		.loc 16 137 0
 3306 00b0 C8F80400 		str	r0, [r8, #4]	@ float
 3307              		.loc 16 138 0
 3308 00b4 31EEA11A 		fadds	s2, s3, s3
 3309 00b8 11EE100A 		fmrs	r0, s2
 3310 00bc FFF7FEFF 		bl	__aeabi_f2d
 3311 00c0 68EE080A 		fmuls	s1, s16, s16
 3312 00c4 48EEA80A 		fmacs	s1, s17, s17
 3313 00c8 0446     		mov	r4, r0
 3314 00ca 30EEA00A 		fadds	s0, s1, s1
 3315 00ce 0D46     		mov	r5, r1
 3316 00d0 79EE407A 		fsubs	s15, s18, s0
 3317 00d4 17EE900A 		fmrs	r0, s15
 3318 00d8 FFF7FEFF 		bl	__aeabi_f2d
 3319 00dc 0246     		mov	r2, r0
 3320 00de 0B46     		mov	r3, r1
 3321 00e0 2046     		mov	r0, r4
 3322 00e2 2946     		mov	r1, r5
 3323 00e4 FFF7FEFF 		bl	atan2
 3324 00e8 FFF7FEFF 		bl	__aeabi_d2f
 3325 00ec C8F80800 		str	r0, [r8, #8]	@ float
 139:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** }
 3326              		.loc 16 139 0
 3327 00f0 BDEC048B 		fldmfdd	sp!, {d8, d9}
 3328 00f4 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 3329              	.L187:
 3330              		.align	2
 3331              	.L186:
 3332 00f8 00000000 		.word	.LANCHOR46
 3333 00fc 00000000 		.word	.LANCHOR48
 3334 0100 00000000 		.word	.LANCHOR47
 3335 0104 00000000 		.word	.LANCHOR45
 3336 0108 00000000 		.word	.LANCHOR42
 3337              		.cfi_endproc
 3338              	.LFE165:
 3340              		.section	.text._Z20initializeKinematicsv,"ax",%progbits
 3341              		.align	1
 3342              		.global	_Z20initializeKinematicsv
 3343              		.thumb
 3344              		.thumb_func
 3346              	_Z20initializeKinematicsv:
 3347              	.LFB166:
 140:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
 141:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
 142:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // Initialize ARG
 143:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
 144:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
 145:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void initializeKinematics() 
 146:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** {
 3348              		.loc 16 146 0
 3349              		.cfi_startproc
 3350              		@ args = 0, pretend = 0, frame = 0
 3351              		@ frame_needed = 0, uses_anonymous_args = 0
 3352 0000 08B5     		push	{r3, lr}
 3353              	.LCFI35:
 3354              		.cfi_def_cfa_offset 8
 3355              		.cfi_offset 14, -4
 3356              		.cfi_offset 3, -8
 147:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   initializeBaseKinematicsParam();
 3357              		.loc 16 147 0
 3358 0002 FFF7FEFF 		bl	_Z29initializeBaseKinematicsParamv
 148:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 = 1.0;
 3359              		.loc 16 148 0
 3360 0006 0F4B     		ldr	r3, .L189
 149:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 = 0.0;
 3361              		.loc 16 149 0
 3362 0008 0F49     		ldr	r1, .L189+4
 150:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 = 0.0;
 3363              		.loc 16 150 0
 3364 000a 1048     		ldr	r0, .L189+8
 151:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3 = 0.0;
 3365              		.loc 16 151 0
 3366 000c 104A     		ldr	r2, .L189+12
 148:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 = 1.0;
 3367              		.loc 16 148 0
 3368 000e 4FF07E5C 		mov	ip, #1065353216
 3369 0012 C3F800C0 		str	ip, [r3, #0]	@ float
 149:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 = 0.0;
 3370              		.loc 16 149 0
 3371 0016 0023     		movs	r3, #0
 3372 0018 0B60     		str	r3, [r1, #0]	@ float
 150:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 = 0.0;
 3373              		.loc 16 150 0
 3374 001a 0360     		str	r3, [r0, #0]	@ float
 3375              		.loc 16 151 0
 3376 001c 1360     		str	r3, [r2, #0]	@ float
 152:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   exInt = 0.0;
 3377              		.loc 16 152 0
 3378 001e 0D49     		ldr	r1, .L189+16
 153:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eyInt = 0.0;
 3379              		.loc 16 153 0
 3380 0020 0D48     		ldr	r0, .L189+20
 154:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ezInt = 0.0;
 3381              		.loc 16 154 0
 3382 0022 0E4A     		ldr	r2, .L189+24
 152:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   exInt = 0.0;
 3383              		.loc 16 152 0
 3384 0024 0B60     		str	r3, [r1, #0]	@ float
 153:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eyInt = 0.0;
 3385              		.loc 16 153 0
 3386 0026 0360     		str	r3, [r0, #0]	@ float
 3387              		.loc 16 154 0
 3388 0028 1360     		str	r3, [r2, #0]	@ float
 155:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 	
 156:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEx = 0;
 3389              		.loc 16 156 0
 3390 002a 0D49     		ldr	r1, .L189+28
 157:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEy = 0;
 3391              		.loc 16 157 0
 3392 002c 0D48     		ldr	r0, .L189+32
 158:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEz = 0;
 3393              		.loc 16 158 0
 3394 002e 0E4A     		ldr	r2, .L189+36
 156:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEx = 0;
 3395              		.loc 16 156 0
 3396 0030 0B60     		str	r3, [r1, #0]	@ float
 157:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEy = 0;
 3397              		.loc 16 157 0
 3398 0032 0360     		str	r3, [r0, #0]	@ float
 3399              		.loc 16 158 0
 3400 0034 1360     		str	r3, [r2, #0]	@ float
 159:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
 160:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   Kp = 0.2; // 2.0;
 3401              		.loc 16 160 0
 3402 0036 0D48     		ldr	r0, .L189+40
 3403 0038 0D49     		ldr	r1, .L189+44
 161:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   Ki = 0.0005; //0.005;
 3404              		.loc 16 161 0
 3405 003a 0E4A     		ldr	r2, .L189+48
 3406 003c 0E4B     		ldr	r3, .L189+52
 160:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   Kp = 0.2; // 2.0;
 3407              		.loc 16 160 0
 3408 003e 0860     		str	r0, [r1, #0]	@ float
 3409              		.loc 16 161 0
 3410 0040 1A60     		str	r2, [r3, #0]	@ float
 162:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** }
 3411              		.loc 16 162 0
 3412 0042 08BD     		pop	{r3, pc}
 3413              	.L190:
 3414              		.align	2
 3415              	.L189:
 3416 0044 00000000 		.word	.LANCHOR47
 3417 0048 00000000 		.word	.LANCHOR45
 3418 004c 00000000 		.word	.LANCHOR48
 3419 0050 00000000 		.word	.LANCHOR46
 3420 0054 00000000 		.word	.LANCHOR49
 3421 0058 00000000 		.word	.LANCHOR52
 3422 005c 00000000 		.word	.LANCHOR54
 3423 0060 00000000 		.word	.LANCHOR51
 3424 0064 00000000 		.word	.LANCHOR53
 3425 0068 00000000 		.word	.LANCHOR55
 3426 006c CDCC4C3E 		.word	1045220557
 3427 0070 00000000 		.word	.LANCHOR56
 3428 0074 6F12033A 		.word	973279855
 3429 0078 00000000 		.word	.LANCHOR50
 3430              		.cfi_endproc
 3431              	.LFE166:
 3433              		.section	.text._Z19calculateKinematicsfffffff,"ax",%progbits
 3434              		.align	1
 3435              		.global	_Z19calculateKinematicsfffffff
 3436              		.thumb
 3437              		.thumb_func
 3439              	_Z19calculateKinematicsfffffff:
 3440              	.LFB167:
 163:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
 164:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
 165:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // Calculate ARG
 166:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
 167:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void calculateKinematics(float rollRate,          float pitchRate,    float yawRate,  
 168:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****                          float longitudinalAccel, float lateralAccel, float verticalAccel, 
 169:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****                          float G_DT) {
 3441              		.loc 16 169 0
 3442              		.cfi_startproc
 3443              		@ args = 12, pretend = 0, frame = 0
 3444              		@ frame_needed = 0, uses_anonymous_args = 0
 3445              	.LVL162:
 3446 0000 1FB5     		push	{r0, r1, r2, r3, r4, lr}
 3447              	.LCFI36:
 3448              		.cfi_def_cfa_offset 24
 3449              		.cfi_offset 14, -4
 3450              		.cfi_offset 4, -8
 3451              		.cfi_offset 3, -12
 3452              		.cfi_offset 2, -16
 3453              		.cfi_offset 1, -20
 3454              		.cfi_offset 0, -24
 170:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
 171:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   argUpdate(rollRate,          pitchRate,    yawRate, 
 172:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****             longitudinalAccel, lateralAccel, verticalAccel,  
 173:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 		    G_Dt);
 3455              		.loc 16 173 0
 3456 0002 DDF818E0 		ldr	lr, [sp, #24]	@ float
 3457 0006 DDF81CC0 		ldr	ip, [sp, #28]	@ float
 3458 000a 074C     		ldr	r4, .L192
 3459 000c CDF800E0 		str	lr, [sp, #0]	@ float
 3460 0010 CDF804C0 		str	ip, [sp, #4]	@ float
 3461 0014 2468     		ldr	r4, [r4, #0]	@ float
 3462 0016 0294     		str	r4, [sp, #8]	@ float
 3463 0018 FFF7FEFF 		bl	_Z9argUpdatefffffff
 3464              	.LVL163:
 174:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eulerAngles();
 175:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** }
 3465              		.loc 16 175 0
 3466 001c 04B0     		add	sp, sp, #16
 3467 001e BDE81040 		pop	{r4, lr}
 174:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eulerAngles();
 3468              		.loc 16 174 0
 3469 0022 FFF7FEBF 		b	_Z11eulerAnglesv
 3470              	.L193:
 3471 0026 00BF     		.align	2
 3472              	.L192:
 3473 0028 00000000 		.word	.LANCHOR57
 3474              		.cfi_endproc
 3475              	.LFE167:
 3477              		.section	.text._Z13getGyroUnbiash,"ax",%progbits
 3478              		.align	1
 3479              		.global	_Z13getGyroUnbiash
 3480              		.thumb
 3481              		.thumb_func
 3483              	_Z13getGyroUnbiash:
 3484              	.LFB168:
 176:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
 177:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float getGyroUnbias(byte axis) {
 3485              		.loc 16 177 0
 3486              		.cfi_startproc
 3487              		@ args = 0, pretend = 0, frame = 0
 3488              		@ frame_needed = 0, uses_anonymous_args = 0
 3489              		@ link register save eliminated.
 3490              	.LVL164:
 178:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   return correctedRateVector[axis];
 3491              		.loc 16 178 0
 3492 0000 0249     		ldr	r1, .L195
 3493 0002 01EB8003 		add	r3, r1, r0, lsl #2
 179:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** }
 3494              		.loc 16 179 0
 3495 0006 1868     		ldr	r0, [r3, #0]	@ float
 3496              	.LVL165:
 3497 0008 7047     		bx	lr
 3498              	.L196:
 3499 000a 00BF     		.align	2
 3500              	.L195:
 3501 000c 00000000 		.word	.LANCHOR58
 3502              		.cfi_endproc
 3503              	.LFE168:
 3505              		.section	.text._Z19calibrateKinematicsv,"ax",%progbits
 3506              		.align	1
 3507              		.global	_Z19calibrateKinematicsv
 3508              		.thumb
 3509              		.thumb_func
 3511              	_Z19calibrateKinematicsv:
 3512              	.LFB169:
 180:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
 181:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void calibrateKinematics() {}
 3513              		.loc 16 181 0
 3514              		.cfi_startproc
 3515              		@ args = 0, pretend = 0, frame = 0
 3516              		@ frame_needed = 0, uses_anonymous_args = 0
 3517              		@ link register save eliminated.
 3518              		.loc 16 181 0
 3519 0000 7047     		bx	lr
 3520              		.cfi_endproc
 3521              	.LFE169:
 3523              		.section	.text._Z7FrqInitiP9timer_devi,"ax",%progbits
 3524              		.align	1
 3525              		.global	_Z7FrqInitiP9timer_devi
 3526              		.thumb
 3527              		.thumb_func
 3529              	_Z7FrqInitiP9timer_devi:
 3530              	.LFB170:
  80:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** {
 3531              		.loc 4 80 0
 3532              		.cfi_startproc
 3533              		@ args = 0, pretend = 0, frame = 0
 3534              		@ frame_needed = 0, uses_anonymous_args = 0
 3535              	.LVL166:
 3536 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3537              	.LCFI37:
 3538              		.cfi_def_cfa_offset 24
 3539              		.cfi_offset 14, -4
 3540              		.cfi_offset 7, -8
 3541              		.cfi_offset 6, -12
 3542              		.cfi_offset 5, -16
 3543              		.cfi_offset 4, -20
 3544              		.cfi_offset 3, -24
 3545              	.LBB77:
  83:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.TimerDev     = aTimer;
 3546              		.loc 4 83 0
 3547 0002 244D     		ldr	r5, .L201
 3548 0004 2960     		str	r1, [r5, #0]
  84:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer_gen_reg_map *timer = aTimer->regs.gen;
 3549              		.loc 4 84 0
 3550 0006 0C68     		ldr	r4, [r1, #0]
  81:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   aTimerChannel--;  // transform timer channel numbering from 1-4 to 0-3
 3551              		.loc 4 81 0
 3552 0008 561E     		subs	r6, r2, #1
 3553              	.LVL167:
  87:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.Timer_ccr    = &timer->CCR1 + aTimerChannel;
 3554              		.loc 4 87 0
 3555 000a B100     		lsls	r1, r6, #2
 3556              	.LVL168:
  90:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   int TimerEnable = (1 << (4*aTimerChannel));
 3557              		.loc 4 90 0
 3558 000c 0127     		movs	r7, #1
 3559 000e 07FA01F7 		lsl	r7, r7, r1
 3560              	.LVL169:
  87:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.Timer_ccr    = &timer->CCR1 + aTimerChannel;
 3561              		.loc 4 87 0
 3562 0012 04F1340E 		add	lr, r4, #52
  91:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.PolarityMask = TimerEnable << 1;
 3563              		.loc 4 91 0
 3564 0016 7B00     		lsls	r3, r7, #1
  87:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.Timer_ccr    = &timer->CCR1 + aTimerChannel;
 3565              		.loc 4 87 0
 3566 0018 0EEB0102 		add	r2, lr, r1
  85:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.TimerRegs    = timer;
 3567              		.loc 4 85 0
 3568 001c 6C60     		str	r4, [r5, #4]
  87:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.Timer_ccr    = &timer->CCR1 + aTimerChannel;
 3569              		.loc 4 87 0
 3570 001e AA60     		str	r2, [r5, #8]
  88:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.TimerChannel = aTimerChannel;
 3571              		.loc 4 88 0
 3572 0020 2E61     		str	r6, [r5, #16]
  91:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.PolarityMask = TimerEnable << 1;
 3573              		.loc 4 91 0
 3574 0022 6B61     		str	r3, [r5, #20]
  93:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   uint32 clock_speed = rcc_dev_timer_clk_speed(FrqData.TimerDev->clk_id);
 3575              		.loc 4 93 0
 3576 0024 2868     		ldr	r0, [r5, #0]
 3577              	.LVL170:
 3578 0026 0079     		ldrb	r0, [r0, #4]	@ zero_extendqisi2
 3579 0028 FFF7FEFF 		bl	rcc_dev_timer_clk_speed
 3580              	.LVL171:
  94:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->PSC	= (clock_speed/1000000)-1;
 3581              		.loc 4 94 0
 3582 002c 1A4A     		ldr	r2, .L201+4
 3583 002e B0FBF2F1 		udiv	r1, r0, r2
 3584 0032 4B1E     		subs	r3, r1, #1
  96:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CR1	= 0;
 3585              		.loc 4 96 0
 3586 0034 0022     		movs	r2, #0
  95:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->ARR	= 0xffff;
 3587              		.loc 4 95 0
 3588 0036 4FF6FF70 		movw	r0, #65535
 3589              	.LVL172:
  94:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->PSC	= (clock_speed/1000000)-1;
 3590              		.loc 4 94 0
 3591 003a A362     		str	r3, [r4, #40]
  95:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->ARR	= 0xffff;
 3592              		.loc 4 95 0
 3593 003c E062     		str	r0, [r4, #44]
  96:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CR1	= 0;
 3594              		.loc 4 96 0
 3595 003e 2260     		str	r2, [r4, #0]
  97:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->DIER &= ~(1);
 3596              		.loc 4 97 0
 3597 0040 E168     		ldr	r1, [r4, #12]
 3598 0042 21F00103 		bic	r3, r1, #1
 3599 0046 E360     		str	r3, [r4, #12]
  99:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CCER &= ~TimerEnable; // Disable timer
 3600              		.loc 4 99 0
 3601 0048 206A     		ldr	r0, [r4, #32]
 3602 004a 20EA0702 		bic	r2, r0, r7
 3603 004e 2262     		str	r2, [r4, #32]
 100:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CCER &= ~(FrqData.PolarityMask);
 3604              		.loc 4 100 0
 3605 0050 236A     		ldr	r3, [r4, #32]
 3606 0052 6969     		ldr	r1, [r5, #20]
 112:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   if(aTimerChannel < 2) {
 3607              		.loc 4 112 0
 3608 0054 012E     		cmp	r6, #1
 100:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CCER &= ~(FrqData.PolarityMask);
 3609              		.loc 4 100 0
 3610 0056 23EA0103 		bic	r3, r3, r1
 3611 005a 2362     		str	r3, [r4, #32]
 113:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     mr = &(timer->CCMR1);
 3612              		.loc 4 113 0
 3613 005c D4BF     		ite	le
 3614 005e 04F11803 		addle	r3, r4, #24
 3615              	.LVL173:
 115:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     mr = &(timer->CCMR2);
 3616              		.loc 4 115 0
 3617 0062 04F11C03 		addgt	r3, r4, #28
 3618              	.LVL174:
 117:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   *mr &= ~(0xFF << (8*(aTimerChannel&1)));	// prescaler 1
 3619              		.loc 4 117 0
 3620 0066 06F00100 		and	r0, r6, #1
 3621 006a 1968     		ldr	r1, [r3, #0]
 3622 006c C000     		lsls	r0, r0, #3
 3623 006e FF22     		movs	r2, #255
 3624 0070 02FA00FC 		lsl	ip, r2, r0
 3625 0074 21EA0C06 		bic	r6, r1, ip
 3626              	.LVL175:
 3627 0078 1E60     		str	r6, [r3, #0]
 118:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   *mr |= 0x61 << (8*(aTimerChannel&1));		// 0x61 -> 6=filter, 1=inputs 1,2,3,4
 3628              		.loc 4 118 0
 3629 007a 1A68     		ldr	r2, [r3, #0]
 3630 007c 6121     		movs	r1, #97
 3631 007e 01FA00F6 		lsl	r6, r1, r0
 3632 0082 1643     		orrs	r6, r6, r2
 3633 0084 1E60     		str	r6, [r3, #0]
 120:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CCER |= TimerEnable; // Enable
 3634              		.loc 4 120 0
 3635 0086 206A     		ldr	r0, [r4, #32]
 121:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CR1 = 1;
 3636              		.loc 4 121 0
 3637 0088 0123     		movs	r3, #1
 3638              	.LVL176:
 120:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CCER |= TimerEnable; // Enable
 3639              		.loc 4 120 0
 3640 008a 0743     		orrs	r7, r7, r0
 3641              	.LVL177:
 3642 008c 2762     		str	r7, [r4, #32]
 121:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CR1 = 1;
 3643              		.loc 4 121 0
 3644 008e 2360     		str	r3, [r4, #0]
 3645              	.LBE77:
 130:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** }
 3646              		.loc 4 130 0
 3647 0090 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3648              	.L202:
 3649 0092 00BF     		.align	2
 3650              	.L201:
 3651 0094 00000000 		.word	.LANCHOR0
 3652 0098 40420F00 		.word	1000000
 3653              		.cfi_endproc
 3654              	.LFE170:
 3656              		.section	.text._Z18InitFrqMeasurementv,"ax",%progbits
 3657              		.align	1
 3658              		.global	_Z18InitFrqMeasurementv
 3659              		.thumb
 3660              		.thumb_func
 3662              	_Z18InitFrqMeasurementv:
 3663              	.LFB172:
 157:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 158:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** void InitFrqMeasurement()
 159:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** {
 3664              		.loc 4 159 0
 3665              		.cfi_startproc
 3666              		@ args = 0, pretend = 0, frame = 0
 3667              		@ frame_needed = 0, uses_anonymous_args = 0
 3668              	.LVL178:
 3669 0000 38B5     		push	{r3, r4, r5, lr}
 3670              	.LCFI38:
 3671              		.cfi_def_cfa_offset 16
 3672              		.cfi_offset 14, -4
 3673              		.cfi_offset 5, -8
 3674              		.cfi_offset 4, -12
 3675              		.cfi_offset 3, -16
 3676              	.LBB78:
 160:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 161:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #ifdef STM32_TIMER_DEBUG
 162:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Serial.println("InitFrqMeasurement");
 163:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #endif
 164:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   int pin = receiverPin;
 165:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer_dev *timer_num = PIN_MAP[pin].timer_device;
 3677              		.loc 4 165 0
 3678 0002 0F4C     		ldr	r4, .L205
 166:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 167:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   currentChannel=8;
 3679              		.loc 4 167 0
 3680 0004 0F4B     		ldr	r3, .L205+4
 165:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer_dev *timer_num = PIN_MAP[pin].timer_device;
 3681              		.loc 4 165 0
 3682 0006 D4F8F453 		ldr	r5, [r4, #1012]
 3683              	.LVL179:
 3684              		.loc 4 167 0
 3685 000a 0822     		movs	r2, #8
 3686 000c 1A70     		strb	r2, [r3, #0]
 168:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   if(timer_num == NULL) {
 3687              		.loc 4 168 0
 3688 000e ADB1     		cbz	r5, .L203
 169:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #ifdef STM32_TIMER_DEBUG
 170:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     Serial.print("InitFrqMeasurement: invalid PWM input ");
 171:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     Serial.print(pin);
 172:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     Serial.println();
 173:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #endif
 174:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   } else {
 175:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #ifdef STM32F2
 176:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     gpio_set_mode(PIN_MAP[pin].gpio_device, PIN_MAP[pin].gpio_bit, GPIO_AF_INPUT_PD);
 3689              		.loc 4 176 0
 3690 0010 D4F8F003 		ldr	r0, [r4, #1008]
 3691 0014 94F8FC13 		ldrb	r1, [r4, #1020]	@ zero_extendqisi2
 3692 0018 0A22     		movs	r2, #10
 3693 001a FFF7FEFF 		bl	gpio_set_mode
 3694              	.LVL180:
 177:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #else
 178:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     pinMode(pin, INPUT_PULLDOWN);
 179:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #endif
 180:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     
 181:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #ifdef STM32_TIMER_DEBUG
 182:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     timer_gen_reg_map *timer = PIN_MAP[pin].timer_device->regs.gen;
 183:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     Serial.print("pin ");
 184:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     Serial.print(pin);
 185:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     Serial.print(" timerbase ");
 186:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     Serial.print((int32)timer,16);
 187:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     Serial.println();
 188:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #endif
 189:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     FrqInit(1500, timer_num, PIN_MAP[pin].timer_channel);
 3695              		.loc 4 189 0
 3696 001e 2946     		mov	r1, r5
 3697 0020 94F8FD23 		ldrb	r2, [r4, #1021]	@ zero_extendqisi2
 3698 0024 40F2DC50 		movw	r0, #1500
 3699 0028 FFF7FEFF 		bl	_Z7FrqInitiP9timer_devi
 190:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     
 191:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     timer_attach_interrupt(timer_num, PIN_MAP[pin].timer_channel, FrqChange);
 3700              		.loc 4 191 0
 3701 002c 94F8FD13 		ldrb	r1, [r4, #1021]	@ zero_extendqisi2
 3702 0030 054A     		ldr	r2, .L205+8
 3703 0032 2846     		mov	r0, r5
 3704              	.LBE78:
 192:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   }
 193:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   
 194:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #ifdef STM32_TIMER_DEBUG
 195:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Serial.println("InitFrqMeasurement done");
 196:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #endif
 197:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** }
 3705              		.loc 4 197 0
 3706 0034 BDE83840 		pop	{r3, r4, r5, lr}
 3707              	.LBB79:
 191:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     timer_attach_interrupt(timer_num, PIN_MAP[pin].timer_channel, FrqChange);
 3708              		.loc 4 191 0
 3709 0038 FFF7FEBF 		b	timer_attach_interrupt
 3710              	.L203:
 3711 003c 38BD     		pop	{r3, r4, r5, pc}
 3712              	.L206:
 3713 003e 00BF     		.align	2
 3714              	.L205:
 3715 0040 00000000 		.word	PIN_MAP
 3716 0044 00000000 		.word	.LANCHOR1
 3717 0048 00000000 		.word	_Z9FrqChangev
 3718              	.LBE79:
 3719              		.cfi_endproc
 3720              	.LFE172:
 3722              		.section	.text._Z18initializeReceiveri,"ax",%progbits
 3723              		.align	1
 3724              		.global	_Z18initializeReceiveri
 3725              		.thumb
 3726              		.thumb_func
 3728              	_Z18initializeReceiveri:
 3729              	.LFB173:
 198:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 199:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 200:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 201:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** ///////////////////////////////////////////////////////////////////////////////
 202:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** // interface part starts here
 203:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 204:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** void initializeReceiver(int nbChannel = 8) {
 3730              		.loc 4 204 0
 3731              		.cfi_startproc
 3732              		@ args = 0, pretend = 0, frame = 0
 3733              		@ frame_needed = 0, uses_anonymous_args = 0
 3734              	.LVL181:
 3735 0000 08B5     		push	{r3, lr}
 3736              	.LCFI39:
 3737              		.cfi_def_cfa_offset 8
 3738              		.cfi_offset 14, -4
 3739              		.cfi_offset 3, -8
 205:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 206:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   initializeReceiverParam(nbChannel);
 3740              		.loc 4 206 0
 3741 0002 FFF7FEFF 		bl	_Z23initializeReceiverParami
 3742              	.LVL182:
 207:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   InitFrqMeasurement();
 208:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** }
 3743              		.loc 4 208 0
 3744 0006 BDE80840 		pop	{r3, lr}
 207:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   InitFrqMeasurement();
 3745              		.loc 4 207 0
 3746 000a FFF7FEBF 		b	_Z18InitFrqMeasurementv
 3747              		.cfi_endproc
 3748              	.LFE173:
 3750              		.section	.text._Z18getRawChannelValueh,"ax",%progbits
 3751              		.align	1
 3752              		.global	_Z18getRawChannelValueh
 3753              		.thumb
 3754              		.thumb_func
 3756              	_Z18getRawChannelValueh:
 3757              	.LFB174:
 209:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 210:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 211:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** int getRawChannelValue(const byte channel) {
 3758              		.loc 4 211 0
 3759              		.cfi_startproc
 3760              		@ args = 0, pretend = 0, frame = 0
 3761              		@ frame_needed = 0, uses_anonymous_args = 0
 3762              		@ link register save eliminated.
 3763              	.LVL183:
 212:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   return rawChannelValue[ReceiverChannelMap[channel]];
 3764              		.loc 4 212 0
 3765 0000 0249     		ldr	r1, .L209
 213:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** }
 3766              		.loc 4 213 0
 3767 0002 034B     		ldr	r3, .L209+4
 212:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   return rawChannelValue[ReceiverChannelMap[channel]];
 3768              		.loc 4 212 0
 3769 0004 0A5C     		ldrb	r2, [r1, r0]	@ zero_extendqisi2
 3770              		.loc 4 213 0
 3771 0006 33F81200 		ldrh	r0, [r3, r2, lsl #1]
 3772              	.LVL184:
 3773 000a 7047     		bx	lr
 3774              	.L210:
 3775              		.align	2
 3776              	.L209:
 3777 000c 00000000 		.word	.LANCHOR59
 3778 0010 00000000 		.word	.LANCHOR2
 3779              		.cfi_endproc
 3780              	.LFE174:
 3782              		.section	.text._Z12readReceiverv,"ax",%progbits
 3783              		.align	1
 3784              		.global	_Z12readReceiverv
 3785              		.thumb
 3786              		.thumb_func
 3788              	_Z12readReceiverv:
 3789              	.LFB122:
  87:../Libraries/AQ_Receiver/Receiver.h **** {
 3790              		.loc 7 87 0
 3791              		.cfi_startproc
 3792              		@ args = 0, pretend = 0, frame = 0
 3793              		@ frame_needed = 0, uses_anonymous_args = 0
 3794              	.LVL185:
 3795 0000 38B5     		push	{r3, r4, r5, lr}
 3796              	.LCFI40:
 3797              		.cfi_def_cfa_offset 16
 3798              		.cfi_offset 14, -4
 3799              		.cfi_offset 5, -8
 3800              		.cfi_offset 4, -12
 3801              		.cfi_offset 3, -16
 3802              	.LBB80:
  88:../Libraries/AQ_Receiver/Receiver.h ****   for(byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 3803              		.loc 7 88 0
 3804 0002 0024     		movs	r4, #0
 3805 0004 33E0     		b	.L212
 3806              	.LVL186:
 3807              	.L213:
  91:../Libraries/AQ_Receiver/Receiver.h ****     receiverData[channel] = (receiverSlope[channel] * getRawChannelValue(channel)) + receiverOffset
 3808              		.loc 7 91 0 discriminator 2
 3809 0006 2046     		mov	r0, r4
 3810 0008 FFF7FEFF 		bl	_Z18getRawChannelValueh
 3811 000c 2D49     		ldr	r1, .L218
 3812 000e 02EE900A 		fmsr	s5, r0	@ int
 3813 0012 2D48     		ldr	r0, .L218+4
 3814 0014 A300     		lsls	r3, r4, #2
 3815 0016 CA18     		adds	r2, r1, r3
 3816 0018 C118     		adds	r1, r0, r3
 3817 001a 92ED007A 		flds	s14, [r2, #0]
 3818 001e 91ED002A 		flds	s4, [r1, #0]
 3819 0022 F8EEE26A 		fsitos	s13, s5
 3820 0026 294A     		ldr	r2, .L218+8
  93:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = filterSmooth(receiverData[channel], receiverCommandSmooth[chan
 3821              		.loc 7 93 0 discriminator 2
 3822 0028 2949     		ldr	r1, .L218+12
  91:../Libraries/AQ_Receiver/Receiver.h ****     receiverData[channel] = (receiverSlope[channel] * getRawChannelValue(channel)) + receiverOffset
 3823              		.loc 7 91 0 discriminator 2
 3824 002a 06EE872A 		fmacs	s4, s13, s14
  93:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = filterSmooth(receiverData[channel], receiverCommandSmooth[chan
 3825              		.loc 7 93 0 discriminator 2
 3826 002e CB18     		adds	r3, r1, r3
  91:../Libraries/AQ_Receiver/Receiver.h ****     receiverData[channel] = (receiverSlope[channel] * getRawChannelValue(channel)) + receiverOffset
 3827              		.loc 7 91 0 discriminator 2
 3828 0030 FDEEC21A 		ftosizs	s3, s4
 3829 0034 11EE900A 		fmrs	r0, s3	@ int
 3830 0038 42F82400 		str	r0, [r2, r4, lsl #2]
  93:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = filterSmooth(receiverData[channel], receiverCommandSmooth[chan
 3831              		.loc 7 93 0 discriminator 2
 3832 003c 55F82420 		ldr	r2, [r5, r4, lsl #2]
 3833 0040 01EE102A 		fmsr	s2, r2	@ int
 3834 0044 F8EEE17A 		fsitos	s15, s3
 3835 0048 F8EEC10A 		fsitos	s1, s2
 3836 004c 17EE900A 		fmrs	r0, s15
 3837 0050 10EE901A 		fmrs	r1, s1
 3838 0054 1A68     		ldr	r2, [r3, #0]	@ float
 3839 0056 FFF7FEFF 		bl	_Z12filterSmoothfff
 3840 005a 00EE100A 		fmsr	s0, r0
 3841 005e BDEEC06A 		ftosizs	s12, s0
 3842 0062 16EE100A 		fmrs	r0, s12	@ int
 3843 0066 45F82400 		str	r0, [r5, r4, lsl #2]
  88:../Libraries/AQ_Receiver/Receiver.h ****   for(byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 3844              		.loc 7 88 0 discriminator 2
 3845 006a 0134     		adds	r4, r4, #1
 3846              	.LVL187:
 3847 006c E4B2     		uxtb	r4, r4
 3848              	.LVL188:
 3849              	.L212:
  88:../Libraries/AQ_Receiver/Receiver.h ****   for(byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 3850              		.loc 7 88 0 is_stmt 0 discriminator 1
 3851 006e 194D     		ldr	r5, .L218+16
 3852 0070 2A68     		ldr	r2, [r5, #0]
 3853 0072 194D     		ldr	r5, .L218+20
 3854 0074 9442     		cmp	r4, r2
 3855 0076 C6DB     		blt	.L213
 3856              	.LVL189:
 3857              	.LBE80:
 3858              	.LBB81:
  98:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommand[channel] = ((receiverCommandSmooth[channel] - receiverZero[channel]) * receiver
 3859              		.loc 7 98 0 is_stmt 1
 3860 0078 184C     		ldr	r4, .L218+24
 3861              	.LVL190:
 3862 007a 94ED007A 		flds	s14, [r4, #0]
 3863 007e 0023     		movs	r3, #0
 3864              	.LVL191:
 3865              	.L214:
  98:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommand[channel] = ((receiverCommandSmooth[channel] - receiverZero[channel]) * receiver
 3866              		.loc 7 98 0 is_stmt 0 discriminator 2
 3867 0080 1749     		ldr	r1, .L218+28
 3868 0082 EC58     		ldr	r4, [r5, r3]
 3869 0084 5858     		ldr	r0, [r3, r1]
 3870 0086 1749     		ldr	r1, .L218+32
 3871 0088 241A     		subs	r4, r4, r0
 3872 008a 05EE104A 		fmsr	s10, r4	@ int
 3873 008e 04EE900A 		fmsr	s9, r0	@ int
 3874 0092 B8EEC54A 		fsitos	s8, s10
 3875 0096 F8EEE43A 		fsitos	s7, s9
 3876 009a 44EE073A 		fmacs	s7, s8, s14
 3877 009e BDEEE33A 		ftosizs	s6, s7
 3878 00a2 13EE100A 		fmrs	r0, s6	@ int
 3879 00a6 5850     		str	r0, [r3, r1]
 3880 00a8 0433     		adds	r3, r3, #4
  97:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < THROTTLE; channel++) {
 3881              		.loc 7 97 0 is_stmt 1 discriminator 2
 3882 00aa 0C2B     		cmp	r3, #12
 3883 00ac E8D1     		bne	.L214
  97:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < THROTTLE; channel++) {
 3884              		.loc 7 97 0 is_stmt 0
 3885 00ae 0323     		movs	r3, #3
 3886 00b0 05E0     		b	.L215
 3887              	.LVL192:
 3888              	.L216:
 3889              	.LBE81:
 3890              	.LBB82:
 102:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommand[channel] = receiverCommandSmooth[channel];
 3891              		.loc 7 102 0 is_stmt 1 discriminator 2
 3892 00b2 55F82300 		ldr	r0, [r5, r3, lsl #2]
 3893 00b6 41F82300 		str	r0, [r1, r3, lsl #2]
 101:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = THROTTLE; channel < lastReceiverChannel; channel++) {
 3894              		.loc 7 101 0 discriminator 2
 3895 00ba 0133     		adds	r3, r3, #1
 3896              	.LVL193:
 3897 00bc DBB2     		uxtb	r3, r3
 3898              	.LVL194:
 3899              	.L215:
 101:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = THROTTLE; channel < lastReceiverChannel; channel++) {
 3900              		.loc 7 101 0 is_stmt 0 discriminator 1
 3901 00be 9342     		cmp	r3, r2
 3902 00c0 F7DB     		blt	.L216
 3903              	.LBE82:
 104:../Libraries/AQ_Receiver/Receiver.h **** }
 3904              		.loc 7 104 0 is_stmt 1
 3905 00c2 38BD     		pop	{r3, r4, r5, pc}
 3906              	.L219:
 3907              		.align	2
 3908              	.L218:
 3909 00c4 00000000 		.word	.LANCHOR12
 3910 00c8 00000000 		.word	.LANCHOR13
 3911 00cc 00000000 		.word	.LANCHOR60
 3912 00d0 00000000 		.word	.LANCHOR14
 3913 00d4 00000000 		.word	.LANCHOR9
 3914 00d8 00000000 		.word	.LANCHOR10
 3915 00dc 00000000 		.word	.LANCHOR61
 3916 00e0 00000000 		.word	.LANCHOR11
 3917 00e4 00000000 		.word	.LANCHOR6
 3918              		.cfi_endproc
 3919              	.LFE122:
 3921              		.section	.text._Z15setChannelValuehi,"ax",%progbits
 3922              		.align	1
 3923              		.global	_Z15setChannelValuehi
 3924              		.thumb
 3925              		.thumb_func
 3927              	_Z15setChannelValuehi:
 3928              	.LFB175:
 214:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 215:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 216:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** void setChannelValue(byte channel,int value) {
 3929              		.loc 4 216 0
 3930              		.cfi_startproc
 3931              		@ args = 0, pretend = 0, frame = 0
 3932              		@ frame_needed = 0, uses_anonymous_args = 0
 3933              		@ link register save eliminated.
 3934              	.LVL195:
 217:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** }
 3935              		.loc 4 217 0
 3936 0000 7047     		bx	lr
 3937              		.cfi_endproc
 3938              	.LFE175:
 3940              		.section	.text._Z14_initMotorInfoii,"ax",%progbits
 3941              		.align	1
 3942              		.global	_Z14_initMotorInfoii
 3943              		.thumb
 3944              		.thumb_func
 3946              	_Z14_initMotorInfoii:
 3947              	.LFB177:
 3948              		.file 17 "../Libraries/AQ_Motors/Motors_STM32.h"
   1:../Libraries/AQ_Motors/Motors_STM32.h **** #ifndef _AEROQUAD_MOTORS_STM32_H_
   2:../Libraries/AQ_Motors/Motors_STM32.h **** #define _AEROQUAD_MOTORS_STM32_H_
   3:../Libraries/AQ_Motors/Motors_STM32.h **** 
   4:../Libraries/AQ_Motors/Motors_STM32.h **** #if defined(AeroQuadSTM32)
   5:../Libraries/AQ_Motors/Motors_STM32.h **** 
   6:../Libraries/AQ_Motors/Motors_STM32.h **** #include "Motors.h"
   7:../Libraries/AQ_Motors/Motors_STM32.h **** 
   8:../Libraries/AQ_Motors/Motors_STM32.h **** ////////////////////////////////////////////////////////
   9:../Libraries/AQ_Motors/Motors_STM32.h **** // definition section
  10:../Libraries/AQ_Motors/Motors_STM32.h **** 
  11:../Libraries/AQ_Motors/Motors_STM32.h **** #define PWM_FREQUENCY 400 // Hz
  12:../Libraries/AQ_Motors/Motors_STM32.h **** 
  13:../Libraries/AQ_Motors/Motors_STM32.h **** #if defined(BOARD_aeroquad32)
  14:../Libraries/AQ_Motors/Motors_STM32.h ****   static byte stm32_motor_mapping[] = {
  15:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('C',  9),
  16:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('C',  8),
  17:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('C',  7),
  18:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('C',  6),
  19:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('A', 15),
  20:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('B',  3),
  21:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('B',  4),
  22:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('B',  5)
  23:../Libraries/AQ_Motors/Motors_STM32.h ****   };
  24:../Libraries/AQ_Motors/Motors_STM32.h **** #elif defined(BOARD_aeroquad32mini)
  25:../Libraries/AQ_Motors/Motors_STM32.h ****   static byte stm32_motor_mapping[] = {3, 9, 10, 11, 12, 13};
  26:../Libraries/AQ_Motors/Motors_STM32.h **** #elif defined(BOARD_freeflight)
  27:../Libraries/AQ_Motors/Motors_STM32.h ****   static byte stm32_motor_mapping[] = {
  28:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('B',  6),
  29:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('B',  7),
  30:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('B',  8),
  31:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('B',  9),
  32:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('A',  8),
  33:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('A', 11)
  34:../Libraries/AQ_Motors/Motors_STM32.h ****   };
  35:../Libraries/AQ_Motors/Motors_STM32.h **** #elif defined(BOARD_discovery_f4)
  36:../Libraries/AQ_Motors/Motors_STM32.h ****   static byte stm32_motor_mapping[] = {
  37:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('C',  9),
  38:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('C',  8),
  39:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('C',  7),
  40:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('C',  6),
  41:../Libraries/AQ_Motors/Motors_STM32.h **** 	// pin mapping for motor 5-8 not specified, yet
  42:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('A', 15),
  43:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('B',  3),
  44:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('B',  4),
  45:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('B',  5)
  46:../Libraries/AQ_Motors/Motors_STM32.h ****   };
  47:../Libraries/AQ_Motors/Motors_STM32.h **** #else
  48:../Libraries/AQ_Motors/Motors_STM32.h ****   #error "No motor pinout defined for this STM32 board"
  49:../Libraries/AQ_Motors/Motors_STM32.h **** #endif
  50:../Libraries/AQ_Motors/Motors_STM32.h **** 
  51:../Libraries/AQ_Motors/Motors_STM32.h **** 
  52:../Libraries/AQ_Motors/Motors_STM32.h **** ////////////////////////////////////////////////////////
  53:../Libraries/AQ_Motors/Motors_STM32.h **** // code section
  54:../Libraries/AQ_Motors/Motors_STM32.h **** 
  55:../Libraries/AQ_Motors/Motors_STM32.h **** #define PWM_PERIODE (1000000/PWM_FREQUENCY)
  56:../Libraries/AQ_Motors/Motors_STM32.h **** 
  57:../Libraries/AQ_Motors/Motors_STM32.h ****   // private section
  58:../Libraries/AQ_Motors/Motors_STM32.h ****   static int _stm32_motor_number;
  59:../Libraries/AQ_Motors/Motors_STM32.h **** 
  60:../Libraries/AQ_Motors/Motors_STM32.h ****   struct _sMotorInfo {
  61:../Libraries/AQ_Motors/Motors_STM32.h **** 	int			pin;
  62:../Libraries/AQ_Motors/Motors_STM32.h ****     timer_dev 	*timer_device;	/**< Pin's timer device, if any. */
  63:../Libraries/AQ_Motors/Motors_STM32.h ****     uint8 		timer_channel;  /**< Timer channel, or 0 if none. */
  64:../Libraries/AQ_Motors/Motors_STM32.h ****   } MotorInfo[8];
  65:../Libraries/AQ_Motors/Motors_STM32.h **** 
  66:../Libraries/AQ_Motors/Motors_STM32.h ****   void _initMotorInfo(int motor, int pin) {
 3949              		.loc 17 66 0
 3950              		.cfi_startproc
 3951              		@ args = 0, pretend = 0, frame = 0
 3952              		@ frame_needed = 0, uses_anonymous_args = 0
 3953              	.LVL196:
  67:../Libraries/AQ_Motors/Motors_STM32.h **** 	  MotorInfo[motor].pin           = pin;
 3954              		.loc 17 67 0
 3955 0000 0C22     		movs	r2, #12
 3956 0002 4243     		muls	r2, r0, r2
 3957 0004 054B     		ldr	r3, .L222
  66:../Libraries/AQ_Motors/Motors_STM32.h ****   void _initMotorInfo(int motor, int pin) {
 3958              		.loc 17 66 0
 3959 0006 10B5     		push	{r4, lr}
 3960              	.LCFI41:
 3961              		.cfi_def_cfa_offset 8
 3962              		.cfi_offset 14, -4
 3963              		.cfi_offset 4, -8
 3964              		.loc 17 67 0
 3965 0008 9C18     		adds	r4, r3, r2
 3966 000a 9950     		str	r1, [r3, r2]
  68:../Libraries/AQ_Motors/Motors_STM32.h **** 	  MotorInfo[motor].timer_device  = PIN_MAP[pin].timer_device;
 3967              		.loc 17 68 0
 3968 000c 044A     		ldr	r2, .L222+4
 3969 000e 02EB0111 		add	r1, r2, r1, lsl #4
 3970              	.LVL197:
 3971 0012 4868     		ldr	r0, [r1, #4]
 3972              	.LVL198:
 3973 0014 6060     		str	r0, [r4, #4]
  69:../Libraries/AQ_Motors/Motors_STM32.h **** 	  MotorInfo[motor].timer_channel = PIN_MAP[pin].timer_channel;
 3974              		.loc 17 69 0
 3975 0016 4B7B     		ldrb	r3, [r1, #13]	@ zero_extendqisi2
 3976 0018 2372     		strb	r3, [r4, #8]
  70:../Libraries/AQ_Motors/Motors_STM32.h ****   }
 3977              		.loc 17 70 0
 3978 001a 10BD     		pop	{r4, pc}
 3979              	.L223:
 3980              		.align	2
 3981              	.L222:
 3982 001c 00000000 		.word	.LANCHOR62
 3983 0020 00000000 		.word	PIN_MAP
 3984              		.cfi_endproc
 3985              	.LFE177:
 3987              		.section	.text._Z11writeMotorsv,"ax",%progbits
 3988              		.align	1
 3989              		.global	_Z11writeMotorsv
 3990              		.thumb
 3991              		.thumb_func
 3993              	_Z11writeMotorsv:
 3994              	.LFB179:
  71:../Libraries/AQ_Motors/Motors_STM32.h **** 
  72:../Libraries/AQ_Motors/Motors_STM32.h ****   // global section
  73:../Libraries/AQ_Motors/Motors_STM32.h **** 
  74:../Libraries/AQ_Motors/Motors_STM32.h ****   void initializeMotors(NB_Motors numbers) {
  75:../Libraries/AQ_Motors/Motors_STM32.h **** 	_stm32_motor_number = sizeof(stm32_motor_mapping)/sizeof(stm32_motor_mapping[0]);
  76:../Libraries/AQ_Motors/Motors_STM32.h **** 	if(numbers < _stm32_motor_number) {
  77:../Libraries/AQ_Motors/Motors_STM32.h **** 		_stm32_motor_number = numbers;
  78:../Libraries/AQ_Motors/Motors_STM32.h **** 	}
  79:../Libraries/AQ_Motors/Motors_STM32.h **** 
  80:../Libraries/AQ_Motors/Motors_STM32.h **** 	int motor;
  81:../Libraries/AQ_Motors/Motors_STM32.h ****     for(motor=0; motor < _stm32_motor_number; motor++) {
  82:../Libraries/AQ_Motors/Motors_STM32.h ****     	_initMotorInfo(motor, stm32_motor_mapping[motor]);
  83:../Libraries/AQ_Motors/Motors_STM32.h **** 
  84:../Libraries/AQ_Motors/Motors_STM32.h ****     	int prescaler = rcc_dev_timer_clk_speed(MotorInfo[motor].timer_device->clk_id)/1000000 - 1;
  85:../Libraries/AQ_Motors/Motors_STM32.h ****     	timer_set_prescaler(MotorInfo[motor].timer_device, prescaler);
  86:../Libraries/AQ_Motors/Motors_STM32.h ****     	timer_set_reload(MotorInfo[motor].timer_device, PWM_PERIODE);
  87:../Libraries/AQ_Motors/Motors_STM32.h **** 
  88:../Libraries/AQ_Motors/Motors_STM32.h ****     	pinMode(MotorInfo[motor].pin, PWM);
  89:../Libraries/AQ_Motors/Motors_STM32.h ****     }
  90:../Libraries/AQ_Motors/Motors_STM32.h **** 
  91:../Libraries/AQ_Motors/Motors_STM32.h ****     // sync timer
  92:../Libraries/AQ_Motors/Motors_STM32.h ****     for(motor=0; motor < _stm32_motor_number; motor++) {
  93:../Libraries/AQ_Motors/Motors_STM32.h ****     	timer_generate_update(MotorInfo[motor].timer_device);
  94:../Libraries/AQ_Motors/Motors_STM32.h ****     }
  95:../Libraries/AQ_Motors/Motors_STM32.h **** 
  96:../Libraries/AQ_Motors/Motors_STM32.h ****     commandAllMotors(1000);
  97:../Libraries/AQ_Motors/Motors_STM32.h **** 	//Serial.println("motor init done\r\n");
  98:../Libraries/AQ_Motors/Motors_STM32.h ****   }
  99:../Libraries/AQ_Motors/Motors_STM32.h **** 
 100:../Libraries/AQ_Motors/Motors_STM32.h ****   void writeMotors(void) {
 3995              		.loc 17 100 0
 3996              		.cfi_startproc
 3997              		@ args = 0, pretend = 0, frame = 0
 3998              		@ frame_needed = 0, uses_anonymous_args = 0
 3999              	.LVL199:
 4000 0000 70B5     		push	{r4, r5, r6, lr}
 4001              	.LCFI42:
 4002              		.cfi_def_cfa_offset 16
 4003              		.cfi_offset 14, -4
 4004              		.cfi_offset 6, -8
 4005              		.cfi_offset 5, -12
 4006              		.cfi_offset 4, -16
 4007              	.LBB83:
 101:../Libraries/AQ_Motors/Motors_STM32.h **** 	for(int motor=0; motor < _stm32_motor_number; motor++) {
 4008              		.loc 17 101 0
 4009 0002 0A4C     		ldr	r4, .L227
 4010 0004 0A4E     		ldr	r6, .L227+4
 4011 0006 0025     		movs	r5, #0
 4012 0008 09E0     		b	.L225
 4013              	.LVL200:
 4014              	.L226:
 102:../Libraries/AQ_Motors/Motors_STM32.h **** 	   	timer_set_compare(MotorInfo[motor].timer_device, MotorInfo[motor].timer_channel,  motorCommand
 4015              		.loc 17 102 0 discriminator 2
 4016 000a 56F8042F 		ldr	r2, [r6, #4]!
 4017 000e 54F80C0C 		ldr	r0, [r4, #-12]
 4018 0012 14F8081C 		ldrb	r1, [r4, #-8]	@ zero_extendqisi2
 4019 0016 92B2     		uxth	r2, r2
 4020 0018 FFF7FEFF 		bl	timer_set_compare
 101:../Libraries/AQ_Motors/Motors_STM32.h **** 	for(int motor=0; motor < _stm32_motor_number; motor++) {
 4021              		.loc 17 101 0 discriminator 2
 4022 001c 0135     		adds	r5, r5, #1
 4023              	.LVL201:
 4024              	.L225:
 101:../Libraries/AQ_Motors/Motors_STM32.h **** 	for(int motor=0; motor < _stm32_motor_number; motor++) {
 4025              		.loc 17 101 0 is_stmt 0 discriminator 1
 4026 001e 0548     		ldr	r0, .L227+8
 4027 0020 0368     		ldr	r3, [r0, #0]
 4028 0022 0C34     		adds	r4, r4, #12
 4029 0024 9D42     		cmp	r5, r3
 4030 0026 F0DB     		blt	.L226
 4031              	.LBE83:
 103:../Libraries/AQ_Motors/Motors_STM32.h **** 	}
 104:../Libraries/AQ_Motors/Motors_STM32.h ****   }
 4032              		.loc 17 104 0 is_stmt 1
 4033 0028 70BD     		pop	{r4, r5, r6, pc}
 4034              	.L228:
 4035 002a 00BF     		.align	2
 4036              	.L227:
 4037 002c 04000000 		.word	.LANCHOR62+4
 4038 0030 FCFFFFFF 		.word	.LANCHOR63-4
 4039 0034 00000000 		.word	.LANCHOR64
 4040              		.cfi_endproc
 4041              	.LFE179:
 4043              		.section	.text._Z16commandAllMotorsi,"ax",%progbits
 4044              		.align	1
 4045              		.global	_Z16commandAllMotorsi
 4046              		.thumb
 4047              		.thumb_func
 4049              	_Z16commandAllMotorsi:
 4050              	.LFB180:
 105:../Libraries/AQ_Motors/Motors_STM32.h **** 
 106:../Libraries/AQ_Motors/Motors_STM32.h ****   void commandAllMotors(int _motorCommand) {   // Sends commands to all motors
 4051              		.loc 17 106 0
 4052              		.cfi_startproc
 4053              		@ args = 0, pretend = 0, frame = 0
 4054              		@ frame_needed = 0, uses_anonymous_args = 0
 4055              	.LVL202:
 4056 0000 70B5     		push	{r4, r5, r6, lr}
 4057              	.LCFI43:
 4058              		.cfi_def_cfa_offset 16
 4059              		.cfi_offset 14, -4
 4060              		.cfi_offset 6, -8
 4061              		.cfi_offset 5, -12
 4062              		.cfi_offset 4, -16
 4063              		.loc 17 106 0
 4064 0002 0646     		mov	r6, r0
 4065              	.LBB84:
 107:../Libraries/AQ_Motors/Motors_STM32.h **** 	for(int motor=0; motor < _stm32_motor_number; motor++) {
 4066              		.loc 17 107 0
 4067 0004 084C     		ldr	r4, .L232
 4068 0006 0025     		movs	r5, #0
 4069 0008 07E0     		b	.L230
 4070              	.LVL203:
 4071              	.L231:
 108:../Libraries/AQ_Motors/Motors_STM32.h **** 	   	timer_set_compare(MotorInfo[motor].timer_device, MotorInfo[motor].timer_channel, _motorCommand
 4072              		.loc 17 108 0 discriminator 2
 4073 000a 54F80C0C 		ldr	r0, [r4, #-12]
 4074 000e 14F8081C 		ldrb	r1, [r4, #-8]	@ zero_extendqisi2
 4075 0012 B2B2     		uxth	r2, r6
 4076 0014 FFF7FEFF 		bl	timer_set_compare
 107:../Libraries/AQ_Motors/Motors_STM32.h **** 	for(int motor=0; motor < _stm32_motor_number; motor++) {
 4077              		.loc 17 107 0 discriminator 2
 4078 0018 0135     		adds	r5, r5, #1
 4079              	.LVL204:
 4080              	.L230:
 107:../Libraries/AQ_Motors/Motors_STM32.h **** 	for(int motor=0; motor < _stm32_motor_number; motor++) {
 4081              		.loc 17 107 0 is_stmt 0 discriminator 1
 4082 001a 0448     		ldr	r0, .L232+4
 4083 001c 0368     		ldr	r3, [r0, #0]
 4084 001e 0C34     		adds	r4, r4, #12
 4085 0020 9D42     		cmp	r5, r3
 4086 0022 F2DB     		blt	.L231
 4087              	.LBE84:
 109:../Libraries/AQ_Motors/Motors_STM32.h **** 	}
 110:../Libraries/AQ_Motors/Motors_STM32.h ****   }
 4088              		.loc 17 110 0 is_stmt 1
 4089 0024 70BD     		pop	{r4, r5, r6, pc}
 4090              	.L233:
 4091 0026 00BF     		.align	2
 4092              	.L232:
 4093 0028 04000000 		.word	.LANCHOR62+4
 4094 002c 00000000 		.word	.LANCHOR64
 4095              		.cfi_endproc
 4096              	.LFE180:
 4098              		.section	.text._Z16initializeMotors9NB_Motors,"ax",%progbits
 4099              		.align	1
 4100              		.global	_Z16initializeMotors9NB_Motors
 4101              		.thumb
 4102              		.thumb_func
 4104              	_Z16initializeMotors9NB_Motors:
 4105              	.LFB178:
  74:../Libraries/AQ_Motors/Motors_STM32.h ****   void initializeMotors(NB_Motors numbers) {
 4106              		.loc 17 74 0
 4107              		.cfi_startproc
 4108              		@ args = 0, pretend = 0, frame = 0
 4109              		@ frame_needed = 0, uses_anonymous_args = 0
 4110              	.LVL205:
 4111 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 4112              	.LCFI44:
 4113              		.cfi_def_cfa_offset 24
 4114              		.cfi_offset 14, -4
 4115              		.cfi_offset 7, -8
 4116              		.cfi_offset 6, -12
 4117              		.cfi_offset 5, -16
 4118              		.cfi_offset 4, -20
 4119              		.cfi_offset 3, -24
 4120 0002 1F4F     		ldr	r7, .L240
 4121              	.LBB98:
  77:../Libraries/AQ_Motors/Motors_STM32.h **** 		_stm32_motor_number = numbers;
 4122              		.loc 17 77 0
 4123 0004 1F4E     		ldr	r6, .L240+4
 4124 0006 0728     		cmp	r0, #7
 4125 0008 C8BF     		it	gt
 4126 000a 0820     		movgt	r0, #8
 4127              	.LVL206:
 4128 000c 3860     		str	r0, [r7, #0]
 4129              	.LBE98:
  74:../Libraries/AQ_Motors/Motors_STM32.h ****   void initializeMotors(NB_Motors numbers) {
 4130              		.loc 17 74 0
 4131 000e 3546     		mov	r5, r6
 4132 0010 0024     		movs	r4, #0
 4133 0012 1BE0     		b	.L236
 4134              	.LVL207:
 4135              	.L237:
 4136              	.LBB119:
 4137              	.LBB99:
 4138              	.LBB100:
  82:../Libraries/AQ_Motors/Motors_STM32.h ****     	_initMotorInfo(motor, stm32_motor_mapping[motor]);
 4139              		.loc 17 82 0 discriminator 2
 4140 0014 1C4A     		ldr	r2, .L240+8
 4141 0016 2046     		mov	r0, r4
 4142 0018 115D     		ldrb	r1, [r2, r4]	@ zero_extendqisi2
 4143 001a FFF7FEFF 		bl	_Z14_initMotorInfoii
  84:../Libraries/AQ_Motors/Motors_STM32.h ****     	int prescaler = rcc_dev_timer_clk_speed(MotorInfo[motor].timer_device->clk_id)/1000000 - 1;
 4144              		.loc 17 84 0 discriminator 2
 4145 001e 55F80C0C 		ldr	r0, [r5, #-12]
 4146 0022 0079     		ldrb	r0, [r0, #4]	@ zero_extendqisi2
 4147 0024 FFF7FEFF 		bl	rcc_dev_timer_clk_speed
 4148              	.LVL208:
 4149 0028 1849     		ldr	r1, .L240+12
 4150              	.LBB101:
 4151              	.LBB102:
 682:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->PSC = psc;
 4152              		.loc 1 682 0 discriminator 2
 4153 002a 55F80C3C 		ldr	r3, [r5, #-12]
 4154              	.LBE102:
 4155              	.LBE101:
  84:../Libraries/AQ_Motors/Motors_STM32.h ****     	int prescaler = rcc_dev_timer_clk_speed(MotorInfo[motor].timer_device->clk_id)/1000000 - 1;
 4156              		.loc 17 84 0 discriminator 2
 4157 002e B0FBF1F2 		udiv	r2, r0, r1
 4158              	.LBB106:
 4159              	.LBB103:
 682:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->PSC = psc;
 4160              		.loc 1 682 0 discriminator 2
 4161 0032 1B68     		ldr	r3, [r3, #0]
 4162              	.LBE103:
 4163              	.LBE106:
  84:../Libraries/AQ_Motors/Motors_STM32.h ****     	int prescaler = rcc_dev_timer_clk_speed(MotorInfo[motor].timer_device->clk_id)/1000000 - 1;
 4164              		.loc 17 84 0 discriminator 2
 4165 0034 511E     		subs	r1, r2, #1
 4166              	.LBB107:
 4167              	.LBB104:
 682:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->PSC = psc;
 4168              		.loc 1 682 0 discriminator 2
 4169 0036 88B2     		uxth	r0, r1
 4170              	.LVL209:
 4171              	.LBE104:
 4172              	.LBE107:
 4173              	.LBB108:
 4174              	.LBB109:
 700:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->ARR = arr;
 4175              		.loc 1 700 0 discriminator 2
 4176 0038 40F6C412 		movw	r2, #2500
 4177              	.LBE109:
 4178              	.LBE108:
 4179              	.LBB111:
 4180              	.LBB105:
 682:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->PSC = psc;
 4181              		.loc 1 682 0 discriminator 2
 4182 003c 9862     		str	r0, [r3, #40]
 4183              	.LVL210:
 4184              	.LBE105:
 4185              	.LBE111:
 4186              	.LBB112:
 4187              	.LBB110:
 700:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->ARR = arr;
 4188              		.loc 1 700 0 discriminator 2
 4189 003e DA62     		str	r2, [r3, #44]
 4190              	.LBE110:
 4191              	.LBE112:
  88:../Libraries/AQ_Motors/Motors_STM32.h ****     	pinMode(MotorInfo[motor].pin, PWM);
 4192              		.loc 17 88 0 discriminator 2
 4193 0040 15F8100C 		ldrb	r0, [r5, #-16]	@ zero_extendqisi2
 4194 0044 0721     		movs	r1, #7
 4195              	.LVL211:
 4196 0046 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 4197              	.LVL212:
 4198              	.LBE100:
  81:../Libraries/AQ_Motors/Motors_STM32.h ****     for(motor=0; motor < _stm32_motor_number; motor++) {
 4199              		.loc 17 81 0 discriminator 2
 4200 004a 0134     		adds	r4, r4, #1
 4201              	.LVL213:
 4202              	.L236:
  81:../Libraries/AQ_Motors/Motors_STM32.h ****     for(motor=0; motor < _stm32_motor_number; motor++) {
 4203              		.loc 17 81 0 is_stmt 0 discriminator 1
 4204 004c 3968     		ldr	r1, [r7, #0]
 4205 004e 0C35     		adds	r5, r5, #12
 4206 0050 8C42     		cmp	r4, r1
 4207 0052 DFDB     		blt	.L237
  81:../Libraries/AQ_Motors/Motors_STM32.h ****     for(motor=0; motor < _stm32_motor_number; motor++) {
 4208              		.loc 17 81 0
 4209 0054 0023     		movs	r3, #0
 4210 0056 09E0     		b	.L238
 4211              	.LVL214:
 4212              	.L239:
 4213              	.LBE99:
 4214              	.LBB113:
 4215              	.LBB114:
 725:../Libmaple/libmaple/libmaple/timer.h **** 
 726:../Libmaple/libmaple/libmaple/timer.h **** /**
 727:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Generate an update event for the given timer.
 728:../Libmaple/libmaple/libmaple/timer.h ****  *
 729:../Libmaple/libmaple/libmaple/timer.h ****  * Normally, this will cause the prescaler and auto-reload values in
 730:../Libmaple/libmaple/libmaple/timer.h ****  * the PSC and ARR registers to take immediate effect.  However, this
 731:../Libmaple/libmaple/libmaple/timer.h ****  * function will do nothing if the UDIS bit is set in the timer's CR1
 732:../Libmaple/libmaple/libmaple/timer.h ****  * register (UDIS is cleared by default).
 733:../Libmaple/libmaple/libmaple/timer.h ****  *
 734:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer device to generate an update for.
 735:../Libmaple/libmaple/libmaple/timer.h ****  */
 736:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_generate_update(timer_dev *dev) {
 737:../Libmaple/libmaple/libmaple/timer.h ****     *bb_perip(&(dev->regs).bas->EGR, TIMER_EGR_UG_BIT) = 1;
 4216              		.loc 1 737 0 is_stmt 1 discriminator 2
 4217 0058 56F80C0C 		ldr	r0, [r6, #-12]
 4218 005c 0268     		ldr	r2, [r0, #0]
 4219              	.LVL215:
 4220              	.LBB115:
 4221              	.LBB116:
 4222              	.LBB117:
 4223              	.LBB118:
 4224              		.file 18 "../Libmaple/libmaple/libmaple/bitband.h"
   1:../Libmaple/libmaple/libmaple/bitband.h **** /******************************************************************************
   2:../Libmaple/libmaple/libmaple/bitband.h ****  * The MIT License
   3:../Libmaple/libmaple/libmaple/bitband.h ****  *
   4:../Libmaple/libmaple/libmaple/bitband.h ****  * Copyright (c) 2011 LeafLabs, LLC.
   5:../Libmaple/libmaple/libmaple/bitband.h ****  *
   6:../Libmaple/libmaple/libmaple/bitband.h ****  * Permission is hereby granted, free of charge, to any person
   7:../Libmaple/libmaple/libmaple/bitband.h ****  * obtaining a copy of this software and associated documentation
   8:../Libmaple/libmaple/libmaple/bitband.h ****  * files (the "Software"), to deal in the Software without
   9:../Libmaple/libmaple/libmaple/bitband.h ****  * restriction, including without limitation the rights to use, copy,
  10:../Libmaple/libmaple/libmaple/bitband.h ****  * modify, merge, publish, distribute, sublicense, and/or sell copies
  11:../Libmaple/libmaple/libmaple/bitband.h ****  * of the Software, and to permit persons to whom the Software is
  12:../Libmaple/libmaple/libmaple/bitband.h ****  * furnished to do so, subject to the following conditions:
  13:../Libmaple/libmaple/libmaple/bitband.h ****  *
  14:../Libmaple/libmaple/libmaple/bitband.h ****  * The above copyright notice and this permission notice shall be
  15:../Libmaple/libmaple/libmaple/bitband.h ****  * included in all copies or substantial portions of the Software.
  16:../Libmaple/libmaple/libmaple/bitband.h ****  *
  17:../Libmaple/libmaple/libmaple/bitband.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  18:../Libmaple/libmaple/libmaple/bitband.h ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  19:../Libmaple/libmaple/libmaple/bitband.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20:../Libmaple/libmaple/libmaple/bitband.h ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  21:../Libmaple/libmaple/libmaple/bitband.h ****  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  22:../Libmaple/libmaple/libmaple/bitband.h ****  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  23:../Libmaple/libmaple/libmaple/bitband.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  24:../Libmaple/libmaple/libmaple/bitband.h ****  * SOFTWARE.
  25:../Libmaple/libmaple/libmaple/bitband.h ****  *****************************************************************************/
  26:../Libmaple/libmaple/libmaple/bitband.h **** 
  27:../Libmaple/libmaple/libmaple/bitband.h **** /**
  28:../Libmaple/libmaple/libmaple/bitband.h ****  * @file bitband.h
  29:../Libmaple/libmaple/libmaple/bitband.h ****  *
  30:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Bit-banding utility functions
  31:../Libmaple/libmaple/libmaple/bitband.h ****  */
  32:../Libmaple/libmaple/libmaple/bitband.h **** 
  33:../Libmaple/libmaple/libmaple/bitband.h **** #include "libmaple_types.h"
  34:../Libmaple/libmaple/libmaple/bitband.h **** 
  35:../Libmaple/libmaple/libmaple/bitband.h **** #ifndef _BITBAND_H_
  36:../Libmaple/libmaple/libmaple/bitband.h **** #define _BITBAND_H_
  37:../Libmaple/libmaple/libmaple/bitband.h **** 
  38:../Libmaple/libmaple/libmaple/bitband.h **** #define BB_SRAM_REF      0x20000000
  39:../Libmaple/libmaple/libmaple/bitband.h **** #define BB_SRAM_BASE     0x22000000
  40:../Libmaple/libmaple/libmaple/bitband.h **** #define BB_PERI_REF      0x40000000
  41:../Libmaple/libmaple/libmaple/bitband.h **** #define BB_PERI_BASE     0x42000000
  42:../Libmaple/libmaple/libmaple/bitband.h **** 
  43:../Libmaple/libmaple/libmaple/bitband.h **** static inline volatile uint32* __bb_addr(volatile void*,
  44:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32,
  45:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32,
  46:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32);
  47:../Libmaple/libmaple/libmaple/bitband.h **** 
  48:../Libmaple/libmaple/libmaple/bitband.h **** /**
  49:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Obtain a pointer to the bit-band address corresponding to a
  50:../Libmaple/libmaple/libmaple/bitband.h ****  * bit in a volatile SRAM address.
  51:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the bit-banded SRAM region
  52:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit     Bit in address to bit-band
  53:../Libmaple/libmaple/libmaple/bitband.h ****  */
  54:../Libmaple/libmaple/libmaple/bitband.h **** static inline volatile uint32* bb_sramp(volatile void *address, uint32 bit) {
  55:../Libmaple/libmaple/libmaple/bitband.h ****     return __bb_addr(address, bit, BB_SRAM_BASE, BB_SRAM_REF);
  56:../Libmaple/libmaple/libmaple/bitband.h **** }
  57:../Libmaple/libmaple/libmaple/bitband.h **** 
  58:../Libmaple/libmaple/libmaple/bitband.h **** /**
  59:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Get a bit from an address in the SRAM bit-band region.
  60:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the SRAM bit-band region to read from
  61:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit Bit in address to read
  62:../Libmaple/libmaple/libmaple/bitband.h ****  * @return bit's value in address.
  63:../Libmaple/libmaple/libmaple/bitband.h ****  */
  64:../Libmaple/libmaple/libmaple/bitband.h **** static inline uint8 bb_sram_get_bit(volatile void *address, uint32 bit) {
  65:../Libmaple/libmaple/libmaple/bitband.h ****     return *bb_sramp(address, bit);
  66:../Libmaple/libmaple/libmaple/bitband.h **** }
  67:../Libmaple/libmaple/libmaple/bitband.h **** 
  68:../Libmaple/libmaple/libmaple/bitband.h **** /**
  69:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Set a bit in an address in the SRAM bit-band region.
  70:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the SRAM bit-band region to write to
  71:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit Bit in address to write to
  72:../Libmaple/libmaple/libmaple/bitband.h ****  * @param val Value to write for bit, either 0 or 1.
  73:../Libmaple/libmaple/libmaple/bitband.h ****  */
  74:../Libmaple/libmaple/libmaple/bitband.h **** static inline void bb_sram_set_bit(volatile void *address,
  75:../Libmaple/libmaple/libmaple/bitband.h ****                                    uint32 bit,
  76:../Libmaple/libmaple/libmaple/bitband.h ****                                    uint8 val) {
  77:../Libmaple/libmaple/libmaple/bitband.h ****     *bb_sramp(address, bit) = val;
  78:../Libmaple/libmaple/libmaple/bitband.h **** }
  79:../Libmaple/libmaple/libmaple/bitband.h **** 
  80:../Libmaple/libmaple/libmaple/bitband.h **** /**
  81:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Obtain a pointer to the bit-band address corresponding to a
  82:../Libmaple/libmaple/libmaple/bitband.h ****  * bit in a peripheral address.
  83:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the bit-banded peripheral region
  84:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit     Bit in address to bit-band
  85:../Libmaple/libmaple/libmaple/bitband.h ****  */
  86:../Libmaple/libmaple/libmaple/bitband.h **** static inline volatile uint32* bb_perip(volatile void *address, uint32 bit) {
  87:../Libmaple/libmaple/libmaple/bitband.h ****     return __bb_addr(address, bit, BB_PERI_BASE, BB_PERI_REF);
  88:../Libmaple/libmaple/libmaple/bitband.h **** }
  89:../Libmaple/libmaple/libmaple/bitband.h **** 
  90:../Libmaple/libmaple/libmaple/bitband.h **** /**
  91:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Get a bit from an address in the peripheral bit-band region.
  92:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the peripheral bit-band region to read from
  93:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit Bit in address to read
  94:../Libmaple/libmaple/libmaple/bitband.h ****  * @return bit's value in address.
  95:../Libmaple/libmaple/libmaple/bitband.h ****  */
  96:../Libmaple/libmaple/libmaple/bitband.h **** static inline uint8 bb_peri_get_bit(volatile void *address, uint32 bit) {
  97:../Libmaple/libmaple/libmaple/bitband.h ****     return *bb_perip(address, bit);
  98:../Libmaple/libmaple/libmaple/bitband.h **** }
  99:../Libmaple/libmaple/libmaple/bitband.h **** 
 100:../Libmaple/libmaple/libmaple/bitband.h **** /**
 101:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Set a bit in an address in the peripheral bit-band region.
 102:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the peripheral bit-band region to write to
 103:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit Bit in address to write to
 104:../Libmaple/libmaple/libmaple/bitband.h ****  * @param val Value to write for bit, either 0 or 1.
 105:../Libmaple/libmaple/libmaple/bitband.h ****  */
 106:../Libmaple/libmaple/libmaple/bitband.h **** static inline void bb_peri_set_bit(volatile void *address,
 107:../Libmaple/libmaple/libmaple/bitband.h ****                                    uint32 bit,
 108:../Libmaple/libmaple/libmaple/bitband.h ****                                    uint8 val) {
 109:../Libmaple/libmaple/libmaple/bitband.h ****     *bb_perip(address, bit) = val;
 110:../Libmaple/libmaple/libmaple/bitband.h **** }
 111:../Libmaple/libmaple/libmaple/bitband.h **** 
 112:../Libmaple/libmaple/libmaple/bitband.h **** static inline volatile uint32* __bb_addr(volatile void *address,
 113:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32 bit,
 114:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32 bb_base,
 115:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32 bb_ref) {
 116:../Libmaple/libmaple/libmaple/bitband.h ****     return (volatile uint32*)(bb_base + ((uint32)address - bb_ref) * 32 +
 117:../Libmaple/libmaple/libmaple/bitband.h ****                               bit * 4);
 4225              		.loc 18 117 0 discriminator 2
 4226 005e 5001     		lsls	r0, r2, #5
 4227 0060 00F18442 		add	r2, r0, #1107296256
 4228              	.LBE118:
 4229              	.LBE117:
 4230              	.LBE116:
 4231              	.LBE115:
 4232              		.loc 1 737 0 discriminator 2
 4233 0064 0120     		movs	r0, #1
 4234 0066 C2F88002 		str	r0, [r2, #640]
 4235              	.LBE114:
 4236              	.LBE113:
  92:../Libraries/AQ_Motors/Motors_STM32.h ****     for(motor=0; motor < _stm32_motor_number; motor++) {
 4237              		.loc 17 92 0 discriminator 2
 4238 006a 1B18     		adds	r3, r3, r0
 4239              	.LVL216:
 4240              	.L238:
  92:../Libraries/AQ_Motors/Motors_STM32.h ****     for(motor=0; motor < _stm32_motor_number; motor++) {
 4241              		.loc 17 92 0 is_stmt 0 discriminator 1
 4242 006c 0C36     		adds	r6, r6, #12
 4243 006e 8B42     		cmp	r3, r1
 4244 0070 F2DB     		blt	.L239
  96:../Libraries/AQ_Motors/Motors_STM32.h ****     commandAllMotors(1000);
 4245              		.loc 17 96 0 is_stmt 1
 4246 0072 4FF47A70 		mov	r0, #1000
 4247              	.LBE119:
  98:../Libraries/AQ_Motors/Motors_STM32.h ****   }
 4248              		.loc 17 98 0
 4249 0076 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 4250              	.LBB120:
  96:../Libraries/AQ_Motors/Motors_STM32.h ****     commandAllMotors(1000);
 4251              		.loc 17 96 0
 4252 007a FFF7FEBF 		b	_Z16commandAllMotorsi
 4253              	.LVL217:
 4254              	.L241:
 4255 007e 00BF     		.align	2
 4256              	.L240:
 4257 0080 00000000 		.word	.LANCHOR64
 4258 0084 04000000 		.word	.LANCHOR62+4
 4259 0088 00000000 		.word	.LANCHOR65
 4260 008c 40420F00 		.word	1000000
 4261              	.LBE120:
 4262              		.cfi_endproc
 4263              	.LFE178:
 4265              		.section	.text._Z11pulseMotorsh,"ax",%progbits
 4266              		.align	1
 4267              		.global	_Z11pulseMotorsh
 4268              		.thumb
 4269              		.thumb_func
 4271              	_Z11pulseMotorsh:
 4272              	.LFB176:
 4273              		.file 19 "../Libraries/AQ_Motors/Motors.h"
   1:../Libraries/AQ_Motors/Motors.h **** /*
   2:../Libraries/AQ_Motors/Motors.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Motors/Motors.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Motors/Motors.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Motors/Motors.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Motors/Motors.h ****  
   7:../Libraries/AQ_Motors/Motors.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Motors/Motors.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Motors/Motors.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Motors/Motors.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Motors/Motors.h **** 
  12:../Libraries/AQ_Motors/Motors.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Motors/Motors.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Motors/Motors.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Motors/Motors.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Motors/Motors.h **** 
  17:../Libraries/AQ_Motors/Motors.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Motors/Motors.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Motors/Motors.h **** */
  20:../Libraries/AQ_Motors/Motors.h **** 
  21:../Libraries/AQ_Motors/Motors.h **** 
  22:../Libraries/AQ_Motors/Motors.h **** #ifndef _AEROQUAD_MOTORS_H_
  23:../Libraries/AQ_Motors/Motors.h **** #define _AEROQUAD_MOTORS_H_
  24:../Libraries/AQ_Motors/Motors.h **** 
  25:../Libraries/AQ_Motors/Motors.h **** #include "Arduino.h"
  26:../Libraries/AQ_Motors/Motors.h **** 
  27:../Libraries/AQ_Motors/Motors.h **** #define MOTOR1 0
  28:../Libraries/AQ_Motors/Motors.h **** #define MOTOR2 1
  29:../Libraries/AQ_Motors/Motors.h **** #define MOTOR3 2
  30:../Libraries/AQ_Motors/Motors.h **** #define MOTOR4 3
  31:../Libraries/AQ_Motors/Motors.h **** #define MOTOR5 4
  32:../Libraries/AQ_Motors/Motors.h **** #define MOTOR6 5
  33:../Libraries/AQ_Motors/Motors.h **** #define MOTOR7 6
  34:../Libraries/AQ_Motors/Motors.h **** #define MOTOR8 7
  35:../Libraries/AQ_Motors/Motors.h **** #define MINCOMMAND 1000
  36:../Libraries/AQ_Motors/Motors.h **** #define MAXCOMMAND 2000
  37:../Libraries/AQ_Motors/Motors.h **** 
  38:../Libraries/AQ_Motors/Motors.h **** enum NB_Motors{
  39:../Libraries/AQ_Motors/Motors.h ****   FOUR_Motors = 4,
  40:../Libraries/AQ_Motors/Motors.h ****   SIX_Motors = 6,
  41:../Libraries/AQ_Motors/Motors.h ****   EIGHT_Motors = 8
  42:../Libraries/AQ_Motors/Motors.h **** };
  43:../Libraries/AQ_Motors/Motors.h **** 
  44:../Libraries/AQ_Motors/Motors.h **** NB_Motors numberOfMotors = FOUR_Motors;
  45:../Libraries/AQ_Motors/Motors.h **** int motorCommand[8] = {0,0,0,0,0,0,0,0};  // LASTMOTOR not know here, so, default at 8 @todo : Kenn
  46:../Libraries/AQ_Motors/Motors.h ****   
  47:../Libraries/AQ_Motors/Motors.h **** void initializeMotors(NB_Motors numbers = FOUR_Motors);
  48:../Libraries/AQ_Motors/Motors.h **** void writeMotors();
  49:../Libraries/AQ_Motors/Motors.h **** void commandAllMotors(int command);
  50:../Libraries/AQ_Motors/Motors.h **** 
  51:../Libraries/AQ_Motors/Motors.h **** void pulseMotors(byte nbPulse) {
 4274              		.loc 19 51 0
 4275              		.cfi_startproc
 4276              		@ args = 0, pretend = 0, frame = 0
 4277              		@ frame_needed = 0, uses_anonymous_args = 0
 4278              	.LVL218:
 4279 0000 38B5     		push	{r3, r4, r5, lr}
 4280              	.LCFI45:
 4281              		.cfi_def_cfa_offset 16
 4282              		.cfi_offset 14, -4
 4283              		.cfi_offset 5, -8
 4284              		.cfi_offset 4, -12
 4285              		.cfi_offset 3, -16
 4286              		.loc 19 51 0
 4287 0002 0546     		mov	r5, r0
 4288              	.LBB121:
  52:../Libraries/AQ_Motors/Motors.h ****   for (byte i = 0; i < nbPulse; i++) {
 4289              		.loc 19 52 0
 4290 0004 0024     		movs	r4, #0
 4291 0006 0FE0     		b	.L243
 4292              	.LVL219:
 4293              	.L244:
  53:../Libraries/AQ_Motors/Motors.h ****     commandAllMotors(MINCOMMAND + 100);
 4294              		.loc 19 53 0 discriminator 2
 4295 0008 40F24C40 		movw	r0, #1100
 4296 000c FFF7FEFF 		bl	_Z16commandAllMotorsi
  54:../Libraries/AQ_Motors/Motors.h ****     delay(250);
 4297              		.loc 19 54 0 discriminator 2
 4298 0010 FA20     		movs	r0, #250
 4299 0012 FFF7FEFF 		bl	_Z5delaym
  55:../Libraries/AQ_Motors/Motors.h ****     commandAllMotors(MINCOMMAND);
 4300              		.loc 19 55 0 discriminator 2
 4301 0016 4FF47A70 		mov	r0, #1000
 4302 001a FFF7FEFF 		bl	_Z16commandAllMotorsi
  56:../Libraries/AQ_Motors/Motors.h ****     delay(250);
 4303              		.loc 19 56 0 discriminator 2
 4304 001e FA20     		movs	r0, #250
 4305 0020 FFF7FEFF 		bl	_Z5delaym
  52:../Libraries/AQ_Motors/Motors.h ****   for (byte i = 0; i < nbPulse; i++) {
 4306              		.loc 19 52 0 discriminator 2
 4307 0024 0134     		adds	r4, r4, #1
 4308              	.LVL220:
 4309 0026 E4B2     		uxtb	r4, r4
 4310              	.LVL221:
 4311              	.L243:
  52:../Libraries/AQ_Motors/Motors.h ****   for (byte i = 0; i < nbPulse; i++) {
 4312              		.loc 19 52 0 is_stmt 0 discriminator 1
 4313 0028 AC42     		cmp	r4, r5
 4314 002a EDD1     		bne	.L244
 4315              	.LBE121:
  57:../Libraries/AQ_Motors/Motors.h ****   }
  58:../Libraries/AQ_Motors/Motors.h **** }
 4316              		.loc 19 58 0 is_stmt 1
 4317 002c 38BD     		pop	{r3, r4, r5, pc}
 4318              		.cfi_endproc
 4319              	.LFE176:
 4321              		.section	.text._Z8getHdgXYh,"ax",%progbits
 4322              		.align	1
 4323              		.global	_Z8getHdgXYh
 4324              		.thumb
 4325              		.thumb_func
 4327              	_Z8getHdgXYh:
 4328              	.LFB181:
 4329              		.file 20 "../Libraries/AQ_Compass/Compass.h"
   1:../Libraries/AQ_Compass/Compass.h **** /*
   2:../Libraries/AQ_Compass/Compass.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Compass/Compass.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Compass/Compass.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Compass/Compass.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Compass/Compass.h ****  
   7:../Libraries/AQ_Compass/Compass.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Compass/Compass.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Compass/Compass.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Compass/Compass.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Compass/Compass.h **** 
  12:../Libraries/AQ_Compass/Compass.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Compass/Compass.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Compass/Compass.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Compass/Compass.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Compass/Compass.h **** 
  17:../Libraries/AQ_Compass/Compass.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Compass/Compass.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Compass/Compass.h **** */
  20:../Libraries/AQ_Compass/Compass.h **** 
  21:../Libraries/AQ_Compass/Compass.h **** 
  22:../Libraries/AQ_Compass/Compass.h **** #ifndef _AEROQUAD_COMPASS_H_
  23:../Libraries/AQ_Compass/Compass.h **** #define _AEROQUAD_COMPASS_H_
  24:../Libraries/AQ_Compass/Compass.h **** 
  25:../Libraries/AQ_Compass/Compass.h **** #include "Arduino.h"
  26:../Libraries/AQ_Compass/Compass.h **** 
  27:../Libraries/AQ_Compass/Compass.h **** float hdgX = 0.0;
  28:../Libraries/AQ_Compass/Compass.h **** float hdgY = 0.0;
  29:../Libraries/AQ_Compass/Compass.h **** 
  30:../Libraries/AQ_Compass/Compass.h **** float measuredMagX = 0.0;
  31:../Libraries/AQ_Compass/Compass.h **** float measuredMagY = 0.0;
  32:../Libraries/AQ_Compass/Compass.h **** float measuredMagZ = 0.0;
  33:../Libraries/AQ_Compass/Compass.h **** float measuredMag[3] = {0.0,0.0,0.0};
  34:../Libraries/AQ_Compass/Compass.h **** float rawMag[3] = {0.0,0.0,0.0};
  35:../Libraries/AQ_Compass/Compass.h **** float magBias[3] = {0.0,0.0,0.0};
  36:../Libraries/AQ_Compass/Compass.h **** 
  37:../Libraries/AQ_Compass/Compass.h **** //float magMax[3] = {0.0,0.0,0.0};
  38:../Libraries/AQ_Compass/Compass.h **** //float magMin[3] = {0.0,0.0,0.0};
  39:../Libraries/AQ_Compass/Compass.h **** float magScale[3] = {1.0,1.0,1.0};
  40:../Libraries/AQ_Compass/Compass.h **** //float magOffset[3] = {0.0,0.0,0.0};
  41:../Libraries/AQ_Compass/Compass.h **** //float magBias[3] = {0.0, 0.0, 0.0};
  42:../Libraries/AQ_Compass/Compass.h **** 
  43:../Libraries/AQ_Compass/Compass.h **** void initializeMagnetometer();
  44:../Libraries/AQ_Compass/Compass.h **** void measureMagnetometer(float roll, float pitch);
  45:../Libraries/AQ_Compass/Compass.h **** 
  46:../Libraries/AQ_Compass/Compass.h **** const float getHdgXY(byte axis) {
 4330              		.loc 20 46 0
 4331              		.cfi_startproc
 4332              		@ args = 0, pretend = 0, frame = 0
 4333              		@ frame_needed = 0, uses_anonymous_args = 0
 4334              		@ link register save eliminated.
 4335              	.LVL222:
  47:../Libraries/AQ_Compass/Compass.h ****   if (axis == XAXIS) {
 4336              		.loc 20 47 0
 4337 0000 10B9     		cbnz	r0, .L246
  48:../Libraries/AQ_Compass/Compass.h ****     return hdgX;
 4338              		.loc 20 48 0
 4339 0002 034B     		ldr	r3, .L248
 4340 0004 1868     		ldr	r0, [r3, #0]	@ float
 4341              	.LVL223:
 4342 0006 7047     		bx	lr
 4343              	.LVL224:
 4344              	.L246:
  49:../Libraries/AQ_Compass/Compass.h ****   } else {
  50:../Libraries/AQ_Compass/Compass.h ****     return hdgY;
 4345              		.loc 20 50 0
 4346 0008 0248     		ldr	r0, .L248+4
 4347              	.LVL225:
 4348 000a 0068     		ldr	r0, [r0, #0]	@ float
  51:../Libraries/AQ_Compass/Compass.h ****   }
  52:../Libraries/AQ_Compass/Compass.h **** }
 4349              		.loc 20 52 0
 4350 000c 7047     		bx	lr
 4351              	.L249:
 4352 000e 00BF     		.align	2
 4353              	.L248:
 4354 0010 00000000 		.word	.LANCHOR66
 4355 0014 00000000 		.word	.LANCHOR67
 4356              		.cfi_endproc
 4357              	.LFE181:
 4359              		.section	.text._Z22getMagnetometerRawDatah,"ax",%progbits
 4360              		.align	1
 4361              		.global	_Z22getMagnetometerRawDatah
 4362              		.thumb
 4363              		.thumb_func
 4365              	_Z22getMagnetometerRawDatah:
 4366              	.LFB182:
  53:../Libraries/AQ_Compass/Compass.h **** 
  54:../Libraries/AQ_Compass/Compass.h **** const int getMagnetometerRawData(byte axis) {
 4367              		.loc 20 54 0
 4368              		.cfi_startproc
 4369              		@ args = 0, pretend = 0, frame = 0
 4370              		@ frame_needed = 0, uses_anonymous_args = 0
 4371              		@ link register save eliminated.
 4372              	.LVL226:
  55:../Libraries/AQ_Compass/Compass.h ****   return rawMag[axis];
 4373              		.loc 20 55 0
 4374 0000 0449     		ldr	r1, .L251
 4375 0002 01EB8003 		add	r3, r1, r0, lsl #2
 4376 0006 93ED000A 		flds	s0, [r3, #0]
  56:../Libraries/AQ_Compass/Compass.h **** }
 4377              		.loc 20 56 0
 4378 000a FDEEC07A 		ftosizs	s15, s0
 4379 000e 17EE900A 		fmrs	r0, s15	@ int
 4380              	.LVL227:
 4381 0012 7047     		bx	lr
 4382              	.L252:
 4383              		.align	2
 4384              	.L251:
 4385 0014 00000000 		.word	.LANCHOR68
 4386              		.cfi_endproc
 4387              	.LFE182:
 4389              		.section	.text._Z19getMagnetometerDatah,"ax",%progbits
 4390              		.align	1
 4391              		.global	_Z19getMagnetometerDatah
 4392              		.thumb
 4393              		.thumb_func
 4395              	_Z19getMagnetometerDatah:
 4396              	.LFB183:
  57:../Libraries/AQ_Compass/Compass.h **** 
  58:../Libraries/AQ_Compass/Compass.h **** const int getMagnetometerData(byte axis) {
 4397              		.loc 20 58 0
 4398              		.cfi_startproc
 4399              		@ args = 0, pretend = 0, frame = 0
 4400              		@ frame_needed = 0, uses_anonymous_args = 0
 4401              		@ link register save eliminated.
 4402              	.LVL228:
  59:../Libraries/AQ_Compass/Compass.h ****   return measuredMag[axis];
 4403              		.loc 20 59 0
 4404 0000 0449     		ldr	r1, .L254
 4405 0002 01EB8003 		add	r3, r1, r0, lsl #2
 4406 0006 93ED000A 		flds	s0, [r3, #0]
  60:../Libraries/AQ_Compass/Compass.h **** }
 4407              		.loc 20 60 0
 4408 000a FDEEC07A 		ftosizs	s15, s0
 4409 000e 17EE900A 		fmrs	r0, s15	@ int
 4410              	.LVL229:
 4411 0012 7047     		bx	lr
 4412              	.L255:
 4413              		.align	2
 4414              	.L254:
 4415 0014 00000000 		.word	.LANCHOR69
 4416              		.cfi_endproc
 4417              	.LFE183:
 4419              		.section	.text._Z18getAbsoluteHeadingv,"ax",%progbits
 4420              		.align	1
 4421              		.global	_Z18getAbsoluteHeadingv
 4422              		.thumb
 4423              		.thumb_func
 4425              	_Z18getAbsoluteHeadingv:
 4426              	.LFB184:
  61:../Libraries/AQ_Compass/Compass.h **** 
  62:../Libraries/AQ_Compass/Compass.h **** 
  63:../Libraries/AQ_Compass/Compass.h **** const float getAbsoluteHeading() {
 4427              		.loc 20 63 0
 4428              		.cfi_startproc
 4429              		@ args = 0, pretend = 0, frame = 0
 4430              		@ frame_needed = 0, uses_anonymous_args = 0
 4431              	.LBB122:
  64:../Libraries/AQ_Compass/Compass.h ****   float heading = atan2(hdgY, hdgX);
 4432              		.loc 20 64 0
 4433 0000 1048     		ldr	r0, .L260
 4434              	.LBE122:
  63:../Libraries/AQ_Compass/Compass.h **** const float getAbsoluteHeading() {
 4435              		.loc 20 63 0
 4436 0002 38B5     		push	{r3, r4, r5, lr}
 4437              	.LCFI46:
 4438              		.cfi_def_cfa_offset 16
 4439              		.cfi_offset 14, -4
 4440              		.cfi_offset 5, -8
 4441              		.cfi_offset 4, -12
 4442              		.cfi_offset 3, -16
 4443              	.LBB123:
 4444              		.loc 20 64 0
 4445 0004 0068     		ldr	r0, [r0, #0]	@ float
 4446 0006 FFF7FEFF 		bl	__aeabi_f2d
 4447 000a 0F4B     		ldr	r3, .L260+4
 4448 000c 0446     		mov	r4, r0
 4449 000e 1868     		ldr	r0, [r3, #0]	@ float
 4450 0010 0D46     		mov	r5, r1
 4451 0012 FFF7FEFF 		bl	__aeabi_f2d
 4452 0016 0246     		mov	r2, r0
 4453 0018 0B46     		mov	r3, r1
 4454 001a 2046     		mov	r0, r4
 4455 001c 2946     		mov	r1, r5
 4456 001e FFF7FEFF 		bl	atan2
 4457 0022 FFF7FEFF 		bl	__aeabi_d2f
 4458 0026 07EE900A 		fmsr	s15, r0
 4459              	.LVL230:
  65:../Libraries/AQ_Compass/Compass.h ****   if (heading < 0) {
 4460              		.loc 20 65 0
 4461 002a F5EEC07A 		fcmpezs	s15
 4462 002e F1EE10FA 		fmstat
  66:../Libraries/AQ_Compass/Compass.h **** 	heading += radians(360);
 4463              		.loc 20 66 0
 4464 0032 44BF     		itt	mi
 4465 0034 9FED057A 		fldsmi	s14, .L260+8
 4466 0038 77EE877A 		faddsmi	s15, s15, s14
 4467              	.LVL231:
 4468              	.LBE123:
  67:../Libraries/AQ_Compass/Compass.h ****   }
  68:../Libraries/AQ_Compass/Compass.h ****   return heading;
  69:../Libraries/AQ_Compass/Compass.h **** }
 4469              		.loc 20 69 0
 4470 003c 17EE900A 		fmrs	r0, s15
 4471 0040 38BD     		pop	{r3, r4, r5, pc}
 4472              	.L261:
 4473 0042 00BF     		.align	2
 4474              	.L260:
 4475 0044 00000000 		.word	.LANCHOR67
 4476 0048 00000000 		.word	.LANCHOR66
 4477 004c DB0FC940 		.word	1086918619
 4478              		.cfi_endproc
 4479              	.LFE184:
 4481              		.section	.text._Z23initializeHeadingFusionv,"ax",%progbits
 4482              		.align	1
 4483              		.global	_Z23initializeHeadingFusionv
 4484              		.thumb
 4485              		.thumb_func
 4487              	_Z23initializeHeadingFusionv:
 4488              	.LFB185:
 4489              		.file 21 "../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h"
   1:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** /*
   2:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   AeroQuad v3.0 - May 2011
   3:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   Copyright (c) 2011 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****  
   7:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  12:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  17:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** */
  20:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  21:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** /*
  22:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****  * eventually, it's about the normal DCM processor and I KNOW that this is heavy!
  23:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****  * Still, this is the best result I did get with my knowledge that give good attitude
  24:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****  * estimator with the AGR and pretty good true heading computation at the same time
  25:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****  * 
  26:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****  * @Kenny9999
  27:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****  * I'm open to anything more lighweight working and FLIGHT TESTED
  28:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****  */
  29:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** #ifndef _AQ_HEADING_FUSION_PROCESSOR_COMP_FILTER_
  30:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** #define _AQ_HEADING_FUSION_PROCESSOR_COMP_FILTER_
  31:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  32:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** #include "Compass.h"
  33:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  34:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** #if defined UseGPS
  35:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   #include "MagnetometerDeclinationDB.h"
  36:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** #endif  
  37:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  38:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** float trueNorthHeading = 0.0;
  39:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** float compassDeclination = 0.0;
  40:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  41:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** float filter1 = 1.0 / (1.0 + 0.002);
  42:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** float filter2 = 1 - filter1;
  43:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** int headingGyroZero = 0;
  44:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** float localHeading = 0.0;
  45:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  46:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** void initializeHeadingFusion() {
 4490              		.loc 21 46 0
 4491              		.cfi_startproc
 4492              		@ args = 0, pretend = 0, frame = 0
 4493              		@ frame_needed = 0, uses_anonymous_args = 0
  47:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  48:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   headingGyroZero = gyroZero[ZAXIS];
 4494              		.loc 21 48 0
 4495 0000 0449     		ldr	r1, .L263
 4496 0002 0548     		ldr	r0, .L263+4
 4497 0004 8A68     		ldr	r2, [r1, #8]
  46:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** void initializeHeadingFusion() {
 4498              		.loc 21 46 0
 4499 0006 08B5     		push	{r3, lr}
 4500              	.LCFI47:
 4501              		.cfi_def_cfa_offset 8
 4502              		.cfi_offset 14, -4
 4503              		.cfi_offset 3, -8
 4504              		.loc 21 48 0
 4505 0008 0260     		str	r2, [r0, #0]
  49:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   gyroHeading = getAbsoluteHeading();
 4506              		.loc 21 49 0
 4507 000a FFF7FEFF 		bl	_Z18getAbsoluteHeadingv
 4508 000e 034B     		ldr	r3, .L263+8
 4509 0010 1860     		str	r0, [r3, #0]	@ float
  50:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** }
 4510              		.loc 21 50 0
 4511 0012 08BD     		pop	{r3, pc}
 4512              	.L264:
 4513              		.align	2
 4514              	.L263:
 4515 0014 00000000 		.word	.LANCHOR31
 4516 0018 00000000 		.word	.LANCHOR70
 4517 001c 00000000 		.word	.LANCHOR28
 4518              		.cfi_endproc
 4519              	.LFE185:
 4521              		.global	__aeabi_dsub
 4522              		.global	__aeabi_dadd
 4523              		.section	.text._Z16calculateHeadingv,"ax",%progbits
 4524              		.align	1
 4525              		.global	_Z16calculateHeadingv
 4526              		.thumb
 4527              		.thumb_func
 4529              	_Z16calculateHeadingv:
 4530              	.LFB186:
  51:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  52:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** void calculateHeading() {
 4531              		.loc 21 52 0
 4532              		.cfi_startproc
 4533              		@ args = 0, pretend = 0, frame = 0
 4534              		@ frame_needed = 0, uses_anonymous_args = 0
 4535 0000 10B5     		push	{r4, lr}
 4536              	.LCFI48:
 4537              		.cfi_def_cfa_offset 8
 4538              		.cfi_offset 14, -4
 4539              		.cfi_offset 4, -8
 4540 0002 2DED028B 		fstmfdd	sp!, {d8}
 4541              	.LCFI49:
 4542              		.cfi_def_cfa_offset 16
 4543              		.cfi_offset 80, -16
 4544              	.LBB124:
  53:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  54:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   float compass = getAbsoluteHeading();
 4545              		.loc 21 54 0
 4546 0006 FFF7FEFF 		bl	_Z18getAbsoluteHeadingv
 4547              	.LVL232:
  55:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   if (compass > PI) {
 4548              		.loc 21 55 0
 4549 000a 9FED438A 		flds	s16, .L279+16
 4550 000e 07EE100A 		fmsr	s14, r0
 4551 0012 B4EEC87A 		fcmpes	s14, s16
 4552 0016 F1EE10FA 		fmstat
 4553 001a 06DD     		ble	.L266
  56:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****     compass = fmod(compass,PI) - PI;
 4554              		.loc 21 56 0
 4555 001c FFF7FEFF 		bl	__aeabi_f2d
 4556              	.LVL233:
 4557 0020 39A3     		adr	r3, .L279
 4558 0022 D3E90023 		ldrd	r2, [r3]
 4559 0026 FFF7FEFF 		bl	fmod
 4560              	.L266:
  57:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   }
  58:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  59:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   if (headingGyroZero != gyroZero[ZAXIS]) {
 4561              		.loc 21 59 0
 4562 002a 3C48     		ldr	r0, .L279+20
 4563 002c 3C4A     		ldr	r2, .L279+24
 4564 002e 8168     		ldr	r1, [r0, #8]
 4565 0030 1368     		ldr	r3, [r2, #0]
 4566 0032 3C4C     		ldr	r4, .L279+28
 4567 0034 8B42     		cmp	r3, r1
 4568 0036 3C4B     		ldr	r3, .L279+32
 4569 0038 04D0     		beq	.L268
  60:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****     gyroHeading = localHeading;
 4570              		.loc 21 60 0
 4571 003a D4F800C0 		ldr	ip, [r4, #0]	@ float
  61:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****     headingGyroZero = gyroZero[ZAXIS];
 4572              		.loc 21 61 0
 4573 003e 1160     		str	r1, [r2, #0]
  60:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****     gyroHeading = localHeading;
 4574              		.loc 21 60 0
 4575 0040 C3F800C0 		str	ip, [r3, #0]	@ float
 4576              	.L268:
  62:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   }
  63:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  64:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   float adjustedGyroHeading = fmod(gyroHeading,(PI*2));
 4577              		.loc 21 64 0
 4578 0044 1868     		ldr	r0, [r3, #0]	@ float
 4579 0046 FFF7FEFF 		bl	__aeabi_f2d
 4580 004a 31A3     		adr	r3, .L279+8
 4581 004c D3E90023 		ldrd	r2, [r3]
 4582 0050 FFF7FEFF 		bl	fmod
 4583 0054 FFF7FEFF 		bl	__aeabi_d2f
 4584 0058 07EE900A 		fmsr	s15, r0
 4585              	.LVL234:
  65:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   int divider = abs(adjustedGyroHeading) / PI;
 4586              		.loc 21 65 0
 4587 005c F5EEC07A 		fcmpezs	s15
 4588 0060 F1EE10FA 		fmstat
 4589 0064 08DD     		ble	.L276
 4590              	.LVL235:
 4591              		.loc 21 65 0 is_stmt 0 discriminator 1
 4592 0066 C7EE880A 		fdivs	s1, s15, s16
 4593 006a BDEEE00A 		ftosizs	s0, s1
 4594 006e 10EE101A 		fmrs	r1, s0	@ int
  66:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   if (adjustedGyroHeading > 0) {
  67:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****     if (divider == 1) {
 4595              		.loc 21 67 0 is_stmt 1 discriminator 1
 4596 0072 0129     		cmp	r1, #1
 4597 0074 30D1     		bne	.L272
 4598 0076 0AE0     		b	.L277
 4599              	.LVL236:
 4600              	.L276:
  65:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   int divider = abs(adjustedGyroHeading) / PI;
 4601              		.loc 21 65 0 discriminator 2
 4602 0078 F1EE671A 		fnegs	s3, s15
 4603 007c C1EE881A 		fdivs	s3, s3, s16
 4604 0080 BDEEE11A 		ftosizs	s2, s3
 4605 0084 11EE102A 		fmrs	r2, s2	@ int
  68:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 	  adjustedGyroHeading = -(PI - fmod(adjustedGyroHeading,PI));
  69:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****     }
  70:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   }
  71:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   else {
  72:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****     if (divider == 1) {
 4606              		.loc 21 72 0 discriminator 2
 4607 0088 012A     		cmp	r2, #1
 4608 008a 25D1     		bne	.L272
 4609 008c 14E0     		b	.L278
 4610              	.LVL237:
 4611              	.L277:
  68:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 	  adjustedGyroHeading = -(PI - fmod(adjustedGyroHeading,PI));
 4612              		.loc 21 68 0
 4613 008e FFF7FEFF 		bl	__aeabi_f2d
 4614              	.LVL238:
 4615 0092 1DA3     		adr	r3, .L279
 4616 0094 D3E90023 		ldrd	r2, [r3]
 4617 0098 FFF7FEFF 		bl	fmod
 4618 009c 0246     		mov	r2, r0
 4619 009e 0B46     		mov	r3, r1
 4620 00a0 19A1     		adr	r1, .L279
 4621 00a2 D1E90001 		ldrd	r0, [r1]
 4622 00a6 FFF7FEFF 		bl	__aeabi_dsub
 4623 00aa FFF7FEFF 		bl	__aeabi_d2f
 4624 00ae 07EE100A 		fmsr	s14, r0
 4625 00b2 F1EE477A 		fnegs	s15, s14
 4626              	.LVL239:
 4627 00b6 0FE0     		b	.L272
 4628              	.LVL240:
 4629              	.L278:
  73:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 	  adjustedGyroHeading = fmod(adjustedGyroHeading,PI) + PI;
 4630              		.loc 21 73 0
 4631 00b8 FFF7FEFF 		bl	__aeabi_f2d
 4632              	.LVL241:
 4633 00bc 12A3     		adr	r3, .L279
 4634 00be D3E90023 		ldrd	r2, [r3]
 4635 00c2 FFF7FEFF 		bl	fmod
 4636 00c6 10A3     		adr	r3, .L279
 4637 00c8 D3E90023 		ldrd	r2, [r3]
 4638 00cc FFF7FEFF 		bl	__aeabi_dadd
 4639 00d0 FFF7FEFF 		bl	__aeabi_d2f
 4640 00d4 07EE900A 		fmsr	s15, r0
 4641              	.LVL242:
 4642              	.L272:
  74:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****     }
  75:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   }
  76:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  77:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   // Complementry filter from http://chiefdelphi.com/media/papers/2010
  78:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   localHeading = (filter1 * adjustedGyroHeading) + (filter2 * getAbsoluteHeading());
 4643              		.loc 21 78 0
 4644 00d8 1449     		ldr	r1, .L279+36
 4645 00da 1548     		ldr	r0, .L279+40
 4646 00dc 91ED002A 		flds	s4, [r1, #0]
 4647 00e0 90ED008A 		flds	s16, [r0, #0]
 4648 00e4 67EE828A 		fmuls	s17, s15, s4
 4649 00e8 FFF7FEFF 		bl	_Z18getAbsoluteHeadingv
 4650              	.LVL243:
 4651 00ec 07EE900A 		fmsr	s15, r0
 4652 00f0 48EE278A 		fmacs	s17, s16, s15
  79:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  80:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   trueNorthHeading = localHeading;
 4653              		.loc 21 80 0
 4654 00f4 0F4B     		ldr	r3, .L279+44
  78:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   localHeading = (filter1 * adjustedGyroHeading) + (filter2 * getAbsoluteHeading());
 4655              		.loc 21 78 0
 4656 00f6 C4ED008A 		fsts	s17, [r4, #0]
 4657              		.loc 21 80 0
 4658 00fa C3ED008A 		fsts	s17, [r3, #0]
 4659              	.LBE124:
  81:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   #if defined UseGPS
  82:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****     if( compassDeclination != 0.0 ) {
  83:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  84:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 	  trueNorthHeading = trueNorthHeading + compassDeclination;
  85:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 	  if (trueNorthHeading > M_PI)  {  // Angle normalization (-180 deg, 180 deg)
  86:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 	    trueNorthHeading -= (2.0 * M_PI);
  87:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 	  } 
  88:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 	  else if (trueNorthHeading < -M_PI){
  89:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 	    trueNorthHeading += (2.0 * M_PI);
  90:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 	  }
  91:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****     }
  92:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   #endif
  93:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** }
 4660              		.loc 21 93 0
 4661 00fe BDEC028B 		fldmfdd	sp!, {d8}
 4662 0102 10BD     		pop	{r4, pc}
 4663              	.L280:
 4664 0104 AFF30080 		.align	3
 4665              	.L279:
 4666 0108 00000060 		.word	1610612736
 4667 010c FB210940 		.word	1074340347
 4668 0110 00000060 		.word	1610612736
 4669 0114 FB211940 		.word	1075388923
 4670 0118 DB0F4940 		.word	1078530011
 4671 011c 00000000 		.word	.LANCHOR31
 4672 0120 00000000 		.word	.LANCHOR70
 4673 0124 00000000 		.word	.LANCHOR71
 4674 0128 00000000 		.word	.LANCHOR28
 4675 012c 00000000 		.word	.LANCHOR72
 4676 0130 00000000 		.word	.LANCHOR73
 4677 0134 00000000 		.word	.LANCHOR74
 4678              		.cfi_endproc
 4679              	.LFE186:
 4681              		.section	.text._Z15readSpecificMagPf,"ax",%progbits
 4682              		.align	1
 4683              		.global	_Z15readSpecificMagPf
 4684              		.thumb
 4685              		.thumb_func
 4687              	_Z15readSpecificMagPf:
 4688              	.LFB189:
 4689              		.file 22 "../Libraries/AQ_Compass/Magnetometer_HMC5883L.h"
   1:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** /*
   2:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** 
   7:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   This program is free software: you can redistribute it and/or modify
   8:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   it under the terms of the GNU General Public License as published by
   9:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   the Free Software Foundation, either version 3 of the License, or
  10:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   (at your option) any later version.
  11:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** 
  12:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   This program is distributed in the hope that it will be useful,
  13:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   GNU General Public License for more details.
  16:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** 
  17:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   You should have received a copy of the GNU General Public License
  18:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** */
  20:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** 
  21:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** 
  22:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** #ifndef _AEROQUAD_MAGNETOMETER_HMC5883L_H_
  23:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** #define _AEROQUAD_MAGNETOMETER_HMC5883L_H_
  24:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** 
  25:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** #include "Compass.h"
  26:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** 
  27:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** #include "Arduino.h"
  28:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** 
  29:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** #include "Magnetometer_HMC58xx.h"
  30:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** 
  31:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** void readSpecificMag(float *rawMag) {
 4690              		.loc 22 31 0
 4691              		.cfi_startproc
 4692              		@ args = 0, pretend = 0, frame = 0
 4693              		@ frame_needed = 0, uses_anonymous_args = 0
 4694              	.LVL244:
 4695 0000 10B5     		push	{r4, lr}
 4696              	.LCFI50:
 4697              		.cfi_def_cfa_offset 8
 4698              		.cfi_offset 14, -4
 4699              		.cfi_offset 4, -8
 4700              		.loc 22 31 0
 4701 0002 0446     		mov	r4, r0
  32:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** 
  33:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   #if defined(SPARKFUN_9DOF_5883L)
  34:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     // JI - 1/4/12 - Add _5883L to define
  35:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     // JI - 11/24/11 - SparkFun DOF on v2p1 Shield Configuration
  36:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     // JI - 11/24/11 - 5883L X axis points aft
  37:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     // JI - 11/24/11 - 5883L Sensor Orientation 3
  38:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     rawMag[XAXIS] = -readShortI2C();
  39:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     rawMag[ZAXIS] = -readShortI2C();
  40:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     rawMag[YAXIS] =  readShortI2C();
  41:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   #elif defined(SPARKFUN_5883L_BOB)
  42:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     // JI - 11/24/11 - Sparkfun 5883L Breakout Board Upside Down on v2p0 shield
  43:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     // JI - 11/24/11 - 5883L is upside down, X axis points forward
  44:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     // JI - 11/24/11 - 5883L Sensor Orientation 5
  45:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     rawMag[XAXIS] = readShortI2C();
  46:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     rawMag[ZAXIS] = readShortI2C();
  47:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     rawMag[YAXIS] = readShortI2C();
  48:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   #elif defined (HMC5883L)  // baloo
  49:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     rawMag[YAXIS] =  readShortI2C();
 4702              		.loc 22 49 0
 4703 0004 FFF7FEFF 		bl	_Z12readShortI2Cv
 4704              	.LVL245:
 4705 0008 01EE900A 		fmsr	s3, r0	@ int
 4706 000c B8EEE11A 		fsitos	s2, s3
 4707 0010 84ED011A 		fsts	s2, [r4, #4]
  50:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     rawMag[ZAXIS] = -readShortI2C();
 4708              		.loc 22 50 0
 4709 0014 FFF7FEFF 		bl	_Z12readShortI2Cv
 4710 0018 4042     		negs	r0, r0
 4711 001a 00EE900A 		fmsr	s1, r0	@ int
 4712 001e B8EEE00A 		fsitos	s0, s1
 4713 0022 84ED020A 		fsts	s0, [r4, #8]
  51:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     rawMag[XAXIS] =  readShortI2C();
 4714              		.loc 22 51 0
 4715 0026 FFF7FEFF 		bl	_Z12readShortI2Cv
 4716 002a 07EE100A 		fmsr	s14, r0	@ int
 4717 002e F8EEC77A 		fsitos	s15, s14
 4718 0032 C4ED007A 		fsts	s15, [r4, #0]
  52:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   #else 
  53:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     #error Define HMC5883L Orientation
  54:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   #endif
  55:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** }
 4719              		.loc 22 55 0
 4720 0036 10BD     		pop	{r4, pc}
 4721              		.cfi_endproc
 4722              	.LFE189:
 4724              		.section	.text._Z19measureMagnetometerff,"ax",%progbits
 4725              		.align	1
 4726              		.global	_Z19measureMagnetometerff
 4727              		.thumb
 4728              		.thumb_func
 4730              	_Z19measureMagnetometerff:
 4731              	.LFB188:
 4732              		.file 23 "../Libraries/AQ_Compass/Magnetometer_HMC58xx.h"
   1:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** /*
   2:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   AeroQuad v3.0 - April 2011
   3:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   www.AeroQuad.com 
   4:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   Copyright (c) 2011 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****  
   7:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  12:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  17:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** */
  20:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  21:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  22:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** #ifndef _AEROQUAD_MAGNETOMETER_HMC58XX_H_
  23:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** #define _AEROQUAD_MAGNETOMETER_HMC58XX_H_
  24:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  25:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** #include "Compass.h"
  26:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  27:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** #include "Arduino.h"
  28:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  29:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** #define COMPASS_ADDRESS 0x1E
  30:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** #define COMPASS_IDENTITY 0x10
  31:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  32:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** //#define SENSOR_GAIN 0x00  // +/- 0.7 Ga
  33:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** #define SENSOR_GAIN 0x20  // +/- 1.0 Ga (default)
  34:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** //#define SENSOR_GAIN 0x40  // +/- 1.5 Ga
  35:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** //#define SENSOR_GAIN 0x60  // +/- 2.0 Ga
  36:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** //#define SENSOR_GAIN 0x80  // +/- 3.2 Ga
  37:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** //#define SENSOR_GAIN 0xA0  // +/- 3.8 Ga
  38:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** //#define SENSOR_GAIN 0xC0  // +/- 4.5 Ga
  39:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** //#define SENSOR_GAIN 0xE0  // +/- 6.5 Ga (not recommended)
  40:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  41:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** void readSpecificMag(float *rawMag);
  42:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  43:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  44:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** void initializeMagnetometer() {
  45:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  46:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   delay(10);                             // Power up delay **
  47:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****    
  48:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   if (readWhoI2C(COMPASS_ADDRESS) == COMPASS_IDENTITY) {
  49:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 	  vehicleState |= MAG_DETECTED;
  50:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   }    
  51:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  52:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   updateRegisterI2C(COMPASS_ADDRESS, 0x01, SENSOR_GAIN); // Gain as defined above
  53:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   delay(20);
  54:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   updateRegisterI2C(COMPASS_ADDRESS, 0x02, 0x01); // start single conversion
  55:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   delay(20);
  56:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  57:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measureMagnetometer(0.0, 0.0);  // Assume 1st measurement at 0 degrees roll and 0 degrees pitch
  58:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** }
  59:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  60:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** void measureMagnetometer(float roll, float pitch) {
 4733              		.loc 23 60 0
 4734              		.cfi_startproc
 4735              		@ args = 0, pretend = 0, frame = 0
 4736              		@ frame_needed = 0, uses_anonymous_args = 0
 4737              	.LVL246:
 4738 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 4739              	.LCFI51:
 4740              		.cfi_def_cfa_offset 24
 4741              		.cfi_offset 14, -4
 4742              		.cfi_offset 7, -8
 4743              		.cfi_offset 6, -12
 4744              		.cfi_offset 5, -16
 4745              		.cfi_offset 4, -20
 4746              		.cfi_offset 3, -24
 4747              	.LBB125:
  61:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****     
  62:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   sendByteI2C(COMPASS_ADDRESS, 0x03);
  63:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   Wire.requestFrom(COMPASS_ADDRESS, 6);
  64:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  65:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   readSpecificMag(rawMag);
 4748              		.loc 23 65 0
 4749 0002 4A4D     		ldr	r5, .L283
  66:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  67:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   updateRegisterI2C(COMPASS_ADDRESS, 0x02, 0x01); // start single conversion
  68:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  69:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMagX = rawMag[XAXIS] * magScale[XAXIS] + magBias[XAXIS];
  70:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMagY = rawMag[YAXIS] * magScale[YAXIS] + magBias[YAXIS];
 4750              		.loc 23 70 0
 4751 0004 4A4C     		ldr	r4, .L283+4
 4752              	.LBE125:
  60:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** void measureMagnetometer(float roll, float pitch) {
 4753              		.loc 23 60 0
 4754 0006 2DED088B 		fstmfdd	sp!, {d8, d9, d10, d11}
 4755              	.LCFI52:
 4756              		.cfi_def_cfa_offset 56
 4757              		.cfi_offset 86, -32
 4758              		.cfi_offset 84, -40
 4759              		.cfi_offset 82, -48
 4760              		.cfi_offset 80, -56
  60:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** void measureMagnetometer(float roll, float pitch) {
 4761              		.loc 23 60 0
 4762 000a 0746     		mov	r7, r0	@ float
 4763 000c 0E46     		mov	r6, r1	@ float
 4764              	.LBB126:
  62:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   sendByteI2C(COMPASS_ADDRESS, 0x03);
 4765              		.loc 23 62 0
 4766 000e 1E20     		movs	r0, #30
 4767              	.LVL247:
 4768 0010 0321     		movs	r1, #3
 4769              	.LVL248:
 4770 0012 FFF7FEFF 		bl	_Z11sendByteI2Cih
  63:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   Wire.requestFrom(COMPASS_ADDRESS, 6);
 4771              		.loc 23 63 0
 4772 0016 1E21     		movs	r1, #30
 4773 0018 0622     		movs	r2, #6
 4774 001a 4648     		ldr	r0, .L283+8
 4775 001c FFF7FEFF 		bl	_ZN7TwoWire11requestFromEii
  65:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   readSpecificMag(rawMag);
 4776              		.loc 23 65 0
 4777 0020 2846     		mov	r0, r5
 4778 0022 FFF7FEFF 		bl	_Z15readSpecificMagPf
  67:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   updateRegisterI2C(COMPASS_ADDRESS, 0x02, 0x01); // start single conversion
 4779              		.loc 23 67 0
 4780 0026 1E20     		movs	r0, #30
 4781 0028 0221     		movs	r1, #2
 4782 002a 0122     		movs	r2, #1
 4783 002c FFF7FEFF 		bl	_Z17updateRegisterI2Cihh
  69:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMagX = rawMag[XAXIS] * magScale[XAXIS] + magBias[XAXIS];
 4784              		.loc 23 69 0
 4785 0030 414B     		ldr	r3, .L283+12
 4786 0032 4248     		ldr	r0, .L283+16
 4787 0034 4249     		ldr	r1, .L283+20
  71:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMagZ = rawMag[ZAXIS] * magScale[ZAXIS] + magBias[ZAXIS];
 4788              		.loc 23 71 0
 4789 0036 434A     		ldr	r2, .L283+24
  69:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMagX = rawMag[XAXIS] * magScale[XAXIS] + magBias[XAXIS];
 4790              		.loc 23 69 0
 4791 0038 95ED004A 		flds	s8, [r5, #0]
 4792 003c D0ED004A 		flds	s9, [r0, #0]
 4793 0040 D3ED009A 		flds	s19, [r3, #0]
  70:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMagY = rawMag[YAXIS] * magScale[YAXIS] + magBias[YAXIS];
 4794              		.loc 23 70 0
 4795 0044 95ED013A 		flds	s6, [r5, #4]
  69:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMagX = rawMag[XAXIS] * magScale[XAXIS] + magBias[XAXIS];
 4796              		.loc 23 69 0
 4797 0048 44EE249A 		fmacs	s19, s8, s9
  70:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMagY = rawMag[YAXIS] * magScale[YAXIS] + magBias[YAXIS];
 4798              		.loc 23 70 0
 4799 004c D0ED013A 		flds	s7, [r0, #4]
 4800 0050 93ED019A 		flds	s18, [r3, #4]
 4801              		.loc 23 71 0
 4802 0054 95ED022A 		flds	s4, [r5, #8]
 4803 0058 D0ED022A 		flds	s5, [r0, #8]
 4804 005c D3ED028A 		flds	s17, [r3, #8]
  70:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMagY = rawMag[YAXIS] * magScale[YAXIS] + magBias[YAXIS];
 4805              		.loc 23 70 0
 4806 0060 03EE239A 		fmacs	s18, s6, s7
 4807              		.loc 23 71 0
 4808 0064 42EE228A 		fmacs	s17, s4, s5
  69:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMagX = rawMag[XAXIS] * magScale[XAXIS] + magBias[XAXIS];
 4809              		.loc 23 69 0
 4810 0068 C1ED009A 		fsts	s19, [r1, #0]
  72:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   
  73:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMag[XAXIS] = measuredMagX;
 4811              		.loc 23 73 0
 4812 006c 3649     		ldr	r1, .L283+28
  71:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMagZ = rawMag[ZAXIS] * magScale[ZAXIS] + magBias[ZAXIS];
 4813              		.loc 23 71 0
 4814 006e C2ED008A 		fsts	s17, [r2, #0]
  70:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMagY = rawMag[YAXIS] * magScale[YAXIS] + magBias[YAXIS];
 4815              		.loc 23 70 0
 4816 0072 84ED009A 		fsts	s18, [r4, #0]
  74:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMag[YAXIS] = measuredMagY;
  75:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMag[ZAXIS] = measuredMagZ;
 4817              		.loc 23 75 0
 4818 0076 C1ED028A 		fsts	s17, [r1, #8]
  76:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   
  77:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   const float cosRoll =  cos(roll);
 4819              		.loc 23 77 0
 4820 007a 3846     		mov	r0, r7	@ float
  73:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMag[XAXIS] = measuredMagX;
 4821              		.loc 23 73 0
 4822 007c C1ED009A 		fsts	s19, [r1, #0]
  74:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMag[YAXIS] = measuredMagY;
 4823              		.loc 23 74 0
 4824 0080 81ED019A 		fsts	s18, [r1, #4]
 4825              		.loc 23 77 0
 4826 0084 FFF7FEFF 		bl	__aeabi_f2d
 4827 0088 0446     		mov	r4, r0
 4828 008a 0D46     		mov	r5, r1
 4829 008c FFF7FEFF 		bl	cos
 4830 0090 FFF7FEFF 		bl	__aeabi_d2f
  78:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   const float sinRoll =  sin(roll);
 4831              		.loc 23 78 0
 4832 0094 2946     		mov	r1, r5
  77:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   const float cosRoll =  cos(roll);
 4833              		.loc 23 77 0
 4834 0096 0BEE100A 		fmsr	s22, r0
 4835              	.LVL249:
 4836              		.loc 23 78 0
 4837 009a 2046     		mov	r0, r4
 4838              	.LVL250:
 4839 009c FFF7FEFF 		bl	sin
 4840 00a0 FFF7FEFF 		bl	__aeabi_d2f
 4841 00a4 0AEE900A 		fmsr	s21, r0
 4842              	.LVL251:
  79:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   const float cosPitch = cos(pitch);
 4843              		.loc 23 79 0
 4844 00a8 3046     		mov	r0, r6	@ float
 4845              	.LVL252:
 4846 00aa FFF7FEFF 		bl	__aeabi_f2d
 4847 00ae 0446     		mov	r4, r0
 4848 00b0 0D46     		mov	r5, r1
 4849 00b2 FFF7FEFF 		bl	cos
 4850 00b6 0646     		mov	r6, r0
 4851              	.LVL253:
 4852 00b8 0F46     		mov	r7, r1
 4853              	.LVL254:
  80:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   const float sinPitch = sin(pitch);
 4854              		.loc 23 80 0
 4855 00ba 2046     		mov	r0, r4
 4856 00bc 2946     		mov	r1, r5
 4857 00be FFF7FEFF 		bl	sin
 4858 00c2 FFF7FEFF 		bl	__aeabi_d2f
  79:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   const float cosPitch = cos(pitch);
 4859              		.loc 23 79 0
 4860 00c6 3946     		mov	r1, r7
 4861              		.loc 23 80 0
 4862 00c8 0AEE100A 		fmsr	s20, r0
 4863              	.LVL255:
  79:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   const float cosPitch = cos(pitch);
 4864              		.loc 23 79 0
 4865 00cc 3046     		mov	r0, r6
 4866              	.LVL256:
 4867 00ce FFF7FEFF 		bl	__aeabi_d2f
  81:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  82:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   const float magX = (float)measuredMagX * cosPitch + 
  83:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****                      (float)measuredMagY * sinRoll * sinPitch + 
  84:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****                      (float)measuredMagZ * cosRoll * sinPitch;
 4868              		.loc 23 84 0
 4869 00d2 69EE2A1A 		fmuls	s3, s18, s21
 4870 00d6 01EE100A 		fmsr	s2, r0
 4871 00da 21EE8A8A 		fmuls	s16, s3, s20
 4872 00de 09EE818A 		fmacs	s16, s19, s2
 4873 00e2 68EE8B0A 		fmuls	s1, s17, s22
  85:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****            
  86:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   const float magY = (float)measuredMagY * cosRoll - 
  87:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****                      (float)measuredMagZ * sinRoll;
 4874              		.loc 23 87 0
 4875 00e6 68EEAA8A 		fmuls	s17, s17, s21
 4876 00ea 59EE0B8A 		fmscs	s17, s18, s22
  84:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****                      (float)measuredMagZ * cosRoll * sinPitch;
 4877              		.loc 23 84 0
 4878 00ee 00EE8A8A 		fmacs	s16, s1, s20
 4879              	.LVL257:
  88:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  89:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   const float tmp  = sqrt(magX * magX + magY * magY);
 4880              		.loc 23 89 0
 4881 00f2 28EEA80A 		fmuls	s0, s17, s17
 4882 00f6 08EE080A 		fmacs	s0, s16, s16
  90:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****    
  91:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   hdgX = magX / tmp;
  92:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   hdgY = -magY / tmp;
 4883              		.loc 23 92 0
 4884 00fa F1EE688A 		fnegs	s17, s17
 4885              	.LVL258:
  89:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   const float tmp  = sqrt(magX * magX + magY * magY);
 4886              		.loc 23 89 0
 4887 00fe 10EE100A 		fmrs	r0, s0
 4888 0102 FFF7FEFF 		bl	__aeabi_f2d
 4889 0106 FFF7FEFF 		bl	sqrt
 4890 010a FFF7FEFF 		bl	__aeabi_d2f
 4891 010e 07EE900A 		fmsr	s15, r0
 4892              	.LVL259:
  91:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   hdgX = magX / tmp;
 4893              		.loc 23 91 0
 4894 0112 88EE277A 		fdivs	s14, s16, s15
 4895 0116 0D48     		ldr	r0, .L283+32
 4896              	.LVL260:
 4897              		.loc 23 92 0
 4898 0118 0D4B     		ldr	r3, .L283+36
 4899 011a C8EEA77A 		fdivs	s15, s17, s15
 4900              	.LVL261:
  91:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   hdgX = magX / tmp;
 4901              		.loc 23 91 0
 4902 011e 80ED007A 		fsts	s14, [r0, #0]
 4903              		.loc 23 92 0
 4904 0122 C3ED007A 		fsts	s15, [r3, #0]
 4905              	.LBE126:
  93:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** }
 4906              		.loc 23 93 0
 4907 0126 BDEC088B 		fldmfdd	sp!, {d8, d9, d10, d11}
 4908 012a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 4909              	.L284:
 4910              		.align	2
 4911              	.L283:
 4912 012c 00000000 		.word	.LANCHOR68
 4913 0130 00000000 		.word	.LANCHOR78
 4914 0134 00000000 		.word	Wire
 4915 0138 00000000 		.word	.LANCHOR76
 4916 013c 00000000 		.word	.LANCHOR75
 4917 0140 00000000 		.word	.LANCHOR77
 4918 0144 00000000 		.word	.LANCHOR79
 4919 0148 00000000 		.word	.LANCHOR69
 4920 014c 00000000 		.word	.LANCHOR66
 4921 0150 00000000 		.word	.LANCHOR67
 4922              		.cfi_endproc
 4923              	.LFE188:
 4925              		.section	.text._Z22initializeMagnetometerv,"ax",%progbits
 4926              		.align	1
 4927              		.global	_Z22initializeMagnetometerv
 4928              		.thumb
 4929              		.thumb_func
 4931              	_Z22initializeMagnetometerv:
 4932              	.LFB187:
  44:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** void initializeMagnetometer() {
 4933              		.loc 23 44 0
 4934              		.cfi_startproc
 4935              		@ args = 0, pretend = 0, frame = 0
 4936              		@ frame_needed = 0, uses_anonymous_args = 0
  46:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   delay(10);                             // Power up delay **
 4937              		.loc 23 46 0
 4938 0000 0A20     		movs	r0, #10
  44:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** void initializeMagnetometer() {
 4939              		.loc 23 44 0
 4940 0002 08B5     		push	{r3, lr}
 4941              	.LCFI53:
 4942              		.cfi_def_cfa_offset 8
 4943              		.cfi_offset 14, -4
 4944              		.cfi_offset 3, -8
  46:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   delay(10);                             // Power up delay **
 4945              		.loc 23 46 0
 4946 0004 FFF7FEFF 		bl	_Z5delaym
  48:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   if (readWhoI2C(COMPASS_ADDRESS) == COMPASS_IDENTITY) {
 4947              		.loc 23 48 0
 4948 0008 1E20     		movs	r0, #30
 4949 000a FFF7FEFF 		bl	_Z10readWhoI2Ci
 4950 000e 1028     		cmp	r0, #16
 4951 0010 04D1     		bne	.L286
  49:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 	  vehicleState |= MAG_DETECTED;
 4952              		.loc 23 49 0
 4953 0012 0D4B     		ldr	r3, .L287
 4954 0014 1868     		ldr	r0, [r3, #0]
 4955 0016 40F00402 		orr	r2, r0, #4
 4956 001a 1A60     		str	r2, [r3, #0]
 4957              	.L286:
  52:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   updateRegisterI2C(COMPASS_ADDRESS, 0x01, SENSOR_GAIN); // Gain as defined above
 4958              		.loc 23 52 0
 4959 001c 0121     		movs	r1, #1
 4960 001e 2022     		movs	r2, #32
 4961 0020 1E20     		movs	r0, #30
 4962 0022 FFF7FEFF 		bl	_Z17updateRegisterI2Cihh
  53:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   delay(20);
 4963              		.loc 23 53 0
 4964 0026 1420     		movs	r0, #20
 4965 0028 FFF7FEFF 		bl	_Z5delaym
  54:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   updateRegisterI2C(COMPASS_ADDRESS, 0x02, 0x01); // start single conversion
 4966              		.loc 23 54 0
 4967 002c 0221     		movs	r1, #2
 4968 002e 1E20     		movs	r0, #30
 4969 0030 0122     		movs	r2, #1
 4970 0032 FFF7FEFF 		bl	_Z17updateRegisterI2Cihh
  55:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   delay(20);
 4971              		.loc 23 55 0
 4972 0036 1420     		movs	r0, #20
 4973 0038 FFF7FEFF 		bl	_Z5delaym
  57:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measureMagnetometer(0.0, 0.0);  // Assume 1st measurement at 0 degrees roll and 0 degrees pitch
 4974              		.loc 23 57 0
 4975 003c 0020     		movs	r0, #0
 4976 003e 0146     		mov	r1, r0	@ float
  58:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** }
 4977              		.loc 23 58 0
 4978 0040 BDE80840 		pop	{r3, lr}
  57:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measureMagnetometer(0.0, 0.0);  // Assume 1st measurement at 0 degrees roll and 0 degrees pitch
 4979              		.loc 23 57 0
 4980 0044 FFF7FEBF 		b	_Z19measureMagnetometerff
 4981              	.L288:
 4982              		.align	2
 4983              	.L287:
 4984 0048 00000000 		.word	.LANCHOR21
 4985              		.cfi_endproc
 4986              	.LFE187:
 4988              		.section	.text._Z15getBaroAltitudev,"ax",%progbits
 4989              		.align	1
 4990              		.global	_Z15getBaroAltitudev
 4991              		.thumb
 4992              		.thumb_func
 4994              	_Z15getBaroAltitudev:
 4995              	.LFB190:
 4996              		.file 24 "../Libraries/AQ_BarometricSensor/BarometricSensor.h"
   1:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** /*
   2:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   www.AeroQuad.com
   4:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****  
   7:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   (at your option) any later version. 
  11:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** 
  12:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** 
  17:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** */
  20:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** 
  21:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** #ifndef _AQ_BAROMETRIC_SENSOR_
  22:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** #define _AQ_BAROMETRIC_SENSOR_
  23:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** 
  24:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** #include "Arduino.h"
  25:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** #include "GlobalDefined.h"
  26:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** 
  27:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** float baroAltitude      = 0.0; 
  28:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** float baroRawAltitude   = 0.0;
  29:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** float baroGroundAltitude = 0.0;
  30:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** float baroSmoothFactor   = 0.02;
  31:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   
  32:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** // **********************************************************************
  33:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** // The following function calls must be defined inside any new subclasses
  34:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** // **********************************************************************
  35:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** void initializeBaro(); 
  36:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** void measureBaro();
  37:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** void measureBaroSum();
  38:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** void evaluateBaroAltitude();
  39:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   
  40:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** // *********************************************************
  41:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** // The following functions are common between all subclasses
  42:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** // *********************************************************
  43:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** const float getBaroAltitude() {
 4997              		.loc 24 43 0
 4998              		.cfi_startproc
 4999              		@ args = 0, pretend = 0, frame = 0
 5000              		@ frame_needed = 0, uses_anonymous_args = 0
 5001              		@ link register save eliminated.
  44:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   return baroAltitude - baroGroundAltitude;
 5002              		.loc 24 44 0
 5003 0000 0548     		ldr	r0, .L290
 5004 0002 064B     		ldr	r3, .L290+4
 5005 0004 90ED007A 		flds	s14, [r0, #0]
 5006 0008 93ED000A 		flds	s0, [r3, #0]
  45:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** }
 5007              		.loc 24 45 0
 5008 000c 77EE407A 		fsubs	s15, s14, s0
 5009 0010 17EE900A 		fmrs	r0, s15
 5010 0014 7047     		bx	lr
 5011              	.L291:
 5012 0016 00BF     		.align	2
 5013              	.L290:
 5014 0018 00000000 		.word	.LANCHOR80
 5015 001c 00000000 		.word	.LANCHOR81
 5016              		.cfi_endproc
 5017              	.LFE190:
 5019              		.section	.text._ZL15hottv4UpdateAltv,"ax",%progbits
 5020              		.align	1
 5021              		.thumb
 5022              		.thumb_func
 5024              	_ZL15hottv4UpdateAltv:
 5025              	.LFB222:
 149:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static int32_t hottv4UpdateAlt() {
 5026              		.loc 5 149 0
 5027              		.cfi_startproc
 5028              		@ args = 0, pretend = 0, frame = 0
 5029              		@ frame_needed = 0, uses_anonymous_args = 0
 5030              	.LVL262:
 5031 0000 08B5     		push	{r3, lr}
 5032              	.LCFI54:
 5033              		.cfi_def_cfa_offset 8
 5034              		.cfi_offset 14, -4
 5035              		.cfi_offset 3, -8
 5036              	.LBB127:
 153:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   alt = (int)getBaroAltitude() + 500;
 5037              		.loc 5 153 0
 5038 0002 FFF7FEFF 		bl	_Z15getBaroAltitudev
 5039 0006 00EE100A 		fmsr	s0, r0
 5040 000a FDEEC07A 		ftosizs	s15, s0
 162:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(alt > maxAltitude) maxAltitude = alt;
 5041              		.loc 5 162 0
 5042 000e 084B     		ldr	r3, .L295
 153:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   alt = (int)getBaroAltitude() + 500;
 5043              		.loc 5 153 0
 5044 0010 17EE900A 		fmrs	r0, s15	@ int
 162:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(alt > maxAltitude) maxAltitude = alt;
 5045              		.loc 5 162 0
 5046 0014 1A68     		ldr	r2, [r3, #0]
 153:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   alt = (int)getBaroAltitude() + 500;
 5047              		.loc 5 153 0
 5048 0016 00F5FA70 		add	r0, r0, #500
 5049              	.LVL263:
 162:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(alt > maxAltitude) maxAltitude = alt;
 5050              		.loc 5 162 0
 5051 001a 9042     		cmp	r0, r2
 5052 001c 01DD     		ble	.L293
 162:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(alt > maxAltitude) maxAltitude = alt;
 5053              		.loc 5 162 0 is_stmt 0 discriminator 1
 5054 001e 1860     		str	r0, [r3, #0]
 5055 0020 08BD     		pop	{r3, pc}
 5056              	.L293:
 163:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   else if(alt < minAltitude) minAltitude = alt;
 5057              		.loc 5 163 0 is_stmt 1
 5058 0022 044B     		ldr	r3, .L295+4
 5059 0024 1968     		ldr	r1, [r3, #0]
 5060 0026 8842     		cmp	r0, r1
 5061 0028 B8BF     		it	lt
 5062 002a 1860     		strlt	r0, [r3, #0]
 5063              	.LBE127:
 166:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 5064              		.loc 5 166 0
 5065 002c 08BD     		pop	{r3, pc}
 5066              	.L296:
 5067 002e 00BF     		.align	2
 5068              	.L295:
 5069 0030 00000000 		.word	.LANCHOR82
 5070 0034 00000000 		.word	.LANCHOR83
 5071              		.cfi_endproc
 5072              	.LFE222:
 5074              		.section	.text._Z10MS5611crc4Pt,"ax",%progbits
 5075              		.align	1
 5076              		.global	_Z10MS5611crc4Pt
 5077              		.thumb
 5078              		.thumb_func
 5080              	_Z10MS5611crc4Pt:
 5081              	.LFB192:
 5082              		.file 25 "../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h"
   1:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** /*
   2:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   www.AeroQuad.com
   4:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
   7:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   This program is free software: you can redistribute it and/or modify
   8:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   it under the terms of the GNU General Public License as published by
   9:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   the Free Software Foundation, either version 3 of the License, or
  10:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   (at your option) any later version.
  11:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  12:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   This program is distributed in the hope that it will be useful,
  13:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   GNU General Public License for more details.
  16:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  17:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   You should have received a copy of the GNU General Public License
  18:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** */
  20:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  21:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** // parts of this code were taken from AN520, an early version of fabio's library and the AQ BMP085 
  22:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  23:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #ifndef _AQ_BAROMETRIC_SENSOR_MS5611_
  24:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define _AQ_BAROMETRIC_SENSOR_MS5611_
  25:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  26:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #include "BarometricSensor.h"
  27:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #include "Device_I2C.h"
  28:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #include <AQMath.h>
  29:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  30:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  31:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** //#define DEBUG_MS5611
  32:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS5611_I2C_ADDRESS         0x76
  33:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  34:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_PROM_BASE_ADDR  0xA0
  35:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_PROM_REG_COUNT  8     // number of registers in the PROM
  36:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_D1_Pressure     0x40
  37:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_D2_Temperature  0x50
  38:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_RESET           0x1E
  39:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  40:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** // D1 and D2 result size (bytes)
  41:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_D1D2_SIZE       3
  42:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  43:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** // OSR (Over Sampling Ratio) constants
  44:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_OSR_256         0x00
  45:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_OSR_512         0x02
  46:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_OSR_1024        0x04
  47:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_OSR_2048        0x06
  48:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_OSR_4096        0x08
  49:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  50:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** unsigned short MS5611Prom[MS561101BA_PROM_REG_COUNT];
  51:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  52:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** long MS5611lastRawTemperature;
  53:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** long MS5611lastRawPressure;
  54:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** int64_t MS5611_sens=0;
  55:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** int64_t MS5611_offset=0;
  56:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  57:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** // taken from AN520
  58:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** unsigned char MS5611crc4(unsigned short n_prom[])
  59:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** {
 5083              		.loc 25 59 0
 5084              		.cfi_startproc
 5085              		@ args = 0, pretend = 0, frame = 0
 5086              		@ frame_needed = 0, uses_anonymous_args = 0
 5087              	.LVL264:
 5088 0000 30B5     		push	{r4, r5, lr}
 5089              	.LCFI55:
 5090              		.cfi_def_cfa_offset 12
 5091              		.cfi_offset 14, -4
 5092              		.cfi_offset 5, -8
 5093              		.cfi_offset 4, -12
 5094              	.LBB128:
  60:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	unsigned short n_rem = 0;               // crc reminder
  61:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	unsigned short crc_read;            // original value of the crc
  62:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  63:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	crc_read  = n_prom[7];               //save read CRC
 5095              		.loc 25 63 0
 5096 0002 C489     		ldrh	r4, [r0, #14]
 5097              	.LVL265:
  64:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	n_prom[7] = (0xFF00 & (n_prom[7])); //CRC byte is replaced by 0
  65:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  66:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	for (int cnt = 0; cnt < 16; cnt++) {   // operation is performed on bytes
 5098              		.loc 25 66 0
 5099 0004 0022     		movs	r2, #0
  64:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	n_prom[7] = (0xFF00 & (n_prom[7])); //CRC byte is replaced by 0
 5100              		.loc 25 64 0
 5101 0006 24F0FF03 		bic	r3, r4, #255
 5102 000a C381     		strh	r3, [r0, #14]	@ movhi
 5103              	.LVL266:
  60:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	unsigned short n_rem = 0;               // crc reminder
 5104              		.loc 25 60 0
 5105 000c 1346     		mov	r3, r2
 5106              	.LVL267:
 5107              	.L303:
 5108 000e 5110     		asrs	r1, r2, #1
 5109              	.LBB129:
 5110              	.LBB130:
  67:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	    // choose LSB or MSB
  68:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		if (cnt%2 == 1) {
 5111              		.loc 25 68 0
 5112 0010 12F0010F 		tst	r2, #1
  69:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			n_rem ^= (n_prom[cnt>>1]) & 0x00FF;
 5113              		.loc 25 69 0
 5114 0014 15BF     		itete	ne
 5115 0016 10F81110 		ldrbne	r1, [r0, r1, lsl #1]	@ zero_extendqisi2
  70:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		} else {
  71:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			n_rem ^= n_prom[cnt>>1] >> 8;
 5116              		.loc 25 71 0
 5117 001a 30F81110 		ldrheq	r1, [r0, r1, lsl #1]
  69:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			n_rem ^= (n_prom[cnt>>1]) & 0x00FF;
 5118              		.loc 25 69 0
 5119 001e 4B40     		eorne	r3, r1, r3
 5120              	.LVL268:
 5121              		.loc 25 71 0
 5122 0020 83EA1123 		eoreq	r3, r3, r1, lsr #8
 5123              	.LVL269:
 5124              	.LBE130:
 5125              	.LBE129:
  60:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	unsigned short n_rem = 0;               // crc reminder
 5126              		.loc 25 60 0
 5127 0024 0821     		movs	r1, #8
 5128              	.LVL270:
 5129              	.L302:
 5130              	.LBB133:
 5131              	.LBB132:
 5132              	.LBB131:
  72:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		}
  73:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  74:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		for (int n_bit = 8; n_bit > 0; n_bit--) {
  75:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			if (n_rem & (0x8000)) {
 5133              		.loc 25 75 0
 5134 0026 13F4004F 		tst	r3, #32768
 5135 002a 4FEA4303 		lsl	r3, r3, #1
  76:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 				n_rem = (n_rem << 1) ^ 0x3000;
 5136              		.loc 25 76 0
 5137 002e 1DBF     		ittte	ne
 5138 0030 83F44055 		eorne	r5, r3, #12288
 5139 0034 4FF6FE73 		movwne	r3, #65534
 5140 0038 2B40     		andne	r3, r5, r3
 5141              	.LVL271:
  77:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			} else {
  78:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 				n_rem = (n_rem << 1);
 5142              		.loc 25 78 0
 5143 003a 9BB2     		uxtheq	r3, r3
 5144              	.LVL272:
  74:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		for (int n_bit = 8; n_bit > 0; n_bit--) {
 5145              		.loc 25 74 0
 5146 003c 0139     		subs	r1, r1, #1
 5147 003e F2D1     		bne	.L302
 5148              	.LBE131:
 5149              	.LBE132:
  66:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	for (int cnt = 0; cnt < 16; cnt++) {   // operation is performed on bytes
 5150              		.loc 25 66 0
 5151 0040 0132     		adds	r2, r2, #1
 5152              	.LVL273:
 5153 0042 102A     		cmp	r2, #16
 5154 0044 E3D1     		bne	.L303
 5155              	.LVL274:
 5156              	.LBE133:
  79:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			}
  80:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		}
  81:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	}
  82:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  83:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	n_rem = (n_rem >> 12) & 0xF; // // final 4-bit reminder is CRC code
  84:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  85:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	n_prom[7] = crc_read; // restore the crc_read to its original place
 5157              		.loc 25 85 0
 5158 0046 C481     		strh	r4, [r0, #14]	@ movhi
 5159              	.LBE128:
  86:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  87:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	return (n_rem);
  88:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5160              		.loc 25 88 0
 5161 0048 180B     		lsrs	r0, r3, #12
 5162              	.LVL275:
 5163 004a 30BD     		pop	{r4, r5, pc}
 5164              		.cfi_endproc
 5165              	.LFE192:
 5167              		.section	.text._Z14MS5611readPROMi,"ax",%progbits
 5168              		.align	1
 5169              		.global	_Z14MS5611readPROMi
 5170              		.thumb
 5171              		.thumb_func
 5173              	_Z14MS5611readPROMi:
 5174              	.LFB193:
  89:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  90:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** int MS5611readPROM(int addr)
  91:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** {
 5175              		.loc 25 91 0
 5176              		.cfi_startproc
 5177              		@ args = 0, pretend = 0, frame = 0
 5178              		@ frame_needed = 0, uses_anonymous_args = 0
 5179              	.LVL276:
 5180 0000 70B5     		push	{r4, r5, r6, lr}
 5181              	.LCFI56:
 5182              		.cfi_def_cfa_offset 16
 5183              		.cfi_offset 14, -4
 5184              		.cfi_offset 6, -8
 5185              		.cfi_offset 5, -12
 5186              		.cfi_offset 4, -16
 5187              	.LBB134:
 5188              	.LBB135:
  92:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	for (int i=0;i<MS561101BA_PROM_REG_COUNT; i++) {
  93:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		sendByteI2C(addr, MS561101BA_PROM_BASE_ADDR + 2*i);
  94:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		if(Wire.requestFrom(addr, 2) == 2) {
  95:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			MS5611Prom[i] = readWordI2C();
  96:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			//print("%d  %5d\r\n", i, MS5611Prom[i]);
  97:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		} else {
  98:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			return 0;
 5189              		.loc 25 98 0
 5190 0002 124D     		ldr	r5, .L311
 5191              	.LBE135:
 5192              	.LBE134:
  91:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** {
 5193              		.loc 25 91 0
 5194 0004 0646     		mov	r6, r0
 5195 0006 A024     		movs	r4, #160
 5196              	.LVL277:
 5197              	.L308:
 5198              	.LBB138:
 5199              	.LBB136:
  93:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		sendByteI2C(addr, MS561101BA_PROM_BASE_ADDR + 2*i);
 5200              		.loc 25 93 0
 5201 0008 3046     		mov	r0, r6
 5202 000a 2146     		mov	r1, r4
 5203 000c FFF7FEFF 		bl	_Z11sendByteI2Cih
  94:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		if(Wire.requestFrom(addr, 2) == 2) {
 5204              		.loc 25 94 0
 5205 0010 0222     		movs	r2, #2
 5206 0012 0F48     		ldr	r0, .L311+4
 5207 0014 3146     		mov	r1, r6
 5208 0016 FFF7FEFF 		bl	_ZN7TwoWire11requestFromEii
 5209 001a 0228     		cmp	r0, #2
 5210 001c 13D1     		bne	.L309
  95:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			MS5611Prom[i] = readWordI2C();
 5211              		.loc 25 95 0
 5212 001e FFF7FEFF 		bl	_Z11readWordI2Cv
 5213 0022 0234     		adds	r4, r4, #2
 5214 0024 E4B2     		uxtb	r4, r4
  92:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	for (int i=0;i<MS561101BA_PROM_REG_COUNT; i++) {
 5215              		.loc 25 92 0
 5216 0026 B02C     		cmp	r4, #176
  95:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			MS5611Prom[i] = readWordI2C();
 5217              		.loc 25 95 0
 5218 0028 25F8020F 		strh	r0, [r5, #2]!	@ movhi
  92:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	for (int i=0;i<MS561101BA_PROM_REG_COUNT; i++) {
 5219              		.loc 25 92 0
 5220 002c ECD1     		bne	.L308
 5221              	.LBE136:
  99:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		}
 100:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	}
 101:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 102:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	int crc     = MS5611crc4(MS5611Prom);
 5222              		.loc 25 102 0
 5223 002e 094C     		ldr	r4, .L311+8
 5224 0030 2046     		mov	r0, r4
 5225 0032 FFF7FEFF 		bl	_Z10MS5611crc4Pt
 5226              	.LVL278:
 103:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	int crcProm = MS5611Prom[7] & 0xf;
 5227              		.loc 25 103 0
 5228 0036 E289     		ldrh	r2, [r4, #14]
 5229 0038 02F00F01 		and	r1, r2, #15
  98:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			return 0;
 5230              		.loc 25 98 0
 5231 003c 431A     		subs	r3, r0, r1
 5232 003e 5842     		rsbs	r0, r3, #0
 5233              	.LVL279:
 5234 0040 40EB0300 		adc	r0, r0, r3
 5235 0044 70BD     		pop	{r4, r5, r6, pc}
 5236              	.LVL280:
 5237              	.L309:
 5238              	.LBB137:
 5239 0046 0020     		movs	r0, #0
 5240              	.LBE137:
 5241              	.LBE138:
 104:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	//print("crc calculated %d,  prom %d, crc is %s\r\n", crc, crcProm, (crc == crcProm) ? "good" : "b
 105:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	if(crc == crcProm) {
 106:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		return 1;
 107:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	}
 108:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	return 0;
 109:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5242              		.loc 25 109 0
 5243 0048 70BD     		pop	{r4, r5, r6, pc}
 5244              	.L312:
 5245 004a 00BF     		.align	2
 5246              	.L311:
 5247 004c FEFFFFFF 		.word	.LANCHOR84-2
 5248 0050 00000000 		.word	Wire
 5249 0054 00000000 		.word	.LANCHOR84
 5250              		.cfi_endproc
 5251              	.LFE193:
 5253              		.section	.text._Z11MS5611reseti,"ax",%progbits
 5254              		.align	1
 5255              		.global	_Z11MS5611reseti
 5256              		.thumb
 5257              		.thumb_func
 5259              	_Z11MS5611reseti:
 5260              	.LFB194:
 110:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 111:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void MS5611reset(int addr) {
 5261              		.loc 25 111 0
 5262              		.cfi_startproc
 5263              		@ args = 0, pretend = 0, frame = 0
 5264              		@ frame_needed = 0, uses_anonymous_args = 0
 5265              		@ link register save eliminated.
 5266              	.LVL281:
 112:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	sendByteI2C(addr, MS561101BA_RESET);
 5267              		.loc 25 112 0
 5268 0000 1E21     		movs	r1, #30
 113:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5269              		.loc 25 113 0
 112:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	sendByteI2C(addr, MS561101BA_RESET);
 5270              		.loc 25 112 0
 5271 0002 FFF7FEBF 		b	_Z11sendByteI2Cih
 5272              	.LVL282:
 5273              		.cfi_endproc
 5274              	.LFE194:
 5276              		.section	.text._Z20MS5611readConversioni,"ax",%progbits
 5277              		.align	1
 5278              		.global	_Z20MS5611readConversioni
 5279              		.thumb
 5280              		.thumb_func
 5282              	_Z20MS5611readConversioni:
 5283              	.LFB195:
 114:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 115:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 116:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 117:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** float pressure			 = 0;
 118:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** long rawPressure         = 0;
 119:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** long rawTemperature      = 0;
 120:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** byte pressureCount       = 0;
 121:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** float pressureFactor     = 1/5.255;
 122:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** boolean isReadPressure   = false;
 123:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** float rawPressureSum     = 0;
 124:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** byte rawPressureSumCount = 0;
 125:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 126:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** unsigned long MS5611readConversion(int addr) {
 5284              		.loc 25 126 0
 5285              		.cfi_startproc
 5286              		@ args = 0, pretend = 0, frame = 0
 5287              		@ frame_needed = 0, uses_anonymous_args = 0
 5288              	.LVL283:
 5289 0000 10B5     		push	{r4, lr}
 5290              	.LCFI57:
 5291              		.cfi_def_cfa_offset 8
 5292              		.cfi_offset 14, -4
 5293              		.cfi_offset 4, -8
 5294              	.LBB139:
 127:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   unsigned long conversion = 0;
 128:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 129:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   // start read sequence
 130:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   sendByteI2C(addr, 0);
 5295              		.loc 25 130 0
 5296 0002 0021     		movs	r1, #0
 5297              	.LBE139:
 126:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** unsigned long MS5611readConversion(int addr) {
 5298              		.loc 25 126 0
 5299 0004 0446     		mov	r4, r0
 5300              	.LBB140:
 5301              		.loc 25 130 0
 5302 0006 FFF7FEFF 		bl	_Z11sendByteI2Cih
 5303              	.LVL284:
 131:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Wire.requestFrom(addr, MS561101BA_D1D2_SIZE);
 5304              		.loc 25 131 0
 5305 000a 0322     		movs	r2, #3
 5306 000c 2146     		mov	r1, r4
 5307 000e 0B48     		ldr	r0, .L317
 5308 0010 FFF7FEFF 		bl	_ZN7TwoWire11requestFromEii
 132:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   if(Wire.available() == MS561101BA_D1D2_SIZE) {
 5309              		.loc 25 132 0
 5310 0014 0948     		ldr	r0, .L317
 5311 0016 FFF7FEFF 		bl	_ZN7TwoWire9availableEv
 5312 001a 0328     		cmp	r0, #3
 5313 001c 0BD1     		bne	.L316
 133:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     conversion = (readByteI2C() << 16) | (readByteI2C() << 8) | (readByteI2C() << 0);
 5314              		.loc 25 133 0
 5315 001e FFF7FEFF 		bl	_Z11readByteI2Cv
 5316 0022 0446     		mov	r4, r0
 5317              	.LVL285:
 5318 0024 FFF7FEFF 		bl	_Z11readByteI2Cv
 5319 0028 0002     		lsls	r0, r0, #8
 5320 002a 40EA0444 		orr	r4, r0, r4, lsl #16
 5321 002e FFF7FEFF 		bl	_Z11readByteI2Cv
 5322 0032 2043     		orrs	r0, r0, r4
 5323              	.LVL286:
 5324 0034 10BD     		pop	{r4, pc}
 5325              	.LVL287:
 5326              	.L316:
 134:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   } else {
 135:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     conversion = 0;
 5327              		.loc 25 135 0
 5328 0036 0020     		movs	r0, #0
 5329              	.LVL288:
 5330              	.LBE140:
 136:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   }
 137:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 138:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   return conversion;
 139:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5331              		.loc 25 139 0
 5332 0038 10BD     		pop	{r4, pc}
 5333              	.L318:
 5334 003a 00BF     		.align	2
 5335              	.L317:
 5336 003c 00000000 		.word	Wire
 5337              		.cfi_endproc
 5338              	.LFE195:
 5340              		.section	.text._Z21requestRawTemperaturev,"ax",%progbits
 5341              		.align	1
 5342              		.global	_Z21requestRawTemperaturev
 5343              		.thumb
 5344              		.thumb_func
 5346              	_Z21requestRawTemperaturev:
 5347              	.LFB196:
 140:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 141:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 142:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void requestRawTemperature()
 143:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** {
 5348              		.loc 25 143 0
 5349              		.cfi_startproc
 5350              		@ args = 0, pretend = 0, frame = 0
 5351              		@ frame_needed = 0, uses_anonymous_args = 0
 5352              		@ link register save eliminated.
 144:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   sendByteI2C(MS5611_I2C_ADDRESS, MS561101BA_D2_Temperature + MS561101BA_OSR_4096);
 5353              		.loc 25 144 0
 5354 0000 7620     		movs	r0, #118
 5355 0002 5821     		movs	r1, #88
 145:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5356              		.loc 25 145 0
 144:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   sendByteI2C(MS5611_I2C_ADDRESS, MS561101BA_D2_Temperature + MS561101BA_OSR_4096);
 5357              		.loc 25 144 0
 5358 0004 FFF7FEBF 		b	_Z11sendByteI2Cih
 5359              		.cfi_endproc
 5360              	.LFE196:
 5362              		.section	.text._Z18readRawTemperaturev,"ax",%progbits
 5363              		.align	1
 5364              		.global	_Z18readRawTemperaturev
 5365              		.thumb
 5366              		.thumb_func
 5368              	_Z18readRawTemperaturev:
 5369              	.LFB197:
 146:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 147:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 148:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** unsigned long readRawTemperature()
 149:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** {
 5370              		.loc 25 149 0
 5371              		.cfi_startproc
 5372              		@ args = 0, pretend = 0, frame = 0
 5373              		@ frame_needed = 0, uses_anonymous_args = 0
 5374 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 5375              	.LCFI58:
 5376              		.cfi_def_cfa_offset 32
 5377              		.cfi_offset 14, -4
 5378              		.cfi_offset 9, -8
 5379              		.cfi_offset 8, -12
 5380              		.cfi_offset 7, -16
 5381              		.cfi_offset 6, -20
 5382              		.cfi_offset 5, -24
 5383              		.cfi_offset 4, -28
 5384              		.cfi_offset 3, -32
 5385              	.LBB141:
 150:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   // see datasheet page 7 for formulas
 151:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611lastRawTemperature = MS5611readConversion(MS5611_I2C_ADDRESS);
 5386              		.loc 25 151 0
 5387 0004 7620     		movs	r0, #118
 5388 0006 FFF7FEFF 		bl	_Z20MS5611readConversioni
 152:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   int64_t dT     = MS5611lastRawTemperature - (((long)MS5611Prom[5]) << 8);
 5389              		.loc 25 152 0
 5390 000a 1849     		ldr	r1, .L321
 151:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611lastRawTemperature = MS5611readConversion(MS5611_I2C_ADDRESS);
 5391              		.loc 25 151 0
 5392 000c 184A     		ldr	r2, .L321+4
 153:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611_offset  = (((int64_t)MS5611Prom[2]) << 16) + ((MS5611Prom[4] * dT) >> 7);
 5393              		.loc 25 153 0
 5394 000e 8B88     		ldrh	r3, [r1, #4]
 152:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   int64_t dT     = MS5611lastRawTemperature - (((long)MS5611Prom[5]) << 8);
 5395              		.loc 25 152 0
 5396 0010 4C89     		ldrh	r4, [r1, #10]
 151:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611lastRawTemperature = MS5611readConversion(MS5611_I2C_ADDRESS);
 5397              		.loc 25 151 0
 5398 0012 1060     		str	r0, [r2, #0]
 5399              		.loc 25 153 0
 5400 0014 4FEA0348 		lsl	r8, r3, #16
 152:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   int64_t dT     = MS5611lastRawTemperature - (((long)MS5611Prom[5]) << 8);
 5401              		.loc 25 152 0
 5402 0018 2402     		lsls	r4, r4, #8
 5403              		.loc 25 153 0
 5404 001a 0B89     		ldrh	r3, [r1, #8]
 5405 001c 154D     		ldr	r5, .L321+8
 152:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   int64_t dT     = MS5611lastRawTemperature - (((long)MS5611Prom[5]) << 8);
 5406              		.loc 25 152 0
 5407 001e 041B     		subs	r4, r0, r4
 5408              		.loc 25 153 0
 5409 0020 A3FB0467 		umull	r6, r7, r3, r4
 152:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   int64_t dT     = MS5611lastRawTemperature - (((long)MS5611Prom[5]) << 8);
 5410              		.loc 25 152 0
 5411 0024 4FEAE47C 		asr	ip, r4, #31
 5412              	.LVL289:
 5413              		.loc 25 153 0
 5414 0028 03FB0C77 		mla	r7, r3, ip, r7
 5415 002c F209     		lsrs	r2, r6, #7
 5416 002e 42EA4762 		orr	r2, r2, r7, lsl #25
 5417 0032 FB11     		asrs	r3, r7, #7
 5418 0034 4FF00009 		mov	r9, #0
 5419 0038 12EB0802 		adds	r2, r2, r8
 5420 003c 43EB0903 		adc	r3, r3, r9
 5421 0040 C5E90023 		strd	r2, [r5]
 154:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611_sens    = (((int64_t)MS5611Prom[1]) << 15) + ((MS5611Prom[3] * dT) >> 8);
 5422              		.loc 25 154 0
 5423 0044 4B88     		ldrh	r3, [r1, #2]
 5424 0046 DE03     		lsls	r6, r3, #15
 5425 0048 CB88     		ldrh	r3, [r1, #6]
 5426 004a 0B49     		ldr	r1, .L321+12
 5427 004c A3FB0445 		umull	r4, r5, r3, r4
 5428              	.LVL290:
 5429 0050 03FB0C55 		mla	r5, r3, ip, r5
 5430 0054 220A     		lsrs	r2, r4, #8
 5431 0056 42EA0562 		orr	r2, r2, r5, lsl #24
 5432 005a 0027     		movs	r7, #0
 5433 005c 2B12     		asrs	r3, r5, #8
 5434 005e 9219     		adds	r2, r2, r6
 5435 0060 43EB0703 		adc	r3, r3, r7
 5436 0064 C1E90023 		strd	r2, [r1]
 5437              	.LBE141:
 155:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 156:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 157:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #ifdef DEBUG_MS5611
 158:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Serial.print(" rT: ");
 159:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Serial.print(MS5611lastRawTemperature);
 160:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #endif
 161:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 162:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   return MS5611lastRawTemperature;
 163:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5438              		.loc 25 163 0
 5439 0068 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 5440              	.L322:
 5441              		.align	2
 5442              	.L321:
 5443 006c 00000000 		.word	.LANCHOR84
 5444 0070 00000000 		.word	.LANCHOR85
 5445 0074 00000000 		.word	.LANCHOR86
 5446 0078 00000000 		.word	.LANCHOR87
 5447              		.cfi_endproc
 5448              	.LFE197:
 5450              		.global	__aeabi_l2f
 5451              		.section	.text._Z15readTemperaturev,"ax",%progbits
 5452              		.align	1
 5453              		.global	_Z15readTemperaturev
 5454              		.thumb
 5455              		.thumb_func
 5457              	_Z15readTemperaturev:
 5458              	.LFB198:
 164:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 165:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 166:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** float readTemperature()
 167:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** {
 5459              		.loc 25 167 0
 5460              		.cfi_startproc
 5461              		@ args = 0, pretend = 0, frame = 0
 5462              		@ frame_needed = 0, uses_anonymous_args = 0
 5463 0000 38B5     		push	{r3, r4, r5, lr}
 5464              	.LCFI59:
 5465              		.cfi_def_cfa_offset 16
 5466              		.cfi_offset 14, -4
 5467              		.cfi_offset 5, -8
 5468              		.cfi_offset 4, -12
 5469              		.cfi_offset 3, -16
 168:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   return ((1<<5)*2000 + (((MS5611lastRawTemperature - ((int64_t)MS5611Prom[5] << 8)) * MS5611Prom[6
 5470              		.loc 25 168 0
 5471 0002 124D     		ldr	r5, .L324
 5472 0004 124B     		ldr	r3, .L324+4
 5473 0006 6C89     		ldrh	r4, [r5, #10]
 5474 0008 1968     		ldr	r1, [r3, #0]
 5475 000a 2002     		lsls	r0, r4, #8
 5476 000c CB17     		asrs	r3, r1, #31
 5477 000e AC89     		ldrh	r4, [r5, #12]
 5478 0010 0A46     		mov	r2, r1
 5479 0012 0021     		movs	r1, #0
 5480 0014 121A     		subs	r2, r2, r0
 5481 0016 63EB0103 		sbc	r3, r3, r1
 5482 001a A2FB0401 		umull	r0, r1, r2, r4
 5483 001e 04FB0311 		mla	r1, r4, r3, r1
 5484 0022 820C     		lsrs	r2, r0, #18
 5485 0024 42EA8132 		orr	r2, r2, r1, lsl #14
 5486 0028 4FF47A40 		mov	r0, #64000
 5487 002c 8B14     		asrs	r3, r1, #18
 5488 002e 0021     		movs	r1, #0
 5489 0030 8018     		adds	r0, r0, r2
 5490 0032 41EB0301 		adc	r1, r1, r3
 5491 0036 FFF7FEFF 		bl	__aeabi_l2f
 169:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5492              		.loc 25 169 0
 5493 003a DFED067A 		flds	s15, .L324+8
 5494 003e 06EE900A 		fmsr	s13, r0
 5495 0042 C6EEA76A 		fdivs	s13, s13, s15
 5496 0046 16EE900A 		fmrs	r0, s13
 5497 004a 38BD     		pop	{r3, r4, r5, pc}
 5498              	.L325:
 5499              		.align	2
 5500              	.L324:
 5501 004c 00000000 		.word	.LANCHOR84
 5502 0050 00000000 		.word	.LANCHOR85
 5503 0054 00004845 		.word	1162346496
 5504              		.cfi_endproc
 5505              	.LFE198:
 5507              		.section	.text._Z18requestRawPressurev,"ax",%progbits
 5508              		.align	1
 5509              		.global	_Z18requestRawPressurev
 5510              		.thumb
 5511              		.thumb_func
 5513              	_Z18requestRawPressurev:
 5514              	.LFB199:
 170:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 171:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void requestRawPressure()
 172:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** {
 5515              		.loc 25 172 0
 5516              		.cfi_startproc
 5517              		@ args = 0, pretend = 0, frame = 0
 5518              		@ frame_needed = 0, uses_anonymous_args = 0
 5519              		@ link register save eliminated.
 173:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   sendByteI2C(MS5611_I2C_ADDRESS, MS561101BA_D1_Pressure + MS561101BA_OSR_4096);
 5520              		.loc 25 173 0
 5521 0000 7620     		movs	r0, #118
 5522 0002 4821     		movs	r1, #72
 174:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5523              		.loc 25 174 0
 173:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   sendByteI2C(MS5611_I2C_ADDRESS, MS561101BA_D1_Pressure + MS561101BA_OSR_4096);
 5524              		.loc 25 173 0
 5525 0004 FFF7FEBF 		b	_Z11sendByteI2Cih
 5526              		.cfi_endproc
 5527              	.LFE199:
 5529              		.section	.text._Z15readRawPressurev,"ax",%progbits
 5530              		.align	1
 5531              		.global	_Z15readRawPressurev
 5532              		.thumb
 5533              		.thumb_func
 5535              	_Z15readRawPressurev:
 5536              	.LFB200:
 175:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 176:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** float readRawPressure()
 177:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** {
 5537              		.loc 25 177 0
 5538              		.cfi_startproc
 5539              		@ args = 0, pretend = 0, frame = 0
 5540              		@ frame_needed = 0, uses_anonymous_args = 0
 5541 0000 38B5     		push	{r3, r4, r5, lr}
 5542              	.LCFI60:
 5543              		.cfi_def_cfa_offset 16
 5544              		.cfi_offset 14, -4
 5545              		.cfi_offset 5, -8
 5546              		.cfi_offset 4, -12
 5547              		.cfi_offset 3, -16
 178:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611lastRawPressure = MS5611readConversion(MS5611_I2C_ADDRESS);
 5548              		.loc 25 178 0
 5549 0002 7620     		movs	r0, #118
 5550 0004 FFF7FEFF 		bl	_Z20MS5611readConversioni
 5551 0008 124B     		ldr	r3, .L328
 179:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #ifdef DEBUG_MS5611
 180:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   //print(" dT: %6d  off: %6u p %6u  sens: %6d  ", (int32)dT, (unsigned int32)off, (unsigned int32)
 181:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Serial.print(" rP: ");
 182:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Serial.print(MS5611lastRawPressure);
 183:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #endif
 184:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 185:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   return (((( MS5611lastRawPressure * MS5611_sens) >> 21) - MS5611_offset) >> (15-5)) / ((float)(1<
 5552              		.loc 25 185 0
 5553 000a 1349     		ldr	r1, .L328+4
 178:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611lastRawPressure = MS5611readConversion(MS5611_I2C_ADDRESS);
 5554              		.loc 25 178 0
 5555 000c 1860     		str	r0, [r3, #0]
 5556              		.loc 25 185 0
 5557 000e 0B68     		ldr	r3, [r1, #0]
 5558 0010 4968     		ldr	r1, [r1, #4]
 5559 0012 C217     		asrs	r2, r0, #31
 5560 0014 4143     		muls	r1, r0, r1
 5561 0016 03FB0212 		mla	r2, r3, r2, r1
 5562 001a A3FB0001 		umull	r0, r1, r3, r0
 5563 001e 0F4B     		ldr	r3, .L328+8
 5564 0020 5118     		adds	r1, r2, r1
 5565 0022 D3E90023 		ldrd	r2, [r3]
 5566 0026 440D     		lsrs	r4, r0, #21
 5567 0028 44EAC124 		orr	r4, r4, r1, lsl #11
 5568 002c 4D15     		asrs	r5, r1, #21
 5569 002e A21A     		subs	r2, r4, r2
 5570 0030 65EB0303 		sbc	r3, r5, r3
 5571 0034 900A     		lsrs	r0, r2, #10
 5572 0036 40EA8350 		orr	r0, r0, r3, lsl #22
 5573 003a 9912     		asrs	r1, r3, #10
 5574 003c FFF7FEFF 		bl	__aeabi_l2f
 186:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5575              		.loc 25 186 0
 5576 0040 DFED077A 		flds	s15, .L328+12
 5577 0044 06EE900A 		fmsr	s13, r0
 5578 0048 66EEA76A 		fmuls	s13, s13, s15
 5579 004c 16EE900A 		fmrs	r0, s13
 5580 0050 38BD     		pop	{r3, r4, r5, pc}
 5581              	.L329:
 5582 0052 00BF     		.align	2
 5583              	.L328:
 5584 0054 00000000 		.word	.LANCHOR88
 5585 0058 00000000 		.word	.LANCHOR87
 5586 005c 00000000 		.word	.LANCHOR86
 5587 0060 0000003D 		.word	1023410176
 5588              		.cfi_endproc
 5589              	.LFE200:
 5591              		.section	.text._Z14measureBaroSumv,"ax",%progbits
 5592              		.align	1
 5593              		.global	_Z14measureBaroSumv
 5594              		.thumb
 5595              		.thumb_func
 5597              	_Z14measureBaroSumv:
 5598              	.LFB203:
 187:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 188:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** bool baroGroundUpdateDone = false;
 189:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** unsigned long baroStartTime;
 190:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 191:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void initializeBaro() {
 192:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroStartTime = micros();
 193:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 194:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressure = 0;
 195:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroGroundAltitude = 0;
 196:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressureFactor = 1/5.255;
 197:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 198:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611reset(MS5611_I2C_ADDRESS); // reset the device to populate its internal PROM registers
 199:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   delay(3); // some safety time
 200:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 201:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   if(MS5611readPROM(MS5611_I2C_ADDRESS) ) {
 202:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	  vehicleState |= BARO_DETECTED;
 203:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   }
 204:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 205:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   requestRawTemperature(); // setup up next measure() for temperature
 206:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   isReadPressure = false;
 207:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressureCount = 0;
 208:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   delay(10);
 209:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureBaroSum(); // read temperature
 210:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   delay(10);
 211:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureBaro(); // read pressure
 212:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   delay(10);
 213:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 214:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureGroundBaro();
 215:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureGroundBaro();
 216:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 217:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #if 0
 218:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   // check if measured ground altitude is valid
 219:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   while (abs(baroRawAltitude - baroGroundAltitude) > 10) {
 220:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     delay(26);
 221:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     measureGroundBaro();
 222:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   }
 223:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #endif
 224:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroAltitude = baroGroundAltitude;
 225:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 226:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 227:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void measureBaro() {
 228:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureBaroSum();
 229:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   evaluateBaroAltitude();
 230:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 231:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 232:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void measureBaroSum() {
 5599              		.loc 25 232 0
 5600              		.cfi_startproc
 5601              		@ args = 0, pretend = 0, frame = 0
 5602              		@ frame_needed = 0, uses_anonymous_args = 0
 5603 0000 38B5     		push	{r3, r4, r5, lr}
 5604              	.LCFI61:
 5605              		.cfi_def_cfa_offset 16
 5606              		.cfi_offset 14, -4
 5607              		.cfi_offset 5, -8
 5608              		.cfi_offset 4, -12
 5609              		.cfi_offset 3, -16
 233:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   // switch between pressure and temperature measurements
 234:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   if (isReadPressure) {
 5610              		.loc 25 234 0
 5611 0002 164C     		ldr	r4, .L335
 5612 0004 2378     		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 232:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void measureBaroSum() {
 5613              		.loc 25 232 0
 5614 0006 2DED028B 		fstmfdd	sp!, {d8}
 5615              	.LCFI62:
 5616              		.cfi_def_cfa_offset 24
 5617              		.cfi_offset 80, -24
 5618              		.loc 25 234 0
 5619 000a F3B1     		cbz	r3, .L331
 235:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     rawPressureSum += readRawPressure();
 5620              		.loc 25 235 0
 5621 000c 144D     		ldr	r5, .L335+4
 5622 000e 95ED008A 		flds	s16, [r5, #0]
 5623 0012 FFF7FEFF 		bl	_Z15readRawPressurev
 5624 0016 07EE900A 		fmsr	s15, r0
 236:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     rawPressureSumCount++;
 5625              		.loc 25 236 0
 5626 001a 1249     		ldr	r1, .L335+8
 235:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     rawPressureSum += readRawPressure();
 5627              		.loc 25 235 0
 5628 001c 38EE278A 		fadds	s16, s16, s15
 5629 0020 85ED008A 		fsts	s16, [r5, #0]
 5630              		.loc 25 236 0
 5631 0024 0D78     		ldrb	r5, [r1, #0]	@ zero_extendqisi2
 5632 0026 6A1C     		adds	r2, r5, #1
 237:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     if (pressureCount == 20) {
 5633              		.loc 25 237 0
 5634 0028 0F4D     		ldr	r5, .L335+12
 236:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     rawPressureSumCount++;
 5635              		.loc 25 236 0
 5636 002a 0A70     		strb	r2, [r1, #0]
 5637              		.loc 25 237 0
 5638 002c 2878     		ldrb	r0, [r5, #0]	@ zero_extendqisi2
 5639 002e 1428     		cmp	r0, #20
 5640 0030 05D1     		bne	.L332
 238:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****       requestRawTemperature();
 5641              		.loc 25 238 0
 5642 0032 FFF7FEFF 		bl	_Z21requestRawTemperaturev
 239:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****       pressureCount = 0;
 5643              		.loc 25 239 0
 5644 0036 0023     		movs	r3, #0
 5645 0038 2B70     		strb	r3, [r5, #0]
 240:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****       isReadPressure = false;
 5646              		.loc 25 240 0
 5647 003a 2370     		strb	r3, [r4, #0]
 5648 003c 01E0     		b	.L333
 5649              	.L332:
 241:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     } else {
 242:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****       requestRawPressure();
 5650              		.loc 25 242 0
 5651 003e FFF7FEFF 		bl	_Z18requestRawPressurev
 5652              	.L333:
 243:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	}
 244:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     pressureCount++;
 5653              		.loc 25 244 0
 5654 0042 2A78     		ldrb	r2, [r5, #0]	@ zero_extendqisi2
 5655 0044 501C     		adds	r0, r2, #1
 5656 0046 2870     		strb	r0, [r5, #0]
 5657 0048 05E0     		b	.L330
 5658              	.L331:
 245:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   } else { // select must equal TEMPERATURE
 246:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     readRawTemperature();
 5659              		.loc 25 246 0
 5660 004a FFF7FEFF 		bl	_Z18readRawTemperaturev
 247:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     requestRawPressure();
 5661              		.loc 25 247 0
 5662 004e FFF7FEFF 		bl	_Z18requestRawPressurev
 248:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     isReadPressure = true;
 5663              		.loc 25 248 0
 5664 0052 0121     		movs	r1, #1
 5665 0054 2170     		strb	r1, [r4, #0]
 5666              	.L330:
 249:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   }
 250:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5667              		.loc 25 250 0
 5668 0056 BDEC028B 		fldmfdd	sp!, {d8}
 5669 005a 38BD     		pop	{r3, r4, r5, pc}
 5670              	.L336:
 5671              		.align	2
 5672              	.L335:
 5673 005c 00000000 		.word	.LANCHOR89
 5674 0060 00000000 		.word	.LANCHOR90
 5675 0064 00000000 		.word	.LANCHOR91
 5676 0068 00000000 		.word	.LANCHOR92
 5677              		.cfi_endproc
 5678              	.LFE203:
 5680              		.global	__aeabi_dmul
 5681              		.section	.text._Z20evaluateBaroAltitudev,"ax",%progbits
 5682              		.align	1
 5683              		.global	_Z20evaluateBaroAltitudev
 5684              		.thumb
 5685              		.thumb_func
 5687              	_Z20evaluateBaroAltitudev:
 5688              	.LFB204:
 251:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 252:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** bool MS5611_first_read = true;
 253:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 254:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void evaluateBaroAltitude() {
 5689              		.loc 25 254 0
 5690              		.cfi_startproc
 5691              		@ args = 0, pretend = 0, frame = 0
 5692              		@ frame_needed = 0, uses_anonymous_args = 0
 5693 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 5694              	.LCFI63:
 5695              		.cfi_def_cfa_offset 24
 5696              		.cfi_offset 14, -4
 5697              		.cfi_offset 7, -8
 5698              		.cfi_offset 6, -12
 5699              		.cfi_offset 5, -16
 5700              		.cfi_offset 4, -20
 5701              		.cfi_offset 3, -24
 5702              	.LBB142:
 255:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   if (rawPressureSumCount == 0) { // it may occur at init time that no pressure has been read yet!
 5703              		.loc 25 255 0
 5704 0002 2D4D     		ldr	r5, .L341+8
 5705 0004 2B78     		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 5706 0006 002B     		cmp	r3, #0
 5707 0008 51D0     		beq	.L337
 256:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     return;
 257:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   }
 258:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 259:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressure = rawPressureSum / rawPressureSumCount;
 5708              		.loc 25 259 0
 5709 000a 06EE903A 		fmsr	s13, r3	@ int
 5710 000e 2B4C     		ldr	r4, .L341+12
 5711 0010 2B4B     		ldr	r3, .L341+16
 5712 0012 94ED007A 		flds	s14, [r4, #0]
 5713 0016 F8EEE67A 		fsitos	s15, s13
 5714 001a C7EE277A 		fdivs	s15, s14, s15
 260:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 261:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroRawAltitude = 44330 * (1 - pow(pressure/101325.0, pressureFactor)); // returns absolute baroA
 5715              		.loc 25 261 0
 5716 001e 9FED297A 		flds	s14, .L341+20
 5717 0022 C7EE876A 		fdivs	s13, s15, s14
 259:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressure = rawPressureSum / rawPressureSumCount;
 5718              		.loc 25 259 0
 5719 0026 C3ED007A 		fsts	s15, [r3, #0]
 5720              		.loc 25 261 0
 5721 002a 16EE900A 		fmrs	r0, s13
 5722 002e FFF7FEFF 		bl	__aeabi_f2d
 5723 0032 254B     		ldr	r3, .L341+24
 5724 0034 0646     		mov	r6, r0
 5725 0036 1868     		ldr	r0, [r3, #0]	@ float
 5726 0038 0F46     		mov	r7, r1
 5727 003a FFF7FEFF 		bl	__aeabi_f2d
 5728 003e 0246     		mov	r2, r0
 5729 0040 0B46     		mov	r3, r1
 5730 0042 3046     		mov	r0, r6
 5731 0044 3946     		mov	r1, r7
 5732 0046 FFF7FEFF 		bl	pow
 5733 004a 0246     		mov	r2, r0
 5734 004c 0B46     		mov	r3, r1
 5735 004e 0020     		movs	r0, #0
 5736 0050 1E49     		ldr	r1, .L341+28
 5737 0052 1F4E     		ldr	r6, .L341+32
 5738 0054 FFF7FEFF 		bl	__aeabi_dsub
 5739 0058 15A3     		adr	r3, .L341
 5740 005a D3E90023 		ldrd	r2, [r3]
 5741 005e FFF7FEFF 		bl	__aeabi_dmul
 5742 0062 FFF7FEFF 		bl	__aeabi_d2f
 5743 0066 1B4B     		ldr	r3, .L341+36
 5744 0068 1860     		str	r0, [r3, #0]	@ float
 262:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   // use calculation below in case you need a smaller binary file for CPUs having just 32KB flash R
 263:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   // baroRawAltitude = (101325.0-pressure)/4096*346;
 264:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 265:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   if(MS5611_first_read) {
 5745              		.loc 25 265 0
 5746 006a 1B4B     		ldr	r3, .L341+40
 5747 006c 1978     		ldrb	r1, [r3, #0]	@ zero_extendqisi2
 5748 006e 19B1     		cbz	r1, .L339
 266:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     baroAltitude = baroRawAltitude;
 267:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     MS5611_first_read = false;
 5749              		.loc 25 267 0
 5750 0070 0022     		movs	r2, #0
 266:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     baroAltitude = baroRawAltitude;
 5751              		.loc 25 266 0
 5752 0072 3060     		str	r0, [r6, #0]	@ float
 5753              		.loc 25 267 0
 5754 0074 1A70     		strb	r2, [r3, #0]
 5755 0076 05E0     		b	.L340
 5756              	.L339:
 268:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   } else {
 269:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     baroAltitude = filterSmooth(baroRawAltitude, baroAltitude, baroSmoothFactor);
 5757              		.loc 25 269 0
 5758 0078 184B     		ldr	r3, .L341+44
 5759 007a 3168     		ldr	r1, [r6, #0]	@ float
 5760 007c 1A68     		ldr	r2, [r3, #0]	@ float
 5761 007e FFF7FEFF 		bl	_Z12filterSmoothfff
 5762 0082 3060     		str	r0, [r6, #0]	@ float
 5763              	.L340:
 270:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   }
 271:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 272:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #ifdef DEBUG_MS5611_b
 273:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Serial.print("  p ");
 274:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Serial.print(pressure);
 275:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Serial.print("  bra ");
 276:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Serial.print(baroRawAltitude);
 277:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Serial.print("  ba ");
 278:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Serial.print(baroAltitude);
 279:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Serial.println();
 280:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #endif
 281:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 282:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   rawPressureSum = 0.0;
 5764              		.loc 25 282 0
 5765 0084 0022     		movs	r2, #0
 5766 0086 2260     		str	r2, [r4, #0]	@ float
 283:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   rawPressureSumCount = 0;
 284:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 285:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   // set ground altitude after a delay, so sensor has time to heat up
 286:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   const unsigned long updateDelayInSeconds = 10;
 287:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   if(!baroGroundUpdateDone && (micros()-baroStartTime) > updateDelayInSeconds*1000000) {
 5767              		.loc 25 287 0
 5768 0088 154C     		ldr	r4, .L341+48
 5769 008a 2078     		ldrb	r0, [r4, #0]	@ zero_extendqisi2
 283:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   rawPressureSumCount = 0;
 5770              		.loc 25 283 0
 5771 008c 0021     		movs	r1, #0
 5772 008e 2970     		strb	r1, [r5, #0]
 5773              	.LVL291:
 5774              		.loc 25 287 0
 5775 0090 68B9     		cbnz	r0, .L337
 5776              		.loc 25 287 0 is_stmt 0 discriminator 1
 5777 0092 FFF7FEFF 		bl	_ZL6microsv
 5778 0096 1349     		ldr	r1, .L341+52
 5779 0098 0B68     		ldr	r3, [r1, #0]
 5780 009a C3EB000C 		rsb	ip, r3, r0
 5781 009e 1248     		ldr	r0, .L341+56
 5782 00a0 8445     		cmp	ip, r0
 5783 00a2 04D9     		bls	.L337
 288:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	  baroGroundAltitude = baroAltitude;
 5784              		.loc 25 288 0 is_stmt 1 discriminator 4
 5785 00a4 3068     		ldr	r0, [r6, #0]	@ float
 5786 00a6 114B     		ldr	r3, .L341+60
 289:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	  baroGroundUpdateDone = true;
 5787              		.loc 25 289 0 discriminator 4
 5788 00a8 0122     		movs	r2, #1
 288:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	  baroGroundAltitude = baroAltitude;
 5789              		.loc 25 288 0 discriminator 4
 5790 00aa 1860     		str	r0, [r3, #0]	@ float
 5791              		.loc 25 289 0 discriminator 4
 5792 00ac 2270     		strb	r2, [r4, #0]
 5793              	.LVL292:
 5794              	.L337:
 5795 00ae F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 5796              	.L342:
 5797              		.align	3
 5798              	.L341:
 5799 00b0 00000000 		.word	0
 5800 00b4 40A5E540 		.word	1088791872
 5801 00b8 00000000 		.word	.LANCHOR91
 5802 00bc 00000000 		.word	.LANCHOR90
 5803 00c0 00000000 		.word	.LANCHOR93
 5804 00c4 80E6C547 		.word	1204151936
 5805 00c8 00000000 		.word	.LANCHOR94
 5806 00cc 0000F03F 		.word	1072693248
 5807 00d0 00000000 		.word	.LANCHOR80
 5808 00d4 00000000 		.word	.LANCHOR95
 5809 00d8 00000000 		.word	.LANCHOR96
 5810 00dc 00000000 		.word	.LANCHOR97
 5811 00e0 00000000 		.word	.LANCHOR98
 5812 00e4 00000000 		.word	.LANCHOR99
 5813 00e8 80969800 		.word	10000000
 5814 00ec 00000000 		.word	.LANCHOR81
 5815              	.LBE142:
 5816              		.cfi_endproc
 5817              	.LFE204:
 5819              		.section	.text._Z11measureBarov,"ax",%progbits
 5820              		.align	1
 5821              		.global	_Z11measureBarov
 5822              		.thumb
 5823              		.thumb_func
 5825              	_Z11measureBarov:
 5826              	.LFB202:
 227:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void measureBaro() {
 5827              		.loc 25 227 0
 5828              		.cfi_startproc
 5829              		@ args = 0, pretend = 0, frame = 0
 5830              		@ frame_needed = 0, uses_anonymous_args = 0
 5831 0000 08B5     		push	{r3, lr}
 5832              	.LCFI64:
 5833              		.cfi_def_cfa_offset 8
 5834              		.cfi_offset 14, -4
 5835              		.cfi_offset 3, -8
 228:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureBaroSum();
 5836              		.loc 25 228 0
 5837 0002 FFF7FEFF 		bl	_Z14measureBaroSumv
 230:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5838              		.loc 25 230 0
 5839 0006 BDE80840 		pop	{r3, lr}
 229:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   evaluateBaroAltitude();
 5840              		.loc 25 229 0
 5841 000a FFF7FEBF 		b	_Z20evaluateBaroAltitudev
 5842              		.cfi_endproc
 5843              	.LFE202:
 5845              		.section	.text._Z17measureGroundBarov,"ax",%progbits
 5846              		.align	1
 5847              		.global	_Z17measureGroundBarov
 5848              		.thumb
 5849              		.thumb_func
 5851              	_Z17measureGroundBarov:
 5852              	.LFB191:
  46:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****  
  47:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** void measureGroundBaro() {
 5853              		.loc 24 47 0
 5854              		.cfi_startproc
 5855              		@ args = 0, pretend = 0, frame = 0
 5856              		@ frame_needed = 0, uses_anonymous_args = 0
 5857              	.LVL293:
 5858 0000 10B5     		push	{r4, lr}
 5859              	.LCFI65:
 5860              		.cfi_def_cfa_offset 8
 5861              		.cfi_offset 14, -4
 5862              		.cfi_offset 4, -8
 5863 0002 2DED028B 		fstmfdd	sp!, {d8}
 5864              	.LCFI66:
 5865              		.cfi_def_cfa_offset 16
 5866              		.cfi_offset 80, -16
  48:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   // measure initial ground pressure (multiple samples)
  49:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   float altSum = 0.0;
 5867              		.loc 24 49 0
 5868 0006 9FED0C8A 		flds	s16, .L347
  47:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** void measureGroundBaro() {
 5869              		.loc 24 47 0
 5870 000a 1924     		movs	r4, #25
 5871              	.LVL294:
 5872              	.L345:
 5873              	.LBB143:
 5874              	.LBB144:
  50:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   for (int i=0; i < 25; i++) {
  51:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****     measureBaro();
 5875              		.loc 24 51 0 discriminator 2
 5876 000c FFF7FEFF 		bl	_Z11measureBarov
  52:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** 	altSum += baroRawAltitude;
 5877              		.loc 24 52 0 discriminator 2
 5878 0010 0A4B     		ldr	r3, .L347+4
 5879 0012 D3ED007A 		flds	s15, [r3, #0]
  53:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****     delay(12);
 5880              		.loc 24 53 0 discriminator 2
 5881 0016 0C20     		movs	r0, #12
  52:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** 	altSum += baroRawAltitude;
 5882              		.loc 24 52 0 discriminator 2
 5883 0018 38EE278A 		fadds	s16, s16, s15
 5884              	.LVL295:
 5885              		.loc 24 53 0 discriminator 2
 5886 001c FFF7FEFF 		bl	_Z5delaym
  50:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   for (int i=0; i < 25; i++) {
 5887              		.loc 24 50 0 discriminator 2
 5888 0020 013C     		subs	r4, r4, #1
 5889 0022 F3D1     		bne	.L345
 5890              	.LBE144:
  54:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   }
  55:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   baroGroundAltitude = altSum / 25;
 5891              		.loc 24 55 0
 5892 0024 B3EE090A 		fconsts	s0, #57
 5893 0028 88EE000A 		fdivs	s0, s16, s0
 5894 002c 0448     		ldr	r0, .L347+8
 5895 002e 80ED000A 		fsts	s0, [r0, #0]
 5896              	.LBE143:
  56:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** }
 5897              		.loc 24 56 0
 5898 0032 BDEC028B 		fldmfdd	sp!, {d8}
 5899 0036 10BD     		pop	{r4, pc}
 5900              	.L348:
 5901              		.align	2
 5902              	.L347:
 5903 0038 00000000 		.word	0
 5904 003c 00000000 		.word	.LANCHOR95
 5905 0040 00000000 		.word	.LANCHOR81
 5906              		.cfi_endproc
 5907              	.LFE191:
 5909              		.section	.text._Z14initializeBarov,"ax",%progbits
 5910              		.align	1
 5911              		.global	_Z14initializeBarov
 5912              		.thumb
 5913              		.thumb_func
 5915              	_Z14initializeBarov:
 5916              	.LFB201:
 191:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void initializeBaro() {
 5917              		.loc 25 191 0
 5918              		.cfi_startproc
 5919              		@ args = 0, pretend = 0, frame = 0
 5920              		@ frame_needed = 0, uses_anonymous_args = 0
 5921 0000 10B5     		push	{r4, lr}
 5922              	.LCFI67:
 5923              		.cfi_def_cfa_offset 8
 5924              		.cfi_offset 14, -4
 5925              		.cfi_offset 4, -8
 192:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroStartTime = micros();
 5926              		.loc 25 192 0
 5927 0002 FFF7FEFF 		bl	_ZL6microsv
 5928 0006 1A4C     		ldr	r4, .L351
 194:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressure = 0;
 5929              		.loc 25 194 0
 5930 0008 1A49     		ldr	r1, .L351+4
 192:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroStartTime = micros();
 5931              		.loc 25 192 0
 5932 000a 2060     		str	r0, [r4, #0]
 196:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressureFactor = 1/5.255;
 5933              		.loc 25 196 0
 5934 000c 1A4A     		ldr	r2, .L351+8
 5935 000e 1B4B     		ldr	r3, .L351+12
 195:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroGroundAltitude = 0;
 5936              		.loc 25 195 0
 5937 0010 1B4C     		ldr	r4, .L351+16
 196:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressureFactor = 1/5.255;
 5938              		.loc 25 196 0
 5939 0012 1A60     		str	r2, [r3, #0]	@ float
 194:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressure = 0;
 5940              		.loc 25 194 0
 5941 0014 0020     		movs	r0, #0
 5942 0016 0860     		str	r0, [r1, #0]	@ float
 195:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroGroundAltitude = 0;
 5943              		.loc 25 195 0
 5944 0018 2060     		str	r0, [r4, #0]	@ float
 198:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611reset(MS5611_I2C_ADDRESS); // reset the device to populate its internal PROM registers
 5945              		.loc 25 198 0
 5946 001a 7620     		movs	r0, #118
 5947 001c FFF7FEFF 		bl	_Z11MS5611reseti
 199:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   delay(3); // some safety time
 5948              		.loc 25 199 0
 5949 0020 0320     		movs	r0, #3
 5950 0022 FFF7FEFF 		bl	_Z5delaym
 201:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   if(MS5611readPROM(MS5611_I2C_ADDRESS) ) {
 5951              		.loc 25 201 0
 5952 0026 7620     		movs	r0, #118
 5953 0028 FFF7FEFF 		bl	_Z14MS5611readPROMi
 5954 002c 20B1     		cbz	r0, .L350
 202:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	  vehicleState |= BARO_DETECTED;
 5955              		.loc 25 202 0
 5956 002e 154B     		ldr	r3, .L351+20
 5957 0030 1868     		ldr	r0, [r3, #0]
 5958 0032 40F00802 		orr	r2, r0, #8
 5959 0036 1A60     		str	r2, [r3, #0]
 5960              	.L350:
 205:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   requestRawTemperature(); // setup up next measure() for temperature
 5961              		.loc 25 205 0
 5962 0038 FFF7FEFF 		bl	_Z21requestRawTemperaturev
 206:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   isReadPressure = false;
 5963              		.loc 25 206 0
 5964 003c 1249     		ldr	r1, .L351+24
 207:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressureCount = 0;
 5965              		.loc 25 207 0
 5966 003e 1348     		ldr	r0, .L351+28
 206:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   isReadPressure = false;
 5967              		.loc 25 206 0
 5968 0040 0023     		movs	r3, #0
 5969 0042 0B70     		strb	r3, [r1, #0]
 207:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressureCount = 0;
 5970              		.loc 25 207 0
 5971 0044 0370     		strb	r3, [r0, #0]
 208:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   delay(10);
 5972              		.loc 25 208 0
 5973 0046 0A20     		movs	r0, #10
 5974 0048 FFF7FEFF 		bl	_Z5delaym
 209:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureBaroSum(); // read temperature
 5975              		.loc 25 209 0
 5976 004c FFF7FEFF 		bl	_Z14measureBaroSumv
 210:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   delay(10);
 5977              		.loc 25 210 0
 5978 0050 0A20     		movs	r0, #10
 5979 0052 FFF7FEFF 		bl	_Z5delaym
 211:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureBaro(); // read pressure
 5980              		.loc 25 211 0
 5981 0056 FFF7FEFF 		bl	_Z11measureBarov
 212:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   delay(10);
 5982              		.loc 25 212 0
 5983 005a 0A20     		movs	r0, #10
 5984 005c FFF7FEFF 		bl	_Z5delaym
 214:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureGroundBaro();
 5985              		.loc 25 214 0
 5986 0060 FFF7FEFF 		bl	_Z17measureGroundBarov
 215:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureGroundBaro();
 5987              		.loc 25 215 0
 5988 0064 FFF7FEFF 		bl	_Z17measureGroundBarov
 224:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroAltitude = baroGroundAltitude;
 5989              		.loc 25 224 0
 5990 0068 2168     		ldr	r1, [r4, #0]	@ float
 5991 006a 094A     		ldr	r2, .L351+32
 5992 006c 1160     		str	r1, [r2, #0]	@ float
 225:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5993              		.loc 25 225 0
 5994 006e 10BD     		pop	{r4, pc}
 5995              	.L352:
 5996              		.align	2
 5997              	.L351:
 5998 0070 00000000 		.word	.LANCHOR99
 5999 0074 00000000 		.word	.LANCHOR93
 6000 0078 AEDC423E 		.word	1044569262
 6001 007c 00000000 		.word	.LANCHOR94
 6002 0080 00000000 		.word	.LANCHOR81
 6003 0084 00000000 		.word	.LANCHOR21
 6004 0088 00000000 		.word	.LANCHOR89
 6005 008c 00000000 		.word	.LANCHOR92
 6006 0090 00000000 		.word	.LANCHOR80
 6007              		.cfi_endproc
 6008              	.LFE201:
 6010              		.section	.text._Z30setBatteryCellVoltageThresholdf,"ax",%progbits
 6011              		.align	1
 6012              		.global	_Z30setBatteryCellVoltageThresholdf
 6013              		.thumb
 6014              		.thumb_func
 6016              	_Z30setBatteryCellVoltageThresholdf:
 6017              	.LFB205:
 6018              		.file 26 "../Libraries/AQ_BatteryMonitor/BatteryMonitor.h"
   1:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** /*
   2:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   AeroQuad v3.0 - May 2011
   3:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   www.AeroQuad.com
   4:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   Copyright (c) 2011 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
   7:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   This program is free software: you can redistribute it and/or modify
   8:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   it under the terms of the GNU General Public License as published by
   9:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   the Free Software Foundation, either version 3 of the License, or
  10:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   (at your option) any later version.
  11:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  12:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   This program is distributed in the hope that it will be useful,
  13:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   GNU General Public License for more details.
  16:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  17:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   You should have received a copy of the GNU General Public License
  18:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** */
  20:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  21:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** #ifndef _AQ_BATTERY_MONITOR_
  22:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** #define _AQ_BATTERY_MONITOR_
  23:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  24:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** #include <BatteryMonitorTypes.h>
  25:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  26:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** #define BM_WARNING_RATIO 1.1
  27:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  28:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** byte    numberOfBatteries = 0; 
  29:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** boolean batteryAlarm      = false;
  30:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** boolean batteryWarning    = false;
  31:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** byte    buzzerState       = 0;
  32:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  33:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** unsigned short batteryAlarmCellVoltage   = 333; // 9.9V on 3S
  34:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** unsigned short batteryWarningCellVoltage = 366; // 11.0V on 3S
  35:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  36:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** void setBatteryCellVoltageThreshold(float alarmVoltage) {
 6019              		.loc 26 36 0
 6020              		.cfi_startproc
 6021              		@ args = 0, pretend = 0, frame = 0
 6022              		@ frame_needed = 0, uses_anonymous_args = 0
 6023              		@ link register save eliminated.
 6024              	.LVL296:
 6025              		.loc 26 36 0
 6026 0000 07EE100A 		fmsr	s14, r0
  37:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   
  38:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   batteryAlarmCellVoltage   = alarmVoltage*100.0;
 6027              		.loc 26 38 0
 6028 0004 9FED0B0A 		flds	s0, .L354
  39:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   batteryWarningCellVoltage = alarmVoltage*BM_WARNING_RATIO*100.0;
 6029              		.loc 26 39 0
 6030 0008 DFED0B6A 		flds	s13, .L354+4
  38:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   batteryAlarmCellVoltage   = alarmVoltage*100.0;
 6031              		.loc 26 38 0
 6032 000c 27EE001A 		fmuls	s2, s14, s0
 6033              		.loc 26 39 0
 6034 0010 27EE267A 		fmuls	s14, s14, s13
  38:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   batteryAlarmCellVoltage   = alarmVoltage*100.0;
 6035              		.loc 26 38 0
 6036 0014 FCEEC10A 		ftouizs	s1, s2
 6037              		.loc 26 39 0
 6038 0018 27EE000A 		fmuls	s0, s14, s0
  38:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   batteryAlarmCellVoltage   = alarmVoltage*100.0;
 6039              		.loc 26 38 0
 6040 001c 10EE900A 		fmrs	r0, s1	@ int
 6041              	.LVL297:
 6042              		.loc 26 39 0
 6043 0020 FCEEC07A 		ftouizs	s15, s0
  38:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   batteryAlarmCellVoltage   = alarmVoltage*100.0;
 6044              		.loc 26 38 0
 6045 0024 0549     		ldr	r1, .L354+8
 6046              		.loc 26 39 0
 6047 0026 064B     		ldr	r3, .L354+12
  38:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   batteryAlarmCellVoltage   = alarmVoltage*100.0;
 6048              		.loc 26 38 0
 6049 0028 0880     		strh	r0, [r1, #0]	@ movhi
 6050              		.loc 26 39 0
 6051 002a 17EE902A 		fmrs	r2, s15	@ int
 6052 002e 1A80     		strh	r2, [r3, #0]	@ movhi
  40:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** }
 6053              		.loc 26 40 0
 6054 0030 7047     		bx	lr
 6055              	.L355:
 6056 0032 00BF     		.align	2
 6057              	.L354:
 6058 0034 0000C842 		.word	1120403456
 6059 0038 CDCC8C3F 		.word	1066192077
 6060 003c 00000000 		.word	.LANCHOR100
 6061 0040 00000000 		.word	.LANCHOR101
 6062              		.cfi_endproc
 6063              	.LFE205:
 6065              		.section	.text._Z12resetBatteryh,"ax",%progbits
 6066              		.align	1
 6067              		.global	_Z12resetBatteryh
 6068              		.thumb
 6069              		.thumb_func
 6071              	_Z12resetBatteryh:
 6072              	.LFB206:
  41:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  42:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** // Reset Battery statistics
  43:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** void resetBattery(byte batno) {
 6073              		.loc 26 43 0
 6074              		.cfi_startproc
 6075              		@ args = 0, pretend = 0, frame = 0
 6076              		@ frame_needed = 0, uses_anonymous_args = 0
 6077              		@ link register save eliminated.
 6078              	.LVL298:
  44:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  45:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   if (batno < numberOfBatteries) {
 6079              		.loc 26 45 0
 6080 0000 0949     		ldr	r1, .L358
 6081 0002 0B78     		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 6082 0004 8342     		cmp	r3, r0
 6083 0006 0ED9     		bls	.L356
  46:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     batteryData[batno].voltage      = 1200;
 6084              		.loc 26 46 0
 6085 0008 0849     		ldr	r1, .L358+4
 6086 000a 1822     		movs	r2, #24
 6087 000c 02FB0010 		mla	r0, r2, r0, r1
 6088              	.LVL299:
 6089 0010 4FF49663 		mov	r3, #1200	@ movhi
 6090 0014 C380     		strh	r3, [r0, #6]	@ movhi
  47:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** #ifdef BM_EXTENDED
  48:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     batteryData[batno].minVoltage   = 9900;
 6091              		.loc 26 48 0
 6092 0016 42F2AC61 		movw	r1, 9900	@ movhi
  49:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     batteryData[batno].current      = 0;
 6093              		.loc 26 49 0
 6094 001a 0023     		movs	r3, #0
  50:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     batteryData[batno].maxCurrent   = 0;
 6095              		.loc 26 50 0
 6096 001c 0022     		movs	r2, #0
  48:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     batteryData[batno].minVoltage   = 9900;
 6097              		.loc 26 48 0
 6098 001e 0181     		strh	r1, [r0, #8]	@ movhi
  49:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     batteryData[batno].current      = 0;
 6099              		.loc 26 49 0
 6100 0020 0382     		strh	r3, [r0, #16]	@ movhi
 6101              		.loc 26 50 0
 6102 0022 4282     		strh	r2, [r0, #18]	@ movhi
  51:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     batteryData[batno].usedCapacity = 0;
 6103              		.loc 26 51 0
 6104 0024 4361     		str	r3, [r0, #20]
 6105              	.L356:
 6106 0026 7047     		bx	lr
 6107              	.L359:
 6108              		.align	2
 6109              	.L358:
 6110 0028 00000000 		.word	.LANCHOR102
 6111 002c 00000000 		.word	.LANCHOR103
 6112              		.cfi_endproc
 6113              	.LFE206:
 6115              		.section	.text._Z19batteryGetCellCounth,"ax",%progbits
 6116              		.align	1
 6117              		.global	_Z19batteryGetCellCounth
 6118              		.thumb
 6119              		.thumb_func
 6121              	_Z19batteryGetCellCounth:
 6122              	.LFB208:
  52:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** #endif
  53:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   }
  54:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** }
  55:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  56:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** void initializeBatteryMonitor(byte nb, float alarmVoltage) {
  57:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  58:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   numberOfBatteries = nb;
  59:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   setBatteryCellVoltageThreshold(alarmVoltage);
  60:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   for (int i = 0; i < numberOfBatteries; i++) {
  61:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     resetBattery(i);
  62:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   }
  63:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   measureBatteryVoltage(0); // Initial measurement
  64:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** }
  65:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  66:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** byte batteryGetCellCount(byte batNo) {
 6123              		.loc 26 66 0
 6124              		.cfi_startproc
 6125              		@ args = 0, pretend = 0, frame = 0
 6126              		@ frame_needed = 0, uses_anonymous_args = 0
 6127              		@ link register save eliminated.
 6128              	.LVL300:
  67:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   if (batteryData[batNo].cells) {
 6129              		.loc 26 67 0
 6130 0000 084B     		ldr	r3, .L364
 6131 0002 1822     		movs	r2, #24
 6132 0004 02FB0033 		mla	r3, r2, r0, r3
 6133 0008 5878     		ldrb	r0, [r3, #1]	@ zero_extendqisi2
 6134              	.LVL301:
 6135 000a 50B9     		cbnz	r0, .L361
  68:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     return batteryData[batNo].cells;
  69:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   }
  70:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   else if (batteryData[batNo].voltage < 500) {
 6136              		.loc 26 70 0
 6137 000c D888     		ldrh	r0, [r3, #6]
 6138 000e B0F5FA7F 		cmp	r0, #500
 6139 0012 05D3     		bcc	.L362
  71:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     return 1;
  72:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   }
  73:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   else if (batteryData[batNo].voltage < 860) {
  74:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     return 2;
 6140              		.loc 26 74 0
 6141 0014 B0F5577F 		cmp	r0, #860
 6142 0018 2CBF     		ite	cs
 6143 001a 0320     		movcs	r0, #3
 6144 001c 0220     		movcc	r0, #2
 6145 001e 7047     		bx	lr
 6146              	.L362:
  71:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     return 1;
 6147              		.loc 26 71 0
 6148 0020 0120     		movs	r0, #1
 6149              	.L361:
  75:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   }
  76:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   else {
  77:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     return 3;
  78:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   }
  79:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** }
 6150              		.loc 26 79 0
 6151 0022 7047     		bx	lr
 6152              	.L365:
 6153              		.align	2
 6154              	.L364:
 6155 0024 00000000 		.word	.LANCHOR103
 6156              		.cfi_endproc
 6157              	.LFE208:
 6159              		.section	.text._Z14batteryIsAlarmh,"ax",%progbits
 6160              		.align	1
 6161              		.global	_Z14batteryIsAlarmh
 6162              		.thumb
 6163              		.thumb_func
 6165              	_Z14batteryIsAlarmh:
 6166              	.LFB209:
  80:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  81:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** boolean batteryIsAlarm(byte batNo) {
 6167              		.loc 26 81 0
 6168              		.cfi_startproc
 6169              		@ args = 0, pretend = 0, frame = 0
 6170              		@ frame_needed = 0, uses_anonymous_args = 0
 6171              	.LVL302:
 6172 0000 10B5     		push	{r4, lr}
 6173              	.LCFI68:
 6174              		.cfi_def_cfa_offset 8
 6175              		.cfi_offset 14, -4
 6176              		.cfi_offset 4, -8
 6177              		.loc 26 81 0
 6178 0002 0446     		mov	r4, r0
  82:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  83:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   if (batteryData[batNo].voltage < batteryGetCellCount(batNo) * batteryAlarmCellVoltage) {
 6179              		.loc 26 83 0
 6180 0004 FFF7FEFF 		bl	_Z19batteryGetCellCounth
 6181              	.LVL303:
 6182 0008 064A     		ldr	r2, .L367
 6183 000a 1821     		movs	r1, #24
 6184 000c 01FB0423 		mla	r3, r1, r4, r2
 6185 0010 0549     		ldr	r1, .L367+4
 6186 0012 DB88     		ldrh	r3, [r3, #6]
 6187 0014 0A88     		ldrh	r2, [r1, #0]
 6188 0016 5043     		muls	r0, r2, r0
  84:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     return true;
  85:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   }
  86:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   return false;
  87:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** }
 6189              		.loc 26 87 0
 6190 0018 8342     		cmp	r3, r0
 6191 001a ACBF     		ite	ge
 6192 001c 0020     		movge	r0, #0
 6193 001e 0120     		movlt	r0, #1
 6194 0020 10BD     		pop	{r4, pc}
 6195              	.L368:
 6196 0022 00BF     		.align	2
 6197              	.L367:
 6198 0024 00000000 		.word	.LANCHOR103
 6199 0028 00000000 		.word	.LANCHOR100
 6200              		.cfi_endproc
 6201              	.LFE209:
 6203              		.section	.text._Z16batteryIsWarningh,"ax",%progbits
 6204              		.align	1
 6205              		.global	_Z16batteryIsWarningh
 6206              		.thumb
 6207              		.thumb_func
 6209              	_Z16batteryIsWarningh:
 6210              	.LFB210:
  88:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  89:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** boolean batteryIsWarning(byte batNo) {
 6211              		.loc 26 89 0
 6212              		.cfi_startproc
 6213              		@ args = 0, pretend = 0, frame = 0
 6214              		@ frame_needed = 0, uses_anonymous_args = 0
 6215              	.LVL304:
 6216 0000 10B5     		push	{r4, lr}
 6217              	.LCFI69:
 6218              		.cfi_def_cfa_offset 8
 6219              		.cfi_offset 14, -4
 6220              		.cfi_offset 4, -8
 6221              		.loc 26 89 0
 6222 0002 0446     		mov	r4, r0
  90:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  91:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   if (batteryData[batNo].voltage < batteryGetCellCount(batNo) * batteryWarningCellVoltage) {
 6223              		.loc 26 91 0
 6224 0004 FFF7FEFF 		bl	_Z19batteryGetCellCounth
 6225              	.LVL305:
 6226 0008 064A     		ldr	r2, .L370
 6227 000a 1821     		movs	r1, #24
 6228 000c 01FB0423 		mla	r3, r1, r4, r2
 6229 0010 0549     		ldr	r1, .L370+4
 6230 0012 DB88     		ldrh	r3, [r3, #6]
 6231 0014 0A88     		ldrh	r2, [r1, #0]
 6232 0016 5043     		muls	r0, r2, r0
  92:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     return true;
  93:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   }
  94:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   return false;
  95:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** }
 6233              		.loc 26 95 0
 6234 0018 8342     		cmp	r3, r0
 6235 001a ACBF     		ite	ge
 6236 001c 0020     		movge	r0, #0
 6237 001e 0120     		movlt	r0, #1
 6238 0020 10BD     		pop	{r4, pc}
 6239              	.L371:
 6240 0022 00BF     		.align	2
 6241              	.L370:
 6242 0024 00000000 		.word	.LANCHOR103
 6243 0028 00000000 		.word	.LANCHOR101
 6244              		.cfi_endproc
 6245              	.LFE210:
 6247              		.section	.text._Z21measureBatteryVoltaget,"ax",%progbits
 6248              		.align	1
 6249              		.global	_Z21measureBatteryVoltaget
 6250              		.thumb
 6251              		.thumb_func
 6253              	_Z21measureBatteryVoltaget:
 6254              	.LFB211:
  96:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  97:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** void measureBatteryVoltage(unsigned short deltaTime) {
 6255              		.loc 26 97 0
 6256              		.cfi_startproc
 6257              		@ args = 0, pretend = 0, frame = 0
 6258              		@ frame_needed = 0, uses_anonymous_args = 0
 6259              	.LVL306:
 6260 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 6261              	.LCFI70:
 6262              		.cfi_def_cfa_offset 32
 6263              		.cfi_offset 14, -4
 6264              		.cfi_offset 9, -8
 6265              		.cfi_offset 8, -12
 6266              		.cfi_offset 7, -16
 6267              		.cfi_offset 6, -20
 6268              		.cfi_offset 5, -24
 6269              		.cfi_offset 4, -28
 6270              		.cfi_offset 3, -32
 6271              	.LBB145:
  98:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  99:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   batteryAlarm = false;  
 6272              		.loc 26 99 0
 6273 0004 2E4B     		ldr	r3, .L383
 100:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   batteryWarning = false;
 6274              		.loc 26 100 0
 6275 0006 2F4F     		ldr	r7, .L383+4
 6276 0008 2F4C     		ldr	r4, .L383+8
  99:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   batteryAlarm = false;  
 6277              		.loc 26 99 0
 6278 000a 0025     		movs	r5, #0
 6279              	.LBE145:
  97:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** void measureBatteryVoltage(unsigned short deltaTime) {
 6280              		.loc 26 97 0
 6281 000c 8146     		mov	r9, r0
 6282              	.LBB147:
  99:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   batteryAlarm = false;  
 6283              		.loc 26 99 0
 6284 000e 1D70     		strb	r5, [r3, #0]
 6285              		.loc 26 100 0
 6286 0010 3D70     		strb	r5, [r7, #0]
 6287              	.LVL307:
 6288 0012 9846     		mov	r8, r3
 6289              	.LBB146:
 101:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   for (int i = 0; i < numberOfBatteries; i++) {
 6290              		.loc 26 101 0
 6291 0014 4EE0     		b	.L373
 6292              	.LVL308:
 6293              	.L382:
 102:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     batteryData[i].voltage = (long)analogRead(batteryData[i].vPin) * batteryData[i].vScale / (1L<<A
 6294              		.loc 26 102 0
 6295 0016 2078     		ldrb	r0, [r4, #0]	@ zero_extendqisi2
 6296 0018 FFF7FEFF 		bl	_Z10analogReadh
 6297 001c B4F90260 		ldrsh	r6, [r4, #2]
 6298 0020 B4F804C0 		ldrh	ip, [r4, #4]
 103:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** #ifdef BM_EXTENDED
 104:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     if (batteryData[i].voltage < batteryData[i].minVoltage) {
 6299              		.loc 26 104 0
 6300 0024 2289     		ldrh	r2, [r4, #8]
 102:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     batteryData[i].voltage = (long)analogRead(batteryData[i].vPin) * batteryData[i].vScale / (1L<<A
 6301              		.loc 26 102 0
 6302 0026 4643     		muls	r6, r0, r6
 6303 0028 44BF     		itt	mi
 6304 002a 06F57E66 		addmi	r6, r6, #4064
 6305 002e 1F36     		addmi	r6, r6, #31
 6306 0030 0CEB2631 		add	r1, ip, r6, asr #12
 6307 0034 88B2     		uxth	r0, r1
 6308              		.loc 26 104 0
 6309 0036 8242     		cmp	r2, r0
 105:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****       batteryData[i].minVoltage = batteryData[i].voltage;
 6310              		.loc 26 105 0
 6311 0038 88BF     		it	hi
 6312 003a 2081     		strhhi	r0, [r4, #8]	@ movhi
 102:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     batteryData[i].voltage = (long)analogRead(batteryData[i].vPin) * batteryData[i].vScale / (1L<<A
 6313              		.loc 26 102 0
 6314 003c E080     		strh	r0, [r4, #6]	@ movhi
 106:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     }
 107:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     if (batteryData[i].cPin != BM_NOPIN) {
 6315              		.loc 26 107 0
 6316 003e A07A     		ldrb	r0, [r4, #10]	@ zero_extendqisi2
 6317 0040 FF28     		cmp	r0, #255
 6318 0042 27D0     		beq	.L376
 108:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****       batteryData[i].current = (long)analogRead(batteryData[i].cPin) * batteryData[i].cScale * 10 /
 6319              		.loc 26 108 0
 6320 0044 FFF7FEFF 		bl	_Z10analogReadh
 6321 0048 B4F90C60 		ldrsh	r6, [r4, #12]
 6322 004c E289     		ldrh	r2, [r4, #14]
 6323 004e 4643     		muls	r6, r0, r6
 6324 0050 0A23     		movs	r3, #10
 6325 0052 5E43     		muls	r6, r3, r6
 6326 0054 44BF     		itt	mi
 6327 0056 06F57E66 		addmi	r6, r6, #4064
 6328 005a 1F36     		addmi	r6, r6, #31
 6329 005c 0A21     		movs	r1, #10
 6330 005e 4A43     		muls	r2, r1, r2
 6331 0060 02EB263C 		add	ip, r2, r6, asr #12
 109:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****       if (batteryData[i].current > batteryData[i].maxCurrent) { 
 6332              		.loc 26 109 0
 6333 0064 B4F91230 		ldrsh	r3, [r4, #18]
 108:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****       batteryData[i].current = (long)analogRead(batteryData[i].cPin) * batteryData[i].cScale * 10 /
 6334              		.loc 26 108 0
 6335 0068 A4F810C0 		strh	ip, [r4, #16]	@ movhi
 6336              		.loc 26 109 0
 6337 006c 0FFA8CF0 		sxth	r0, ip
 110:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****         batteryData[i].maxCurrent = batteryData[i].current;
 111:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****       }
 112:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****       // current in 10mA , time in ms -> usedCapacity in uAh  // i.e. / 360 <=> * ( 91 / 32768 )
 113:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****       batteryData[i].usedCapacity += (long)batteryData[i].current * (long)deltaTime * 91 / 32768;
 6338              		.loc 26 113 0
 6339 0070 B4F91060 		ldrsh	r6, [r4, #16]
 6340 0074 6269     		ldr	r2, [r4, #20]
 109:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****       if (batteryData[i].current > batteryData[i].maxCurrent) { 
 6341              		.loc 26 109 0
 6342 0076 8342     		cmp	r3, r0
 110:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****         batteryData[i].maxCurrent = batteryData[i].current;
 6343              		.loc 26 110 0
 6344 0078 B8BF     		it	lt
 6345 007a A4F812C0 		strhlt	ip, [r4, #18]	@ movhi
 6346              		.loc 26 113 0
 6347 007e 09FB06F0 		mul	r0, r9, r6
 6348 0082 5B21     		movs	r1, #91
 6349 0084 4843     		muls	r0, r1, r0
 6350 0086 44BF     		itt	mi
 6351 0088 00F5FE40 		addmi	r0, r0, #32512
 6352 008c FF30     		addmi	r0, r0, #255
 6353 008e 02EBE033 		add	r3, r2, r0, asr #15
 6354 0092 6361     		str	r3, [r4, #20]
 6355              	.L376:
 114:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     }
 115:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** #endif
 116:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     if (batteryIsAlarm(i)) {
 6356              		.loc 26 116 0
 6357 0094 EEB2     		uxtb	r6, r5
 6358 0096 3046     		mov	r0, r6
 6359 0098 FFF7FEFF 		bl	_Z14batteryIsAlarmh
 6360 009c 10B1     		cbz	r0, .L380
 117:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****       batteryAlarm = true;
 6361              		.loc 26 117 0
 6362 009e 0120     		movs	r0, #1
 6363 00a0 88F80000 		strb	r0, [r8, #0]
 6364              	.L380:
 118:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     }
 119:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     if (batteryIsWarning(i)) {
 6365              		.loc 26 119 0
 6366 00a4 3046     		mov	r0, r6
 6367 00a6 FFF7FEFF 		bl	_Z16batteryIsWarningh
 6368 00aa 08B1     		cbz	r0, .L381
 120:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****       batteryWarning = true;
 6369              		.loc 26 120 0
 6370 00ac 0122     		movs	r2, #1
 6371 00ae 3A70     		strb	r2, [r7, #0]
 6372              	.L381:
 101:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   for (int i = 0; i < numberOfBatteries; i++) {
 6373              		.loc 26 101 0
 6374 00b0 0135     		adds	r5, r5, #1
 6375              	.LVL309:
 6376 00b2 1834     		adds	r4, r4, #24
 6377              	.LVL310:
 6378              	.L373:
 101:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   for (int i = 0; i < numberOfBatteries; i++) {
 6379              		.loc 26 101 0 is_stmt 0 discriminator 1
 6380 00b4 054B     		ldr	r3, .L383+12
 6381 00b6 1978     		ldrb	r1, [r3, #0]	@ zero_extendqisi2
 6382 00b8 8D42     		cmp	r5, r1
 6383 00ba ACDB     		blt	.L382
 6384              	.LBE146:
 6385              	.LBE147:
 121:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     }
 122:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   }  
 123:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** }
 6386              		.loc 26 123 0 is_stmt 1
 6387 00bc BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 6388              	.L384:
 6389              		.align	2
 6390              	.L383:
 6391 00c0 00000000 		.word	.LANCHOR104
 6392 00c4 00000000 		.word	.LANCHOR105
 6393 00c8 00000000 		.word	.LANCHOR103
 6394 00cc 00000000 		.word	.LANCHOR102
 6395              		.cfi_endproc
 6396              	.LFE211:
 6398              		.section	.text._Z24initializeBatteryMonitorhf,"ax",%progbits
 6399              		.align	1
 6400              		.global	_Z24initializeBatteryMonitorhf
 6401              		.thumb
 6402              		.thumb_func
 6404              	_Z24initializeBatteryMonitorhf:
 6405              	.LFB207:
  56:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** void initializeBatteryMonitor(byte nb, float alarmVoltage) {
 6406              		.loc 26 56 0
 6407              		.cfi_startproc
 6408              		@ args = 0, pretend = 0, frame = 0
 6409              		@ frame_needed = 0, uses_anonymous_args = 0
 6410              	.LVL311:
 6411 0000 38B5     		push	{r3, r4, r5, lr}
 6412              	.LCFI71:
 6413              		.cfi_def_cfa_offset 16
 6414              		.cfi_offset 14, -4
 6415              		.cfi_offset 5, -8
 6416              		.cfi_offset 4, -12
 6417              		.cfi_offset 3, -16
 6418              	.LBB148:
  58:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   numberOfBatteries = nb;
 6419              		.loc 26 58 0
 6420 0002 094C     		ldr	r4, .L388
 6421 0004 2070     		strb	r0, [r4, #0]
  59:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   setBatteryCellVoltageThreshold(alarmVoltage);
 6422              		.loc 26 59 0
 6423 0006 0846     		mov	r0, r1	@ float
 6424              	.LVL312:
 6425 0008 FFF7FEFF 		bl	_Z30setBatteryCellVoltageThresholdf
 6426              	.LVL313:
 6427              	.LBB149:
  60:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   for (int i = 0; i < numberOfBatteries; i++) {
 6428              		.loc 26 60 0
 6429 000c 0025     		movs	r5, #0
 6430 000e 03E0     		b	.L386
 6431              	.LVL314:
 6432              	.L387:
  61:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     resetBattery(i);
 6433              		.loc 26 61 0 discriminator 2
 6434 0010 E8B2     		uxtb	r0, r5
 6435 0012 FFF7FEFF 		bl	_Z12resetBatteryh
  60:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   for (int i = 0; i < numberOfBatteries; i++) {
 6436              		.loc 26 60 0 discriminator 2
 6437 0016 0135     		adds	r5, r5, #1
 6438              	.LVL315:
 6439              	.L386:
  60:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   for (int i = 0; i < numberOfBatteries; i++) {
 6440              		.loc 26 60 0 is_stmt 0 discriminator 1
 6441 0018 2378     		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 6442 001a 9D42     		cmp	r5, r3
 6443 001c F8DB     		blt	.L387
 6444              	.LBE149:
  63:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   measureBatteryVoltage(0); // Initial measurement
 6445              		.loc 26 63 0 is_stmt 1
 6446 001e 0020     		movs	r0, #0
 6447              	.LBE148:
  64:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** }
 6448              		.loc 26 64 0
 6449 0020 BDE83840 		pop	{r3, r4, r5, lr}
 6450              	.LBB150:
  63:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   measureBatteryVoltage(0); // Initial measurement
 6451              		.loc 26 63 0
 6452 0024 FFF7FEBF 		b	_Z21measureBatteryVoltaget
 6453              	.L389:
 6454              		.align	2
 6455              	.L388:
 6456 0028 00000000 		.word	.LANCHOR102
 6457              	.LBE150:
 6458              		.cfi_endproc
 6459              	.LFE207:
 6461              		.section	.text._Z17applyMotorCommandv,"ax",%progbits
 6462              		.align	1
 6463              		.global	_Z17applyMotorCommandv
 6464              		.thumb
 6465              		.thumb_func
 6467              	_Z17applyMotorCommandv:
 6468              	.LFB212:
 6469              		.file 27 "../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h"
   1:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** /*
   2:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   www.AeroQuad.com
   4:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****  
   7:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   (at your option) any later version. 
  11:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****  
  12:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****  
  17:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** */
  20:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  21:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #ifndef _AQ_PROCESS_FLIGHT_CONTROL_X_MODE_H_
  22:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #define _AQ_PROCESS_FLIGHT_CONTROL_X_MODE_H_
  23:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  24:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** /*
  25:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****        CW  0....Front....0 CCW
  26:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****            ......***......    
  27:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****            ......***......    
  28:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****            ......***......    
  29:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****       CCW  0....Back.....0  CW
  30:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** */
  31:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  32:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #include "FlightControlVariable.h"
  33:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  34:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #ifdef OLD_MOTOR_NUMBERING  
  35:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define FRONT_LEFT  MOTOR1
  36:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define REAR_RIGHT  MOTOR2
  37:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define FRONT_RIGHT MOTOR3
  38:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define REAR_LEFT   MOTOR4
  39:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #else
  40:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define FRONT_LEFT  MOTOR1
  41:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define FRONT_RIGHT MOTOR2
  42:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define REAR_RIGHT  MOTOR3
  43:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define REAR_LEFT   MOTOR4
  44:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #endif
  45:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #define LASTMOTOR   MOTOR4+1
  46:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  47:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** int motorMaxCommand[4] = {0,0,0,0};
  48:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** int motorMinCommand[4] = {0,0,0,0};
  49:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** int motorConfiguratorCommand[4] = {0,0,0,0};
  50:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  51:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #if !defined FRONT_YAW_CORRECTION
  52:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define FRONT_YAW_CORRECTION 1
  53:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define REAR_YAW_CORRECTION 1
  54:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #endif  
  55:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  56:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** void applyMotorCommand() {
 6470              		.loc 27 56 0
 6471              		.cfi_startproc
 6472              		@ args = 0, pretend = 0, frame = 0
 6473              		@ frame_needed = 0, uses_anonymous_args = 0
  57:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_LEFT]  = throttle - motorAxisCommandPitch + motorAxisCommandRoll - (YAW_DIRECT
 6474              		.loc 27 57 0
 6475 0000 0D48     		ldr	r0, .L391
 6476 0002 0E49     		ldr	r1, .L391+4
 6477 0004 0E4A     		ldr	r2, .L391+8
 6478 0006 0F4B     		ldr	r3, .L391+12
  56:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** void applyMotorCommand() {
 6479              		.loc 27 56 0
 6480 0008 70B5     		push	{r4, r5, r6, lr}
 6481              	.LCFI72:
 6482              		.cfi_def_cfa_offset 16
 6483              		.cfi_offset 14, -4
 6484              		.cfi_offset 6, -8
 6485              		.cfi_offset 5, -12
 6486              		.cfi_offset 4, -16
 6487              		.loc 27 57 0
 6488 000a 0468     		ldr	r4, [r0, #0]
 6489 000c 0868     		ldr	r0, [r1, #0]
 6490 000e 1168     		ldr	r1, [r2, #0]
 6491 0010 1A68     		ldr	r2, [r3, #0]
 6492 0012 0D4B     		ldr	r3, .L391+16
 6493 0014 C0EB040C 		rsb	ip, r0, r4
  58:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_RIGHT] = throttle - motorAxisCommandPitch - motorAxisCommandRoll + (YAW_DIRECT
  59:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[REAR_LEFT]   = throttle + motorAxisCommandPitch + motorAxisCommandRoll + (YAW_DIRECT
 6494              		.loc 27 59 0
 6495 0018 2018     		adds	r0, r4, r0
  57:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_LEFT]  = throttle - motorAxisCommandPitch + motorAxisCommandRoll - (YAW_DIRECT
 6496              		.loc 27 57 0
 6497 001a 0CEB0106 		add	r6, ip, r1
  58:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_RIGHT] = throttle - motorAxisCommandPitch - motorAxisCommandRoll + (YAW_DIRECT
 6498              		.loc 27 58 0
 6499 001e C1EB0C05 		rsb	r5, r1, ip
 6500              		.loc 27 59 0
 6501 0022 4418     		adds	r4, r0, r1
  60:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[REAR_RIGHT]  = throttle + motorAxisCommandPitch - motorAxisCommandRoll - (YAW_DIRECT
 6502              		.loc 27 60 0
 6503 0024 411A     		subs	r1, r0, r1
  57:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_LEFT]  = throttle - motorAxisCommandPitch + motorAxisCommandRoll - (YAW_DIRECT
 6504              		.loc 27 57 0
 6505 0026 B61A     		subs	r6, r6, r2
  58:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_RIGHT] = throttle - motorAxisCommandPitch - motorAxisCommandRoll + (YAW_DIRECT
 6506              		.loc 27 58 0
 6507 0028 AD18     		adds	r5, r5, r2
  59:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[REAR_LEFT]   = throttle + motorAxisCommandPitch + motorAxisCommandRoll + (YAW_DIRECT
 6508              		.loc 27 59 0
 6509 002a A418     		adds	r4, r4, r2
 6510              		.loc 27 60 0
 6511 002c 8A1A     		subs	r2, r1, r2
  57:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_LEFT]  = throttle - motorAxisCommandPitch + motorAxisCommandRoll - (YAW_DIRECT
 6512              		.loc 27 57 0
 6513 002e 1E60     		str	r6, [r3, #0]
  58:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_RIGHT] = throttle - motorAxisCommandPitch - motorAxisCommandRoll + (YAW_DIRECT
 6514              		.loc 27 58 0
 6515 0030 5D60     		str	r5, [r3, #4]
  59:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[REAR_LEFT]   = throttle + motorAxisCommandPitch + motorAxisCommandRoll + (YAW_DIRECT
 6516              		.loc 27 59 0
 6517 0032 DC60     		str	r4, [r3, #12]
 6518              		.loc 27 60 0
 6519 0034 9A60     		str	r2, [r3, #8]
  61:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** }
 6520              		.loc 27 61 0
 6521 0036 70BD     		pop	{r4, r5, r6, pc}
 6522              	.L392:
 6523              		.align	2
 6524              	.L391:
 6525 0038 00000000 		.word	.LANCHOR106
 6526 003c 00000000 		.word	.LANCHOR107
 6527 0040 00000000 		.word	.LANCHOR108
 6528 0044 00000000 		.word	.LANCHOR109
 6529 0048 00000000 		.word	.LANCHOR63
 6530              		.cfi_endproc
 6531              	.LFE212:
 6533              		.section	.text._Z22hottV4SerialClearInputv,"ax",%progbits
 6534              		.align	1
 6535              		.global	_Z22hottV4SerialClearInputv
 6536              		.thumb
 6537              		.thumb_func
 6539              	_Z22hottV4SerialClearInputv:
 6540              	.LFB214:
  51:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** void hottV4SerialClearInput() {
 6541              		.loc 5 51 0
 6542              		.cfi_startproc
 6543              		@ args = 0, pretend = 0, frame = 0
 6544              		@ frame_needed = 0, uses_anonymous_args = 0
 6545 0000 10B5     		push	{r4, lr}
 6546              	.LCFI73:
 6547              		.cfi_def_cfa_offset 8
 6548              		.cfi_offset 14, -4
 6549              		.cfi_offset 4, -8
  52:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	while(hottV4Serial->available() > 0) {
 6550              		.loc 5 52 0
 6551 0002 02E0     		b	.L394
 6552              	.L395:
  53:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		hottV4Serial->read();
 6553              		.loc 5 53 0
 6554 0004 2068     		ldr	r0, [r4, #0]
 6555 0006 FFF7FEFF 		bl	_ZN14HardwareSerial4readEv
 6556              	.L394:
  52:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	while(hottV4Serial->available() > 0) {
 6557              		.loc 5 52 0 discriminator 1
 6558 000a 034C     		ldr	r4, .L396
 6559 000c 2068     		ldr	r0, [r4, #0]
 6560 000e FFF7FEFF 		bl	_ZN14HardwareSerial9availableEv
 6561 0012 0028     		cmp	r0, #0
 6562 0014 F6D1     		bne	.L395
  55:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 6563              		.loc 5 55 0
 6564 0016 10BD     		pop	{r4, pc}
 6565              	.L397:
 6566              		.align	2
 6567              	.L396:
 6568 0018 00000000 		.word	.LANCHOR110
 6569              		.cfi_endproc
 6570              	.LFE214:
 6572              		.section	.text._Z16hottV4SerialReadv,"ax",%progbits
 6573              		.align	1
 6574              		.global	_Z16hottV4SerialReadv
 6575              		.thumb
 6576              		.thumb_func
 6578              	_Z16hottV4SerialReadv:
 6579              	.LFB215:
  60:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** int hottV4SerialRead() {
 6580              		.loc 5 60 0
 6581              		.cfi_startproc
 6582              		@ args = 0, pretend = 0, frame = 0
 6583              		@ frame_needed = 0, uses_anonymous_args = 0
 6584 0000 10B5     		push	{r4, lr}
 6585              	.LCFI74:
 6586              		.cfi_def_cfa_offset 8
 6587              		.cfi_offset 14, -4
 6588              		.cfi_offset 4, -8
  61:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	while(hottV4Serial->available() > 1) {
 6589              		.loc 5 61 0
 6590 0002 01E0     		b	.L399
 6591              	.L400:
  62:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		hottV4Serial->read();
 6592              		.loc 5 62 0
 6593 0004 FFF7FEFF 		bl	_ZN14HardwareSerial4readEv
 6594              	.L399:
  61:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	while(hottV4Serial->available() > 1) {
 6595              		.loc 5 61 0 discriminator 1
 6596 0008 084C     		ldr	r4, .L402
 6597 000a 2068     		ldr	r0, [r4, #0]
 6598 000c FFF7FEFF 		bl	_ZN14HardwareSerial9availableEv
 6599 0010 0128     		cmp	r0, #1
  62:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		hottV4Serial->read();
 6600              		.loc 5 62 0 discriminator 1
 6601 0012 2068     		ldr	r0, [r4, #0]
  61:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	while(hottV4Serial->available() > 1) {
 6602              		.loc 5 61 0 discriminator 1
 6603 0014 F6D8     		bhi	.L400
  64:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     if(hottV4Serial->available()) {
 6604              		.loc 5 64 0
 6605 0016 FFF7FEFF 		bl	_ZN14HardwareSerial9availableEv
 6606 001a 20B1     		cbz	r0, .L401
  65:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     	return hottV4Serial->read();
 6607              		.loc 5 65 0
 6608 001c 2068     		ldr	r0, [r4, #0]
  69:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 6609              		.loc 5 69 0
 6610 001e BDE81040 		pop	{r4, lr}
  65:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     	return hottV4Serial->read();
 6611              		.loc 5 65 0
 6612 0022 FFF7FEBF 		b	_ZN14HardwareSerial4readEv
 6613              	.L401:
  69:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 6614              		.loc 5 69 0
 6615 0026 FF20     		movs	r0, #255
 6616 0028 10BD     		pop	{r4, pc}
 6617              	.L403:
 6618 002a 00BF     		.align	2
 6619              	.L402:
 6620 002c 00000000 		.word	.LANCHOR110
 6621              		.cfi_endproc
 6622              	.LFE215:
 6624              		.section	.text._Z8SetDelayj,"ax",%progbits
 6625              		.align	1
 6626              		.global	_Z8SetDelayj
 6627              		.thumb
 6628              		.thumb_func
 6630              	_Z8SetDelayj:
 6631              	.LFB224:
 180:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #endif
 181:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 182:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** unsigned int SetDelay (unsigned int t) {
 6632              		.loc 5 182 0
 6633              		.cfi_startproc
 6634              		@ args = 0, pretend = 0, frame = 0
 6635              		@ frame_needed = 0, uses_anonymous_args = 0
 6636              		@ link register save eliminated.
 6637              	.LVL316:
 183:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	return(CountMilliseconds + t + 1);
 6638              		.loc 5 183 0
 6639 0000 024A     		ldr	r2, .L405
 6640 0002 1168     		ldr	r1, [r2, #0]
 6641 0004 4B1C     		adds	r3, r1, #1
 184:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 6642              		.loc 5 184 0
 6643 0006 1818     		adds	r0, r3, r0
 6644              	.LVL317:
 6645 0008 7047     		bx	lr
 6646              	.L406:
 6647 000a 00BF     		.align	2
 6648              	.L405:
 6649 000c 00000000 		.word	.LANCHOR111
 6650              		.cfi_endproc
 6651              	.LFE224:
 6653              		.section	.text._Z10CheckDelayj,"ax",%progbits
 6654              		.align	1
 6655              		.global	_Z10CheckDelayj
 6656              		.thumb
 6657              		.thumb_func
 6659              	_Z10CheckDelayj:
 6660              	.LFB225:
 185:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 186:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** char CheckDelay(unsigned int t)	{
 6661              		.loc 5 186 0
 6662              		.cfi_startproc
 6663              		@ args = 0, pretend = 0, frame = 0
 6664              		@ frame_needed = 0, uses_anonymous_args = 0
 6665              		@ link register save eliminated.
 6666              	.LVL318:
 187:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	return(((t - CountMilliseconds) & 0x8000) >> 9);
 6667              		.loc 5 187 0
 6668 0000 0449     		ldr	r1, .L408
 6669 0002 0B68     		ldr	r3, [r1, #0]
 6670 0004 C21A     		subs	r2, r0, r3
 6671 0006 02F40041 		and	r1, r2, #32768
 6672 000a 480A     		lsrs	r0, r1, #9
 6673              	.LVL319:
 188:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 6674              		.loc 5 188 0
 6675 000c 00F04000 		and	r0, r0, #64
 6676 0010 7047     		bx	lr
 6677              	.L409:
 6678 0012 00BF     		.align	2
 6679              	.L408:
 6680 0014 00000000 		.word	.LANCHOR111
 6681              		.cfi_endproc
 6682              	.LFE225:
 6684              		.section	.text._Z10hottv4InitP14HardwareSerial,"ax",%progbits
 6685              		.align	1
 6686              		.global	_Z10hottv4InitP14HardwareSerial
 6687              		.thumb
 6688              		.thumb_func
 6690              	_Z10hottv4InitP14HardwareSerial:
 6691              	.LFB228:
 189:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 190:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static unsigned char HoTTWarning()
 191:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	{
 192:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	unsigned char status = 0;
 193:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	static char old_status = 0;
 194:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	static int repeat;
 195:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 196:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #if defined(BattMonitor)
 197:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	// Activate low voltage alarm
 198:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryWarning || batteryAlarm) {
 199:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		status = HoTTv4NotificationUndervoltage;
 200:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	}
 201:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #endif
 202:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	
 203:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if(!status) {
 204:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		status = SpeakHoTT; 
 205:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	}
 206:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 207:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if(old_status == status) {
 208:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		if(!CheckDelay(repeat)) return 0;
 209:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		repeat = SetDelay(5000);
 210:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	}
 211:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	else repeat = SetDelay(2000);
 212:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 213:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if(status) 	{
 214:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		if(status == SpeakHoTT) SpeakHoTT = 0;
 215:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	}   
 216:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 217:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	old_status = status;
 218:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 219:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	return status;
 220:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	}
 221:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 222:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 223:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
 224:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Updates current flight time by counting the seconds from the moment
 225:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * the copter was armed.
 226:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
 227:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static void hottv4UpdateFlightTime(uint8_t *data) {
 228:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   static uint32_t previousEAMUpdate = 0;
 229:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   
 230:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint16_t timeDiff = millis() - previousEAMUpdate;
 231:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   previousEAMUpdate += timeDiff;
 232:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   
 233:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   CountMilliseconds += timeDiff;
 234:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 235:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if (motorArmed) {
 236:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     milliseconds += timeDiff;
 237:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	
 238:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     if (milliseconds >= 60000) {
 239:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       milliseconds -= 60000;
 240:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       minutes += 1;
 241:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     }
 242:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   }
 243:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   
 244:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   data[39] = minutes;
 245:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   // Enough accuracy and faster than divide by 1000
 246:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   data[40] = (milliseconds >> 10) ;
 247:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 248:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 249:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
 250:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Call to initialize HOTTV4
 251:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
 252:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** void hottv4Init(HardwareSerial *serial) {
 6692              		.loc 5 252 0
 6693              		.cfi_startproc
 6694              		@ args = 0, pretend = 0, frame = 0
 6695              		@ frame_needed = 0, uses_anonymous_args = 0
 6696              		@ link register save eliminated.
 6697              	.LVL320:
 253:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4Serial = serial;
 6698              		.loc 5 253 0
 6699 0000 024B     		ldr	r3, .L411
 254:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     
 255:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   #if defined (__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
 256:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     /* Enable PullUps on RX3
 257:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****      * without signal is to weak to be recognized
 258:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****      */
 259:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     DDRJ &= ~(1 << 0);
 260:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     PORTJ |= (1 << 0);
 261:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   #endif
 262:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4Serial->begin(19200);
 6700              		.loc 5 262 0
 6701 0002 4FF49641 		mov	r1, #19200
 253:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4Serial = serial;
 6702              		.loc 5 253 0
 6703 0006 1860     		str	r0, [r3, #0]
 263:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 6704              		.loc 5 263 0
 262:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4Serial->begin(19200);
 6705              		.loc 5 262 0
 6706 0008 FFF7FEBF 		b	_ZN14HardwareSerial5beginEj
 6707              	.LVL321:
 6708              	.L412:
 6709              		.align	2
 6710              	.L411:
 6711 000c 00000000 		.word	.LANCHOR110
 6712              		.cfi_endproc
 6713              	.LFE228:
 6715              		.section	.text._Z10hottV4Hookh,"ax",%progbits
 6716              		.align	1
 6717              		.global	_Z10hottV4Hookh
 6718              		.thumb
 6719              		.thumb_func
 6721              	_Z10hottV4Hookh:
 6722              	.LFB232:
 264:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 265:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /* ##################################################################### *
 266:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  *                HoTTv4 EAM Module                                      *
 267:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * ##################################################################### */
 268:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 269:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
 270:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Main method to send EAM telemetry data
 271:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
 272:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static void hottV4SendEAMTelemetry() {  
 273:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint8_t telemetry_data[] = { 
 274:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x7C,
 275:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               HOTTV4_ELECTRICAL_AIR_MODULE, 
 276:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Alarm */
 277:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               HOTTV4_ELECTRICAL_AIR_SENSOR_ID,
 278:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, /* Alarm Value 1 and 2 */
 279:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* Low Voltage Cell 1-7 in 2mV steps */
 280:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* High Voltage Cell 1-7 in 2mV steps */
 281:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, /* Battetry 1 LSB/MSB in 100mv steps, 50 == 5V */
 282:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, /* Battetry 2 LSB/MSB in 100mv steps, 50 == 5V */
 283:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x14, /* Temp 1, Offset of 20. 20 == 0C */ 
 284:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x14, /* Temp 2, Offset of 20. 20 == 0C */
 285:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0xF4, 0x01, /* Height. Offset -500. 500 == 0 */
 286:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, /* Current LSB, MSB 1 = 0.1A */
 287:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, /* Drive Voltage */
 288:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00,  /* mAh */
 289:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x48, 0x00, /* m2s */ 
 290:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x78, /* m3s */
 291:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, /* RPM. 10er steps, 300 == 3000rpm */
 292:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Electric minutes */
 293:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Electric seconds */
 294:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Speed */
 295:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Version Number */
 296:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x7D, /* End sign */
 297:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00 /* Checksum */
 298:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****             };
 299:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   
 300:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   #if defined(HOTTV4BATT)
 301:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     short voltage = hottv4UpdateBattery(telemetry_data);
 302:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[20] = telemetry_data[22] = telemetry_data[30] = voltage;
 303:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[21] = telemetry_data[23] = telemetry_data[31] = (voltage >> 8) & 0xFF;
 304:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 305:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	short current = hottv4UpdateCurrent();
 306:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[28] = current;
 307:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[29] = (current >> 8) & 0xFF;
 308:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 309:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	long capacity = hottv4UpdateCapacity();
 310:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[32] = capacity;
 311:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[33] = (capacity >> 8) & 0xFF;
 312:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   #endif
 313:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   
 314:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   #if defined(HOTTV4ALTITUDE)
 315:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     int32_t altitude = hottv4UpdateAlt();
 316:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[26] = altitude;
 317:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[27] = (altitude >> 8) & 0xFF;
 318:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 319:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	unsigned int varioSound = hottv4UpdateAltVario();
 320:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     telemetry_data[11] = telemetry_data[13] = varioSound;
 321:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     telemetry_data[12] = telemetry_data[14] = (varioSound >> 8) & 0xFF;
 322:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   #endif
 323:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 324:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottv4UpdateFlightTime(telemetry_data);
 325:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 326:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   // Write out telemetry data as Electric Air Module to serial           
 327:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4SendBinary(telemetry_data);
 328:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 329:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 330:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /* ##################################################################### *
 331:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  *                HoTTv4 GPS Module                                      *
 332:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * ##################################################################### */
 333:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 334:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #if defined(UseGPS)
 335:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
 336:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Converts unsigned long representation of GPS coordinate back to
 337:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * N Deg MM.SSSS representation and puts it into GPS data frame.
 338:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
 339:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static void updatePosition(uint8_t *data, uint32_t value, uint8_t index) {
 340:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   data[index] = (value < 0); 
 341:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 342:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint8_t deg = value / 100000;
 343:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint32_t sec = (value - (deg * 100000)) * 6;
 344:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint8_t min = sec / 10000;
 345:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   sec = sec % 10000;
 346:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   
 347:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint16_t degMin = (deg * 100) + min;
 348:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 349:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   data[index+1] = degMin;
 350:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   data[index+2] = degMin >> 8; 
 351:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   data[index+3] = sec; 
 352:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   data[index+4] = sec >> 8;
 353:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 354:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #endif
 355:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 356:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
 357:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Main method to send GPS telemetry data
 358:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
 359:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static void hottV4SendGPSTelemetry() {
 360:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint8_t telemetry_data[] = { 
 361:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x7C,
 362:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               HOTTV4_GPS_MODULE, 
 363:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Alarm */
 364:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               HOTTV4_GPS_SENSOR_ID,
 365:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, /* Alarm Value 1 and 2 */
 366:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Flight direction */ 
 367:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, /* Velocity */ 
 368:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, 0x00, 0x00, 0x00, /* Latitude */
 369:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, 0x00, 0x00, 0x00, /* Longitude */
 370:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, /* Distance */
 371:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0xF4, 0x01, /* Altitude, 500 = 0m */
 372:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x78, 0x00, /* m/s, 1 = 0.01m/s */ 
 373:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x78, /* m/3s, 120 = 0 */
 374:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Number of satelites */ 
 375:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* GPS fix character */
 376:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Home direction */
 377:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* angle x-direction */
 378:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* angle y-direction */
 379:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* angle z-direction */
 380:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00,  /* gyro x */
 381:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, /* gyro y */ 
 382:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, /* gyro z */
 383:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Vibrations */
 384:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* ASCII Free Character 4 */
 385:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* ASCII Free Character 5 */
 386:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* ASCII Free Character 6 */
 387:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Version Number */
 388:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x7D, /* End sign */
 389:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00 /* Checksum */
 390:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****             };
 391:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 392:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 393:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 394:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #if defined(UseGPS)
 395:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 396:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[26] = nbSatelitesInUse;
 397:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 398:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     if (haveAGpsLock()) {
 399:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       updatePosition(telemetry_data, currentPosition.latitude, 9);
 400:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       updatePosition(telemetry_data, currentPosition.longitude, 14);
 401:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 402:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       telemetry_data[27] = telemetry_data[41] = 'f'; // Displays a 'f' for fix
 403:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 404:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       /** GPS Speed in km/h */
 405:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       telemetry_data[7] = getGpsSpeed()*36/1000;
 406:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 407:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       /** Distance to home */
 408:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  if(isHomeBaseInitialized()) {
 409:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		  computeDistanceAndBearing(currentPosition, missionPositionToReach);
 410:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		  telemetry_data[19] = (int)getDistanceMeter();
 411:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		  telemetry_data[20] = (int)getDistanceMeter() >> 8;
 412:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		  telemetry_data[28] = (gpsBearing - (int)(trueNorthHeading * RAD2DEG)) * 50;
 413:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		  }
 414:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 415:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  if (navigationState == ON) { 
 416:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		  telemetry_data[39] = HoTTGPSComingHome; // Displays a 'W' for Waypoint
 417:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		  }
 418:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  else if(positionHoldState == ON) {
 419:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		  telemetry_data[39] = HoTTGPSPositionHold; //Displays a 'P' for Position Hold
 420:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		  }
 421:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  else {
 422:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		  telemetry_data[39] = HoTTGPSFree; //Displays a '/' for GPS Mode off 
 423:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		  }
 424:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     }
 425:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #endif
 426:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****           
 427:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #if defined(HOTTV4ALTITUDE)
 428:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	int32_t altitude = hottv4UpdateAlt();
 429:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[21] = altitude;
 430:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[22] = (altitude >> 8) & 0xFF;
 431:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 432:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	unsigned int varioSound = hottv4UpdateAltVario();
 433:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[11] = varioSound;
 434:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[13] = 120;
 435:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #endif
 436:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 437:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 438:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #if defined(HOTTV4DIR) 
 439:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     telemetry_data[6] = hottV4UpdateDirection();
 440:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #endif
 441:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 442:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   // Triggers voice alarm if necessary
 443:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[2] = HoTTWarning();
 444:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   
 445:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   // Write out telemetry data as GPS Module to serial           
 446:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4SendBinary(telemetry_data);
 447:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 448:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 449:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /* ##################################################################### *
 450:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  *                HoTTv4 Vario Module                                    *
 451:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * ##################################################################### */
 452:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 453:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
 454:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Main method to send Vario telemetry data
 455:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
 456:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static void hottV4SendVarioTelemetry() {
 457:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint8_t telemetry_data[] = { 
 458:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x7C,
 459:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               HOTTV4_VARIO_MODULE, 
 460:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Alarm */
 461:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               HOTTV4_VARIO_SENSOR_ID,
 462:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Inverse status */
 463:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0xF4, 0x01, /* Current altitude */ 
 464:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0xF4, 0x01, /* Max. altitude */ 
 465:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0xF4, 0x01, /* Min. altitude */
 466:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x30, 0x75, /* m/s */
 467:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x30, 0x75, /* m/3s  */
 468:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x30, 0x75, /* m/10s */
 469:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, 0x00, 0x00, /* ASCII */
 470:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, 0x00, 0x00, /* ASCII */
 471:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, 0x00, 0x00, /* ASCII */
 472:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, 0x00, 0x00, /* ASCII */
 473:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, 0x00, 0x00, /* ASCII */
 474:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00,                   /* ASCII */
 475:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, 0x00, 0x00, /* free */
 476:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Version Number */
 477:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x7D, /* End sign */
 478:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00  /* Checksum */
 479:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****             };
 480:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 481:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #if defined(HOTTV4ALTITUDE)
 482:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   int32_t altitude = hottv4UpdateAlt();
 483:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[5] = altitude;
 484:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[6] = (altitude >> 8) & 0xFF;
 485:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 486:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[7] = maxAltitude;
 487:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[9] = minAltitude;
 488:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 489:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   unsigned int varioSound = hottv4UpdateAltVario();
 490:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[11] = telemetry_data[13] = telemetry_data[15] = varioSound;
 491:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[12] = telemetry_data[14] = telemetry_data[16] = (varioSound >> 8) & 0xFF;
 492:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 493:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(altitudeHoldState == ON) {
 494:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  if((receiverCommand[THROTTLE] > (altitudeHoldThrottle + altitudeHoldBump))) telemetry_data[38] =
 495:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  else if((receiverCommand[THROTTLE] < (altitudeHoldThrottle - altitudeHoldBump))) telemetry_data[
 496:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  else telemetry_data[38] = '=';
 497:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  }
 498:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   else if (altitudeHoldState == ALTPANIC) {
 499:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  telemetry_data[38] = '!';
 500:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  }
 501:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #endif
 502:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 503:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   // Buffer for the available 21 ASCII + \0 chars
 504:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   char text[VARIO_ASCIIS+1];
 505:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   
 506:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(flightMode == ATTITUDE_FLIGHT_MODE) snprintf(text, VARIO_ASCIIS+1, HOTTV4_VARIO_ATTITUDE);
 507:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   else snprintf(text, VARIO_ASCIIS+1, HOTTV4_VARIO_RATE);
 508:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 509:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint8_t offset = (VARIO_ASCIIS - strlen(text)) / 2;
 510:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 511:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   for(uint8_t index = 0; (index + offset) < VARIO_ASCIIS; index++) {
 512:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     if (text[index] != 0x0) {
 513:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       // 17 == start byte for ASCII
 514:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       telemetry_data[17+index+offset] = text[index];
 515:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     } else {
 516:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       break;
 517:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     }
 518:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   }  
 519:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****             
 520:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   // Write out telemetry data as Vario Module to serial           
 521:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4SendBinary(telemetry_data);
 522:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 523:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 524:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /* ##################################################################### *
 525:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  *                HoTTv4 Text Mode                                       *
 526:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * ##################################################################### */
 527:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 528:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
 529:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Main entry point for HoTTv4 telemetry
 530:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
 531:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** bool hottV4Hook(uint8_t serialData) {
 6723              		.loc 5 531 0
 6724              		.cfi_startproc
 6725              		@ args = 0, pretend = 0, frame = 72
 6726              		@ frame_needed = 0, uses_anonymous_args = 0
 6727              	.LVL322:
 6728 0000 70B5     		push	{r4, r5, r6, lr}
 6729              	.LCFI75:
 6730              		.cfi_def_cfa_offset 16
 6731              		.cfi_offset 14, -4
 6732              		.cfi_offset 6, -8
 6733              		.cfi_offset 5, -12
 6734              		.cfi_offset 4, -16
 532:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #ifdef HOTTV4_DEBUG
 533:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   Serial.print("Hott cmd ");
 534:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   Serial.print((int)serialData);
 535:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   Serial.print(" time ");
 536:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   Serial.println(micros());
 537:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #endif
 538:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 539:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   switch (serialData) {
 6735              		.loc 5 539 0
 6736 0002 3328     		cmp	r0, #51
 531:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** bool hottV4Hook(uint8_t serialData) {
 6737              		.loc 5 531 0
 6738 0004 92B0     		sub	sp, sp, #72
 6739              	.LCFI76:
 6740              		.cfi_def_cfa_offset 88
 6741              		.loc 5 539 0
 6742 0006 00F0FE80 		beq	.L417
 6743 000a 05D8     		bhi	.L418
 6744 000c 3128     		cmp	r0, #49
 6745 000e 0BD0     		beq	.L415
 6746 0010 3228     		cmp	r0, #50
 6747 0012 40F06D81 		bne	.L439
 6748 0016 5CE0     		b	.L416
 6749              	.L418:
 6750 0018 8A28     		cmp	r0, #138
 6751 001a 05D0     		beq	.L415
 6752 001c 8E28     		cmp	r0, #142
 6753 001e 58D0     		beq	.L416
 6754 0020 8928     		cmp	r0, #137
 6755 0022 40F06581 		bne	.L439
 6756 0026 EEE0     		b	.L417
 6757              	.L415:
 6758              	.LBB178:
 6759              	.LBB179:
 390:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****             };
 6760              		.loc 5 390 0
 6761 0028 2D22     		movs	r2, #45
 6762 002a 0021     		movs	r1, #0
 6763 002c 7C24     		movs	r4, #124
 6764 002e 6846     		mov	r0, sp
 6765              	.LVL323:
 6766 0030 FFF7FEFF 		bl	memset
 6767 0034 0126     		movs	r6, #1
 6768 0036 8A21     		movs	r1, #138
 6769 0038 F423     		movs	r3, #244
 6770 003a 8DF80040 		strb	r4, [sp, #0]
 6771 003e A020     		movs	r0, #160
 6772 0040 7824     		movs	r4, #120
 6773 0042 7D25     		movs	r5, #125
 6774 0044 8DF80110 		strb	r1, [sp, #1]
 6775 0048 8DF81530 		strb	r3, [sp, #21]
 6776 004c 8DF80300 		strb	r0, [sp, #3]
 6777 0050 8DF81660 		strb	r6, [sp, #22]
 6778 0054 8DF81740 		strb	r4, [sp, #23]
 6779 0058 8DF81940 		strb	r4, [sp, #25]
 6780 005c 8DF82B50 		strb	r5, [sp, #43]
 428:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	int32_t altitude = hottv4UpdateAlt();
 6781              		.loc 5 428 0
 6782 0060 FFF7FEFF 		bl	_ZL15hottv4UpdateAltv
 6783              	.LVL324:
 430:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[22] = (altitude >> 8) & 0xFF;
 6784              		.loc 5 430 0
 6785 0064 0212     		asrs	r2, r0, #8
 429:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[21] = altitude;
 6786              		.loc 5 429 0
 6787 0066 8DF81500 		strb	r0, [sp, #21]
 430:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[22] = (altitude >> 8) & 0xFF;
 6788              		.loc 5 430 0
 6789 006a 8DF81620 		strb	r2, [sp, #22]
 432:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	unsigned int varioSound = hottv4UpdateAltVario();
 6790              		.loc 5 432 0
 6791 006e FFF7FEFF 		bl	_ZL20hottv4UpdateAltVariov
 6792              	.LVL325:
 433:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[11] = varioSound;
 6793              		.loc 5 433 0
 6794 0072 8DF80B00 		strb	r0, [sp, #11]
 6795              	.LBB180:
 6796              	.LBB181:
 198:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryWarning || batteryAlarm) {
 6797              		.loc 5 198 0
 6798 0076 A048     		ldr	r0, .L449
 6799              	.LVL326:
 6800              	.LBE181:
 6801              	.LBE180:
 434:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[13] = 120;
 6802              		.loc 5 434 0
 6803 0078 8DF80D40 		strb	r4, [sp, #13]
 6804              	.LBB184:
 6805              	.LBB182:
 198:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryWarning || batteryAlarm) {
 6806              		.loc 5 198 0
 6807 007c 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 6808              	.LBE182:
 6809              	.LBE184:
 439:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     telemetry_data[6] = hottV4UpdateDirection();
 6810              		.loc 5 439 0
 6811 007e B421     		movs	r1, #180
 6812 0080 8DF80610 		strb	r1, [sp, #6]
 6813              	.LVL327:
 6814              	.LBB185:
 6815              	.LBB183:
 198:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryWarning || batteryAlarm) {
 6816              		.loc 5 198 0
 6817 0084 2BB9     		cbnz	r3, .L441
 6818 0086 9D4D     		ldr	r5, .L449+4
 6819 0088 2A78     		ldrb	r2, [r5, #0]	@ zero_extendqisi2
 6820 008a 12B9     		cbnz	r2, .L441
 204:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		status = SpeakHoTT; 
 6821              		.loc 5 204 0
 6822 008c 9C4E     		ldr	r6, .L449+8
 6823 008e 3478     		ldrb	r4, [r6, #0]	@ zero_extendqisi2
 6824              	.LVL328:
 6825 0090 00E0     		b	.L419
 6826              	.LVL329:
 6827              	.L441:
 198:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryWarning || batteryAlarm) {
 6828              		.loc 5 198 0
 6829 0092 1024     		movs	r4, #16
 6830              	.LVL330:
 6831              	.L419:
 207:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if(old_status == status) {
 6832              		.loc 5 207 0
 6833 0094 9B4E     		ldr	r6, .L449+12
 6834 0096 9C4D     		ldr	r5, .L449+16
 6835 0098 96F800C0 		ldrb	ip, [r6, #0]	@ zero_extendqisi2
 6836 009c A445     		cmp	ip, r4
 6837 009e 06D1     		bne	.L420
 208:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		if(!CheckDelay(repeat)) return 0;
 6838              		.loc 5 208 0
 6839 00a0 2868     		ldr	r0, [r5, #0]
 6840 00a2 FFF7FEFF 		bl	_Z10CheckDelayj
 6841 00a6 80B1     		cbz	r0, .L442
 209:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		repeat = SetDelay(5000);
 6842              		.loc 5 209 0
 6843 00a8 41F28830 		movw	r0, #5000
 6844 00ac 01E0     		b	.L446
 6845              	.L420:
 211:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	else repeat = SetDelay(2000);
 6846              		.loc 5 211 0
 6847 00ae 4FF4FA60 		mov	r0, #2000
 6848              	.L446:
 6849 00b2 FFF7FEFF 		bl	_Z8SetDelayj
 6850 00b6 2860     		str	r0, [r5, #0]
 213:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if(status) 	{
 6851              		.loc 5 213 0
 6852 00b8 2CB1     		cbz	r4, .L423
 214:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		if(status == SpeakHoTT) SpeakHoTT = 0;
 6853              		.loc 5 214 0
 6854 00ba 914B     		ldr	r3, .L449+8
 6855 00bc 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 6856 00be A042     		cmp	r0, r4
 6857 00c0 01D1     		bne	.L423
 6858 00c2 0021     		movs	r1, #0
 6859 00c4 1970     		strb	r1, [r3, #0]
 6860              	.L423:
 217:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	old_status = status;
 6861              		.loc 5 217 0
 6862 00c6 3470     		strb	r4, [r6, #0]
 6863 00c8 00E0     		b	.L421
 6864              	.L442:
 208:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		if(!CheckDelay(repeat)) return 0;
 6865              		.loc 5 208 0
 6866 00ca 0446     		mov	r4, r0
 6867              	.LVL331:
 6868              	.L421:
 6869              	.LBE183:
 6870              	.LBE185:
 443:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[2] = HoTTWarning();
 6871              		.loc 5 443 0
 6872 00cc 8DF80240 		strb	r4, [sp, #2]
 6873 00d0 09E1     		b	.L437
 6874              	.LVL332:
 6875              	.L416:
 6876              	.LBE179:
 6877              	.LBE178:
 6878              	.LBB186:
 6879              	.LBB187:
 298:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****             };
 6880              		.loc 5 298 0
 6881 00d2 0021     		movs	r1, #0
 6882 00d4 2D22     		movs	r2, #45
 6883 00d6 6846     		mov	r0, sp
 6884              	.LVL333:
 6885 00d8 FFF7FEFF 		bl	memset
 6886 00dc 7C22     		movs	r2, #124
 6887 00de 8DF80020 		strb	r2, [sp, #0]
 6888 00e2 F422     		movs	r2, #244
 6889 00e4 8DF81A20 		strb	r2, [sp, #26]
 6890 00e8 7D22     		movs	r2, #125
 6891 00ea 1421     		movs	r1, #20
 6892 00ec 8E20     		movs	r0, #142
 6893 00ee 8DF82B20 		strb	r2, [sp, #43]
 6894              	.LVL334:
 6895              	.LBB188:
 6896              	.LBB189:
 120:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	short voltage = batteryData[0].voltage/10;
 6897              		.loc 5 120 0
 6898 00f2 864A     		ldr	r2, .L449+20
 6899              	.LBE189:
 6900              	.LBE188:
 298:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****             };
 6901              		.loc 5 298 0
 6902 00f4 8DF80100 		strb	r0, [sp, #1]
 6903 00f8 E023     		movs	r3, #224
 6904 00fa 0120     		movs	r0, #1
 6905 00fc 8DF81810 		strb	r1, [sp, #24]
 6906 0100 8DF81910 		strb	r1, [sp, #25]
 6907 0104 7821     		movs	r1, #120
 6908 0106 8DF80330 		strb	r3, [sp, #3]
 6909 010a 8DF81B00 		strb	r0, [sp, #27]
 6910 010e 4823     		movs	r3, #72
 6911              	.LBB195:
 6912              	.LBB192:
 120:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	short voltage = batteryData[0].voltage/10;
 6913              		.loc 5 120 0
 6914 0110 D088     		ldrh	r0, [r2, #6]
 6915              	.LBE192:
 6916              	.LBE195:
 298:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****             };
 6917              		.loc 5 298 0
 6918 0112 8DF82410 		strb	r1, [sp, #36]
 6919              	.LBB196:
 6920              	.LBB193:
 122:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryWarning || batteryAlarm) {
 6921              		.loc 5 122 0
 6922 0116 7849     		ldr	r1, .L449
 6923              	.LBE193:
 6924              	.LBE196:
 298:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****             };
 6925              		.loc 5 298 0
 6926 0118 8DF82230 		strb	r3, [sp, #34]
 6927              	.LBB197:
 6928              	.LBB194:
 120:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	short voltage = batteryData[0].voltage/10;
 6929              		.loc 5 120 0
 6930 011c 0A23     		movs	r3, #10
 6931 011e B0FBF3F3 		udiv	r3, r0, r3
 6932              	.LVL335:
 122:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryWarning || batteryAlarm) {
 6933              		.loc 5 122 0
 6934 0122 0878     		ldrb	r0, [r1, #0]	@ zero_extendqisi2
 6935 0124 10B9     		cbnz	r0, .L424
 6936 0126 7548     		ldr	r0, .L449+4
 6937 0128 0178     		ldrb	r1, [r0, #0]	@ zero_extendqisi2
 6938 012a 11B1     		cbz	r1, .L425
 6939              	.L424:
 6940              	.LVL336:
 6941              	.LBB190:
 6942              	.LBB191:
 110:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     data[4] = 0x80; // Inverts MikroKopter Telemetry Display for Voltage
 6943              		.loc 5 110 0
 6944 012c 8021     		movs	r1, #128
 6945 012e 8DF80410 		strb	r1, [sp, #4]
 6946              	.LVL337:
 6947              	.L425:
 6948              	.LBE191:
 6949              	.LBE190:
 6950              	.LBE194:
 6951              	.LBE197:
 6952              	.LBB198:
 6953              	.LBB199:
 130:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryData[0].cPin != BM_NOPIN) return batteryData[0].current/100;
 6954              		.loc 5 130 0
 6955 0132 917A     		ldrb	r1, [r2, #10]	@ zero_extendqisi2
 6956              	.LBE199:
 6957              	.LBE198:
 302:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[20] = telemetry_data[22] = telemetry_data[30] = voltage;
 6958              		.loc 5 302 0
 6959 0134 8DF81E30 		strb	r3, [sp, #30]
 6960 0138 8DF81630 		strb	r3, [sp, #22]
 6961 013c 8DF81430 		strb	r3, [sp, #20]
 303:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[21] = telemetry_data[23] = telemetry_data[31] = (voltage >> 8) & 0xFF;
 6962              		.loc 5 303 0
 6963 0140 1B0A     		lsrs	r3, r3, #8
 6964              	.LVL338:
 6965              	.LBB202:
 6966              	.LBB200:
 130:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryData[0].cPin != BM_NOPIN) return batteryData[0].current/100;
 6967              		.loc 5 130 0
 6968 0142 FF29     		cmp	r1, #255
 6969              	.LBE200:
 6970              	.LBE202:
 303:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[21] = telemetry_data[23] = telemetry_data[31] = (voltage >> 8) & 0xFF;
 6971              		.loc 5 303 0
 6972 0144 8DF81F30 		strb	r3, [sp, #31]
 6973 0148 8DF81730 		strb	r3, [sp, #23]
 6974 014c 8DF81530 		strb	r3, [sp, #21]
 6975              	.LBB203:
 6976              	.LBB201:
 130:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryData[0].cPin != BM_NOPIN) return batteryData[0].current/100;
 6977              		.loc 5 130 0
 6978 0150 07D0     		beq	.L443
 6979 0152 6E48     		ldr	r0, .L449+20
 6980 0154 B0F910E0 		ldrsh	lr, [r0, #16]
 6981 0158 6423     		movs	r3, #100
 6982 015a 9EFBF3F0 		sdiv	r0, lr, r3
 6983 015e 83B2     		uxth	r3, r0
 6984 0160 00E0     		b	.L426
 6985              	.L443:
 131:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	return 0;
 6986              		.loc 5 131 0
 6987 0162 0023     		movs	r3, #0
 6988              	.L426:
 6989              	.LBE201:
 6990              	.LBE203:
 307:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[29] = (current >> 8) & 0xFF;
 6991              		.loc 5 307 0
 6992 0164 180A     		lsrs	r0, r3, #8
 6993              	.LBB204:
 6994              	.LBB205:
 135:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryData[0].cPin != BM_NOPIN) return batteryData[0].usedCapacity/1000;
 6995              		.loc 5 135 0
 6996 0166 FF29     		cmp	r1, #255
 6997 0168 18BF     		it	ne
 6998 016a 5269     		ldrne	r2, [r2, #20]
 6999              	.LBE205:
 7000              	.LBE204:
 307:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[29] = (current >> 8) & 0xFF;
 7001              		.loc 5 307 0
 7002 016c 8DF81D00 		strb	r0, [sp, #29]
 7003              	.LBB207:
 7004              	.LBB206:
 135:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryData[0].cPin != BM_NOPIN) return batteryData[0].usedCapacity/1000;
 7005              		.loc 5 135 0
 7006 0170 1ABF     		itte	ne
 7007 0172 4FF47A70 		movne	r0, #1000
 7008 0176 92FBF0F0 		sdivne	r0, r2, r0
 136:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	return 0;
 7009              		.loc 5 136 0
 7010 017a 0020     		moveq	r0, #0
 7011              	.LBE206:
 7012              	.LBE207:
 306:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[28] = current;
 7013              		.loc 5 306 0
 7014 017c 8DF81C30 		strb	r3, [sp, #28]
 311:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[33] = (capacity >> 8) & 0xFF;
 7015              		.loc 5 311 0
 7016 0180 0312     		asrs	r3, r0, #8
 7017 0182 8DF82130 		strb	r3, [sp, #33]
 310:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[32] = capacity;
 7018              		.loc 5 310 0
 7019 0186 8DF82000 		strb	r0, [sp, #32]
 315:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     int32_t altitude = hottv4UpdateAlt();
 7020              		.loc 5 315 0
 7021 018a FFF7FEFF 		bl	_ZL15hottv4UpdateAltv
 7022              	.LVL339:
 316:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[26] = altitude;
 7023              		.loc 5 316 0
 7024 018e 8DF81A00 		strb	r0, [sp, #26]
 317:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[27] = (altitude >> 8) & 0xFF;
 7025              		.loc 5 317 0
 7026 0192 0012     		asrs	r0, r0, #8
 7027              	.LVL340:
 7028 0194 8DF81B00 		strb	r0, [sp, #27]
 319:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	unsigned int varioSound = hottv4UpdateAltVario();
 7029              		.loc 5 319 0
 7030 0198 FFF7FEFF 		bl	_ZL20hottv4UpdateAltVariov
 7031              	.LVL341:
 321:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     telemetry_data[12] = telemetry_data[14] = (varioSound >> 8) & 0xFF;
 7032              		.loc 5 321 0
 7033 019c 010A     		lsrs	r1, r0, #8
 7034 019e 8DF80E10 		strb	r1, [sp, #14]
 7035 01a2 8DF80C10 		strb	r1, [sp, #12]
 7036              	.LVL342:
 320:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     telemetry_data[11] = telemetry_data[13] = varioSound;
 7037              		.loc 5 320 0
 7038 01a6 8DF80D00 		strb	r0, [sp, #13]
 7039 01aa 8DF80B00 		strb	r0, [sp, #11]
 7040              	.LBB208:
 7041              	.LBB209:
 230:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint16_t timeDiff = millis() - previousEAMUpdate;
 7042              		.loc 5 230 0
 7043 01ae FFF7FEFF 		bl	_ZL6millisv
 7044              	.LVL343:
 7045 01b2 574B     		ldr	r3, .L449+24
 7046 01b4 1A68     		ldr	r2, [r3, #0]
 7047 01b6 C2EB000C 		rsb	ip, r2, r0
 7048 01ba 1FFA8CF1 		uxth	r1, ip
 7049              	.LVL344:
 231:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   previousEAMUpdate += timeDiff;
 7050              		.loc 5 231 0
 7051 01be 8818     		adds	r0, r1, r2
 7052 01c0 1860     		str	r0, [r3, #0]
 233:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   CountMilliseconds += timeDiff;
 7053              		.loc 5 233 0
 7054 01c2 544B     		ldr	r3, .L449+28
 7055 01c4 1A68     		ldr	r2, [r3, #0]
 7056 01c6 8818     		adds	r0, r1, r2
 235:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if (motorArmed) {
 7057              		.loc 5 235 0
 7058 01c8 534A     		ldr	r2, .L449+32
 233:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   CountMilliseconds += timeDiff;
 7059              		.loc 5 233 0
 7060 01ca 1860     		str	r0, [r3, #0]
 235:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if (motorArmed) {
 7061              		.loc 5 235 0
 7062 01cc 1078     		ldrb	r0, [r2, #0]	@ zero_extendqisi2
 7063 01ce 534B     		ldr	r3, .L449+36
 7064 01d0 534A     		ldr	r2, .L449+40
 7065 01d2 80B1     		cbz	r0, .L428
 236:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     milliseconds += timeDiff;
 7066              		.loc 5 236 0
 7067 01d4 1888     		ldrh	r0, [r3, #0]
 7068 01d6 01EB000C 		add	ip, r1, r0
 7069 01da 1FFA8CF1 		uxth	r1, ip
 7070              	.LVL345:
 238:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     if (milliseconds >= 60000) {
 7071              		.loc 5 238 0
 7072 01de 4EF65F2E 		movw	lr, #59999
 7073 01e2 7145     		cmp	r1, lr
 236:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     milliseconds += timeDiff;
 7074              		.loc 5 236 0
 7075 01e4 1980     		strh	r1, [r3, #0]	@ movhi
 238:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     if (milliseconds >= 60000) {
 7076              		.loc 5 238 0
 7077 01e6 06D9     		bls	.L428
 240:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       minutes += 1;
 7078              		.loc 5 240 0
 7079 01e8 1078     		ldrb	r0, [r2, #0]	@ zero_extendqisi2
 239:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       milliseconds -= 60000;
 7080              		.loc 5 239 0
 7081 01ea 01F5AD5E 		add	lr, r1, #5536
 240:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       minutes += 1;
 7082              		.loc 5 240 0
 7083 01ee 411C     		adds	r1, r0, #1
 239:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       milliseconds -= 60000;
 7084              		.loc 5 239 0
 7085 01f0 A3F800E0 		strh	lr, [r3, #0]	@ movhi
 240:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       minutes += 1;
 7086              		.loc 5 240 0
 7087 01f4 1170     		strb	r1, [r2, #0]
 7088              	.L428:
 246:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   data[40] = (milliseconds >> 10) ;
 7089              		.loc 5 246 0
 7090 01f6 1B88     		ldrh	r3, [r3, #0]
 244:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   data[39] = minutes;
 7091              		.loc 5 244 0
 7092 01f8 1178     		ldrb	r1, [r2, #0]	@ zero_extendqisi2
 246:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   data[40] = (milliseconds >> 10) ;
 7093              		.loc 5 246 0
 7094 01fa 9A12     		asrs	r2, r3, #10
 244:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   data[39] = minutes;
 7095              		.loc 5 244 0
 7096 01fc 8DF82710 		strb	r1, [sp, #39]
 246:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   data[40] = (milliseconds >> 10) ;
 7097              		.loc 5 246 0
 7098 0200 8DF82820 		strb	r2, [sp, #40]
 7099 0204 6FE0     		b	.L437
 7100              	.LVL346:
 7101              	.L417:
 7102              	.LBE209:
 7103              	.LBE208:
 7104              	.LBE187:
 7105              	.LBE186:
 7106              	.LBB210:
 7107              	.LBB211:
 479:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****             };
 7108              		.loc 5 479 0
 7109 0206 474B     		ldr	r3, .L449+44
 7110 0208 6A46     		mov	r2, sp
 7111 020a 03F12805 		add	r5, r3, #40
 7112              	.LVL347:
 7113              	.L429:
 7114 020e 1868     		ldr	r0, [r3, #0]	@ unaligned
 7115 0210 5968     		ldr	r1, [r3, #4]	@ unaligned
 7116 0212 1446     		mov	r4, r2
 7117 0214 03C4     		stmia	r4!, {r0, r1}
 7118 0216 0833     		adds	r3, r3, #8
 7119 0218 AB42     		cmp	r3, r5
 7120 021a 2246     		mov	r2, r4
 7121 021c F7D1     		bne	.L429
 7122 021e 1868     		ldr	r0, [r3, #0]	@ unaligned
 7123 0220 2060     		str	r0, [r4, #0]	@ unaligned
 7124 0222 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 7125 0224 2171     		strb	r1, [r4, #4]
 482:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   int32_t altitude = hottv4UpdateAlt();
 7126              		.loc 5 482 0
 7127 0226 FFF7FEFF 		bl	_ZL15hottv4UpdateAltv
 7128              	.LVL348:
 486:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[7] = maxAltitude;
 7129              		.loc 5 486 0
 7130 022a 3F4A     		ldr	r2, .L449+48
 487:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[9] = minAltitude;
 7131              		.loc 5 487 0
 7132 022c 3F49     		ldr	r1, .L449+52
 483:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[5] = altitude;
 7133              		.loc 5 483 0
 7134 022e 8DF80500 		strb	r0, [sp, #5]
 484:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[6] = (altitude >> 8) & 0xFF;
 7135              		.loc 5 484 0
 7136 0232 0312     		asrs	r3, r0, #8
 7137 0234 8DF80630 		strb	r3, [sp, #6]
 486:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[7] = maxAltitude;
 7138              		.loc 5 486 0
 7139 0238 1068     		ldr	r0, [r2, #0]
 7140              	.LVL349:
 487:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[9] = minAltitude;
 7141              		.loc 5 487 0
 7142 023a 0B68     		ldr	r3, [r1, #0]
 486:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[7] = maxAltitude;
 7143              		.loc 5 486 0
 7144 023c 8DF80700 		strb	r0, [sp, #7]
 487:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[9] = minAltitude;
 7145              		.loc 5 487 0
 7146 0240 8DF80930 		strb	r3, [sp, #9]
 489:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   unsigned int varioSound = hottv4UpdateAltVario();
 7147              		.loc 5 489 0
 7148 0244 FFF7FEFF 		bl	_ZL20hottv4UpdateAltVariov
 7149              	.LVL350:
 491:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[12] = telemetry_data[14] = telemetry_data[16] = (varioSound >> 8) & 0xFF;
 7150              		.loc 5 491 0
 7151 0248 020A     		lsrs	r2, r0, #8
 490:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[11] = telemetry_data[13] = telemetry_data[15] = varioSound;
 7152              		.loc 5 490 0
 7153 024a 8DF80F00 		strb	r0, [sp, #15]
 7154 024e 8DF80D00 		strb	r0, [sp, #13]
 7155 0252 8DF80B00 		strb	r0, [sp, #11]
 493:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(altitudeHoldState == ON) {
 7156              		.loc 5 493 0
 7157 0256 3648     		ldr	r0, .L449+56
 7158              	.LVL351:
 491:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[12] = telemetry_data[14] = telemetry_data[16] = (varioSound >> 8) & 0xFF;
 7159              		.loc 5 491 0
 7160 0258 8DF81020 		strb	r2, [sp, #16]
 493:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(altitudeHoldState == ON) {
 7161              		.loc 5 493 0
 7162 025c 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 491:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[12] = telemetry_data[14] = telemetry_data[16] = (varioSound >> 8) & 0xFF;
 7163              		.loc 5 491 0
 7164 025e 8DF80E20 		strb	r2, [sp, #14]
 493:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(altitudeHoldState == ON) {
 7165              		.loc 5 493 0
 7166 0262 012B     		cmp	r3, #1
 491:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[12] = telemetry_data[14] = telemetry_data[16] = (varioSound >> 8) & 0xFF;
 7167              		.loc 5 491 0
 7168 0264 8DF80C20 		strb	r2, [sp, #12]
 493:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(altitudeHoldState == ON) {
 7169              		.loc 5 493 0
 7170 0268 12D1     		bne	.L430
 494:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  if((receiverCommand[THROTTLE] > (altitudeHoldThrottle + altitudeHoldBump))) telemetry_data[38] =
 7171              		.loc 5 494 0
 7172 026a 3249     		ldr	r1, .L449+60
 7173 026c 324A     		ldr	r2, .L449+64
 7174 026e 334B     		ldr	r3, .L449+68
 7175 0270 0968     		ldr	r1, [r1, #0]
 7176 0272 1268     		ldr	r2, [r2, #0]
 7177 0274 DB68     		ldr	r3, [r3, #12]
 7178 0276 01EB020C 		add	ip, r1, r2
 7179 027a 6345     		cmp	r3, ip
 7180 027c 01DD     		ble	.L431
 7181 027e 2B23     		movs	r3, #43
 7182 0280 09E0     		b	.L447
 7183              	.L431:
 495:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  else if((receiverCommand[THROTTLE] < (altitudeHoldThrottle - altitudeHoldBump))) telemetry_data[
 7184              		.loc 5 495 0
 7185 0282 8A1A     		subs	r2, r1, r2
 7186 0284 9342     		cmp	r3, r2
 7187 0286 01DA     		bge	.L433
 7188 0288 2D23     		movs	r3, #45
 7189 028a 04E0     		b	.L447
 7190              	.L433:
 496:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  else telemetry_data[38] = '=';
 7191              		.loc 5 496 0
 7192 028c 3D23     		movs	r3, #61
 7193 028e 02E0     		b	.L447
 7194              	.L430:
 498:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   else if (altitudeHoldState == ALTPANIC) {
 7195              		.loc 5 498 0
 7196 0290 022B     		cmp	r3, #2
 7197 0292 02D1     		bne	.L432
 499:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  telemetry_data[38] = '!';
 7198              		.loc 5 499 0
 7199 0294 2123     		movs	r3, #33
 7200              	.L447:
 7201 0296 8DF82630 		strb	r3, [sp, #38]
 7202              	.L432:
 506:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(flightMode == ATTITUDE_FLIGHT_MODE) snprintf(text, VARIO_ASCIIS+1, HOTTV4_VARIO_ATTITUDE);
 7203              		.loc 5 506 0
 7204 029a 2949     		ldr	r1, .L449+72
 7205 029c 91F800E0 		ldrb	lr, [r1, #0]	@ zero_extendqisi2
 7206 02a0 1621     		movs	r1, #22
 7207 02a2 BEF1010F 		cmp	lr, #1
 7208 02a6 0CBF     		ite	eq
 7209 02a8 264A     		ldreq	r2, .L449+76
 507:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   else snprintf(text, VARIO_ASCIIS+1, HOTTV4_VARIO_RATE);
 7210              		.loc 5 507 0
 7211 02aa 274A     		ldrne	r2, .L449+80
 506:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(flightMode == ATTITUDE_FLIGHT_MODE) snprintf(text, VARIO_ASCIIS+1, HOTTV4_VARIO_ATTITUDE);
 7212              		.loc 5 506 0
 7213 02ac 0CA8     		add	r0, sp, #48
 507:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   else snprintf(text, VARIO_ASCIIS+1, HOTTV4_VARIO_RATE);
 7214              		.loc 5 507 0
 7215 02ae FFF7FEFF 		bl	snprintf
 509:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint8_t offset = (VARIO_ASCIIS - strlen(text)) / 2;
 7216              		.loc 5 509 0
 7217 02b2 0CA8     		add	r0, sp, #48
 7218 02b4 FFF7FEFF 		bl	strlen
 7219 02b8 C0F11502 		rsb	r2, r0, #21
 7220 02bc 5008     		lsrs	r0, r2, #1
 7221 02be C2B2     		uxtb	r2, r0
 7222              	.LVL352:
 511:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   for(uint8_t index = 0; (index + offset) < VARIO_ASCIIS; index++) {
 7223              		.loc 5 511 0
 7224 02c0 0023     		movs	r3, #0
 7225 02c2 0BE0     		b	.L436
 7226              	.LVL353:
 7227              	.L438:
 7228              	.LBB212:
 512:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     if (text[index] != 0x0) {
 7229              		.loc 5 512 0
 7230 02c4 0DF1480C 		add	ip, sp, #72
 7231 02c8 0CEB0300 		add	r0, ip, r3
 7232 02cc 10F8181C 		ldrb	r1, [r0, #-24]	@ zero_extendqisi2
 7233 02d0 49B1     		cbz	r1, .L437
 514:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       telemetry_data[17+index+offset] = text[index];
 7234              		.loc 5 514 0
 7235 02d2 8018     		adds	r0, r0, r2
 511:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   for(uint8_t index = 0; (index + offset) < VARIO_ASCIIS; index++) {
 7236              		.loc 5 511 0
 7237 02d4 0133     		adds	r3, r3, #1
 7238              	.LVL354:
 514:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       telemetry_data[17+index+offset] = text[index];
 7239              		.loc 5 514 0
 7240 02d6 00F8371C 		strb	r1, [r0, #-55]
 511:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   for(uint8_t index = 0; (index + offset) < VARIO_ASCIIS; index++) {
 7241              		.loc 5 511 0
 7242 02da DBB2     		uxtb	r3, r3
 7243              	.LVL355:
 7244              	.L436:
 7245 02dc 03EB020E 		add	lr, r3, r2
 7246 02e0 BEF1140F 		cmp	lr, #20
 7247 02e4 EEDD     		ble	.L438
 7248              	.LVL356:
 7249              	.L437:
 7250              	.LBE212:
 521:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4SendBinary(telemetry_data);
 7251              		.loc 5 521 0
 7252 02e6 6846     		mov	r0, sp
 7253 02e8 FFF7FEFF 		bl	_ZL16hottV4SendBinaryPh
 540:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     case HOTTV4_GPS_MODULE:
 541:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     case '1':
 542:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       hottV4SendGPSTelemetry();
 543:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       return true;
 544:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       break;
 545:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     
 546:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     case HOTTV4_ELECTRICAL_AIR_MODULE:
 547:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     case '2':
 548:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       hottV4SendEAMTelemetry();
 549:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       return true;
 550:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       break;
 551:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****          
 552:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     case HOTTV4_VARIO_MODULE:
 553:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     case '3':
 554:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       hottV4SendVarioTelemetry();
 555:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       return true;
 7254              		.loc 5 555 0
 7255 02ec 0120     		movs	r0, #1
 7256 02ee 00E0     		b	.L414
 7257              	.LVL357:
 7258              	.L439:
 7259              	.LBE211:
 7260              	.LBE210:
 556:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       break;
 557:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   }
 558:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 559:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   return false;
 7261              		.loc 5 559 0
 7262 02f0 0020     		movs	r0, #0
 7263              	.LVL358:
 7264              	.L414:
 560:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 7265              		.loc 5 560 0
 7266 02f2 12B0     		add	sp, sp, #72
 7267 02f4 70BD     		pop	{r4, r5, r6, pc}
 7268              	.L450:
 7269 02f6 00BF     		.align	2
 7270              	.L449:
 7271 02f8 00000000 		.word	.LANCHOR105
 7272 02fc 00000000 		.word	.LANCHOR104
 7273 0300 00000000 		.word	.LANCHOR112
 7274 0304 00000000 		.word	.LANCHOR113
 7275 0308 00000000 		.word	.LANCHOR114
 7276 030c 00000000 		.word	.LANCHOR103
 7277 0310 00000000 		.word	.LANCHOR115
 7278 0314 00000000 		.word	.LANCHOR111
 7279 0318 00000000 		.word	.LANCHOR116
 7280 031c 00000000 		.word	.LANCHOR117
 7281 0320 00000000 		.word	.LANCHOR118
 7282 0324 00000000 		.word	.LANCHOR119
 7283 0328 00000000 		.word	.LANCHOR82
 7284 032c 00000000 		.word	.LANCHOR83
 7285 0330 00000000 		.word	.LANCHOR5
 7286 0334 00000000 		.word	.LANCHOR7
 7287 0338 00000000 		.word	.LANCHOR8
 7288 033c 00000000 		.word	.LANCHOR6
 7289 0340 00000000 		.word	.LANCHOR120
 7290 0344 94000000 		.word	.LC6
 7291 0348 A8000000 		.word	.LC7
 7292              		.cfi_endproc
 7293              	.LFE232:
 7295              		.section	.text._Z11hottHandlerv,"ax",%progbits
 7296              		.align	1
 7297              		.global	_Z11hottHandlerv
 7298              		.thumb
 7299              		.thumb_func
 7301              	_Z11hottHandlerv:
 7302              	.LFB233:
 561:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 562:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** enum HottStateMachine {
 563:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	eHottReadCmd,
 564:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	eHottSendStartDelay,
 565:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	eHottSendByte,
 566:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	eHottCleanUp
 567:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** } ;
 568:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 569:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 570:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** HottStateMachine hottState = eHottReadCmd;
 571:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** uint32 hottTime;
 572:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** void hottHandler()
 573:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** {
 7303              		.loc 5 573 0
 7304              		.cfi_startproc
 7305              		@ args = 0, pretend = 0, frame = 0
 7306              		@ frame_needed = 0, uses_anonymous_args = 0
 7307 0000 70B5     		push	{r4, r5, r6, lr}
 7308              	.LCFI77:
 7309              		.cfi_def_cfa_offset 16
 7310              		.cfi_offset 14, -4
 7311              		.cfi_offset 6, -8
 7312              		.cfi_offset 5, -12
 7313              		.cfi_offset 4, -16
 7314              	.LBB218:
 574:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	switch(hottState) {
 7315              		.loc 5 574 0
 7316 0002 2A4C     		ldr	r4, .L459
 7317 0004 2378     		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 7318 0006 032B     		cmp	r3, #3
 7319 0008 4ED8     		bhi	.L451
 7320 000a DFE803F0 		tbb	[pc, r3]
 7321              	.L457:
 7322 000e 02       		.byte	(.L453-.L457)/2
 7323 000f 11       		.byte	(.L454-.L457)/2
 7324 0010 1F       		.byte	(.L455-.L457)/2
 7325 0011 3D       		.byte	(.L456-.L457)/2
 7326              		.align	1
 7327              	.L453:
 7328              	.LBB219:
 7329              	.LBB220:
 575:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	case eHottReadCmd:
 576:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		{
 577:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		  byte cmd = hottV4SerialRead();
 7330              		.loc 5 577 0
 7331 0012 FFF7FEFF 		bl	_Z16hottV4SerialReadv
 7332 0016 C0B2     		uxtb	r0, r0
 7333              	.LVL359:
 578:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	      if(cmd != 0xff && hottV4Hook(cmd)) {
 7334              		.loc 5 578 0
 7335 0018 FF28     		cmp	r0, #255
 7336 001a 45D0     		beq	.L451
 7337              		.loc 5 578 0 is_stmt 0 discriminator 1
 7338 001c FFF7FEFF 		bl	_Z10hottV4Hookh
 7339              	.LVL360:
 7340 0020 0028     		cmp	r0, #0
 7341 0022 41D0     		beq	.L451
 579:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   	        hottTime = micros();
 7342              		.loc 5 579 0 is_stmt 1 discriminator 4
 7343 0024 FFF7FEFF 		bl	_ZL6microsv
 7344 0028 2149     		ldr	r1, .L459+4
 580:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   	        hottState = eHottSendStartDelay;
 7345              		.loc 5 580 0 discriminator 4
 7346 002a 0123     		movs	r3, #1
 579:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   	        hottTime = micros();
 7347              		.loc 5 579 0 discriminator 4
 7348 002c 0860     		str	r0, [r1, #0]
 7349 002e 0BE0     		b	.L458
 7350              	.L454:
 7351              	.LBE220:
 581:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	      }
 582:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		}
 583:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		break;
 584:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 585:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	case eHottSendStartDelay:
 586:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		if(micros() - hottTime > 2000) {
 7352              		.loc 5 586 0
 7353 0030 1F4D     		ldr	r5, .L459+4
 7354 0032 FFF7FEFF 		bl	_ZL6microsv
 7355 0036 2A68     		ldr	r2, [r5, #0]
 7356 0038 801A     		subs	r0, r0, r2
 7357 003a B0F5FA6F 		cmp	r0, #2000
 7358 003e 33D9     		bls	.L451
 587:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		    hottTime = micros();
 7359              		.loc 5 587 0
 7360 0040 FFF7FEFF 		bl	_ZL6microsv
 588:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		    hottState = eHottSendByte;
 7361              		.loc 5 588 0
 7362 0044 0223     		movs	r3, #2
 587:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		    hottTime = micros();
 7363              		.loc 5 587 0
 7364 0046 2860     		str	r0, [r5, #0]
 7365              	.L458:
 7366              		.loc 5 588 0
 7367 0048 2370     		strb	r3, [r4, #0]
 7368 004a 70BD     		pop	{r4, r5, r6, pc}
 7369              	.L455:
 589:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		}
 590:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		break;
 591:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 592:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	case eHottSendByte:
 593:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		if(micros() - hottTime > 1000) {
 7370              		.loc 5 593 0
 7371 004c 184E     		ldr	r6, .L459+4
 7372 004e FFF7FEFF 		bl	_ZL6microsv
 7373 0052 3368     		ldr	r3, [r6, #0]
 7374 0054 C3EB000C 		rsb	ip, r3, r0
 7375 0058 BCF57A7F 		cmp	ip, #1000
 7376 005c 24D9     		bls	.L451
 594:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 			hottV4SerialWrite(hottV4TelemetryBuffer[hottV4TelemetryBufferIndex++]);
 7377              		.loc 5 594 0
 7378 005e 154D     		ldr	r5, .L459+8
 7379              	.LBB221:
 7380              	.LBB222:
  45:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4Serial->write(data);
 7381              		.loc 5 45 0
 7382 0060 1548     		ldr	r0, .L459+12
 7383              	.LBE222:
 7384              	.LBE221:
 7385              		.loc 5 594 0
 7386 0062 2B78     		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 7387              	.LBB226:
 7388              	.LBB223:
  45:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4Serial->write(data);
 7389              		.loc 5 45 0
 7390 0064 0068     		ldr	r0, [r0, #0]
 7391              	.LBE223:
 7392              	.LBE226:
 7393              		.loc 5 594 0
 7394 0066 1549     		ldr	r1, .L459+16
 7395 0068 5A1C     		adds	r2, r3, #1
 7396 006a C95C     		ldrb	r1, [r1, r3]	@ zero_extendqisi2
 7397              	.LBB227:
 7398              	.LBB224:
  45:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4Serial->write(data);
 7399              		.loc 5 45 0
 7400 006c 0368     		ldr	r3, [r0, #0]
 7401              	.LBE224:
 7402              	.LBE227:
 7403              		.loc 5 594 0
 7404 006e 2A70     		strb	r2, [r5, #0]
 7405              	.LVL361:
 7406              	.LBB228:
 7407              	.LBB225:
  45:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4Serial->write(data);
 7408              		.loc 5 45 0
 7409 0070 1A68     		ldr	r2, [r3, #0]
 7410 0072 9047     		blx	r2
 7411              	.LVL362:
 7412              	.LBE225:
 7413              	.LBE228:
 595:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 			hottV4SerialClearInput();
 7414              		.loc 5 595 0
 7415 0074 FFF7FEFF 		bl	_Z22hottV4SerialClearInputv
 596:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 597:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 			hottTime = micros();
 7416              		.loc 5 597 0
 7417 0078 FFF7FEFF 		bl	_ZL6microsv
 598:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		    if(hottV4TelemetryBufferIndex >= hottV4TelemetryBufferSize) {
 7418              		.loc 5 598 0
 7419 007c 2978     		ldrb	r1, [r5, #0]	@ zero_extendqisi2
 597:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 			hottTime = micros();
 7420              		.loc 5 597 0
 7421 007e 3060     		str	r0, [r6, #0]
 7422              		.loc 5 598 0
 7423 0080 2C29     		cmp	r1, #44
 7424 0082 11D9     		bls	.L451
 599:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		    	hottState = eHottCleanUp;
 7425              		.loc 5 599 0
 7426 0084 0323     		movs	r3, #3
 7427 0086 DFE7     		b	.L458
 7428              	.L456:
 600:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		    }
 601:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		}
 602:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		break;
 603:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 604:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	case eHottCleanUp:
 605:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		hottV4SerialClearInput();
 606:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 607:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		if(micros() - hottTime > 5000) {
 7429              		.loc 5 607 0
 7430 0088 094D     		ldr	r5, .L459+4
 605:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		hottV4SerialClearInput();
 7431              		.loc 5 605 0
 7432 008a FFF7FEFF 		bl	_Z22hottV4SerialClearInputv
 7433              		.loc 5 607 0
 7434 008e FFF7FEFF 		bl	_ZL6microsv
 7435 0092 2B68     		ldr	r3, [r5, #0]
 7436 0094 C21A     		subs	r2, r0, r3
 7437 0096 41F28830 		movw	r0, #5000
 7438 009a 8242     		cmp	r2, r0
 7439 009c 04D9     		bls	.L451
 608:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		    hottTime = micros();
 7440              		.loc 5 608 0
 7441 009e FFF7FEFF 		bl	_ZL6microsv
 609:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		    hottState = eHottReadCmd;
 7442              		.loc 5 609 0
 7443 00a2 0021     		movs	r1, #0
 608:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		    hottTime = micros();
 7444              		.loc 5 608 0
 7445 00a4 2860     		str	r0, [r5, #0]
 7446              		.loc 5 609 0
 7447 00a6 2170     		strb	r1, [r4, #0]
 7448              	.L451:
 7449 00a8 70BD     		pop	{r4, r5, r6, pc}
 7450              	.L460:
 7451 00aa 00BF     		.align	2
 7452              	.L459:
 7453 00ac 00000000 		.word	.LANCHOR121
 7454 00b0 00000000 		.word	.LANCHOR122
 7455 00b4 00000000 		.word	.LANCHOR4
 7456 00b8 00000000 		.word	.LANCHOR110
 7457 00bc 00000000 		.word	.LANCHOR3
 7458              	.LBE219:
 7459              	.LBE218:
 7460              		.cfi_endproc
 7461              	.LFE233:
 7463              		.section	.text._Z19processAltitudeHoldv,"ax",%progbits
 7464              		.align	1
 7465              		.global	_Z19processAltitudeHoldv
 7466              		.thumb
 7467              		.thumb_func
 7469              	_Z19processAltitudeHoldv:
 7470              	.LFB234:
 7471              		.file 28 "C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h"
   1:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** /*
   2:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   AeroQuad v3.0.1 - February 2012
   3:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   www.AeroQuad.com
   4:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   An Open Source Arduino based multicopter.
   6:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****  
   7:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   This program is free software: you can redistribute it and/or modify 
   8:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   it under the terms of the GNU General Public License as published by 
   9:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   (at your option) any later version. 
  11:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****  
  12:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   This program is distributed in the hope that it will be useful, 
  13:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   GNU General Public License for more details. 
  16:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****  
  17:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   You should have received a copy of the GNU General Public License 
  18:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** */
  20:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** 
  21:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** // FlightControl.pde is responsible for combining sensor measurements and
  22:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** // transmitter commands into motor commands for the defined flight configuration (X, +, etc.)
  23:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** //////////////////////////////////////////////////////////////////////////////
  24:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** /////////////////////////// calculateFlightError /////////////////////////////
  25:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** //////////////////////////////////////////////////////////////////////////////
  26:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** 
  27:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** #ifndef _AQ_ALTITUDE_CONTROL_PROCESSOR_H_
  28:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** #define _AQ_ALTITUDE_CONTROL_PROCESSOR_H_
  29:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** 
  30:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** 
  31:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
  32:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** 
  33:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** #define INVALID_THROTTLE_CORRECTION -1000
  34:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** #define ALTITUDE_BUMP_SPEED 0.01
  35:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** 
  36:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** 
  37:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** /**
  38:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****  * processAltitudeHold
  39:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****  * 
  40:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****  * This function is responsible to process the throttle correction 
  41:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****  * to keep the current altitude if selected by the user 
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****  */
  43:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** void processAltitudeHold()
  44:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** {
 7472              		.loc 28 44 0
 7473              		.cfi_startproc
 7474              		@ args = 0, pretend = 0, frame = 0
 7475              		@ frame_needed = 0, uses_anonymous_args = 0
 7476 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 7477              	.LCFI78:
 7478              		.cfi_def_cfa_offset 24
 7479              		.cfi_offset 14, -4
 7480              		.cfi_offset 8, -8
 7481              		.cfi_offset 7, -12
 7482              		.cfi_offset 6, -16
 7483              		.cfi_offset 5, -20
 7484              		.cfi_offset 4, -24
 7485              	.LBB229:
  45:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   // ****************************** Altitude Adjust *************************
  46:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   // Thanks to Honk for his work with altitude hold
  47:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   // http://aeroquad.com/showthread.php?792-Problems-with-BMP085-I2C-barometer
  48:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   // Thanks to Sherbakov for his work in Z Axis dampening
  49:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   // http://aeroquad.com/showthread.php?359-Stable-flight-logic...&p=10325&viewfull=1#post10325
  50:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   if (altitudeHoldState == ON) {
 7486              		.loc 28 50 0
 7487 0004 274F     		ldr	r7, .L470
 7488 0006 284C     		ldr	r4, .L470+4
 7489 0008 3B78     		ldrb	r3, [r7, #0]	@ zero_extendqisi2
 7490 000a 284D     		ldr	r5, .L470+8
 7491 000c 012B     		cmp	r3, #1
 7492 000e 44D1     		bne	.L462
 7493              	.LVL363:
 7494              	.LBB230:
  51:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** 
  52:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     int altitudeHoldThrottleCorrection = INVALID_THROTTLE_CORRECTION;
  53:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     // computer altitude error!
  54:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     #if defined AltitudeHoldRangeFinder
  55:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       if (isOnRangerRange(rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX])) {
  56:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         if (sonarAltitudeToHoldTarget == INVALID_RANGE) {
  57:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****           sonarAltitudeToHoldTarget = rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX];
  58:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         }
  59:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         altitudeHoldThrottleCorrection = updatePID(sonarAltitudeToHoldTarget, rangeFinderRange[ALTI
  60:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         altitudeHoldThrottleCorrection = constrain(altitudeHoldThrottleCorrection, minThrottleAdjus
  61:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       }
  62:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     #endif
  63:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     #if defined AltitudeHoldBaro
  64:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       if (altitudeHoldThrottleCorrection == INVALID_THROTTLE_CORRECTION) {
  65:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         altitudeHoldThrottleCorrection = updatePID(baroAltitudeToHoldTarget, getBaroAltitude(), &PI
 7495              		.loc 28 65 0
 7496 0010 274E     		ldr	r6, .L470+12
 7497 0012 FFF7FEFF 		bl	_Z15getBaroAltitudev
 7498 0016 D6F80080 		ldr	r8, [r6, #0]	@ float
 7499 001a 264A     		ldr	r2, .L470+16
 7500 001c 0146     		mov	r1, r0	@ float
 7501 001e 4046     		mov	r0, r8	@ float
 7502 0020 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 7503 0024 00EE100A 		fmsr	s0, r0
  66:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         altitudeHoldThrottleCorrection = constrain(altitudeHoldThrottleCorrection, minThrottleAdjus
 7504              		.loc 28 66 0
 7505 0028 2349     		ldr	r1, .L470+20
  65:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         altitudeHoldThrottleCorrection = updatePID(baroAltitudeToHoldTarget, getBaroAltitude(), &PI
 7506              		.loc 28 65 0
 7507 002a FDEEC07A 		ftosizs	s15, s0
 7508              		.loc 28 66 0
 7509 002e 0B68     		ldr	r3, [r1, #0]
  65:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         altitudeHoldThrottleCorrection = updatePID(baroAltitudeToHoldTarget, getBaroAltitude(), &PI
 7510              		.loc 28 65 0
 7511 0030 17EE900A 		fmrs	r0, s15	@ int
 7512              	.LVL364:
 7513              		.loc 28 66 0
 7514 0034 9842     		cmp	r0, r3
 7515 0036 04DB     		blt	.L463
 7516              		.loc 28 66 0 is_stmt 0 discriminator 2
 7517 0038 204A     		ldr	r2, .L470+24
 7518 003a 1368     		ldr	r3, [r2, #0]
 7519 003c 9842     		cmp	r0, r3
 7520 003e B8BF     		it	lt
 7521 0040 0346     		movlt	r3, r0
 7522              	.L463:
 7523              	.LVL365:
  67:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       }
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     #endif        
  69:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     if (altitudeHoldThrottleCorrection == INVALID_THROTTLE_CORRECTION) {
 7524              		.loc 28 69 0 is_stmt 1 discriminator 6
 7525 0042 13F57A7F 		cmn	r3, #1000
 7526 0046 28D0     		beq	.L462
 7527              	.L464:
  70:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       throttle = receiverCommand[THROTTLE];
  71:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       return;
  72:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     }
  73:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     if (abs(altitudeHoldThrottle - receiverCommand[THROTTLE]) > altitudeHoldPanicStickMovement) {
 7528              		.loc 28 74 0
 7529 0048 1D49     		ldr	r1, .L470+28
 7530 004a 1E48     		ldr	r0, .L470+32
 7531 004c 0A68     		ldr	r2, [r1, #0]
 7532 004e E968     		ldr	r1, [r5, #12]
 7533 0050 0068     		ldr	r0, [r0, #0]
 7534 0052 551A     		subs	r5, r2, r1
 7535 0054 002D     		cmp	r5, #0
 7536 0056 B8BF     		it	lt
 7537 0058 6D42     		rsblt	r5, r5, #0
 7538 005a 8542     		cmp	r5, r0
 7539 005c 02DD     		ble	.L466
  75:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       altitudeHoldState = ALTPANIC; // too rapid of stick movement so PANIC out of ALTHOLD
 7540              		.loc 28 75 0
 7541 005e 0220     		movs	r0, #2
 7542 0060 3870     		strb	r0, [r7, #0]
 7543 0062 18E0     		b	.L467
 7544              	.L466:
  76:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     } 
  77:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     else {
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       
  79:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       if (receiverCommand[THROTTLE] > (altitudeHoldThrottle + altitudeHoldBump)) { // AKA changed t
 7545              		.loc 28 79 0
 7546 0064 184D     		ldr	r5, .L470+36
 7547 0066 2868     		ldr	r0, [r5, #0]
 7548 0068 1518     		adds	r5, r2, r0
 7549 006a A942     		cmp	r1, r5
 7550 006c 07DD     		ble	.L468
  80:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         #if defined AltitudeHoldBaro
  81:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****           baroAltitudeToHoldTarget += ALTITUDE_BUMP_SPEED;
 7551              		.loc 28 81 0
 7552 006e 96ED007A 		flds	s14, [r6, #0]
 7553 0072 9FED161A 		flds	s2, .L470+40
 7554 0076 77EE010A 		fadds	s1, s14, s2
 7555 007a C6ED000A 		fsts	s1, [r6, #0]
 7556              	.L468:
  82:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         #endif
  83:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         #if defined AltitudeHoldRangeFinder
  84:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****           float newalt = sonarAltitudeToHoldTarget + ALTITUDE_BUMP_SPEED;
  85:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****           if (isOnRangerRange(newalt)) {
  86:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****             sonarAltitudeToHoldTarget = newalt;
  87:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****           }
  88:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         #endif
  89:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       }
  90:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       
  91:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       if (receiverCommand[THROTTLE] < (altitudeHoldThrottle - altitudeHoldBump)) { // AKA change to
 7557              		.loc 28 91 0
 7558 007e C0EB020C 		rsb	ip, r0, r2
 7559 0082 6145     		cmp	r1, ip
 7560 0084 07DA     		bge	.L467
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         #if defined AltitudeHoldBaro
  93:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****           baroAltitudeToHoldTarget -= ALTITUDE_BUMP_SPEED;
 7561              		.loc 28 93 0
 7562 0086 D6ED002A 		flds	s5, [r6, #0]
 7563 008a 9FED102A 		flds	s4, .L470+40
 7564 008e 72EEC21A 		fsubs	s3, s5, s4
 7565 0092 C6ED001A 		fsts	s3, [r6, #0]
 7566              	.L467:
  94:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         #endif
  95:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         #if defined AltitudeHoldRangeFinder
  96:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****           float newalt = sonarAltitudeToHoldTarget - ALTITUDE_BUMP_SPEED;
  97:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****           if (isOnRangerRange(newalt)) {
  98:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****             sonarAltitudeToHoldTarget = newalt;
  99:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****           }
 100:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         #endif
 101:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       }
 102:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     }
 103:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     throttle = altitudeHoldThrottle + altitudeHoldThrottleCorrection;// + zDampeningThrottleCorrect
 7567              		.loc 28 103 0
 7568 0096 D318     		adds	r3, r2, r3
 7569              	.LVL366:
 7570 0098 00E0     		b	.L469
 7571              	.L462:
 7572              	.LBE230:
 104:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   }
 105:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   else {
 106:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     throttle = receiverCommand[THROTTLE];
 7573              		.loc 28 106 0
 7574 009a EB68     		ldr	r3, [r5, #12]
 7575              	.L469:
 7576 009c 2360     		str	r3, [r4, #0]
 7577 009e BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 7578              	.L471:
 7579 00a2 00BF     		.align	2
 7580              	.L470:
 7581 00a4 00000000 		.word	.LANCHOR5
 7582 00a8 00000000 		.word	.LANCHOR106
 7583 00ac 00000000 		.word	.LANCHOR6
 7584 00b0 00000000 		.word	.LANCHOR123
 7585 00b4 E0000000 		.word	.LANCHOR17+224
 7586 00b8 00000000 		.word	.LANCHOR124
 7587 00bc 00000000 		.word	.LANCHOR125
 7588 00c0 00000000 		.word	.LANCHOR7
 7589 00c4 00000000 		.word	.LANCHOR126
 7590 00c8 00000000 		.word	.LANCHOR8
 7591 00cc 0AD7233C 		.word	1008981770
 7592              	.LBE229:
 7593              		.cfi_endproc
 7594              	.LFE234:
 7596              		.section	.text._Z20calculateFlightErrorv,"ax",%progbits
 7597              		.align	1
 7598              		.global	_Z20calculateFlightErrorv
 7599              		.thumb
 7600              		.thumb_func
 7602              	_Z20calculateFlightErrorv:
 7603              	.LFB235:
 7604              		.file 29 "C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad/FlightControlProcessor.h"
   1:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** /*
   2:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   AeroQuad v3.0.1 - February 2012
   3:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   www.AeroQuad.com
   4:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   An Open Source Arduino based multicopter.
   6:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  
   7:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   This program is free software: you can redistribute it and/or modify 
   8:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   it under the terms of the GNU General Public License as published by 
   9:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   (at your option) any later version. 
  11:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  
  12:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   This program is distributed in the hope that it will be useful, 
  13:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   GNU General Public License for more details. 
  16:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  
  17:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   You should have received a copy of the GNU General Public License 
  18:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** */
  20:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
  21:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** // FlightControl.pde is responsible for combining sensor measurements and
  22:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** // transmitter commands into motor commands for the defined flight configuration (X, +, etc.)
  23:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
  24:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
  25:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** #ifndef _AQ_PROCESS_FLIGHT_CONTROL_H_
  26:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** #define _AQ_PROCESS_FLIGHT_CONTROL_H_
  27:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
  28:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** #define ATTITUDE_SCALING (0.75 * PWM2RAD)
  29:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
  30:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
  31:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** /**
  32:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * calculateFlightError
  33:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  *
  34:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * Calculate roll/pitch axis error with gyro/accel data to
  35:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * compute motor command thrust so used command are executed
  36:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  */
  37:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** void calculateFlightError()
  38:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** {
 7605              		.loc 29 38 0
 7606              		.cfi_startproc
 7607              		@ args = 0, pretend = 0, frame = 0
 7608              		@ frame_needed = 0, uses_anonymous_args = 0
 7609 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, sl, lr}
 7610              	.LCFI79:
 7611              		.cfi_def_cfa_offset 32
 7612              		.cfi_offset 14, -4
 7613              		.cfi_offset 10, -8
 7614              		.cfi_offset 9, -12
 7615              		.cfi_offset 8, -16
 7616              		.cfi_offset 7, -20
 7617              		.cfi_offset 6, -24
 7618              		.cfi_offset 5, -28
 7619              		.cfi_offset 4, -32
 7620 0004 2DED028B 		fstmfdd	sp!, {d8}
 7621              	.LCFI80:
 7622              		.cfi_def_cfa_offset 40
 7623              		.cfi_offset 80, -40
 7624              	.LBB231:
  39:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #if defined (UseGPSNavigator)
  40:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     if (navigationState == ON || positionHoldState == ON) {
  41:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       float rollAttitudeCmd  = updatePID((receiverCommand[XAXIS] - receiverZero[XAXIS] + gpsRollAxi
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       float pitchAttitudeCmd = updatePID((receiverCommand[YAXIS] - receiverZero[YAXIS] + gpsPitchAx
  43:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorAxisCommandRoll   = updatePID(rollAttitudeCmd, gyroRate[XAXIS], &PID[ATTITUDE_GYRO_XAXIS
  44:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorAxisCommandPitch  = updatePID(pitchAttitudeCmd, -gyroRate[YAXIS], &PID[ATTITUDE_GYRO_YAX
  45:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
  46:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     else
  47:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #endif
  48:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if (flightMode == ATTITUDE_FLIGHT_MODE) {
 7625              		.loc 29 48 0
 7626 0008 3D48     		ldr	r0, .L475
 7627 000a 3E4C     		ldr	r4, .L475+4
 7628 000c 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 7629 000e 3E4E     		ldr	r6, .L475+8
 7630 0010 3E4D     		ldr	r5, .L475+12
 7631 0012 012B     		cmp	r3, #1
 7632 0014 46D1     		bne	.L473
 7633              	.LBB232:
  49:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     float rollAttitudeCmd  = updatePID((receiverCommand[XAXIS] - receiverZero[XAXIS]) * ATTITUDE_SC
 7634              		.loc 29 49 0
 7635 0016 DFF81C91 		ldr	r9, .L475+52
 7636 001a DFF81C81 		ldr	r8, .L475+56
 7637 001e D9F80020 		ldr	r2, [r9, #0]
 7638 0022 D8F80070 		ldr	r7, [r8, #0]
 7639 0026 D11B     		subs	r1, r2, r7
 7640 0028 03EE101A 		fmsr	s6, r1	@ int
 7641 002c 9FED388A 		flds	s16, .L475+16
 7642 0030 F8EEC32A 		fsitos	s5, s6
 7643 0034 374F     		ldr	r7, .L475+20
 7644 0036 384A     		ldr	r2, .L475+24
 7645 0038 3968     		ldr	r1, [r7, #0]	@ float
 7646 003a 22EE882A 		fmuls	s4, s5, s16
 7647 003e 12EE100A 		fmrs	r0, s4
 7648 0042 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
  50:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     float pitchAttitudeCmd = updatePID((receiverCommand[YAXIS] - receiverZero[YAXIS]) * ATTITUDE_SC
 7649              		.loc 29 50 0
 7650 0046 D8F80430 		ldr	r3, [r8, #4]
 7651 004a 7A68     		ldr	r2, [r7, #4]	@ float
  49:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     float rollAttitudeCmd  = updatePID((receiverCommand[XAXIS] - receiverZero[XAXIS]) * ATTITUDE_SC
 7652              		.loc 29 49 0
 7653 004c 8246     		mov	sl, r0	@ float
 7654              	.LVL367:
 7655              		.loc 29 50 0
 7656 004e D9F80400 		ldr	r0, [r9, #4]
 7657              	.LVL368:
 7658 0052 C3EB000C 		rsb	ip, r3, r0
 7659 0056 01EE90CA 		fmsr	s3, ip	@ int
 7660 005a B8EEE11A 		fsitos	s2, s3
 7661 005e 82F00041 		eor	r1, r2, #-2147483648
 7662 0062 21EE087A 		fmuls	s14, s2, s16
 7663 0066 2D4A     		ldr	r2, .L475+28
 7664 0068 17EE100A 		fmrs	r0, s14
 7665 006c FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
  51:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorAxisCommandRoll   = updatePID(rollAttitudeCmd, gyroRate[XAXIS], &PID[ATTITUDE_GYRO_XAXIS_P
 7666              		.loc 29 51 0
 7667 0070 2168     		ldr	r1, [r4, #0]	@ float
 7668 0072 2B4A     		ldr	r2, .L475+32
  50:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     float pitchAttitudeCmd = updatePID((receiverCommand[YAXIS] - receiverZero[YAXIS]) * ATTITUDE_SC
 7669              		.loc 29 50 0
 7670 0074 0746     		mov	r7, r0	@ float
 7671              	.LVL369:
 7672              		.loc 29 51 0
 7673 0076 5046     		mov	r0, sl	@ float
 7674              	.LVL370:
 7675 0078 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 7676 007c 00EE900A 		fmsr	s1, r0
  52:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorAxisCommandPitch  = updatePID(pitchAttitudeCmd, -gyroRate[YAXIS], &PID[ATTITUDE_GYRO_YAXIS
 7677              		.loc 29 52 0
 7678 0080 6168     		ldr	r1, [r4, #4]	@ float
 7679 0082 284A     		ldr	r2, .L475+36
  51:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorAxisCommandRoll   = updatePID(rollAttitudeCmd, gyroRate[XAXIS], &PID[ATTITUDE_GYRO_XAXIS_P
 7680              		.loc 29 51 0
 7681 0084 FDEEE07A 		ftosizs	s15, s1
 7682              		.loc 29 52 0
 7683 0088 3846     		mov	r0, r7	@ float
 7684 008a 81F00041 		eor	r1, r1, #-2147483648
  51:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorAxisCommandRoll   = updatePID(rollAttitudeCmd, gyroRate[XAXIS], &PID[ATTITUDE_GYRO_XAXIS_P
 7685              		.loc 29 51 0
 7686 008e C6ED007A 		fsts	s15, [r6, #0]	@ int
 7687              		.loc 29 52 0
 7688 0092 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 7689 0096 00EE100A 		fmsr	s0, r0
 7690 009a FDEEC06A 		ftosizs	s13, s0
 7691 009e C5ED006A 		fsts	s13, [r5, #0]	@ int
 7692 00a2 28E0     		b	.L472
 7693              	.LVL371:
 7694              	.L473:
 7695              	.LBE232:
  53:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
  54:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   else {
  55:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorAxisCommandRoll = updatePID(getReceiverSIData(XAXIS), gyroRate[XAXIS]*rotationSpeedFactor,
 7696              		.loc 29 55 0
 7697 00a4 204F     		ldr	r7, .L475+40
 7698 00a6 0020     		movs	r0, #0
 7699 00a8 FFF7FEFF 		bl	_Z17getReceiverSIDatah
 7700 00ac D4ED000A 		flds	s1, [r4, #0]
 7701 00b0 D7ED007A 		flds	s15, [r7, #0]
 7702 00b4 20EEA70A 		fmuls	s0, s1, s15
 7703 00b8 1C4A     		ldr	r2, .L475+44
 7704 00ba 10EE101A 		fmrs	r1, s0
 7705 00be FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 7706 00c2 06EE900A 		fmsr	s13, r0
 7707 00c6 BDEEE66A 		ftosizs	s12, s13
  56:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorAxisCommandPitch = updatePID(getReceiverSIData(YAXIS), -gyroRate[YAXIS]*rotationSpeedFacto
 7708              		.loc 29 56 0
 7709 00ca 0120     		movs	r0, #1
  55:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorAxisCommandRoll = updatePID(getReceiverSIData(XAXIS), gyroRate[XAXIS]*rotationSpeedFactor,
 7710              		.loc 29 55 0
 7711 00cc 86ED006A 		fsts	s12, [r6, #0]	@ int
 7712              		.loc 29 56 0
 7713 00d0 FFF7FEFF 		bl	_Z17getReceiverSIDatah
 7714 00d4 94ED015A 		flds	s10, [r4, #4]
 7715 00d8 D7ED005A 		flds	s11, [r7, #0]
 7716 00dc 65EE654A 		fnmuls	s9, s10, s11
 7717 00e0 134A     		ldr	r2, .L475+48
 7718 00e2 14EE901A 		fmrs	r1, s9
 7719 00e6 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 7720 00ea 04EE100A 		fmsr	s8, r0
 7721 00ee FDEEC43A 		ftosizs	s7, s8
 7722 00f2 C5ED003A 		fsts	s7, [r5, #0]	@ int
 7723              	.L472:
 7724              	.LBE231:
  57:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
  58:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** }
 7725              		.loc 29 58 0
 7726 00f6 BDEC028B 		fldmfdd	sp!, {d8}
 7727 00fa BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, sl, pc}
 7728              	.L476:
 7729 00fe 00BF     		.align	2
 7730              	.L475:
 7731 0100 00000000 		.word	.LANCHOR120
 7732 0104 00000000 		.word	.LANCHOR27
 7733 0108 00000000 		.word	.LANCHOR108
 7734 010c 00000000 		.word	.LANCHOR107
 7735 0110 A69BC43A 		.word	985963430
 7736 0114 00000000 		.word	.LANCHOR42
 7737 0118 54000000 		.word	.LANCHOR17+84
 7738 011c 70000000 		.word	.LANCHOR17+112
 7739 0120 A8000000 		.word	.LANCHOR17+168
 7740 0124 C4000000 		.word	.LANCHOR17+196
 7741 0128 00000000 		.word	.LANCHOR127
 7742 012c 00000000 		.word	.LANCHOR17
 7743 0130 1C000000 		.word	.LANCHOR17+28
 7744 0134 00000000 		.word	.LANCHOR6
 7745 0138 00000000 		.word	.LANCHOR11
 7746              		.cfi_endproc
 7747              	.LFE235:
 7749              		.section	.text._Z19processCalibrateESCv,"ax",%progbits
 7750              		.align	1
 7751              		.global	_Z19processCalibrateESCv
 7752              		.thumb
 7753              		.thumb_func
 7755              	_Z19processCalibrateESCv:
 7756              	.LFB236:
  59:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
  60:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** /**
  61:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * processCalibrateESC
  62:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * 
  63:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * Proces esc calibration command with the help of the configurator
  64:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  */
  65:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** void processCalibrateESC()
  66:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** {
 7757              		.loc 29 66 0
 7758              		.cfi_startproc
 7759              		@ args = 0, pretend = 0, frame = 0
 7760              		@ frame_needed = 0, uses_anonymous_args = 0
 7761              		@ link register save eliminated.
 7762              	.LBB233:
 7763              	.LBB234:
  67:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   switch (calibrateESC) { // used for calibrating ESC's
 7764              		.loc 29 67 0
 7765 0000 1B4B     		ldr	r3, .L491
 7766 0002 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 7767 0004 1B4B     		ldr	r3, .L491+4
 7768 0006 032A     		cmp	r2, #3
 7769 0008 0CD0     		beq	.L480
 7770 000a 052A     		cmp	r2, #5
 7771 000c 19D0     		beq	.L486
 7772 000e 012A     		cmp	r2, #1
 7773              	.LVL372:
 7774              	.LBB235:
 7775              	.LBB236:
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   case 1:
  69:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++)
  70:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = MAXCOMMAND;
 7776              		.loc 29 70 0
 7777 0010 0CBF     		ite	eq
 7778 0012 4FF4FA62 		moveq	r2, #2000
 7779              	.LVL373:
 7780              	.LBE236:
 7781              	.LBB237:
  71:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     break;
  72:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   case 3:
  73:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++)
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = constrain(testCommand, 1000, 1200);
  75:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     break;
  76:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   case 5:
  77:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++)
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
  79:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     safetyCheck = ON;
  80:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     break;
  81:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   default:
  82:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++)
  83:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = MINCOMMAND;
 7782              		.loc 29 83 0
 7783 0016 4FF47A72 		movne	r2, #1000
 7784              	.LVL374:
 7785              	.L490:
 7786              		.loc 29 83 0 is_stmt 0 discriminator 1
 7787 001a 1A60     		str	r2, [r3, #0]
 7788              	.LVL375:
 7789 001c 5A60     		str	r2, [r3, #4]
 7790              	.LVL376:
 7791 001e 9A60     		str	r2, [r3, #8]
 7792              	.LVL377:
 7793 0020 DA60     		str	r2, [r3, #12]
 7794              	.LVL378:
 7795 0022 23E0     		b	.L482
 7796              	.LVL379:
 7797              	.L480:
 7798              	.LBE237:
 7799              	.LBB238:
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = constrain(testCommand, 1000, 1200);
 7800              		.loc 29 74 0 is_stmt 1
 7801 0024 1448     		ldr	r0, .L491+8
 7802 0026 0268     		ldr	r2, [r0, #0]
 7803 0028 B2F5966F 		cmp	r2, #1200
 7804 002c B4BF     		ite	lt
 7805 002e 1146     		movlt	r1, r2
 7806 0030 4FF49661 		movge	r1, #1200
 7807 0034 B2F57A7F 		cmp	r2, #1000
 7808 0038 ACBF     		ite	ge
 7809 003a 0A46     		movge	r2, r1
 7810 003c 4FF47A72 		movlt	r2, #1000
 7811 0040 EBE7     		b	.L490
 7812              	.L486:
 7813              	.LBE238:
 7814              	.LBE235:
  67:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   switch (calibrateESC) { // used for calibrating ESC's
 7815              		.loc 29 67 0
 7816 0042 0022     		movs	r2, #0
 7817              	.L481:
 7818              	.LBB240:
 7819              	.LBB239:
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
 7820              		.loc 29 78 0
 7821 0044 0D49     		ldr	r1, .L491+12
 7822 0046 5158     		ldr	r1, [r2, r1]
 7823 0048 B1F57A7F 		cmp	r1, #1000
 7824 004c 05DB     		blt	.L487
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
 7825              		.loc 29 78 0 is_stmt 0 discriminator 1
 7826 004e B1F5966F 		cmp	r1, #1200
 7827 0052 A8BF     		it	ge
 7828 0054 4FF49661 		movge	r1, #1200
 7829 0058 01E0     		b	.L485
 7830              	.L487:
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
 7831              		.loc 29 78 0
 7832 005a 4FF47A71 		mov	r1, #1000
 7833              	.L485:
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
 7834              		.loc 29 78 0 discriminator 3
 7835 005e 9950     		str	r1, [r3, r2]
 7836 0060 0432     		adds	r2, r2, #4
  77:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++)
 7837              		.loc 29 77 0 is_stmt 1 discriminator 3
 7838 0062 102A     		cmp	r2, #16
 7839 0064 EED1     		bne	.L481
 7840              	.LBE239:
  79:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     safetyCheck = ON;
 7841              		.loc 29 79 0
 7842 0066 064B     		ldr	r3, .L491+16
 7843 0068 0122     		movs	r2, #1
 7844 006a 1A70     		strb	r2, [r3, #0]
 7845              	.LVL380:
 7846              	.L482:
 7847              	.LBE240:
 7848              	.LBE234:
 7849              	.LBE233:
  84:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
  85:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // Send calibration commands to motors
  86:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   writeMotors(); // Defined in Motors.h
  87:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** }
 7850              		.loc 29 87 0
 7851              	.LBB241:
  86:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   writeMotors(); // Defined in Motors.h
 7852              		.loc 29 86 0
 7853 006c FFF7FEBF 		b	_Z11writeMotorsv
 7854              	.L492:
 7855              		.align	2
 7856              	.L491:
 7857 0070 00000000 		.word	.LANCHOR128
 7858 0074 00000000 		.word	.LANCHOR63
 7859 0078 00000000 		.word	.LANCHOR129
 7860 007c 00000000 		.word	.LANCHOR130
 7861 0080 00000000 		.word	.LANCHOR131
 7862              	.LBE241:
 7863              		.cfi_endproc
 7864              	.LFE236:
 7866              		.section	.text._Z25processThrottleCorrectionv,"ax",%progbits
 7867              		.align	1
 7868              		.global	_Z25processThrottleCorrectionv
 7869              		.thumb
 7870              		.thumb_func
 7872              	_Z25processThrottleCorrectionv:
 7873              	.LFB237:
  88:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
  89:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** /**
  90:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * processBatteryMonitorThrottleAdjustment
  91:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  *
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * Check battery alarm and if in alarm, increment a counter
  93:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * When this counter reach BATTERY_MONITOR_MAX_ALARM_COUNT, then
  94:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * we are now in auto-descent mode.
  95:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  *
  96:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * When in auto-descent mode, the user can pass throttle keep when the
  97:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * alarm was reach, and the throttle is slowly decrease for a minute til
  98:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * batteryMonitorThrottle that is configurable with the configurator
  99:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  */
 100:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** #if defined BattMonitor && defined BattMonitorAutoDescent
 101:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   void processBatteryMonitorThrottleAdjustment() {
 102:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     
 103:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     if (batteryMonitorAlarmCounter < BATTERY_MONITOR_MAX_ALARM_COUNT) {
 104:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       if (batteryAlarm) {
 105:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         batteryMonitorAlarmCounter++;
 106:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       }
 107:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
 108:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     else {
 109:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 110:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         if (altitudeHoldState == ON) {
 111:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           #if defined AltitudeHoldBaro
 112:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             baroAltitudeToHoldTarget -= 0.01;
 113:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           #endif
 114:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           #if defined AltitudeHoldRangeFinder
 115:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             if (sonarAltitudeToHoldTarget != INVALID_RANGE) {
 116:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****               sonarAltitudeToHoldTarget -= 0.01;
 117:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             }
 118:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           #endif
 119:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         }
 120:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         else {
 121:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       #endif
 122:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           if (batteryMonitorStartThrottle == 0) {  // init battery monitor throttle correction!
 123:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             batteryMonitorStartTime = millis();
 124:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             if (throttle < batteryMonitorThrottleTarget) {
 125:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****               batteryMonitorStartThrottle = batteryMonitorThrottleTarget;
 126:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             }
 127:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             else {
 128:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****               batteryMonitorStartThrottle = throttle; 
 129:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             }
 130:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           }
 131:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           int batteryMonitorThrottle = map(millis()-batteryMonitorStartTime, 0, batteryMonitorGoing
 132:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           if (batteryMonitorThrottle < batteryMonitorThrottleTarget) {
 133:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             batteryMonitorThrottle = batteryMonitorThrottleTarget;
 134:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           }
 135:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           if (throttle < batteryMonitorThrottle) {
 136:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             batteyMonitorThrottleCorrection = 0;
 137:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           }
 138:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           else {
 139:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             batteyMonitorThrottleCorrection = batteryMonitorThrottle - throttle;
 140:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           }
 141:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 142:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         }
 143:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       #endif
 144:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
 145:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 146:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** #endif  
 147:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 148:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 149:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** #if defined AutoLanding
 150:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #define BARO_AUTO_LANDING_DESCENT_SPEED 0.008
 151:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #define SONAR_AUTO_LANDING_DESCENT_SPEED 0.005
 152:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   void processAutoLandingAltitudeCorrection() {
 153:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     if (autoLandingState != OFF) {   
 154:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 155:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       if (autoLandingState == BARO_AUTO_DESCENT_STATE) {
 156:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         baroAltitudeToHoldTarget -= BARO_AUTO_LANDING_DESCENT_SPEED;
 157:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         if (isOnRangerRange(rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX])) { 
 158:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           autoLandingState = SONAR_AUTO_DESCENT_STATE;
 159:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         }
 160:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       }
 161:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       else if (autoLandingState == SONAR_AUTO_DESCENT_STATE) {
 162:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         baroAltitudeToHoldTarget -= BARO_AUTO_LANDING_DESCENT_SPEED;
 163:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         sonarAltitudeToHoldTarget -= SONAR_AUTO_LANDING_DESCENT_SPEED;
 164:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         if (rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX] < 0.5) {
 165:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           autoLandingState = MOTOR_AUTO_DESCENT_STATE;
 166:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         }
 167:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       }
 168:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       else {
 169:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         autoLandingThrottleCorrection -= 1;
 170:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         baroAltitudeToHoldTarget -= BARO_AUTO_LANDING_DESCENT_SPEED;
 171:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         sonarAltitudeToHoldTarget -= SONAR_AUTO_LANDING_DESCENT_SPEED;
 172:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 173:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         if (((throttle + autoLandingThrottleCorrection) < 1000) || (rangeFinderRange[ALTITUDE_RANGE
 174:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           commandAllMotors(MINCOMMAND);
 175:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           motorArmed = OFF;
 176:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         }
 177:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       }
 178:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
 179:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  }
 180:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** #endif
 181:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 182:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 183:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** /**
 184:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * processThrottleCorrection
 185:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * 
 186:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * This function will add some throttle imput if the craft is angled
 187:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * this prevent the craft to loose altitude when angled.
 188:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * it also add the battery throttle correction in case
 189:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * of we are in auto-descent.
 190:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * 
 191:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * Special thank to Ziojo for this.
 192:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  */
 193:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** void processThrottleCorrection() {
 7874              		.loc 29 193 0
 7875              		.cfi_startproc
 7876              		@ args = 0, pretend = 0, frame = 0
 7877              		@ frame_needed = 0, uses_anonymous_args = 0
 7878              		@ link register save eliminated.
 7879              	.LVL381:
 7880              	.LBB242:
 194:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  
 195:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   int throttleAdjust = 0;
 196:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #if defined UseGPSNavigator
 197:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     if (navigationState == ON || positionHoldState == ON) {
 198:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       throttleAdjust = throttle / (cos (kinematicsAngle[XAXIS]*0.55) * cos (kinematicsAngle[YAXIS]*
 199:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       throttleAdjust = constrain ((throttleAdjust - throttle), 0, 50); //compensate max  +/- 25 deg
 200:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
 201:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #endif
 202:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #if defined BattMonitorAutoDescent
 203:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     throttleAdjust += batteyMonitorThrottleCorrection;
 204:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #endif
 205:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #if defined (AutoLanding)
 206:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #if defined BattMonitorAutoDescent
 207:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       if (batteyMonitorThrottleCorrection != 0) { // don't auto land in the same time that the batt
 208:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         throttleAdjust += autoLandingThrottleCorrection;
 209:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       }
 210:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #else
 211:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       throttleAdjust += autoLandingThrottleCorrection;
 212:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #endif
 213:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #endif
 214:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   
 215:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   throttle = constrain((throttle + throttleAdjust),MINCOMMAND,MAXCOMMAND-150);  // limmit throttle 
 7881              		.loc 29 215 0
 7882 0000 074A     		ldr	r2, .L496
 7883 0002 1368     		ldr	r3, [r2, #0]
 7884 0004 B3F57A7F 		cmp	r3, #1000
 7885 0008 05DB     		blt	.L495
 7886              		.loc 29 215 0 is_stmt 0 discriminator 1
 7887 000a 40F23A71 		movw	r1, #1850
 7888 000e 8B42     		cmp	r3, r1
 7889 0010 A8BF     		it	ge
 7890 0012 0B46     		movge	r3, r1
 7891 0014 01E0     		b	.L494
 7892              	.L495:
 7893              		.loc 29 215 0
 7894 0016 4FF47A73 		mov	r3, #1000
 7895              	.L494:
 7896              		.loc 29 215 0 discriminator 3
 7897 001a 1360     		str	r3, [r2, #0]
 7898              	.LBE242:
 216:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** }
 7899              		.loc 29 216 0 is_stmt 1 discriminator 3
 7900 001c 7047     		bx	lr
 7901              	.L497:
 7902 001e 00BF     		.align	2
 7903              	.L496:
 7904 0020 00000000 		.word	.LANCHOR106
 7905              		.cfi_endproc
 7906              	.LFE237:
 7908              		.section	.text._Z20processHardManueversv,"ax",%progbits
 7909              		.align	1
 7910              		.global	_Z20processHardManueversv
 7911              		.thumb
 7912              		.thumb_func
 7914              	_Z20processHardManueversv:
 7915              	.LFB238:
 217:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 218:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 219:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** /**
 220:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * processHardManuevers
 221:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  *
 222:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * In case of a roll/pitch stick at one edge to do a loop, this function
 223:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * will prevent the lower throttle motor side to have too much low throtte.
 224:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  */
 225:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** void processHardManuevers() {
 7916              		.loc 29 225 0
 7917              		.cfi_startproc
 7918              		@ args = 0, pretend = 0, frame = 0
 7919              		@ frame_needed = 0, uses_anonymous_args = 0
 7920              		@ link register save eliminated.
 7921              	.LBB243:
 226:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   
 227:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if ((receiverCommand[XAXIS] < MINCHECK) ||
 7922              		.loc 29 227 0
 7923 0000 0F4A     		ldr	r2, .L504
 7924 0002 1068     		ldr	r0, [r2, #0]
 7925 0004 A0F58863 		sub	r3, r0, #1088
 7926 0008 0C3B     		subs	r3, r3, #12
 7927 000a B3F5487F 		cmp	r3, #800
 7928 000e 04D8     		bhi	.L499
 228:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       (receiverCommand[XAXIS] > MAXCHECK) ||
 229:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       (receiverCommand[YAXIS] < MINCHECK) ||
 7929              		.loc 29 229 0 discriminator 1
 7930 0010 5368     		ldr	r3, [r2, #4]
 227:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if ((receiverCommand[XAXIS] < MINCHECK) ||
 7931              		.loc 29 227 0 discriminator 1
 7932 0012 40F24B42 		movw	r2, #1099
 7933 0016 9342     		cmp	r3, r2
 7934 0018 03DC     		bgt	.L500
 7935              	.L499:
 7936              	.LBB244:
 230:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       (receiverCommand[YAXIS] > MAXCHECK)) {  
 231:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         
 232:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (int motor = 0; motor < LASTMOTOR; motor++) {
 233:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 7937              		.loc 29 233 0 discriminator 2
 7938 001a 0A49     		ldr	r1, .L504+4
 7939 001c 0023     		movs	r3, #0
 7940 001e 0A68     		ldr	r2, [r1, #0]
 7941 0020 04E0     		b	.L501
 7942              	.L500:
 7943              	.LBE244:
 227:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if ((receiverCommand[XAXIS] < MINCHECK) ||
 7944              		.loc 29 227 0 discriminator 2
 7945 0022 40F26C70 		movw	r0, #1900
 7946 0026 8342     		cmp	r3, r0
 7947 0028 F7DC     		bgt	.L499
 7948 002a 7047     		bx	lr
 7949              	.L501:
 7950              	.LBB245:
 7951              		.loc 29 233 0 discriminator 2
 7952 002c 0648     		ldr	r0, .L504+8
 234:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorMaxCommand[motor] = MAXCOMMAND;
 7953              		.loc 29 234 0 discriminator 2
 7954 002e 0749     		ldr	r1, .L504+12
 233:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 7955              		.loc 29 233 0 discriminator 2
 7956 0030 1A50     		str	r2, [r3, r0]
 7957              		.loc 29 234 0 discriminator 2
 7958 0032 4FF4FA60 		mov	r0, #2000
 7959 0036 5850     		str	r0, [r3, r1]
 7960 0038 0433     		adds	r3, r3, #4
 232:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (int motor = 0; motor < LASTMOTOR; motor++) {
 7961              		.loc 29 232 0 discriminator 2
 7962 003a 102B     		cmp	r3, #16
 7963 003c F6D1     		bne	.L501
 7964 003e 7047     		bx	lr
 7965              	.L505:
 7966              		.align	2
 7967              	.L504:
 7968 0040 00000000 		.word	.LANCHOR6
 7969 0044 00000000 		.word	.LANCHOR132
 7970 0048 00000000 		.word	.LANCHOR133
 7971 004c 00000000 		.word	.LANCHOR134
 7972              	.LBE245:
 7973              	.LBE243:
 7974              		.cfi_endproc
 7975              	.LFE238:
 7977              		.section	.text._Z20processMinMaxCommandv,"ax",%progbits
 7978              		.align	1
 7979              		.global	_Z20processMinMaxCommandv
 7980              		.thumb
 7981              		.thumb_func
 7983              	_Z20processMinMaxCommandv:
 7984              	.LFB239:
 235:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
 236:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 237:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** }
 238:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 239:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** /**
 240:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * processMinMaxCommand
 241:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  *
 242:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * This function correct too low/max throttle when manuevering
 243:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * preventing some wobbling behavior
 244:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  */
 245:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** void processMinMaxCommand()
 246:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** {
 7985              		.loc 29 246 0
 7986              		.cfi_startproc
 7987              		@ args = 0, pretend = 0, frame = 0
 7988              		@ frame_needed = 0, uses_anonymous_args = 0
 7989              	.LVL382:
 7990              	.LBB246:
 7991              	.LBB247:
 247:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   for (byte motor = 0; motor < LASTMOTOR; motor++)
 248:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   {
 249:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorMinCommand[motor] = minArmedThrottle;
 7992              		.loc 29 249 0
 7993 0000 154A     		ldr	r2, .L510
 250:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorMaxCommand[motor] = MAXCOMMAND;
 7994              		.loc 29 250 0
 7995 0002 164B     		ldr	r3, .L510+4
 249:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorMinCommand[motor] = minArmedThrottle;
 7996              		.loc 29 249 0
 7997 0004 1068     		ldr	r0, [r2, #0]
 7998 0006 1649     		ldr	r1, .L510+8
 7999              		.loc 29 250 0
 8000 0008 4FF4FA62 		mov	r2, #2000
 8001              	.LBE247:
 8002              	.LBE246:
 246:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** {
 8003              		.loc 29 246 0
 8004 000c 10B5     		push	{r4, lr}
 8005              	.LCFI81:
 8006              		.cfi_def_cfa_offset 8
 8007              		.cfi_offset 14, -4
 8008              		.cfi_offset 4, -8
 8009              	.LBB252:
 8010              	.LBB248:
 8011              		.loc 29 250 0
 8012 000e 9A60     		str	r2, [r3, #8]
 8013 0010 DA60     		str	r2, [r3, #12]
 8014 0012 1A60     		str	r2, [r3, #0]
 8015              	.LVL383:
 8016 0014 5A60     		str	r2, [r3, #4]
 8017              	.LVL384:
 8018              	.LBE248:
 251:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 252:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 253:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   int maxMotor = motorCommand[0];
 8019              		.loc 29 253 0
 8020 0016 134B     		ldr	r3, .L510+12
 8021              	.LBB249:
 249:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorMinCommand[motor] = minArmedThrottle;
 8022              		.loc 29 249 0
 8023 0018 0860     		str	r0, [r1, #0]
 8024 001a 4860     		str	r0, [r1, #4]
 8025 001c 8860     		str	r0, [r1, #8]
 8026 001e C860     		str	r0, [r1, #12]
 8027              	.LBE249:
 8028              		.loc 29 253 0
 8029 0020 93E80600 		ldmia	r3, {r1, r2}
 8030 0024 9868     		ldr	r0, [r3, #8]
 8031 0026 9142     		cmp	r1, r2
 8032 0028 B8BF     		it	lt
 8033 002a 1146     		movlt	r1, r2
 8034              	.LVL385:
 8035 002c DA68     		ldr	r2, [r3, #12]
 8036 002e 8142     		cmp	r1, r0
 8037 0030 B8BF     		it	lt
 8038 0032 0146     		movlt	r1, r0
 8039              	.LVL386:
 8040 0034 9142     		cmp	r1, r2
 8041 0036 B8BF     		it	lt
 8042 0038 1146     		movlt	r1, r2
 8043              	.LVL387:
 8044              	.LBB250:
 254:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   
 255:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   for (byte motor=1; motor < LASTMOTOR; motor++) {
 256:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     if (motorCommand[motor] > maxMotor) {
 8045              		.loc 29 256 0
 8046 003a 0022     		movs	r2, #0
 8047              	.LVL388:
 8048              	.L508:
 8049              	.LBE250:
 8050              	.LBB251:
 257:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       maxMotor = motorCommand[motor];
 258:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
 259:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 260:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     
 261:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   for (byte motor = 0; motor < LASTMOTOR; motor++) {
 262:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     if (maxMotor > MAXCOMMAND) {
 8051              		.loc 29 262 0
 8052 003c B1F5FA6F 		cmp	r1, #2000
 8053 0040 05DD     		ble	.L507
 263:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] =  motorCommand[motor] - (maxMotor - MAXCOMMAND);
 8054              		.loc 29 263 0
 8055 0042 9C58     		ldr	r4, [r3, r2]
 8056 0044 C1F5FA6C 		rsb	ip, r1, #2000
 8057 0048 04EB0C00 		add	r0, r4, ip
 8058 004c 9850     		str	r0, [r3, r2]
 8059              	.L507:
 8060 004e 0432     		adds	r2, r2, #4
 261:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   for (byte motor = 0; motor < LASTMOTOR; motor++) {
 8061              		.loc 29 261 0
 8062 0050 102A     		cmp	r2, #16
 8063 0052 F3D1     		bne	.L508
 8064              	.LBE251:
 8065              	.LBE252:
 264:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
 265:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 266:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** }
 8066              		.loc 29 266 0
 8067 0054 10BD     		pop	{r4, pc}
 8068              	.L511:
 8069 0056 00BF     		.align	2
 8070              	.L510:
 8071 0058 00000000 		.word	.LANCHOR132
 8072 005c 00000000 		.word	.LANCHOR134
 8073 0060 00000000 		.word	.LANCHOR133
 8074 0064 00000000 		.word	.LANCHOR63
 8075              		.cfi_endproc
 8076              	.LFE239:
 8078              		.section	.text._Z14processHeadingv,"ax",%progbits
 8079              		.align	1
 8080              		.global	_Z14processHeadingv
 8081              		.thumb
 8082              		.thumb_func
 8084              	_Z14processHeadingv:
 8085              	.LFB242:
 8086              		.file 30 "C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h"
   1:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** /*
   2:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   AeroQuad v3.0.1 - February 2012
   3:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   www.AeroQuad.com
   4:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   An Open Source Arduino based multicopter.
   6:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  
   7:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   This program is free software: you can redistribute it and/or modify 
   8:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   it under the terms of the GNU General Public License as published by 
   9:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   (at your option) any later version. 
  11:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  
  12:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   This program is distributed in the hope that it will be useful, 
  13:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   GNU General Public License for more details. 
  16:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  
  17:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   You should have received a copy of the GNU General Public License 
  18:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** */
  20:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  21:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  22:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** #ifndef _AQ_HEADING_CONTROL_PROCESSOR_H_
  23:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** #define _AQ_HEADING_CONTROL_PROCESSOR_H_
  24:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  25:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  26:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** float setHeading          = 0;
  27:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** unsigned long headingTime = micros();
  28:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  29:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  30:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** /**
  31:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  * processHeading
  32:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  *
  33:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  * This function will calculate the craft heading correction depending 
  34:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  * of the users command. Heading correction is process with the gyro
  35:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  * or a magnetometer
  36:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  */
  37:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** void processHeading()
  38:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** {
 8087              		.loc 30 38 0
 8088              		.cfi_startproc
 8089              		@ args = 0, pretend = 0, frame = 0
 8090              		@ frame_needed = 0, uses_anonymous_args = 0
 8091 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 8092              	.LCFI82:
 8093              		.cfi_def_cfa_offset 24
 8094              		.cfi_offset 14, -4
 8095              		.cfi_offset 7, -8
 8096              		.cfi_offset 6, -12
 8097              		.cfi_offset 5, -16
 8098              		.cfi_offset 4, -20
 8099              		.cfi_offset 3, -24
 8100              	.LBB253:
  39:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   if (headingHoldConfig == ON) {
 8101              		.loc 30 39 0
 8102 0002 5C48     		ldr	r0, .L533
 8103 0004 5C4E     		ldr	r6, .L533+4
 8104 0006 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 8105 0008 5C4C     		ldr	r4, .L533+8
 8106 000a 012B     		cmp	r3, #1
 8107 000c 7ED1     		bne	.L513
  40:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  41:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     #if defined(HeadingMagHold)
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       heading = degrees(trueNorthHeading);
 8108              		.loc 30 42 0
 8109 000e 5C4A     		ldr	r2, .L533+12
 8110 0010 5C49     		ldr	r1, .L533+16
  43:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     #else
  44:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       heading = degrees(gyroHeading);
  45:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     #endif
  46:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  47:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     // Always center relative heading around absolute heading chosen during yaw command
  48:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     // This assumes that an incorrect yaw can't be forced on the AeroQuad >180 or <-180 degrees
  49:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     // This is done so that AeroQuad does not accidentally hit transition between 0 and 360 or -180
  50:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     // AKA - THERE IS A BUG HERE - if relative heading is greater than 180 degrees, the PID will sw
  51:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     // Doubt that will happen as it would have to be uncommanded.
  52:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     relativeHeading = heading - setHeading;
 8111              		.loc 30 52 0
 8112 0012 5D4B     		ldr	r3, .L533+20
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       heading = degrees(trueNorthHeading);
 8113              		.loc 30 42 0
 8114 0014 92ED007A 		flds	s14, [r2, #0]
 8115 0018 DFED5C7A 		flds	s15, .L533+24
 8116              		.loc 30 52 0
 8117 001c 5C4A     		ldr	r2, .L533+28
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       heading = degrees(trueNorthHeading);
 8118              		.loc 30 42 0
 8119 001e 67EE277A 		fmuls	s15, s14, s15
  53:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     if (heading <= (setHeading - 180)) {
 8120              		.loc 30 53 0
 8121 0022 9FED5C6A 		flds	s12, .L533+32
  52:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     relativeHeading = heading - setHeading;
 8122              		.loc 30 52 0
 8123 0026 92ED007A 		flds	s14, [r2, #0]
 8124              		.loc 30 53 0
 8125 002a 77EE465A 		fsubs	s11, s14, s12
  52:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     relativeHeading = heading - setHeading;
 8126              		.loc 30 52 0
 8127 002e 77EEC76A 		fsubs	s13, s15, s14
 8128              		.loc 30 53 0
 8129 0032 F4EEE57A 		fcmpes	s15, s11
 8130 0036 F1EE10FA 		fmstat
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       heading = degrees(trueNorthHeading);
 8131              		.loc 30 42 0
 8132 003a C1ED007A 		fsts	s15, [r1, #0]
  52:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     relativeHeading = heading - setHeading;
 8133              		.loc 30 52 0
 8134 003e C3ED006A 		fsts	s13, [r3, #0]
 8135              		.loc 30 53 0
 8136 0042 05D8     		bhi	.L514
  54:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       relativeHeading += 360;
 8137              		.loc 30 54 0
 8138 0044 9FED540A 		flds	s0, .L533+36
 8139 0048 76EE806A 		fadds	s13, s13, s0
 8140 004c C3ED006A 		fsts	s13, [r3, #0]
 8141              	.L514:
  55:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     }
  56:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     if (heading >= (setHeading + 180)) {
 8142              		.loc 30 56 0
 8143 0050 77EE060A 		fadds	s1, s14, s12
 8144 0054 F4EEE07A 		fcmpes	s15, s1
 8145 0058 F1EE10FA 		fmstat
 8146 005c 07DB     		blt	.L516
  57:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       relativeHeading -= 360;
 8147              		.loc 30 57 0
 8148 005e 93ED002A 		flds	s4, [r3, #0]
 8149 0062 DFED4D1A 		flds	s3, .L533+36
 8150 0066 32EE611A 		fsubs	s2, s4, s3
 8151 006a 83ED001A 		fsts	s2, [r3, #0]
 8152              	.L516:
  58:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     }
  59:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  60:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     // Apply heading hold only when throttle high enough to start flight
  61:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     if (receiverCommand[THROTTLE] > MINCHECK ) { 
 8153              		.loc 30 61 0
 8154 006e F068     		ldr	r0, [r6, #12]
 8155 0070 40F24C4C 		movw	ip, #1100
 8156 0074 6045     		cmp	r0, ip
 8157 0076 42DD     		ble	.L518
  62:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       
  63:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       #if defined (UseGPSNavigator)
  64:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         if (( (receiverCommand[ZAXIS] + gpsYawAxisCorrection) > (MIDCOMMAND + 25)) || 
  65:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****             ( (receiverCommand[ZAXIS] + gpsYawAxisCorrection) < (MIDCOMMAND - 25))) {
  66:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       #else
  67:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         if ((receiverCommand[ZAXIS] > (MIDCOMMAND + 25)) || 
 8158              		.loc 30 67 0
 8159 0078 3F48     		ldr	r0, .L533+4
 8160 007a 8168     		ldr	r1, [r0, #8]
 8161 007c A1F5B860 		sub	r0, r1, #1472
 8162 0080 C11E     		subs	r1, r0, #3
 8163 0082 3229     		cmp	r1, #50
 8164 0084 0ED9     		bls	.L519
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****             (receiverCommand[ZAXIS] < (MIDCOMMAND - 25))) {
  69:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       #endif
  70:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       
  71:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         
  72:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         // If commanding yaw, turn off heading hold and store latest heading
  73:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         setHeading = heading;
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         headingHold = 0;
  75:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         PID[HEADING_HOLD_PID_IDX].integratedError = 0;
 8165              		.loc 30 75 0
 8166 0086 4549     		ldr	r1, .L533+40
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         headingHold = 0;
 8167              		.loc 30 74 0
 8168 0088 0023     		movs	r3, #0
  73:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         setHeading = heading;
 8169              		.loc 30 73 0
 8170 008a C2ED007A 		fsts	s15, [r2, #0]
 8171              		.loc 30 75 0
 8172 008e C1F8A030 		str	r3, [r1, #160]	@ float
  76:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         headingHoldState = OFF;
 8173              		.loc 30 76 0
 8174 0092 434A     		ldr	r2, .L533+44
  77:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         headingTime = currentTime;
 8175              		.loc 30 77 0
 8176 0094 4349     		ldr	r1, .L533+48
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         headingHold = 0;
 8177              		.loc 30 74 0
 8178 0096 2360     		str	r3, [r4, #0]	@ float
  76:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         headingHoldState = OFF;
 8179              		.loc 30 76 0
 8180 0098 0020     		movs	r0, #0
 8181 009a 1070     		strb	r0, [r2, #0]
 8182              		.loc 30 77 0
 8183 009c 424B     		ldr	r3, .L533+52
 8184 009e 0A68     		ldr	r2, [r1, #0]
 8185 00a0 1A60     		str	r2, [r3, #0]
 8186 00a2 33E0     		b	.L513
 8187              	.L519:
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       }
  79:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       else {
  80:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         if (relativeHeading < 0.25 && relativeHeading > -0.25) {
 8188              		.loc 30 80 0
 8189 00a4 93ED007A 		flds	s14, [r3, #0]
 8190 00a8 F5EE002A 		fconsts	s5, #80
 8191 00ac B4EEE27A 		fcmpes	s14, s5
 8192 00b0 F1EE10FA 		fmstat
 8193 00b4 06D5     		bpl	.L520
 8194              		.loc 30 80 0 is_stmt 0 discriminator 1
 8195 00b6 BDEE003A 		fconsts	s6, #208
 8196 00ba B4EEC37A 		fcmpes	s14, s6
 8197 00be F1EE10FA 		fmstat
 8198 00c2 1EDC     		bgt	.L532
 8199              	.L520:
  81:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****           headingHold = 0;
  82:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****           PID[HEADING_HOLD_PID_IDX].integratedError = 0;
  83:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         }
  84:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         else if (headingHoldState == OFF) { // quick fix to soften heading hold on new heading
 8200              		.loc 30 84 0 is_stmt 1
 8201 00c4 3649     		ldr	r1, .L533+44
 8202 00c6 384D     		ldr	r5, .L533+52
 8203 00c8 0878     		ldrb	r0, [r1, #0]	@ zero_extendqisi2
 8204 00ca 364F     		ldr	r7, .L533+48
 8205 00cc 68B9     		cbnz	r0, .L523
  85:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****           if ((currentTime - headingTime) > 500000) {
 8206              		.loc 30 85 0
 8207 00ce 3B68     		ldr	r3, [r7, #0]
 8208 00d0 2F68     		ldr	r7, [r5, #0]
 8209 00d2 3648     		ldr	r0, .L533+56
 8210 00d4 DF1B     		subs	r7, r3, r7
 8211 00d6 8742     		cmp	r7, r0
 8212 00d8 18D9     		bls	.L513
  86:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****             headingHoldState = ON;
 8213              		.loc 30 86 0
 8214 00da 0120     		movs	r0, #1
  87:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****             headingTime = currentTime;
  88:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****             setHeading = heading;
 8215              		.loc 30 88 0
 8216 00dc C2ED007A 		fsts	s15, [r2, #0]
  89:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****             headingHold = 0;
 8217              		.loc 30 89 0
 8218 00e0 0022     		movs	r2, #0
  86:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****             headingHoldState = ON;
 8219              		.loc 30 86 0
 8220 00e2 0870     		strb	r0, [r1, #0]
  87:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****             headingTime = currentTime;
 8221              		.loc 30 87 0
 8222 00e4 2B60     		str	r3, [r5, #0]
 8223              		.loc 30 89 0
 8224 00e6 2260     		str	r2, [r4, #0]	@ float
 8225 00e8 10E0     		b	.L513
 8226              	.L523:
  90:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****           }
  91:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         }
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         else {
  93:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         // No new yaw input, calculate current heading vs. desired heading heading hold
  94:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         // Relative heading is always centered around zero
  95:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****           headingHold = updatePID(0, relativeHeading, &PID[HEADING_HOLD_PID_IDX]);
 8227              		.loc 30 95 0
 8228 00ea 17EE101A 		fmrs	r1, s14
 8229 00ee 0020     		movs	r0, #0
 8230 00f0 2F4A     		ldr	r2, .L533+60
 8231 00f2 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
  96:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****           headingTime = currentTime; // quick fix to soften heading hold, wait 100ms before applyin
 8232              		.loc 30 96 0
 8233 00f6 3968     		ldr	r1, [r7, #0]
  95:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****           headingHold = updatePID(0, relativeHeading, &PID[HEADING_HOLD_PID_IDX]);
 8234              		.loc 30 95 0
 8235 00f8 2060     		str	r0, [r4, #0]	@ float
 8236              		.loc 30 96 0
 8237 00fa 2960     		str	r1, [r5, #0]
 8238 00fc 06E0     		b	.L513
 8239              	.L518:
  97:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         }
  98:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       }
  99:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     }
 100:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     else {
 101:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       // minimum throttle not reached, use off settings
 102:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       setHeading = heading;
 8240              		.loc 30 102 0
 8241 00fe C2ED007A 		fsts	s15, [r2, #0]
 8242              	.L532:
 103:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       headingHold = 0;
 104:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       PID[HEADING_HOLD_PID_IDX].integratedError = 0;
 8243              		.loc 30 104 0
 8244 0102 264A     		ldr	r2, .L533+40
 103:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       headingHold = 0;
 8245              		.loc 30 103 0
 8246 0104 0023     		movs	r3, #0
 8247 0106 2360     		str	r3, [r4, #0]	@ float
 8248              		.loc 30 104 0
 8249 0108 C2F8A030 		str	r3, [r2, #160]	@ float
 8250              	.L513:
 8251              	.LVL389:
 105:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     }
 106:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   }
 107:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   // NEW SI Version
 108:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   #if defined (UseGPSNavigator) 
 109:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     float receiverSiData = (receiverCommand[ZAXIS] - receiverZero[ZAXIS] + gpsYawAxisCorrection) * 
 110:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   #else
 111:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     float receiverSiData = (receiverCommand[ZAXIS] - receiverZero[ZAXIS]) * (2.5 * PWM2RAD);
 8252              		.loc 30 111 0
 8253 010c 294B     		ldr	r3, .L533+64
 8254 010e B268     		ldr	r2, [r6, #8]
 8255 0110 9968     		ldr	r1, [r3, #8]
 8256 0112 501A     		subs	r0, r2, r1
 8257 0114 07EE900A 		fmsr	s15, r0	@ int
 112:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   #endif
 113:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   
 114:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   const float commandedYaw = constrain(receiverSiData + radians(headingHold), -PI, PI);
 8258              		.loc 30 114 0
 8259 0118 D4ED004A 		flds	s9, [r4, #0]
 111:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     float receiverSiData = (receiverCommand[ZAXIS] - receiverZero[ZAXIS]) * (2.5 * PWM2RAD);
 8260              		.loc 30 111 0
 8261 011c F8EEE73A 		fsitos	s7, s15
 8262              		.loc 30 114 0
 8263 0120 DFED257A 		flds	s15, .L533+68
 8264 0124 9FED254A 		flds	s8, .L533+72
 8265 0128 64EEA77A 		fmuls	s15, s9, s15
 8266 012c 43EE847A 		fmacs	s15, s7, s8
 8267 0130 9FED237A 		flds	s14, .L533+76
 8268 0134 F4EEC77A 		fcmpes	s15, s14
 8269 0138 F1EE10FA 		fmstat
 8270 013c 0BD4     		bmi	.L526
 8271              		.loc 30 114 0 is_stmt 0 discriminator 2
 8272 013e 9FED215A 		flds	s10, .L533+80
 8273 0142 F4EE457A 		fcmps	s15, s10
 8274 0146 F1EE10FA 		fmstat
 8275 014a CCBF     		ite	gt
 8276 014c 15EE100A 		fmrsgt	r0, s10
 8277 0150 17EE900A 		fmrsle	r0, s15
 8278 0154 01E0     		b	.L524
 8279              	.L526:
 8280              		.loc 30 114 0
 8281 0156 17EE100A 		fmrs	r0, s14
 8282              	.L524:
 115:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   motorAxisCommandYaw = updatePID(commandedYaw, gyroRate[ZAXIS], &PID[ZAXIS_PID_IDX]);
 8283              		.loc 30 115 0 is_stmt 1 discriminator 6
 8284 015a 1B49     		ldr	r1, .L533+84
 8285 015c 1B4A     		ldr	r2, .L533+88
 8286 015e 8968     		ldr	r1, [r1, #8]	@ float
 8287 0160 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 8288              	.LVL390:
 8289 0164 05EE900A 		fmsr	s11, r0
 8290 0168 1948     		ldr	r0, .L533+92
 8291 016a BDEEE56A 		ftosizs	s12, s11
 8292 016e 80ED006A 		fsts	s12, [r0, #0]	@ int
 8293              	.LBE253:
 116:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** }
 8294              		.loc 30 116 0 discriminator 6
 8295 0172 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 8296              	.L534:
 8297              		.align	2
 8298              	.L533:
 8299 0174 00000000 		.word	.LANCHOR135
 8300 0178 00000000 		.word	.LANCHOR6
 8301 017c 00000000 		.word	.LANCHOR139
 8302 0180 00000000 		.word	.LANCHOR74
 8303 0184 00000000 		.word	.LANCHOR136
 8304 0188 00000000 		.word	.LANCHOR138
 8305 018c E12E6542 		.word	1113927393
 8306 0190 00000000 		.word	.LANCHOR137
 8307 0194 00003443 		.word	1127481344
 8308 0198 0000B443 		.word	1135869952
 8309 019c 00000000 		.word	.LANCHOR17
 8310 01a0 00000000 		.word	.LANCHOR140
 8311 01a4 00000000 		.word	.LANCHOR15
 8312 01a8 00000000 		.word	.LANCHOR141
 8313 01ac 20A10700 		.word	500000
 8314 01b0 8C000000 		.word	.LANCHOR17+140
 8315 01b4 00000000 		.word	.LANCHOR11
 8316 01b8 35FA8E3C 		.word	1016003125
 8317 01bc 0BD7A33B 		.word	1000593163
 8318 01c0 DB0F49C0 		.word	-1068953637
 8319 01c4 DB0F4940 		.word	1078530011
 8320 01c8 00000000 		.word	.LANCHOR27
 8321 01cc 38000000 		.word	.LANCHOR17+56
 8322 01d0 00000000 		.word	.LANCHOR109
 8323              		.cfi_endproc
 8324              	.LFE242:
 8326              		.section	.text._Z20processFlightControlv,"ax",%progbits
 8327              		.align	1
 8328              		.global	_Z20processFlightControlv
 8329              		.thumb
 8330              		.thumb_func
 8332              	_Z20processFlightControlv:
 8333              	.LFB240:
 267:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 268:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** /**
 269:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * processFlightControl
 270:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  *
 271:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * Main flight control processos function
 272:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  */
 273:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** void processFlightControl() {
 8334              		.loc 29 273 0
 8335              		.cfi_startproc
 8336              		@ args = 0, pretend = 0, frame = 0
 8337              		@ frame_needed = 0, uses_anonymous_args = 0
 8338 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 8339              	.LCFI83:
 8340              		.cfi_def_cfa_offset 24
 8341              		.cfi_offset 14, -4
 8342              		.cfi_offset 7, -8
 8343              		.cfi_offset 6, -12
 8344              		.cfi_offset 5, -16
 8345              		.cfi_offset 4, -20
 8346              		.cfi_offset 3, -24
 8347              	.LBB254:
 274:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   
 275:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // ********************** Calculate Flight Error ***************************
 276:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   calculateFlightError();
 8348              		.loc 29 276 0
 8349 0002 FFF7FEFF 		bl	_Z20calculateFlightErrorv
 277:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   
 278:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // ********************** Update Yaw ***************************************
 279:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   processHeading();
 8350              		.loc 29 279 0
 8351 0006 FFF7FEFF 		bl	_Z14processHeadingv
 280:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   
 281:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if (frameCounter % THROTTLE_ADJUST_TASK_SPEED == 0) {  // 50hz task
 8352              		.loc 29 281 0
 8353 000a 2848     		ldr	r0, .L550
 8354 000c 0368     		ldr	r3, [r0, #0]
 8355 000e DA07     		lsls	r2, r3, #31
 8356 0010 03D4     		bmi	.L536
 282:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     
 283:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     // ********************** Process position hold or navigation **************************
 284:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #if defined (UseGPS)
 285:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       #if defined (UseGPSNavigator)
 286:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         processGpsNavigation();
 287:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       #endif  
 288:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #endif
 289:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     
 290:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     // ********************** Process Altitude hold **************************
 291:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 292:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       processAltitudeHold();
 8357              		.loc 29 292 0
 8358 0012 FFF7FEFF 		bl	_Z19processAltitudeHoldv
 293:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #else
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       throttle = receiverCommand[THROTTLE];
 295:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #endif
 296:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     
 297:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     // ********************** Process Battery monitor hold **************************
 298:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #if defined BattMonitor && defined BattMonitorAutoDescent
 299:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       processBatteryMonitorThrottleAdjustment();
 300:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #endif
 301:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 302:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     // ********************** Process Auto-Descent  **************************
 303:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #if defined AutoLanding
 304:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       processAutoLandingAltitudeCorrection();
 305:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #endif
 306:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     
 307:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     // ********************** Process throttle correction ********************
 308:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     processThrottleCorrection();
 8359              		.loc 29 308 0
 8360 0016 FFF7FEFF 		bl	_Z25processThrottleCorrectionv
 8361              	.L536:
 309:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 310:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 311:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // ********************** Calculate Motor Commands *************************
 312:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if (motorArmed && safetyCheck) {
 8362              		.loc 29 312 0
 8363 001a 254C     		ldr	r4, .L550+4
 8364 001c 2178     		ldrb	r1, [r4, #0]	@ zero_extendqisi2
 8365 001e 21B1     		cbz	r1, .L537
 8366              		.loc 29 312 0 is_stmt 0 discriminator 1
 8367 0020 244D     		ldr	r5, .L550+8
 8368 0022 2A78     		ldrb	r2, [r5, #0]	@ zero_extendqisi2
 8369 0024 0AB1     		cbz	r2, .L537
 313:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     applyMotorCommand();
 8370              		.loc 29 313 0 is_stmt 1
 8371 0026 FFF7FEFF 		bl	_Z17applyMotorCommandv
 8372              	.L537:
 314:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   } 
 315:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 316:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // *********************** process min max motor command *******************
 317:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   processMinMaxCommand();
 8373              		.loc 29 317 0
 8374 002a FFF7FEFF 		bl	_Z20processMinMaxCommandv
 8375              	.LBB255:
 318:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 319:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // If throttle in minimum position, don't apply yaw
 320:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if (receiverCommand[THROTTLE] < MINCHECK) {
 8376              		.loc 29 320 0
 8377 002e 224B     		ldr	r3, .L550+12
 8378 0030 2249     		ldr	r1, .L550+16
 8379 0032 D868     		ldr	r0, [r3, #12]
 8380 0034 40F24B4C 		movw	ip, #1099
 8381 0038 6045     		cmp	r0, ip
 8382 003a 01DD     		ble	.L538
 8383              	.L542:
 8384              	.LVL391:
 8385              	.LBB256:
 321:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 322:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 323:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 324:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         motorMaxCommand[motor] = MAXCOMMAND;
 325:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       }
 326:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       else {
 327:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         motorMaxCommand[motor] = minArmedThrottle;
 8386              		.loc 29 327 0 discriminator 1
 8387 003c 0023     		movs	r3, #0
 8388 003e 15E0     		b	.L539
 8389              	.LVL392:
 8390              	.L538:
 322:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 8391              		.loc 29 322 0
 8392 0040 1F4A     		ldr	r2, .L550+20
 323:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 8393              		.loc 29 323 0
 8394 0042 204E     		ldr	r6, .L550+24
 8395 0044 204F     		ldr	r7, .L550+28
 322:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 8396              		.loc 29 322 0
 8397 0046 1268     		ldr	r2, [r2, #0]
 323:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 8398              		.loc 29 323 0
 8399 0048 3678     		ldrb	r6, [r6, #0]	@ zero_extendqisi2
 8400 004a 3D78     		ldrb	r5, [r7, #0]	@ zero_extendqisi2
 8401 004c 0023     		movs	r3, #0
 8402              	.L541:
 322:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 8403              		.loc 29 322 0
 8404 004e CA50     		str	r2, [r1, r3]
 323:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 8405              		.loc 29 323 0
 8406 0050 2EB1     		cbz	r6, .L546
 8407              		.loc 29 327 0 discriminator 1
 8408 0052 002D     		cmp	r5, #0
 8409 0054 14BF     		ite	ne
 8410 0056 1046     		movne	r0, r2
 8411 0058 4FF4FA60 		moveq	r0, #2000
 8412 005c 00E0     		b	.L540
 8413              	.L546:
 8414              		.loc 29 327 0 is_stmt 0
 8415 005e 1046     		mov	r0, r2
 8416              	.L540:
 323:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 8417              		.loc 29 323 0 is_stmt 1
 8418 0060 1A4F     		ldr	r7, .L550+32
 8419 0062 D851     		str	r0, [r3, r7]
 8420 0064 0433     		adds	r3, r3, #4
 321:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 8421              		.loc 29 321 0
 8422 0066 102B     		cmp	r3, #16
 8423 0068 F1D1     		bne	.L541
 8424 006a E7E7     		b	.L542
 8425              	.LVL393:
 8426              	.L539:
 8427              	.LBE256:
 8428              	.LBE255:
 8429              	.LBB257:
 328:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       }
 329:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
 330:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 331:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   
 332:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // Apply limits to motor commands
 333:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   for (byte motor = 0; motor < LASTMOTOR; motor++) {
 334:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorCommand[motor] = constrain(motorCommand[motor], motorMinCommand[motor], motorMaxCommand[mo
 8430              		.loc 29 334 0
 8431 006c 1848     		ldr	r0, .L550+36
 8432 006e CA58     		ldr	r2, [r1, r3]
 8433 0070 1D58     		ldr	r5, [r3, r0]
 8434 0072 9542     		cmp	r5, r2
 8435 0074 04DB     		blt	.L543
 8436              		.loc 29 334 0 is_stmt 0 discriminator 2
 8437 0076 154A     		ldr	r2, .L550+32
 8438 0078 9A58     		ldr	r2, [r3, r2]
 8439 007a 9542     		cmp	r5, r2
 8440 007c B8BF     		it	lt
 8441 007e 2A46     		movlt	r2, r5
 8442              	.L543:
 8443              		.loc 29 334 0 discriminator 6
 8444 0080 C250     		str	r2, [r0, r3]
 8445 0082 0433     		adds	r3, r3, #4
 333:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   for (byte motor = 0; motor < LASTMOTOR; motor++) {
 8446              		.loc 29 333 0 is_stmt 1 discriminator 6
 8447 0084 102B     		cmp	r3, #16
 8448 0086 F1D1     		bne	.L539
 8449              	.LBE257:
 335:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 336:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 337:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // ESC Calibration
 338:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if (motorArmed == OFF) {
 8450              		.loc 29 338 0
 8451 0088 2178     		ldrb	r1, [r4, #0]	@ zero_extendqisi2
 8452 008a 09B9     		cbnz	r1, .L544
 339:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     processCalibrateESC();
 8453              		.loc 29 339 0
 8454 008c FFF7FEFF 		bl	_Z19processCalibrateESCv
 8455              	.L544:
 340:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 341:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   
 342:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // *********************** Command Motors **********************
 343:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if (motorArmed == ON && safetyCheck == ON) {
 8456              		.loc 29 343 0
 8457 0090 2078     		ldrb	r0, [r4, #0]	@ zero_extendqisi2
 8458 0092 0128     		cmp	r0, #1
 8459 0094 09D1     		bne	.L535
 8460              		.loc 29 343 0 is_stmt 0 discriminator 1
 8461 0096 074B     		ldr	r3, .L550+8
 8462 0098 93F800E0 		ldrb	lr, [r3, #0]	@ zero_extendqisi2
 8463 009c BEF1010F 		cmp	lr, #1
 8464 00a0 03D1     		bne	.L535
 8465              	.LBE254:
 344:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     writeMotors();
 345:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 346:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** }
 8466              		.loc 29 346 0 is_stmt 1
 8467 00a2 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 8468              	.LBB258:
 344:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     writeMotors();
 8469              		.loc 29 344 0
 8470 00a6 FFF7FEBF 		b	_Z11writeMotorsv
 8471              	.L535:
 8472 00aa F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 8473              	.L551:
 8474              		.align	2
 8475              	.L550:
 8476 00ac 00000000 		.word	.LANCHOR41
 8477 00b0 00000000 		.word	.LANCHOR116
 8478 00b4 00000000 		.word	.LANCHOR131
 8479 00b8 00000000 		.word	.LANCHOR6
 8480 00bc 00000000 		.word	.LANCHOR133
 8481 00c0 00000000 		.word	.LANCHOR132
 8482 00c4 00000000 		.word	.LANCHOR16
 8483 00c8 00000000 		.word	.LANCHOR120
 8484 00cc 00000000 		.word	.LANCHOR134
 8485 00d0 00000000 		.word	.LANCHOR63
 8486              	.LBE258:
 8487              		.cfi_endproc
 8488              	.LFE240:
 8490              		.section	.text._Z12nvrReadFloati,"ax",%progbits
 8491              		.align	1
 8492              		.global	_Z12nvrReadFloati
 8493              		.thumb
 8494              		.thumb_func
 8496              	_Z12nvrReadFloati:
 8497              	.LFB243:
 8498              		.file 31 "C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad/DataStorage.h"
   1:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** /*
   2:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   AeroQuad v3.0.1 - February 2012
   3:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   www.AeroQuad.com
   4:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   An Open Source Arduino based multicopter.
   6:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
   7:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   This program is free software: you can redistribute it and/or modify
   8:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   it under the terms of the GNU General Public License as published by
   9:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   the Free Software Foundation, either version 3 of the License, or
  10:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   (at your option) any later version.
  11:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  12:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   This program is distributed in the hope that it will be useful,
  13:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   GNU General Public License for more details.
  16:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  17:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   You should have received a copy of the GNU General Public License
  18:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** */
  20:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  21:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** // Special thanks for 1k space optimization update from Ala42
  22:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** // http://aeroquad.com/showthread.php?1369-The-big-enhancement-addition-to-2.0-code&p=13359&viewful
  23:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  24:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #ifndef _AQ_DATA_STORAGE_H_
  25:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #define _AQ_DATA_STORAGE_H_
  26:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  27:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** // Utilities for writing and reading from the EEPROM
  28:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** float nvrReadFloat(int address) {
 8499              		.loc 31 28 0
 8500              		.cfi_startproc
 8501              		@ args = 0, pretend = 0, frame = 0
 8502              		@ frame_needed = 0, uses_anonymous_args = 0
 8503              	.LVL394:
 8504 0000 38B5     		push	{r3, r4, r5, lr}
 8505              	.LCFI84:
 8506              		.cfi_def_cfa_offset 16
 8507              		.cfi_offset 14, -4
 8508              		.cfi_offset 5, -8
 8509              		.cfi_offset 4, -12
 8510              		.cfi_offset 3, -16
 8511              	.LBB259:
 8512              	.LBB260:
  29:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   union floatStore {
  30:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     byte floatByte[4];
  31:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     unsigned short floatUShort[2];
  32:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     float floatVal;
  33:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   } floatOut;
  34:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  35:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #ifdef EEPROM_USES_16BIT_WORDS
  36:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for (int i = 0; i < 2; i++) {
  37:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     floatOut.floatUShort[i] = EEPROM.read(address + 2*i);
 8513              		.loc 31 37 0
 8514 0002 85B2     		uxth	r5, r0
 8515 0004 2946     		mov	r1, r5
 8516 0006 0748     		ldr	r0, .L553
 8517              	.LVL395:
 8518 0008 FFF7FEFF 		bl	_ZN11EEPROMClass4readEt
 8519 000c 0024     		movs	r4, #0
 8520              	.LVL396:
 8521 000e A91C     		adds	r1, r5, #2
 8522 0010 60F30F04 		bfi	r4, r0, #0, #16
 8523              	.LVL397:
 8524 0014 89B2     		uxth	r1, r1
 8525 0016 0348     		ldr	r0, .L553
 8526 0018 FFF7FEFF 		bl	_ZN11EEPROMClass4readEt
 8527 001c 60F31F44 		bfi	r4, r0, #16, #16
 8528              	.LVL398:
 8529              	.LBE260:
  38:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
  39:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #else
  40:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for (int i = 0; i < 4; i++) {
  41:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     floatOut.floatByte[i] = EEPROM.read(address + i);
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
  43:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #endif
  44:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  45:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   return floatOut.floatVal;
 8530              		.loc 31 45 0
 8531 0020 2046     		mov	r0, r4	@ float
 8532              	.LBE259:
  46:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** }
 8533              		.loc 31 46 0
 8534 0022 38BD     		pop	{r3, r4, r5, pc}
 8535              	.L554:
 8536              		.align	2
 8537              	.L553:
 8538 0024 00000000 		.word	EEPROM
 8539              		.cfi_endproc
 8540              	.LFE243:
 8542              		.section	.text._Z13nvrWriteFloatfi,"ax",%progbits
 8543              		.align	1
 8544              		.global	_Z13nvrWriteFloatfi
 8545              		.thumb
 8546              		.thumb_func
 8548              	_Z13nvrWriteFloatfi:
 8549              	.LFB244:
  47:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  48:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void nvrWriteFloat(float value, int address) {
 8550              		.loc 31 48 0
 8551              		.cfi_startproc
 8552              		@ args = 0, pretend = 0, frame = 0
 8553              		@ frame_needed = 0, uses_anonymous_args = 0
 8554              	.LVL399:
 8555 0000 38B5     		push	{r3, r4, r5, lr}
 8556              	.LCFI85:
 8557              		.cfi_def_cfa_offset 16
 8558              		.cfi_offset 14, -4
 8559              		.cfi_offset 5, -8
 8560              		.cfi_offset 4, -12
 8561              		.cfi_offset 3, -16
 8562              	.LBB261:
  49:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   union floatStore {
  50:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     byte floatByte[4];
  51:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     unsigned short floatUShort[2];
  52:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     float floatVal;
  53:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   } floatIn;
  54:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  55:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   floatIn.floatVal = value;
 8563              		.loc 31 55 0
 8564 0002 0446     		mov	r4, r0	@ float
 8565              	.LVL400:
 8566              	.LBB262:
  56:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #ifdef EEPROM_USES_16BIT_WORDS
  57:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for (int i = 0; i < 2; i++) {
  58:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     EEPROM.write(address + 2*i, floatIn.floatUShort[i]);
 8567              		.loc 31 58 0
 8568 0004 8DB2     		uxth	r5, r1
 8569 0006 2946     		mov	r1, r5
 8570              	.LVL401:
 8571 0008 A2B2     		uxth	r2, r4
 8572 000a 0548     		ldr	r0, .L556
 8573              	.LVL402:
 8574 000c FFF7FEFF 		bl	_ZN11EEPROMClass5writeEtt
 8575              	.LVL403:
 8576 0010 A91C     		adds	r1, r5, #2
 8577 0012 0348     		ldr	r0, .L556
 8578 0014 89B2     		uxth	r1, r1
 8579 0016 220C     		lsrs	r2, r4, #16
 8580              	.LBE262:
 8581              	.LBE261:
  59:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
  60:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #else
  61:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for (int i = 0; i < 4; i++) {
  62:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     EEPROM.write(address + i, floatIn.floatByte[i]);
  63:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
  64:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #endif
  65:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** }
 8582              		.loc 31 65 0
 8583 0018 BDE83840 		pop	{r3, r4, r5, lr}
 8584              	.LBB264:
 8585              	.LBB263:
  58:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     EEPROM.write(address + 2*i, floatIn.floatUShort[i]);
 8586              		.loc 31 58 0
 8587 001c FFF7FEBF 		b	_ZN11EEPROMClass5writeEtt
 8588              	.L557:
 8589              		.align	2
 8590              	.L556:
 8591 0020 00000000 		.word	EEPROM
 8592              	.LBE263:
 8593              	.LBE264:
 8594              		.cfi_endproc
 8595              	.LFE244:
 8597              		.section	.text._Z11nvrReadLongi,"ax",%progbits
 8598              		.align	1
 8599              		.global	_Z11nvrReadLongi
 8600              		.thumb
 8601              		.thumb_func
 8603              	_Z11nvrReadLongi:
 8604              	.LFB245:
  66:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  67:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** long nvrReadLong(int address) {
 8605              		.loc 31 67 0
 8606              		.cfi_startproc
 8607              		@ args = 0, pretend = 0, frame = 0
 8608              		@ frame_needed = 0, uses_anonymous_args = 0
 8609              	.LVL404:
 8610 0000 38B5     		push	{r3, r4, r5, lr}
 8611              	.LCFI86:
 8612              		.cfi_def_cfa_offset 16
 8613              		.cfi_offset 14, -4
 8614              		.cfi_offset 5, -8
 8615              		.cfi_offset 4, -12
 8616              		.cfi_offset 3, -16
 8617              	.LBB265:
 8618              	.LBB266:
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   union longStore {
  69:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     byte longByte[4];
  70:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     unsigned short longUShort[2];
  71:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     long longVal;
  72:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   } longOut;  
  73:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #ifdef EEPROM_USES_16BIT_WORDS
  75:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for (int i = 0; i < 2; i++) {
  76:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     longOut.longUShort[i] = EEPROM.read(address + 2*i);
 8619              		.loc 31 76 0
 8620 0002 85B2     		uxth	r5, r0
 8621 0004 2946     		mov	r1, r5
 8622 0006 0748     		ldr	r0, .L559
 8623              	.LVL405:
 8624 0008 FFF7FEFF 		bl	_ZN11EEPROMClass4readEt
 8625 000c 0024     		movs	r4, #0
 8626              	.LVL406:
 8627 000e A91C     		adds	r1, r5, #2
 8628 0010 60F30F04 		bfi	r4, r0, #0, #16
 8629              	.LVL407:
 8630 0014 89B2     		uxth	r1, r1
 8631 0016 0348     		ldr	r0, .L559
 8632 0018 FFF7FEFF 		bl	_ZN11EEPROMClass4readEt
 8633 001c 60F31F44 		bfi	r4, r0, #16, #16
 8634              	.LVL408:
 8635              	.LBE266:
 8636              	.LBE265:
  77:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #else
  79:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for (byte i = 0; i < 4; i++) {
  80:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     longOut.longByte[i] = EEPROM.read(address + i);
  81:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
  82:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #endif
  83:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     
  84:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   return longOut.longVal;
  85:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** }
 8637              		.loc 31 85 0
 8638 0020 2046     		mov	r0, r4
 8639 0022 38BD     		pop	{r3, r4, r5, pc}
 8640              	.L560:
 8641              		.align	2
 8642              	.L559:
 8643 0024 00000000 		.word	EEPROM
 8644              		.cfi_endproc
 8645              	.LFE245:
 8647              		.section	.text._Z12nvrWriteLongli,"ax",%progbits
 8648              		.align	1
 8649              		.global	_Z12nvrWriteLongli
 8650              		.thumb
 8651              		.thumb_func
 8653              	_Z12nvrWriteLongli:
 8654              	.LFB246:
  86:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  87:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void nvrWriteLong(long value, int address) {
 8655              		.loc 31 87 0
 8656              		.cfi_startproc
 8657              		@ args = 0, pretend = 0, frame = 0
 8658              		@ frame_needed = 0, uses_anonymous_args = 0
 8659              	.LVL409:
 8660 0000 38B5     		push	{r3, r4, r5, lr}
 8661              	.LCFI87:
 8662              		.cfi_def_cfa_offset 16
 8663              		.cfi_offset 14, -4
 8664              		.cfi_offset 5, -8
 8665              		.cfi_offset 4, -12
 8666              		.cfi_offset 3, -16
 8667              		.loc 31 87 0
 8668 0002 0446     		mov	r4, r0
 8669              	.LBB267:
 8670              	.LBB268:
  88:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   union longStore {
  89:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     byte longByte[4];
  90:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     unsigned short longUShort[2];
  91:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     long longVal;
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   } longIn;  
  93:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  94:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   longIn.longVal = value;
  95:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
  96:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #ifdef EEPROM_USES_16BIT_WORDS
  97:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for (int i = 0; i < 2; i++) {
  98:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     EEPROM.write(address + 2*i, longIn.longUShort[i]);
 8671              		.loc 31 98 0
 8672 0004 8DB2     		uxth	r5, r1
 8673 0006 2946     		mov	r1, r5
 8674              	.LVL410:
 8675 0008 A2B2     		uxth	r2, r4
 8676 000a 0548     		ldr	r0, .L562
 8677              	.LVL411:
 8678 000c FFF7FEFF 		bl	_ZN11EEPROMClass5writeEtt
 8679              	.LVL412:
 8680 0010 A91C     		adds	r1, r5, #2
 8681 0012 0348     		ldr	r0, .L562
 8682 0014 89B2     		uxth	r1, r1
 8683 0016 220C     		lsrs	r2, r4, #16
 8684              	.LBE268:
 8685              	.LBE267:
  99:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
 100:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #else
 101:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for (int i = 0; i < 4; i++) {
 102:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     EEPROM.write(address + i, longIn.longByte[i]);
 103:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
 104:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #endif
 105:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** }
 8686              		.loc 31 105 0
 8687 0018 BDE83840 		pop	{r3, r4, r5, lr}
 8688              	.LBB270:
 8689              	.LBB269:
  98:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     EEPROM.write(address + 2*i, longIn.longUShort[i]);
 8690              		.loc 31 98 0
 8691 001c FFF7FEBF 		b	_ZN11EEPROMClass5writeEtt
 8692              	.L563:
 8693              		.align	2
 8694              	.L562:
 8695 0020 00000000 		.word	EEPROM
 8696              	.LBE269:
 8697              	.LBE270:
 8698              		.cfi_endproc
 8699              	.LFE246:
 8701              		.section	.text._Z10nvrReadPIDhj,"ax",%progbits
 8702              		.align	1
 8703              		.global	_Z10nvrReadPIDhj
 8704              		.thumb
 8705              		.thumb_func
 8707              	_Z10nvrReadPIDhj:
 8708              	.LFB247:
 106:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 107:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void nvrReadPID(unsigned char IDPid, unsigned int IDEeprom) {
 8709              		.loc 31 107 0
 8710              		.cfi_startproc
 8711              		@ args = 0, pretend = 0, frame = 0
 8712              		@ frame_needed = 0, uses_anonymous_args = 0
 8713              	.LVL413:
 8714              	.LBB271:
 108:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   struct PIDdata* pid = &PID[IDPid];
 8715              		.loc 31 108 0
 8716 0000 0B4A     		ldr	r2, .L565
 8717              	.LBE271:
 107:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void nvrReadPID(unsigned char IDPid, unsigned int IDEeprom) {
 8718              		.loc 31 107 0
 8719 0002 38B5     		push	{r3, r4, r5, lr}
 8720              	.LCFI88:
 8721              		.cfi_def_cfa_offset 16
 8722              		.cfi_offset 14, -4
 8723              		.cfi_offset 5, -8
 8724              		.cfi_offset 4, -12
 8725              		.cfi_offset 3, -16
 8726              	.LBB272:
 8727              		.loc 31 108 0
 8728 0004 1C24     		movs	r4, #28
 8729 0006 04FB0024 		mla	r4, r4, r0, r2
 8730              	.LVL414:
 109:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   pid->P = nvrReadFloat(IDEeprom);
 8731              		.loc 31 109 0
 8732 000a 0846     		mov	r0, r1
 8733              	.LVL415:
 8734              	.LBE272:
 107:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void nvrReadPID(unsigned char IDPid, unsigned int IDEeprom) {
 8735              		.loc 31 107 0
 8736 000c 0D46     		mov	r5, r1
 8737              	.LBB273:
 8738              		.loc 31 109 0
 8739 000e FFF7FEFF 		bl	_Z12nvrReadFloati
 8740              	.LVL416:
 8741 0012 2060     		str	r0, [r4, #0]	@ float
 110:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   pid->I = nvrReadFloat(IDEeprom+4);
 8742              		.loc 31 110 0
 8743 0014 281D     		adds	r0, r5, #4
 8744 0016 FFF7FEFF 		bl	_Z12nvrReadFloati
 8745 001a 6060     		str	r0, [r4, #4]	@ float
 111:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   pid->D = nvrReadFloat(IDEeprom+8);
 8746              		.loc 31 111 0
 8747 001c 05F10800 		add	r0, r5, #8
 8748 0020 FFF7FEFF 		bl	_Z12nvrReadFloati
 112:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   pid->lastError = 0;
 8749              		.loc 31 112 0
 8750 0024 0023     		movs	r3, #0
 111:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   pid->D = nvrReadFloat(IDEeprom+8);
 8751              		.loc 31 111 0
 8752 0026 A060     		str	r0, [r4, #8]	@ float
 8753              		.loc 31 112 0
 8754 0028 E360     		str	r3, [r4, #12]	@ float
 113:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   pid->integratedError = 0;
 8755              		.loc 31 113 0
 8756 002a 6361     		str	r3, [r4, #20]	@ float
 8757              	.LBE273:
 114:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** }
 8758              		.loc 31 114 0
 8759 002c 38BD     		pop	{r3, r4, r5, pc}
 8760              	.L566:
 8761 002e 00BF     		.align	2
 8762              	.L565:
 8763 0030 00000000 		.word	.LANCHOR17
 8764              		.cfi_endproc
 8765              	.LFE247:
 8767              		.section	.text._Z11nvrWritePIDhj,"ax",%progbits
 8768              		.align	1
 8769              		.global	_Z11nvrWritePIDhj
 8770              		.thumb
 8771              		.thumb_func
 8773              	_Z11nvrWritePIDhj:
 8774              	.LFB248:
 115:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 116:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void nvrWritePID(unsigned char IDPid, unsigned int IDEeprom) {
 8775              		.loc 31 116 0
 8776              		.cfi_startproc
 8777              		@ args = 0, pretend = 0, frame = 0
 8778              		@ frame_needed = 0, uses_anonymous_args = 0
 8779              	.LVL417:
 8780 0000 38B5     		push	{r3, r4, r5, lr}
 8781              	.LCFI89:
 8782              		.cfi_def_cfa_offset 16
 8783              		.cfi_offset 14, -4
 8784              		.cfi_offset 5, -8
 8785              		.cfi_offset 4, -12
 8786              		.cfi_offset 3, -16
 8787              	.LBB274:
 117:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   struct PIDdata* pid = &PID[IDPid];
 8788              		.loc 31 117 0
 8789 0002 094B     		ldr	r3, .L568
 8790 0004 1C24     		movs	r4, #28
 8791 0006 04FB0034 		mla	r4, r4, r0, r3
 8792              	.LVL418:
 8793              	.LBE274:
 116:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void nvrWritePID(unsigned char IDPid, unsigned int IDEeprom) {
 8794              		.loc 31 116 0
 8795 000a 0D46     		mov	r5, r1
 8796              	.LBB275:
 118:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   nvrWriteFloat(pid->P, IDEeprom);
 8797              		.loc 31 118 0
 8798 000c 2068     		ldr	r0, [r4, #0]	@ float
 8799              	.LVL419:
 8800 000e FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 8801              	.LVL420:
 119:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   nvrWriteFloat(pid->I, IDEeprom+4);
 8802              		.loc 31 119 0
 8803 0012 6068     		ldr	r0, [r4, #4]	@ float
 8804 0014 291D     		adds	r1, r5, #4
 8805 0016 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 120:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   nvrWriteFloat(pid->D, IDEeprom+8);
 8806              		.loc 31 120 0
 8807 001a A068     		ldr	r0, [r4, #8]	@ float
 8808 001c 05F10801 		add	r1, r5, #8
 8809              	.LBE275:
 121:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** }
 8810              		.loc 31 121 0
 8811 0020 BDE83840 		pop	{r3, r4, r5, lr}
 8812              	.LBB276:
 120:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   nvrWriteFloat(pid->D, IDEeprom+8);
 8813              		.loc 31 120 0
 8814 0024 FFF7FEBF 		b	_Z13nvrWriteFloatfi
 8815              	.L569:
 8816              		.align	2
 8817              	.L568:
 8818 0028 00000000 		.word	.LANCHOR17
 8819              	.LBE276:
 8820              		.cfi_endproc
 8821              	.LFE248:
 8823              		.section	.text._Z16initializeEEPROMv,"ax",%progbits
 8824              		.align	1
 8825              		.global	_Z16initializeEEPROMv
 8826              		.thumb
 8827              		.thumb_func
 8829              	_Z16initializeEEPROMv:
 8830              	.LFB249:
 122:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 123:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** // contains all default values when re-writing EEPROM
 124:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void initializeEEPROM() {
 8831              		.loc 31 124 0
 8832              		.cfi_startproc
 8833              		@ args = 0, pretend = 0, frame = 0
 8834              		@ frame_needed = 0, uses_anonymous_args = 0
 8835              	.LBB277:
 125:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].P = 100.0;
 8836              		.loc 31 125 0
 8837 0000 514B     		ldr	r3, .L573
 8838 0002 5248     		ldr	r0, .L573+4
 126:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].I = 0.0;
 127:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].D = -300.0;
 128:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].P = 100.0;
 129:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].I = 0.0;
 130:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].D = -300.0;
 131:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].P = 4.0;
 8839              		.loc 31 131 0
 8840 0004 4FF08141 		mov	r1, #1082130432
 8841              	.LBE277:
 124:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void initializeEEPROM() {
 8842              		.loc 31 124 0
 8843 0008 70B5     		push	{r4, r5, r6, lr}
 8844              	.LCFI90:
 8845              		.cfi_def_cfa_offset 16
 8846              		.cfi_offset 14, -4
 8847              		.cfi_offset 6, -8
 8848              		.cfi_offset 5, -12
 8849              		.cfi_offset 4, -16
 8850              	.LBB280:
 8851              		.loc 31 131 0
 8852 000a 5965     		str	r1, [r3, #84]	@ float
 132:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].I = 0.0;
 133:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].D = 0.0;
 134:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].P = 4.0;
 8853              		.loc 31 134 0
 8854 000c 1967     		str	r1, [r3, #112]	@ float
 135:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].I = 0.0;
 136:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].D = 0.0;
 137:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ZAXIS_PID_IDX].P = 200.0;
 138:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ZAXIS_PID_IDX].I = 5.0;
 139:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ZAXIS_PID_IDX].D = 0.0;
 140:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].P = 3.0;
 141:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].I = 0.1;
 142:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].D = 0.0;
 143:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // AKA PID experiements
 144:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].P = 100.0;
 145:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].I = 0.0;
 146:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].D = -300.0;
 147:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].P = 100.0;
 148:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].I = 0.0;
 149:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].D = -300.0;
 150:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   rotationSpeedFactor = 1.0;
 8855              		.loc 31 150 0
 8856 000e 5049     		ldr	r1, .L573+8
 127:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].D = -300.0;
 8857              		.loc 31 127 0
 8858 0010 504E     		ldr	r6, .L573+12
 125:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].P = 100.0;
 8859              		.loc 31 125 0
 8860 0012 1860     		str	r0, [r3, #0]	@ float
 128:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].P = 100.0;
 8861              		.loc 31 128 0
 8862 0014 D861     		str	r0, [r3, #28]	@ float
 144:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].P = 100.0;
 8863              		.loc 31 144 0
 8864 0016 C3F8A800 		str	r0, [r3, #168]	@ float
 147:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].P = 100.0;
 8865              		.loc 31 147 0
 8866 001a C3F8C400 		str	r0, [r3, #196]	@ float
 8867              		.loc 31 150 0
 8868 001e 4FF07E50 		mov	r0, #1065353216
 137:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ZAXIS_PID_IDX].P = 200.0;
 8869              		.loc 31 137 0
 8870 0022 4D4D     		ldr	r5, .L573+16
 140:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].P = 3.0;
 8871              		.loc 31 140 0
 8872 0024 4D4C     		ldr	r4, .L573+20
 8873              		.loc 31 150 0
 8874 0026 0860     		str	r0, [r1, #0]	@ float
 151:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 152:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined (AltitudeHoldBaro)
 153:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].P = 25.0;
 8875              		.loc 31 153 0
 8876 0028 4D49     		ldr	r1, .L573+24
 127:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].D = -300.0;
 8877              		.loc 31 127 0
 8878 002a 9E60     		str	r6, [r3, #8]	@ float
 130:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].D = -300.0;
 8879              		.loc 31 130 0
 8880 002c 5E62     		str	r6, [r3, #36]	@ float
 146:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].D = -300.0;
 8881              		.loc 31 146 0
 8882 002e C3F8B060 		str	r6, [r3, #176]	@ float
 149:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].D = -300.0;
 8883              		.loc 31 149 0
 8884 0032 C3F8CC60 		str	r6, [r3, #204]	@ float
 154:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].I = 0.6;
 8885              		.loc 31 154 0
 8886 0036 4B4E     		ldr	r6, .L573+28
 137:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ZAXIS_PID_IDX].P = 200.0;
 8887              		.loc 31 137 0
 8888 0038 9D63     		str	r5, [r3, #56]	@ float
 140:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].P = 3.0;
 8889              		.loc 31 140 0
 8890 003a C3F88C40 		str	r4, [r3, #140]	@ float
 153:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].P = 25.0;
 8891              		.loc 31 153 0
 8892 003e C3F8E010 		str	r1, [r3, #224]	@ float
 141:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].I = 0.1;
 8893              		.loc 31 141 0
 8894 0042 494C     		ldr	r4, .L573+32
 155:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].D = 0.0;
 156:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard = 25.0; //this prevents the 0.1 I term to rise too 
 8895              		.loc 31 156 0
 8896 0044 C3F8F810 		str	r1, [r3, #248]	@ float
 138:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ZAXIS_PID_IDX].I = 5.0;
 8897              		.loc 31 138 0
 8898 0048 484D     		ldr	r5, .L573+36
 157:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[ZDAMPENING_PID_IDX].P = 0.0;
 158:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[ZDAMPENING_PID_IDX].I = 0.0;
 159:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[ZDAMPENING_PID_IDX].D = 0.0;
 160:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 161:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined (AltitudeHoldRangeFinder)
 162:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].P = 50.0;
 163:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].I = 0.6;
 164:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].D = 0.0;
 165:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].windupGuard = 25.0; //this prevents the 0.1 I term to rise too
 166:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 167:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 168:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 169:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 170:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     minThrottleAdjust = -50.0;
 8899              		.loc 31 170 0
 8900 004a 4949     		ldr	r1, .L573+40
 154:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].I = 0.6;
 8901              		.loc 31 154 0
 8902 004c C3F8E460 		str	r6, [r3, #228]	@ float
 126:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].I = 0.0;
 8903              		.loc 31 126 0
 8904 0050 0022     		movs	r2, #0
 8905              		.loc 31 170 0
 8906 0052 6FF03106 		mvn	r6, #49
 141:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].I = 0.1;
 8907              		.loc 31 141 0
 8908 0056 C3F89040 		str	r4, [r3, #144]	@ float
 126:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].I = 0.0;
 8909              		.loc 31 126 0
 8910 005a 5A60     		str	r2, [r3, #4]	@ float
 129:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].I = 0.0;
 8911              		.loc 31 129 0
 8912 005c 1A62     		str	r2, [r3, #32]	@ float
 132:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].I = 0.0;
 8913              		.loc 31 132 0
 8914 005e 9A65     		str	r2, [r3, #88]	@ float
 133:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].D = 0.0;
 8915              		.loc 31 133 0
 8916 0060 DA65     		str	r2, [r3, #92]	@ float
 135:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].I = 0.0;
 8917              		.loc 31 135 0
 8918 0062 5A67     		str	r2, [r3, #116]	@ float
 136:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].D = 0.0;
 8919              		.loc 31 136 0
 8920 0064 9A67     		str	r2, [r3, #120]	@ float
 138:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ZAXIS_PID_IDX].I = 5.0;
 8921              		.loc 31 138 0
 8922 0066 DD63     		str	r5, [r3, #60]	@ float
 139:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ZAXIS_PID_IDX].D = 0.0;
 8923              		.loc 31 139 0
 8924 0068 1A64     		str	r2, [r3, #64]	@ float
 142:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].D = 0.0;
 8925              		.loc 31 142 0
 8926 006a C3F89420 		str	r2, [r3, #148]	@ float
 145:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].I = 0.0;
 8927              		.loc 31 145 0
 8928 006e C3F8AC20 		str	r2, [r3, #172]	@ float
 148:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].I = 0.0;
 8929              		.loc 31 148 0
 8930 0072 C3F8C820 		str	r2, [r3, #200]	@ float
 155:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].D = 0.0;
 8931              		.loc 31 155 0
 8932 0076 C3F8E820 		str	r2, [r3, #232]	@ float
 157:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[ZDAMPENING_PID_IDX].P = 0.0;
 8933              		.loc 31 157 0
 8934 007a C3F8FC20 		str	r2, [r3, #252]	@ float
 158:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[ZDAMPENING_PID_IDX].I = 0.0;
 8935              		.loc 31 158 0
 8936 007e C3F80021 		str	r2, [r3, #256]	@ float
 159:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[ZDAMPENING_PID_IDX].D = 0.0;
 8937              		.loc 31 159 0
 8938 0082 C3F80421 		str	r2, [r3, #260]	@ float
 8939              		.loc 31 170 0
 8940 0086 0E60     		str	r6, [r1, #0]
 171:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     maxThrottleAdjust = 50.0; //we don't want it to be able to take over totally
 8941              		.loc 31 171 0
 8942 0088 3A49     		ldr	r1, .L573+44
 8943 008a 3226     		movs	r6, #50
 8944 008c 0E60     		str	r6, [r1, #0]
 172:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #if defined AltitudeHoldBaro
 173:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       baroSmoothFactor = 0.1;
 8945              		.loc 31 173 0
 8946 008e 3A49     		ldr	r1, .L573+48
 8947 0090 0C60     		str	r4, [r1, #0]	@ float
 174:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #endif
 175:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     altitudeHoldBump = 90;
 8948              		.loc 31 175 0
 8949 0092 3A49     		ldr	r1, .L573+52
 8950 0094 5A26     		movs	r6, #90
 8951 0096 0E60     		str	r6, [r1, #0]
 176:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     altitudeHoldPanicStickMovement = 250;
 8952              		.loc 31 176 0
 8953 0098 394E     		ldr	r6, .L573+56
 8954 009a FA24     		movs	r4, #250
 8955 009c 3460     		str	r4, [r6, #0]
 177:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 178:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 179:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Gyro Cal
 180:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[XAXIS] = 0.0;
 8956              		.loc 31 180 0
 8957 009e 394E     		ldr	r6, .L573+60
 181:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[YAXIS] = 0.0;
 182:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[ZAXIS] = 0.0;
 183:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** //  gyroTempBiasSlope[XAXIS] = 0.0;
 184:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** //  gyroTempBiasSlope[YAXIS] = 0.0;
 185:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** //  gyroTempBiasSlope[ZAXIS] = 0.0;
 186:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** //  gyroTempBiasIntercept[XAXIS] = 0.0;
 187:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** //  gyroTempBiasIntercept[YAXIS] = 0.0;
 188:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** //  gyroTempBiasIntercept[ZAXIS] = 0.0;
 189:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 190:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Accel Cal
 191:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[XAXIS] = 1.0;
 8958              		.loc 31 191 0
 8959 00a0 394C     		ldr	r4, .L573+64
 180:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[XAXIS] = 0.0;
 8960              		.loc 31 180 0
 8961 00a2 0021     		movs	r1, #0
 8962 00a4 3160     		str	r1, [r6, #0]
 181:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[YAXIS] = 0.0;
 8963              		.loc 31 181 0
 8964 00a6 7160     		str	r1, [r6, #4]
 182:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[ZAXIS] = 0.0;
 8965              		.loc 31 182 0
 8966 00a8 B160     		str	r1, [r6, #8]
 192:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[XAXIS] = 0.0;
 8967              		.loc 31 192 0
 8968 00aa 3849     		ldr	r1, .L573+68
 193:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[YAXIS] = 1.0;
 194:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[YAXIS] = 0.0;
 195:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[ZAXIS] = 1.0;
 196:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[ZAXIS] = 0.0;
 197:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 198:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef HeadingMagHold
 199:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magScale[XAXIS] = 1.0;
 8969              		.loc 31 199 0
 8970 00ac 384E     		ldr	r6, .L573+72
 192:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[XAXIS] = 0.0;
 8971              		.loc 31 192 0
 8972 00ae 0A60     		str	r2, [r1, #0]	@ float
 194:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[YAXIS] = 0.0;
 8973              		.loc 31 194 0
 8974 00b0 4A60     		str	r2, [r1, #4]	@ float
 196:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[ZAXIS] = 0.0;
 8975              		.loc 31 196 0
 8976 00b2 8A60     		str	r2, [r1, #8]	@ float
 200:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magBias[XAXIS] = 0.0;
 8977              		.loc 31 200 0
 8978 00b4 3749     		ldr	r1, .L573+76
 191:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[XAXIS] = 1.0;
 8979              		.loc 31 191 0
 8980 00b6 2060     		str	r0, [r4, #0]	@ float
 199:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magScale[XAXIS] = 1.0;
 8981              		.loc 31 199 0
 8982 00b8 3060     		str	r0, [r6, #0]	@ float
 8983              		.loc 31 200 0
 8984 00ba 0A60     		str	r2, [r1, #0]	@ float
 193:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[YAXIS] = 1.0;
 8985              		.loc 31 193 0
 8986 00bc 6060     		str	r0, [r4, #4]	@ float
 195:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[ZAXIS] = 1.0;
 8987              		.loc 31 195 0
 8988 00be A060     		str	r0, [r4, #8]	@ float
 201:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magScale[YAXIS] = 1.0;
 8989              		.loc 31 201 0
 8990 00c0 7060     		str	r0, [r6, #4]	@ float
 202:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magBias[YAXIS] = 0.0;
 203:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magScale[ZAXIS] = 1.0;
 204:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magBias[ZAXIS] = 0.0;
 205:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 206:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   windupGuard = 1000.0;
 8991              		.loc 31 206 0
 8992 00c2 354C     		ldr	r4, .L573+80
 202:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magBias[YAXIS] = 0.0;
 8993              		.loc 31 202 0
 8994 00c4 4A60     		str	r2, [r1, #4]	@ float
 203:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magScale[ZAXIS] = 1.0;
 8995              		.loc 31 203 0
 8996 00c6 B060     		str	r0, [r6, #8]	@ float
 204:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magBias[ZAXIS] = 0.0;
 8997              		.loc 31 204 0
 8998 00c8 8A60     		str	r2, [r1, #8]	@ float
 8999              		.loc 31 206 0
 9000 00ca 344E     		ldr	r6, .L573+84
 207:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 208:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // AKA - added so that each PID has its own windupGuard, will need to be removed once each PID's 
 209:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for (byte i = XAXIS; i < LAST_PID_IDX; i++ ) {
 210:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #if defined AltitudeHoldBaro
 211:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       if (i != BARO_ALTITUDE_HOLD_PID_IDX) {
 212:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****         PID[i].windupGuard = windupGuard;
 213:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       }
 214:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #else
 215:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       PID[i].windupGuard = windupGuard;
 216:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #endif
 217:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
 218:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     
 219:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   receiverXmitFactor = 1.0;
 9001              		.loc 31 219 0
 9002 00cc 3449     		ldr	r1, .L573+88
 206:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   windupGuard = 1000.0;
 9003              		.loc 31 206 0
 9004 00ce 2660     		str	r6, [r4, #0]	@ float
 9005              	.LVL421:
 9006              	.LBB278:
 212:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****         PID[i].windupGuard = windupGuard;
 9007              		.loc 31 212 0
 9008 00d0 9E61     		str	r6, [r3, #24]	@ float
 9009              	.LVL422:
 9010 00d2 5E63     		str	r6, [r3, #52]	@ float
 9011              	.LVL423:
 9012 00d4 1E65     		str	r6, [r3, #80]	@ float
 9013              	.LVL424:
 9014 00d6 DE66     		str	r6, [r3, #108]	@ float
 9015              	.LVL425:
 9016 00d8 C3F88860 		str	r6, [r3, #136]	@ float
 9017              	.LVL426:
 9018 00dc C3F8A460 		str	r6, [r3, #164]	@ float
 9019              	.LVL427:
 9020 00e0 C3F8C060 		str	r6, [r3, #192]	@ float
 9021              	.LVL428:
 9022 00e4 C3F8DC60 		str	r6, [r3, #220]	@ float
 9023              	.LVL429:
 9024 00e8 C3F81461 		str	r6, [r3, #276]	@ float
 9025              	.LVL430:
 9026              	.LBE278:
 9027              		.loc 31 219 0
 9028 00ec 0860     		str	r0, [r1, #0]	@ float
 220:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   minArmedThrottle = 1150;
 9029              		.loc 31 220 0
 9030 00ee 2D4E     		ldr	r6, .L573+92
 221:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // AKA - old setOneG not in SI - accel->setOneG(500);
 222:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelOneG = -9.80665; // AKA set one G to 9.8 m/s^2
 9031              		.loc 31 222 0
 9032 00f0 2D49     		ldr	r1, .L573+96
 9033 00f2 2E4B     		ldr	r3, .L573+100
 220:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   minArmedThrottle = 1150;
 9034              		.loc 31 220 0
 9035 00f4 40F27E44 		movw	r4, #1150
 9036 00f8 3460     		str	r4, [r6, #0]
 9037              		.loc 31 222 0
 9038 00fa 1960     		str	r1, [r3, #0]	@ float
 9039              	.LVL431:
 9040 00fc 2C4E     		ldr	r6, .L573+104
 9041 00fe 2D4C     		ldr	r4, .L573+108
 9042 0100 2D49     		ldr	r1, .L573+112
 9043 0102 0823     		movs	r3, #8
 9044              	.LVL432:
 9045              	.L571:
 9046              	.LBB279:
 223:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for (byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 224:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     receiverSlope[channel] = 1.0;
 225:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     receiverOffset[channel] = 0.0;
 226:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     receiverSmoothFactor[channel] = 1.0;
 9047              		.loc 31 226 0 discriminator 2
 9048 0104 013B     		subs	r3, r3, #1
 9049 0106 DBB2     		uxtb	r3, r3
 224:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     receiverSlope[channel] = 1.0;
 9050              		.loc 31 224 0 discriminator 2
 9051 0108 46F8040F 		str	r0, [r6, #4]!	@ float
 225:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     receiverOffset[channel] = 0.0;
 9052              		.loc 31 225 0 discriminator 2
 9053 010c 44F8042F 		str	r2, [r4, #4]!	@ float
 9054              		.loc 31 226 0 discriminator 2
 9055 0110 41F8040F 		str	r0, [r1, #4]!	@ float
 223:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for (byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 9056              		.loc 31 223 0 discriminator 2
 9057 0114 002B     		cmp	r3, #0
 9058 0116 F5D1     		bne	.L571
 9059              	.LBE279:
 227:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
 228:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   receiverSmoothFactor[ZAXIS] = 0.5;
 229:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 230:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   flightMode = RATE_FLIGHT_MODE;
 9060              		.loc 31 230 0
 9061 0118 2848     		ldr	r0, .L573+116
 228:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   receiverSmoothFactor[ZAXIS] = 0.5;
 9062              		.loc 31 228 0
 9063 011a 2949     		ldr	r1, .L573+120
 9064              		.loc 31 230 0
 9065 011c 0370     		strb	r3, [r0, #0]
 231:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   headingHoldConfig = ON;
 9066              		.loc 31 231 0
 9067 011e 294B     		ldr	r3, .L573+124
 232:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   aref = 5.0; // Use 3.0 if using a v1.7 shield or use 2.8 for an AeroQuad Shield < v1.7
 233:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 234:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Battery Monitor
 235:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef BattMonitor
 236:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     batteryMonitorAlarmVoltage = 3.33;
 9068              		.loc 31 236 0
 9069 0120 2948     		ldr	r0, .L573+128
 231:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   headingHoldConfig = ON;
 9070              		.loc 31 231 0
 9071 0122 0122     		movs	r2, #1
 9072 0124 1A70     		strb	r2, [r3, #0]
 228:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   receiverSmoothFactor[ZAXIS] = 0.5;
 9073              		.loc 31 228 0
 9074 0126 4FF07C5C 		mov	ip, #1056964608
 9075              		.loc 31 236 0
 9076 012a 284A     		ldr	r2, .L573+132
 228:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   receiverSmoothFactor[ZAXIS] = 0.5;
 9077              		.loc 31 228 0
 9078 012c C1F808C0 		str	ip, [r1, #8]	@ float
 232:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   aref = 5.0; // Use 3.0 if using a v1.7 shield or use 2.8 for an AeroQuad Shield < v1.7
 9079              		.loc 31 232 0
 9080 0130 2749     		ldr	r1, .L573+136
 9081              		.loc 31 236 0
 9082 0132 0260     		str	r2, [r0, #0]	@ float
 237:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     batteryMonitorThrottleTarget = 1450;
 9083              		.loc 31 237 0
 9084 0134 274B     		ldr	r3, .L573+140
 238:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     batteryMonitorGoingDownTime = 60000;
 9085              		.loc 31 238 0
 9086 0136 2848     		ldr	r0, .L573+144
 232:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   aref = 5.0; // Use 3.0 if using a v1.7 shield or use 2.8 for an AeroQuad Shield < v1.7
 9087              		.loc 31 232 0
 9088 0138 0D60     		str	r5, [r1, #0]	@ float
 9089              		.loc 31 238 0
 9090 013a 4EF66022 		movw	r2, #60000
 237:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     batteryMonitorThrottleTarget = 1450;
 9091              		.loc 31 237 0
 9092 013e 40F2AA51 		movw	r1, #1450
 9093 0142 1960     		str	r1, [r3, #0]
 9094              		.loc 31 238 0
 9095 0144 0260     		str	r2, [r0, #0]
 9096              	.LBE280:
 239:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 240:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 241:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Range Finder
 242:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined (AltitudeHoldRangeFinder)
 243:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     maxRangeFinderRange = 4.5;
 244:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     minRangeFinderRange = 0.0;
 245:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 246:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 247:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined (UseGPSNavigator)
 248:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     missionNbPoint = 0;
 249:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSROLL_PID_IDX].P = 0.8;
 250:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSROLL_PID_IDX].I = 0.0;
 251:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSROLL_PID_IDX].D = 0.0;
 252:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSPITCH_PID_IDX].P = 0.8;
 253:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSPITCH_PID_IDX].I = 0.0;
 254:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSPITCH_PID_IDX].D = 0.0;
 255:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSYAW_PID_IDX].P = 50.0;
 256:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSYAW_PID_IDX].I = 0.0;
 257:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSYAW_PID_IDX].D = 0.0;
 258:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 259:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     for (byte location = 0; location < MAX_WAYPOINTS; location++) {
 260:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       waypoint[location].longitude = GPS_INVALID_ANGLE;
 261:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       waypoint[location].latitude = GPS_INVALID_ANGLE;
 262:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       waypoint[location].altitude = GPS_INVALID_ALTITUDE;
 263:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     }
 264:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 265:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 266:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Camera Control
 267:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef CameraControl
 268:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     cameraMode = 1;
 269:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     mCameraPitch = 1273.2;    
 270:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     mCameraRoll = 636.6;    
 271:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     mCameraYaw = 318.3;
 272:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoCenterPitch = 1500;
 273:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoCenterRoll = 1500;
 274:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoCenterYaw = 1500;
 275:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMinPitch = 1000;
 276:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMinRoll = 1000;
 277:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMinYaw = 1000;
 278:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMaxPitch = 2000;
 279:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMaxRoll = 2000;
 280:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMaxYaw = 2000;
 281:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 282:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** }
 9097              		.loc 31 282 0
 9098 0146 70BD     		pop	{r4, r5, r6, pc}
 9099              	.L574:
 9100              		.align	2
 9101              	.L573:
 9102 0148 00000000 		.word	.LANCHOR17
 9103 014c 0000C842 		.word	1120403456
 9104 0150 00000000 		.word	.LANCHOR127
 9105 0154 000096C3 		.word	-1013579776
 9106 0158 00004843 		.word	1128792064
 9107 015c 00004040 		.word	1077936128
 9108 0160 0000C841 		.word	1103626240
 9109 0164 9A99193F 		.word	1058642330
 9110 0168 CDCCCC3D 		.word	1036831949
 9111 016c 0000A040 		.word	1084227584
 9112 0170 00000000 		.word	.LANCHOR124
 9113 0174 00000000 		.word	.LANCHOR125
 9114 0178 00000000 		.word	.LANCHOR97
 9115 017c 00000000 		.word	.LANCHOR8
 9116 0180 00000000 		.word	.LANCHOR126
 9117 0184 00000000 		.word	.LANCHOR31
 9118 0188 00000000 		.word	.LANCHOR35
 9119 018c 00000000 		.word	.LANCHOR36
 9120 0190 00000000 		.word	.LANCHOR75
 9121 0194 00000000 		.word	.LANCHOR76
 9122 0198 00000000 		.word	.LANCHOR142
 9123 019c 00007A44 		.word	1148846080
 9124 01a0 00000000 		.word	.LANCHOR61
 9125 01a4 00000000 		.word	.LANCHOR132
 9126 01a8 0AE81CC1 		.word	-1055070198
 9127 01ac 00000000 		.word	.LANCHOR39
 9128 01b0 FCFFFFFF 		.word	.LANCHOR12-4
 9129 01b4 FCFFFFFF 		.word	.LANCHOR13-4
 9130 01b8 FCFFFFFF 		.word	.LANCHOR14-4
 9131 01bc 00000000 		.word	.LANCHOR120
 9132 01c0 00000000 		.word	.LANCHOR14
 9133 01c4 00000000 		.word	.LANCHOR135
 9134 01c8 00000000 		.word	.LANCHOR144
 9135 01cc B81E5540 		.word	1079320248
 9136 01d0 00000000 		.word	.LANCHOR143
 9137 01d4 00000000 		.word	.LANCHOR145
 9138 01d8 00000000 		.word	.LANCHOR146
 9139              		.cfi_endproc
 9140              	.LFE249:
 9142              		.section	.text._Z10readEEPROMv,"ax",%progbits
 9143              		.align	1
 9144              		.global	_Z10readEEPROMv
 9145              		.thumb
 9146              		.thumb_func
 9148              	_Z10readEEPROMv:
 9149              	.LFB250:
 283:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 284:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void readEEPROM() {
 9150              		.loc 31 284 0
 9151              		.cfi_startproc
 9152              		@ args = 0, pretend = 0, frame = 0
 9153              		@ frame_needed = 0, uses_anonymous_args = 0
 9154              	.LBB281:
 285:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   readPID(XAXIS, ROLL_PID_GAIN_ADR);
 9155              		.loc 31 285 0
 9156 0000 0020     		movs	r0, #0
 9157              	.LBE281:
 284:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void readEEPROM() {
 9158              		.loc 31 284 0
 9159 0002 70B5     		push	{r4, r5, r6, lr}
 9160              	.LCFI91:
 9161              		.cfi_def_cfa_offset 16
 9162              		.cfi_offset 14, -4
 9163              		.cfi_offset 6, -8
 9164              		.cfi_offset 5, -12
 9165              		.cfi_offset 4, -16
 9166              	.LBB284:
 9167              		.loc 31 285 0
 9168 0004 0146     		mov	r1, r0
 9169 0006 FFF7FEFF 		bl	_Z10nvrReadPIDhj
 286:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   readPID(YAXIS, PITCH_PID_GAIN_ADR);
 9170              		.loc 31 286 0
 9171 000a 0120     		movs	r0, #1
 9172 000c 2421     		movs	r1, #36
 9173 000e FFF7FEFF 		bl	_Z10nvrReadPIDhj
 287:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   readPID(ZAXIS, YAW_PID_GAIN_ADR);
 9174              		.loc 31 287 0
 9175 0012 0220     		movs	r0, #2
 9176 0014 1821     		movs	r1, #24
 9177 0016 FFF7FEFF 		bl	_Z10nvrReadPIDhj
 288:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   readPID(ATTITUDE_XAXIS_PID_IDX, LEVELROLL_PID_GAIN_ADR);
 9178              		.loc 31 288 0
 9179 001a 0320     		movs	r0, #3
 9180 001c 0C21     		movs	r1, #12
 9181 001e FFF7FEFF 		bl	_Z10nvrReadPIDhj
 289:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   readPID(ATTITUDE_YAXIS_PID_IDX, LEVELPITCH_PID_GAIN_ADR);
 9182              		.loc 31 289 0
 9183 0022 0420     		movs	r0, #4
 9184 0024 3021     		movs	r1, #48
 9185 0026 FFF7FEFF 		bl	_Z10nvrReadPIDhj
 290:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   readPID(HEADING_HOLD_PID_IDX, HEADING_PID_GAIN_ADR);
 9186              		.loc 31 290 0
 9187 002a 0520     		movs	r0, #5
 9188 002c 3C21     		movs	r1, #60
 9189 002e FFF7FEFF 		bl	_Z10nvrReadPIDhj
 291:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   readPID(ATTITUDE_GYRO_XAXIS_PID_IDX, LEVEL_GYRO_ROLL_PID_GAIN_ADR);
 9190              		.loc 31 291 0
 9191 0032 0620     		movs	r0, #6
 9192 0034 4821     		movs	r1, #72
 9193 0036 FFF7FEFF 		bl	_Z10nvrReadPIDhj
 292:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   readPID(ATTITUDE_GYRO_YAXIS_PID_IDX, LEVEL_GYRO_PITCH_PID_GAIN_ADR);
 9194              		.loc 31 292 0
 9195 003a 5421     		movs	r1, #84
 9196 003c 0720     		movs	r0, #7
 9197 003e FFF7FEFF 		bl	_Z10nvrReadPIDhj
 293:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   rotationSpeedFactor = readFloat(ROTATION_SPEED_FACTOR_ARD);
 9198              		.loc 31 294 0
 9199 0042 4FF4A070 		mov	r0, #320
 9200 0046 FFF7FEFF 		bl	_Z12nvrReadFloati
 9201 004a 614C     		ldr	r4, .L576
 295:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 296:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Leaving separate PID reads as commented for now
 297:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Previously had issue where EEPROM was not reading right data
 298:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 299:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     readPID(BARO_ALTITUDE_HOLD_PID_IDX, ALTITUDE_PID_GAIN_ADR);
 300:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard = readFloat(ALTITUDE_WINDUP_ADR);
 301:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #if defined AltitudeHoldBaro
 302:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       baroSmoothFactor = readFloat(ALTITUDE_SMOOTH_ADR);
 303:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #endif  
 304:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     altitudeHoldBump = readFloat(ALTITUDE_BUMP_ADR);
 305:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     altitudeHoldPanicStickMovement = readFloat(ALTITUDE_PANIC_ADR);
 306:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     minThrottleAdjust = readFloat(ALTITUDE_MIN_THROTTLE_ADR);
 9202              		.loc 31 306 0
 9203 004c 614E     		ldr	r6, .L576+4
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   rotationSpeedFactor = readFloat(ROTATION_SPEED_FACTOR_ARD);
 9204              		.loc 31 294 0
 9205 004e 2060     		str	r0, [r4, #0]	@ float
 299:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     readPID(BARO_ALTITUDE_HOLD_PID_IDX, ALTITUDE_PID_GAIN_ADR);
 9206              		.loc 31 299 0
 9207 0050 6021     		movs	r1, #96
 9208 0052 0820     		movs	r0, #8
 9209 0054 FFF7FEFF 		bl	_Z10nvrReadPIDhj
 300:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard = readFloat(ALTITUDE_WINDUP_ADR);
 9210              		.loc 31 300 0
 9211 0058 4FF49470 		mov	r0, #296
 9212 005c FFF7FEFF 		bl	_Z12nvrReadFloati
 9213 0060 5D4C     		ldr	r4, .L576+8
 307:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     maxThrottleAdjust = readFloat(ALTITUDE_MAX_THROTTLE_ADR);
 9214              		.loc 31 307 0
 9215 0062 5E4D     		ldr	r5, .L576+12
 300:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard = readFloat(ALTITUDE_WINDUP_ADR);
 9216              		.loc 31 300 0
 9217 0064 C4F8F800 		str	r0, [r4, #248]	@ float
 302:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       baroSmoothFactor = readFloat(ALTITUDE_SMOOTH_ADR);
 9218              		.loc 31 302 0
 9219 0068 4FF49270 		mov	r0, #292
 9220 006c FFF7FEFF 		bl	_Z12nvrReadFloati
 9221 0070 5B4B     		ldr	r3, .L576+16
 9222 0072 1860     		str	r0, [r3, #0]	@ float
 304:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     altitudeHoldBump = readFloat(ALTITUDE_BUMP_ADR);
 9223              		.loc 31 304 0
 9224 0074 4FF49670 		mov	r0, #300
 9225 0078 FFF7FEFF 		bl	_Z12nvrReadFloati
 9226 007c 00EE100A 		fmsr	s0, r0
 9227 0080 5848     		ldr	r0, .L576+20
 9228 0082 FDEEC07A 		ftosizs	s15, s0
 9229 0086 C0ED007A 		fsts	s15, [r0, #0]	@ int
 305:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     altitudeHoldPanicStickMovement = readFloat(ALTITUDE_PANIC_ADR);
 9230              		.loc 31 305 0
 9231 008a 4FF49870 		mov	r0, #304
 9232 008e FFF7FEFF 		bl	_Z12nvrReadFloati
 9233 0092 07EE100A 		fmsr	s14, r0
 9234 0096 544A     		ldr	r2, .L576+24
 9235 0098 FDEEC76A 		ftosizs	s13, s14
 306:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     minThrottleAdjust = readFloat(ALTITUDE_MIN_THROTTLE_ADR);
 9236              		.loc 31 306 0
 9237 009c 4FF49070 		mov	r0, #288
 305:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     altitudeHoldPanicStickMovement = readFloat(ALTITUDE_PANIC_ADR);
 9238              		.loc 31 305 0
 9239 00a0 C2ED006A 		fsts	s13, [r2, #0]	@ int
 306:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     minThrottleAdjust = readFloat(ALTITUDE_MIN_THROTTLE_ADR);
 9240              		.loc 31 306 0
 9241 00a4 FFF7FEFF 		bl	_Z12nvrReadFloati
 9242 00a8 06EE100A 		fmsr	s12, r0
 9243 00ac FDEEC65A 		ftosizs	s11, s12
 9244              		.loc 31 307 0
 9245 00b0 4FF48E70 		mov	r0, #284
 306:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     minThrottleAdjust = readFloat(ALTITUDE_MIN_THROTTLE_ADR);
 9246              		.loc 31 306 0
 9247 00b4 C6ED005A 		fsts	s11, [r6, #0]	@ int
 9248              		.loc 31 307 0
 9249 00b8 FFF7FEFF 		bl	_Z12nvrReadFloati
 9250 00bc 05EE100A 		fmsr	s10, r0
 9251 00c0 FDEEC54A 		ftosizs	s9, s10
 308:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     readPID(ZDAMPENING_PID_IDX, ZDAMP_PID_GAIN_ADR);
 9252              		.loc 31 308 0
 9253 00c4 0920     		movs	r0, #9
 307:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     maxThrottleAdjust = readFloat(ALTITUDE_MAX_THROTTLE_ADR);
 9254              		.loc 31 307 0
 9255 00c6 C5ED004A 		fsts	s9, [r5, #0]	@ int
 9256              		.loc 31 308 0
 9257 00ca 6C21     		movs	r1, #108
 9258 00cc FFF7FEFF 		bl	_Z10nvrReadPIDhj
 309:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 310:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 311:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Mag calibration
 312:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef HeadingMagHold
 313:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magBias[XAXIS]  = readFloat(XAXIS_MAG_BIAS_ADR);
 9259              		.loc 31 313 0
 9260 00d0 4FF4AE70 		mov	r0, #348
 9261 00d4 FFF7FEFF 		bl	_Z12nvrReadFloati
 9262 00d8 444E     		ldr	r6, .L576+28
 314:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magScale[XAXIS] = readFloat(XAXIS_MAG_SCALE_FACTOR_ADR);
 9263              		.loc 31 314 0
 9264 00da 454D     		ldr	r5, .L576+32
 313:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magBias[XAXIS]  = readFloat(XAXIS_MAG_BIAS_ADR);
 9265              		.loc 31 313 0
 9266 00dc 3060     		str	r0, [r6, #0]	@ float
 9267              		.loc 31 314 0
 9268 00de 4FF4B070 		mov	r0, #352
 9269 00e2 FFF7FEFF 		bl	_Z12nvrReadFloati
 9270 00e6 2860     		str	r0, [r5, #0]	@ float
 315:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magBias[YAXIS]  = readFloat(YAXIS_MAG_BIAS_ADR);
 9271              		.loc 31 315 0
 9272 00e8 4FF4B270 		mov	r0, #356
 9273 00ec FFF7FEFF 		bl	_Z12nvrReadFloati
 9274 00f0 7060     		str	r0, [r6, #4]	@ float
 316:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magScale[YAXIS] = readFloat(YAXIS_MAG_SCALE_FACTOR_ADR);
 9275              		.loc 31 316 0
 9276 00f2 4FF4B470 		mov	r0, #360
 9277 00f6 FFF7FEFF 		bl	_Z12nvrReadFloati
 9278 00fa 6860     		str	r0, [r5, #4]	@ float
 317:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magBias[ZAXIS]  = readFloat(ZAXIS_MAG_BIAS_ADR);
 9279              		.loc 31 317 0
 9280 00fc 4FF4B670 		mov	r0, #364
 9281 0100 FFF7FEFF 		bl	_Z12nvrReadFloati
 9282 0104 B060     		str	r0, [r6, #8]	@ float
 318:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magScale[ZAXIS] = readFloat(ZAXIS_MAG_SCALE_FACTOR_ADR);
 9283              		.loc 31 318 0
 9284 0106 4FF4B870 		mov	r0, #368
 9285 010a FFF7FEFF 		bl	_Z12nvrReadFloati
 9286 010e A860     		str	r0, [r5, #8]	@ float
 319:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 320:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 321:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Battery Monitor
 322:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef BattMonitor
 323:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     batteryMonitorAlarmVoltage = readFloat(BATT_ALARM_VOLTAGE_ADR);
 9287              		.loc 31 323 0
 9288 0110 4FF4BA70 		mov	r0, #372
 9289 0114 FFF7FEFF 		bl	_Z12nvrReadFloati
 9290 0118 3649     		ldr	r1, .L576+36
 9291 011a 0860     		str	r0, [r1, #0]	@ float
 324:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     batteryMonitorThrottleTarget = readFloat(BATT_THROTTLE_TARGET_ADR);
 9292              		.loc 31 324 0
 9293 011c 4FF4BC70 		mov	r0, #376
 9294 0120 FFF7FEFF 		bl	_Z12nvrReadFloati
 9295 0124 04EE100A 		fmsr	s8, r0
 9296 0128 334B     		ldr	r3, .L576+40
 9297 012a FDEEC43A 		ftosizs	s7, s8
 325:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     batteryMonitorGoingDownTime = readFloat(BATT_DOWN_TIME_ADR);
 9298              		.loc 31 325 0
 9299 012e 4FF4BE70 		mov	r0, #380
 324:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     batteryMonitorThrottleTarget = readFloat(BATT_THROTTLE_TARGET_ADR);
 9300              		.loc 31 324 0
 9301 0132 C3ED003A 		fsts	s7, [r3, #0]	@ int
 9302              		.loc 31 325 0
 9303 0136 FFF7FEFF 		bl	_Z12nvrReadFloati
 9304 013a 03EE100A 		fmsr	s6, r0
 9305 013e 2F48     		ldr	r0, .L576+44
 9306 0140 FCEEC32A 		ftouizs	s5, s6
 9307 0144 C0ED002A 		fsts	s5, [r0, #0]	@ int
 326:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 327:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 328:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   windupGuard = readFloat(WINDUPGUARD_ADR);
 9308              		.loc 31 328 0
 9309 0148 4FF48070 		mov	r0, #256
 9310 014c FFF7FEFF 		bl	_Z12nvrReadFloati
 9311 0150 2B4A     		ldr	r2, .L576+48
 9312              	.LBB282:
 329:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // AKA - added so that each PID has its own windupGuard, will need to be removed once each PID's 
 330:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for (byte i = XAXIS; i < LAST_PID_IDX; i++ ) {
 331:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #if defined AltitudeHoldBaro
 332:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       if (i != BARO_ALTITUDE_HOLD_PID_IDX) {
 333:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****         PID[i].windupGuard = windupGuard;
 9313              		.loc 31 333 0
 9314 0152 A061     		str	r0, [r4, #24]	@ float
 9315              	.LBE282:
 328:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   windupGuard = readFloat(WINDUPGUARD_ADR);
 9316              		.loc 31 328 0
 9317 0154 1060     		str	r0, [r2, #0]	@ float
 9318              	.LVL433:
 9319              	.LBB283:
 9320              		.loc 31 333 0
 9321 0156 6063     		str	r0, [r4, #52]	@ float
 9322              	.LVL434:
 9323 0158 2065     		str	r0, [r4, #80]	@ float
 9324              	.LVL435:
 9325 015a E066     		str	r0, [r4, #108]	@ float
 9326              	.LVL436:
 9327 015c C4F88800 		str	r0, [r4, #136]	@ float
 9328              	.LVL437:
 9329 0160 C4F8A400 		str	r0, [r4, #164]	@ float
 9330              	.LVL438:
 9331 0164 C4F8C000 		str	r0, [r4, #192]	@ float
 9332              	.LVL439:
 9333 0168 C4F8DC00 		str	r0, [r4, #220]	@ float
 9334              	.LVL440:
 9335 016c C4F81401 		str	r0, [r4, #276]	@ float
 9336              	.LVL441:
 9337              	.LBE283:
 334:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       }
 335:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #else
 336:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       PID[i].windupGuard = windupGuard;
 337:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #endif      
 338:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
 339:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     
 340:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   minArmedThrottle = readFloat(MINARMEDTHROTTLE_ADR);
 9338              		.loc 31 340 0
 9339 0170 4FF48470 		mov	r0, #264
 9340 0174 FFF7FEFF 		bl	_Z12nvrReadFloati
 9341 0178 02EE100A 		fmsr	s4, r0
 9342 017c 2149     		ldr	r1, .L576+52
 9343 017e FDEEC21A 		ftosizs	s3, s4
 341:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   aref = readFloat(AREF_ADR);
 9344              		.loc 31 341 0
 9345 0182 4FF48670 		mov	r0, #268
 340:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   minArmedThrottle = readFloat(MINARMEDTHROTTLE_ADR);
 9346              		.loc 31 340 0
 9347 0186 C1ED001A 		fsts	s3, [r1, #0]	@ int
 9348              		.loc 31 341 0
 9349 018a FFF7FEFF 		bl	_Z12nvrReadFloati
 9350 018e 1E4B     		ldr	r3, .L576+56
 9351 0190 1860     		str	r0, [r3, #0]	@ float
 342:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   flightMode = readFloat(FLIGHTMODE_ADR);
 9352              		.loc 31 342 0
 9353 0192 4FF48870 		mov	r0, #272
 9354 0196 FFF7FEFF 		bl	_Z12nvrReadFloati
 9355 019a 01EE100A 		fmsr	s2, r0
 9356 019e FCEEC10A 		ftouizs	s1, s2
 9357 01a2 1A48     		ldr	r0, .L576+60
 9358 01a4 10EE902A 		fmrs	r2, s1	@ int
 9359 01a8 0270     		strb	r2, [r0, #0]
 343:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelOneG = readFloat(ACCEL_1G_ADR);
 9360              		.loc 31 343 0
 9361 01aa 4FF48C70 		mov	r0, #280
 9362 01ae FFF7FEFF 		bl	_Z12nvrReadFloati
 9363 01b2 1749     		ldr	r1, .L576+64
 9364 01b4 0860     		str	r0, [r1, #0]	@ float
 344:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   headingHoldConfig = readFloat(HEADINGHOLD_ADR);
 9365              		.loc 31 344 0
 9366 01b6 4FF48A70 		mov	r0, #276
 9367 01ba FFF7FEFF 		bl	_Z12nvrReadFloati
 9368 01be 00EE100A 		fmsr	s0, r0
 9369 01c2 FCEEC07A 		ftouizs	s15, s0
 9370 01c6 134B     		ldr	r3, .L576+68
 9371 01c8 17EE900A 		fmrs	r0, s15	@ int
 9372 01cc 1870     		strb	r0, [r3, #0]
 9373              	.LBE284:
 345:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 346:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Range Finder
 347:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined (AltitudeHoldRangeFinder)
 348:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** //    maxRangeFinderRange = readFloat(RANGE_FINDER_MAX_ADR);  // @Kenny @todo, remove this!
 349:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** //    minRangeFinderRange = readFloat(RANGE_FINDER_MIN_ADR);
 350:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif     
 351:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 352:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined (UseGPSNavigator)
 353:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     missionNbPoint = readFloat(GPS_MISSION_NB_POINT_ADR);
 354:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     readPID(GPSROLL_PID_IDX, GPSROLL_PID_GAIN_ADR);
 355:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     readPID(GPSPITCH_PID_IDX, GPSPITCH_PID_GAIN_ADR);
 356:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     readPID(GPSYAW_PID_IDX, GPSYAW_PID_GAIN_ADR);
 357:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     
 358:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     for (byte location = 0; location < MAX_WAYPOINTS; location++) {
 359:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       waypoint[location].longitude = readLong(WAYPOINT_ADR[location].longitude);
 360:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       waypoint[location].latitude = readLong(WAYPOINT_ADR[location].latitude);
 361:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       waypoint[location].altitude = readLong(WAYPOINT_ADR[location].altitude);
 362:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     }    
 363:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 364:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 365:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Camera Control
 366:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef CameraControl
 367:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     cameraMode = readFloat(CAMERAMODE_ADR);
 368:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     mCameraPitch = readFloat(MCAMERAPITCH_ADR);
 369:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     mCameraRoll = readFloat(MCAMERAROLL_ADR);    
 370:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     mCameraYaw = readFloat(MCAMERAYAW_ADR);
 371:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoCenterPitch = readFloat(SERVOCENTERPITCH_ADR);
 372:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoCenterRoll = readFloat(SERVOCENTERROLL_ADR);
 373:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoCenterYaw = readFloat(SERVOCENTERYAW_ADR);
 374:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMinPitch = readFloat(SERVOMINPITCH_ADR);
 375:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMinRoll = readFloat(SERVOMINROLL_ADR);
 376:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMinYaw = readFloat(SERVOMINYAW_ADR);
 377:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMaxPitch = readFloat(SERVOMAXPITCH_ADR);
 378:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMaxRoll = readFloat(SERVOMAXROLL_ADR);
 379:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMaxYaw = readFloat(SERVOMAXYAW_ADR);
 380:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif   
 381:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** }
 9374              		.loc 31 381 0
 9375 01ce 70BD     		pop	{r4, r5, r6, pc}
 9376              	.L577:
 9377              		.align	2
 9378              	.L576:
 9379 01d0 00000000 		.word	.LANCHOR127
 9380 01d4 00000000 		.word	.LANCHOR124
 9381 01d8 00000000 		.word	.LANCHOR17
 9382 01dc 00000000 		.word	.LANCHOR125
 9383 01e0 00000000 		.word	.LANCHOR97
 9384 01e4 00000000 		.word	.LANCHOR8
 9385 01e8 00000000 		.word	.LANCHOR126
 9386 01ec 00000000 		.word	.LANCHOR76
 9387 01f0 00000000 		.word	.LANCHOR75
 9388 01f4 00000000 		.word	.LANCHOR144
 9389 01f8 00000000 		.word	.LANCHOR145
 9390 01fc 00000000 		.word	.LANCHOR146
 9391 0200 00000000 		.word	.LANCHOR142
 9392 0204 00000000 		.word	.LANCHOR132
 9393 0208 00000000 		.word	.LANCHOR143
 9394 020c 00000000 		.word	.LANCHOR120
 9395 0210 00000000 		.word	.LANCHOR39
 9396 0214 00000000 		.word	.LANCHOR135
 9397              		.cfi_endproc
 9398              	.LFE250:
 9400              		.section	.text._Z11writeEEPROMv,"ax",%progbits
 9401              		.align	1
 9402              		.global	_Z11writeEEPROMv
 9403              		.thumb
 9404              		.thumb_func
 9406              	_Z11writeEEPROMv:
 9407              	.LFB251:
 382:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 383:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void writeEEPROM(){
 9408              		.loc 31 383 0
 9409              		.cfi_startproc
 9410              		@ args = 0, pretend = 0, frame = 0
 9411              		@ frame_needed = 0, uses_anonymous_args = 0
 9412 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 9413              	.LCFI92:
 9414              		.cfi_def_cfa_offset 24
 9415              		.cfi_offset 14, -4
 9416              		.cfi_offset 7, -8
 9417              		.cfi_offset 6, -12
 9418              		.cfi_offset 5, -16
 9419              		.cfi_offset 4, -20
 9420              		.cfi_offset 3, -24
 9421              	.LBB291:
 9422              	.LBB292:
 9423              	.LBB293:
 9424              		.file 32 "../Libmaple/libmaple/libmaple/nvic.h"
   1:../Libmaple/libmaple/libmaple/nvic.h **** /******************************************************************************
   2:../Libmaple/libmaple/libmaple/nvic.h ****  * The MIT License
   3:../Libmaple/libmaple/libmaple/nvic.h ****  *
   4:../Libmaple/libmaple/libmaple/nvic.h ****  * Copyright (c) 2010 Perry Hung.
   5:../Libmaple/libmaple/libmaple/nvic.h ****  *
   6:../Libmaple/libmaple/libmaple/nvic.h ****  * Permission is hereby granted, free of charge, to any person
   7:../Libmaple/libmaple/libmaple/nvic.h ****  * obtaining a copy of this software and associated documentation
   8:../Libmaple/libmaple/libmaple/nvic.h ****  * files (the "Software"), to deal in the Software without
   9:../Libmaple/libmaple/libmaple/nvic.h ****  * restriction, including without limitation the rights to use, copy,
  10:../Libmaple/libmaple/libmaple/nvic.h ****  * modify, merge, publish, distribute, sublicense, and/or sell copies
  11:../Libmaple/libmaple/libmaple/nvic.h ****  * of the Software, and to permit persons to whom the Software is
  12:../Libmaple/libmaple/libmaple/nvic.h ****  * furnished to do so, subject to the following conditions:
  13:../Libmaple/libmaple/libmaple/nvic.h ****  *
  14:../Libmaple/libmaple/libmaple/nvic.h ****  * The above copyright notice and this permission notice shall be
  15:../Libmaple/libmaple/libmaple/nvic.h ****  * included in all copies or substantial portions of the Software.
  16:../Libmaple/libmaple/libmaple/nvic.h ****  *
  17:../Libmaple/libmaple/libmaple/nvic.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  18:../Libmaple/libmaple/libmaple/nvic.h ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  19:../Libmaple/libmaple/libmaple/nvic.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20:../Libmaple/libmaple/libmaple/nvic.h ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  21:../Libmaple/libmaple/libmaple/nvic.h ****  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  22:../Libmaple/libmaple/libmaple/nvic.h ****  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  23:../Libmaple/libmaple/libmaple/nvic.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  24:../Libmaple/libmaple/libmaple/nvic.h ****  * SOFTWARE.
  25:../Libmaple/libmaple/libmaple/nvic.h ****  *****************************************************************************/
  26:../Libmaple/libmaple/libmaple/nvic.h **** 
  27:../Libmaple/libmaple/libmaple/nvic.h **** /**
  28:../Libmaple/libmaple/libmaple/nvic.h ****  * @file nvic.h
  29:../Libmaple/libmaple/libmaple/nvic.h ****  * @brief Nested vector interrupt controller support.
  30:../Libmaple/libmaple/libmaple/nvic.h ****  *
  31:../Libmaple/libmaple/libmaple/nvic.h ****  * Basic usage:
  32:../Libmaple/libmaple/libmaple/nvic.h ****  *
  33:../Libmaple/libmaple/libmaple/nvic.h ****  * @code
  34:../Libmaple/libmaple/libmaple/nvic.h ****  *   // Initialise the interrupt controller and point to the vector
  35:../Libmaple/libmaple/libmaple/nvic.h ****  *   // table at the start of flash.
  36:../Libmaple/libmaple/libmaple/nvic.h ****  *   nvic_init(0x08000000, 0);
  37:../Libmaple/libmaple/libmaple/nvic.h ****  *   // Bind in a timer interrupt handler
  38:../Libmaple/libmaple/libmaple/nvic.h ****  *   timer_attach_interrupt(TIMER_CC1_INTERRUPT, handler);
  39:../Libmaple/libmaple/libmaple/nvic.h ****  *   // Optionally set the priority
  40:../Libmaple/libmaple/libmaple/nvic.h ****  *   nvic_irq_set_priority(NVIC_TIMER1_CC, 5);
  41:../Libmaple/libmaple/libmaple/nvic.h ****  *   // All done, enable all interrupts
  42:../Libmaple/libmaple/libmaple/nvic.h ****  *   nvic_globalirq_enable();
  43:../Libmaple/libmaple/libmaple/nvic.h ****  * @endcode
  44:../Libmaple/libmaple/libmaple/nvic.h ****  */
  45:../Libmaple/libmaple/libmaple/nvic.h **** 
  46:../Libmaple/libmaple/libmaple/nvic.h **** #ifndef _NVIC_H_
  47:../Libmaple/libmaple/libmaple/nvic.h **** #define _NVIC_H_
  48:../Libmaple/libmaple/libmaple/nvic.h **** 
  49:../Libmaple/libmaple/libmaple/nvic.h **** #include "libmaple_types.h"
  50:../Libmaple/libmaple/libmaple/nvic.h **** #include "util.h"
  51:../Libmaple/libmaple/libmaple/nvic.h **** 
  52:../Libmaple/libmaple/libmaple/nvic.h **** #ifdef __cplusplus
  53:../Libmaple/libmaple/libmaple/nvic.h **** extern "C"{
  54:../Libmaple/libmaple/libmaple/nvic.h **** #endif
  55:../Libmaple/libmaple/libmaple/nvic.h **** 
  56:../Libmaple/libmaple/libmaple/nvic.h **** /** NVIC register map type. */
  57:../Libmaple/libmaple/libmaple/nvic.h **** typedef struct nvic_reg_map {
  58:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 ISER[8];      /**< Interrupt Set Enable Registers */
  59:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RESERVED0[24];     /**< Reserved */
  60:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 ICER[8];      /**< Interrupt Clear Enable Registers */
  61:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RSERVED1[24];      /**< Reserved */
  62:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 ISPR[8];      /**< Interrupt Set Pending Registers */
  63:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RESERVED2[24];     /**< Reserved */
  64:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 ICPR[8];      /**< Interrupt Clear Pending Registers */
  65:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RESERVED3[24];     /**< Reserved */
  66:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 IABR[8];      /**< Interrupt Active bit Registers */
  67:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RESERVED4[56];     /**< Reserved */
  68:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint8  IP[240];      /**< Interrupt Priority Registers */
  69:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RESERVED5[644];    /**< Reserved */
  70:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 STIR;         /**< Software Trigger Interrupt Registers */
  71:../Libmaple/libmaple/libmaple/nvic.h **** } nvic_reg_map;
  72:../Libmaple/libmaple/libmaple/nvic.h **** 
  73:../Libmaple/libmaple/libmaple/nvic.h **** /** NVIC register map base pointer. */
  74:../Libmaple/libmaple/libmaple/nvic.h **** #define NVIC_BASE                       ((struct nvic_reg_map*)0xE000E100)
  75:../Libmaple/libmaple/libmaple/nvic.h **** 
  76:../Libmaple/libmaple/libmaple/nvic.h **** /**
  77:../Libmaple/libmaple/libmaple/nvic.h ****  * @brief Interrupt vector table interrupt numbers.
  78:../Libmaple/libmaple/libmaple/nvic.h ****  *
  79:../Libmaple/libmaple/libmaple/nvic.h ****  * Each positive-valued enumerator is the position of the
  80:../Libmaple/libmaple/libmaple/nvic.h ****  * corresponding interrupt in the vector table.  Negative-valued
  81:../Libmaple/libmaple/libmaple/nvic.h ****  * enumerators correspond to interrupts controlled by the system
  82:../Libmaple/libmaple/libmaple/nvic.h ****  * handler block.
  83:../Libmaple/libmaple/libmaple/nvic.h ****  *
  84:../Libmaple/libmaple/libmaple/nvic.h ****  * @see scb.h
  85:../Libmaple/libmaple/libmaple/nvic.h ****  */
  86:../Libmaple/libmaple/libmaple/nvic.h **** typedef enum nvic_irq_num {
  87:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_NMI            = -14,  /**< Non-maskable interrupt */
  88:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_HARDFAULT      = -13,  /**< Hard fault (all class of fault) */
  89:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_MEM_MANAGE     = -12,  /**< Memory management */
  90:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_BUS_FAULT      = -11,  /**< Bus fault: prefetch fault, memory
  91:../Libmaple/libmaple/libmaple/nvic.h ****                                      access fault. */
  92:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USAGE_FAULT    = -10,  /**< Usage fault: Undefined instruction or
  93:../Libmaple/libmaple/libmaple/nvic.h ****                                      illegal state. */
  94:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SVC            = -5,   /**< System service call via SWI insruction */
  95:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DEBUG_MON      = -4,   /**< Debug monitor */
  96:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_PEND_SVC       = -2,   /**< Pendable request for system service */
  97:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SYSTICK        = -1,   /**< System tick timer */
  98:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_WWDG           = 0,    /**< Window watchdog interrupt */
  99:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_PVD            = 1,    /**< PVD through EXTI line detection */
 100:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TAMPER         = 2,    /**< Tamper */
 101:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_RTC            = 3,    /**< Real-time clock */
 102:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_FLASH          = 4,    /**< Flash */
 103:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_RCC            = 5,    /**< Reset and clock control */
 104:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI0          = 6,    /**< EXTI line 0 */
 105:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI1          = 7,    /**< EXTI line 1 */
 106:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI2          = 8,    /**< EXTI line 2 */
 107:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI3          = 9,    /**< EXTI line 3 */
 108:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI4          = 10,   /**< EXTI line 4 */
 109:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH1        = 11,   /**< DMA1 channel 1 */
 110:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH2        = 12,   /**< DMA1 channel 2 */
 111:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH3        = 13,   /**< DMA1 channel 3 */
 112:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH4        = 14,   /**< DMA1 channel 4 */
 113:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH5        = 15,   /**< DMA1 channel 5 */
 114:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH6        = 16,   /**< DMA1 channel 6 */
 115:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH7        = 17,   /**< DMA1 channel 7 */
 116:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_ADC_1_2        = 18,   /**< ADC1 and ADC2 */
 117:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USB_HP_CAN_TX  = 19,   /**< USB high priority or CAN TX */
 118:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USB_LP_CAN_RX0 = 20,   /**< USB low priority or CAN RX0 */
 119:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_CAN_RX1        = 21,   /**< CAN RX1 */
 120:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_CAN_SCE        = 22,   /**< CAN SCE */
 121:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI_9_5       = 23,   /**< EXTI line [9:5] */
 122:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER1_BRK     = 24,   /**< Timer 1 break */
 123:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER1_UP      = 25,   /**< Timer 1 update */
 124:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER1_TRG_COM = 26,   /**< Timer 1 trigger and commutation */
 125:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER1_CC      = 27,   /**< Timer 1 capture/compare */
 126:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER2         = 28,   /**< Timer 2 */
 127:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER3         = 29,   /**< Timer 3 */
 128:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER4         = 30,   /**< Timer 4 */
 129:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_I2C1_EV        = 31,   /**< I2C1 event */
 130:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_I2C1_ER        = 32,   /**< I2C1 error */
 131:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_I2C2_EV        = 33,   /**< I2C2 event */
 132:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_I2C2_ER        = 34,   /**< I2C2 error */
 133:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SPI1           = 35,   /**< SPI1 */
 134:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SPI2           = 36,   /**< SPI2 */
 135:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USART1         = 37,   /**< USART1 */
 136:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USART2         = 38,   /**< USART2 */
 137:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USART3         = 39,   /**< USART3 */
 138:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI_15_10     = 40,   /**< EXTI line [15:10] */
 139:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_RTCALARM       = 41,   /**< RTC alarm through EXTI line */
 140:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USBWAKEUP      = 42,   /**< USB wakeup from suspend through
 141:../Libmaple/libmaple/libmaple/nvic.h ****                                      EXTI line */
 142:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER8_BRK     = 43,   /**< Timer 8 break */
 143:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER8_UP      = 44,   /**< Timer 8 update */
 144:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER8_TRG_COM = 45,   /**< Timer 8 trigger and commutation */
 145:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER8_CC      = 46,   /**< Timer 8 capture/compare */
 146:../Libmaple/libmaple/libmaple/nvic.h **** #ifdef STM32_HIGH_DENSITY
 147:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_ADC3           = 47,   /**< ADC3 */
 148:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_FSMC           = 48,   /**< FSMC */
 149:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SDIO           = 49,   /**< SDIO */
 150:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER5         = 50,   /**< Timer 5 */
 151:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SPI3           = 51,   /**< SPI3 */
 152:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_UART4          = 52,   /**< UART4 */
 153:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_UART5          = 53,   /**< UART5 */
 154:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER6         = 54,   /**< Timer 6 */
 155:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER7         = 55,   /**< Timer 7 */
 156:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA2_CH1       = 56,   /**< DMA2 channel 1 */
 157:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA2_CH2       = 57,   /**< DMA2 channel 2 */
 158:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA2_CH3       = 58,   /**< DMA2 channel 3 */
 159:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA2_CH_4_5    = 59,   /**< DMA2 channels 4 and 5 */
 160:../Libmaple/libmaple/libmaple/nvic.h **** #endif
 161:../Libmaple/libmaple/libmaple/nvic.h **** } nvic_irq_num;
 162:../Libmaple/libmaple/libmaple/nvic.h **** 
 163:../Libmaple/libmaple/libmaple/nvic.h **** /*
 164:../Libmaple/libmaple/libmaple/nvic.h ****  * Initialises the interrupt controller and sets all interrupts to the
 165:../Libmaple/libmaple/libmaple/nvic.h ****  * lowest priority.
 166:../Libmaple/libmaple/libmaple/nvic.h ****  *
 167:../Libmaple/libmaple/libmaple/nvic.h ****  * For stand-alone products, the base address is normally the start of
 168:../Libmaple/libmaple/libmaple/nvic.h ****  * flash (0x08000000).
 169:../Libmaple/libmaple/libmaple/nvic.h ****  *
 170:../Libmaple/libmaple/libmaple/nvic.h ****  * @param vector_table_address  base address of the vector table
 171:../Libmaple/libmaple/libmaple/nvic.h ****  */
 172:../Libmaple/libmaple/libmaple/nvic.h **** void nvic_init(uint32 vector_table_address, uint32 offset);
 173:../Libmaple/libmaple/libmaple/nvic.h **** 
 174:../Libmaple/libmaple/libmaple/nvic.h **** /**
 175:../Libmaple/libmaple/libmaple/nvic.h ****  * Sets the base address of the vector table.
 176:../Libmaple/libmaple/libmaple/nvic.h ****  */
 177:../Libmaple/libmaple/libmaple/nvic.h **** void nvic_set_vector_table(uint32 address, uint32 offset);
 178:../Libmaple/libmaple/libmaple/nvic.h **** 
 179:../Libmaple/libmaple/libmaple/nvic.h **** void nvic_irq_set_priority(nvic_irq_num irqn, uint8 priority);
 180:../Libmaple/libmaple/libmaple/nvic.h **** 
 181:../Libmaple/libmaple/libmaple/nvic.h **** /**
 182:../Libmaple/libmaple/libmaple/nvic.h ****  * Enables interrupts and configurable fault handlers (clear PRIMASK).
 183:../Libmaple/libmaple/libmaple/nvic.h ****  */
 184:../Libmaple/libmaple/libmaple/nvic.h **** static inline void nvic_globalirq_enable() {
 185:../Libmaple/libmaple/libmaple/nvic.h ****     asm volatile("cpsie i");
 186:../Libmaple/libmaple/libmaple/nvic.h **** }
 187:../Libmaple/libmaple/libmaple/nvic.h **** 
 188:../Libmaple/libmaple/libmaple/nvic.h **** /**
 189:../Libmaple/libmaple/libmaple/nvic.h ****  * Disable interrupts and configurable fault handlers (set PRIMASK).
 190:../Libmaple/libmaple/libmaple/nvic.h ****  */
 191:../Libmaple/libmaple/libmaple/nvic.h **** static inline void nvic_globalirq_disable() {
 192:../Libmaple/libmaple/libmaple/nvic.h ****     asm volatile("cpsid i");
 9425              		.loc 32 192 0
 9426              	@ 192 "../Libmaple/libmaple/libmaple/nvic.h" 1
 9427 0002 72B6     		cpsid i
 9428              	@ 0 "" 2
 9429              		.thumb
 9430              	.LBE293:
 9431              	.LBE292:
 384:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   cli(); // Needed so that APM sensor data does not overflow
 385:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(XAXIS, ROLL_PID_GAIN_ADR);
 9432              		.loc 31 385 0
 9433 0004 0020     		movs	r0, #0
 9434 0006 0146     		mov	r1, r0
 9435 0008 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 386:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(YAXIS, PITCH_PID_GAIN_ADR);
 9436              		.loc 31 386 0
 9437 000c 0120     		movs	r0, #1
 9438 000e 2421     		movs	r1, #36
 9439 0010 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 387:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(ATTITUDE_XAXIS_PID_IDX, LEVELROLL_PID_GAIN_ADR);
 9440              		.loc 31 387 0
 9441 0014 0320     		movs	r0, #3
 9442 0016 0C21     		movs	r1, #12
 9443 0018 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 388:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(ATTITUDE_YAXIS_PID_IDX, LEVELPITCH_PID_GAIN_ADR);
 9444              		.loc 31 388 0
 9445 001c 0420     		movs	r0, #4
 9446 001e 3021     		movs	r1, #48
 9447 0020 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 389:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(ZAXIS, YAW_PID_GAIN_ADR);
 9448              		.loc 31 389 0
 9449 0024 0220     		movs	r0, #2
 9450 0026 1821     		movs	r1, #24
 9451 0028 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 390:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(HEADING_HOLD_PID_IDX, HEADING_PID_GAIN_ADR);
 9452              		.loc 31 390 0
 9453 002c 0520     		movs	r0, #5
 9454 002e 3C21     		movs	r1, #60
 9455 0030 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 391:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(ATTITUDE_GYRO_XAXIS_PID_IDX, LEVEL_GYRO_ROLL_PID_GAIN_ADR);
 392:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(ATTITUDE_GYRO_YAXIS_PID_IDX, LEVEL_GYRO_PITCH_PID_GAIN_ADR);
 393:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 394:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(rotationSpeedFactor,ROTATION_SPEED_FACTOR_ARD);
 9456              		.loc 31 394 0
 9457 0034 7A4E     		ldr	r6, .L581
 395:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 396:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined AltitudeHoldBaro
 397:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writePID(BARO_ALTITUDE_HOLD_PID_IDX, ALTITUDE_PID_GAIN_ADR);
 398:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard, ALTITUDE_WINDUP_ADR);
 399:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 400:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 401:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 402:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #if defined AltitudeHoldBaro
 403:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       writeFloat(baroSmoothFactor, ALTITUDE_SMOOTH_ADR);
 404:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #else
 405:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       writeFloat(0.0, ALTITUDE_SMOOTH_ADR);
 406:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #endif
 407:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(altitudeHoldBump, ALTITUDE_BUMP_ADR);
 9458              		.loc 31 407 0
 9459 0036 7B4D     		ldr	r5, .L581+4
 408:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(altitudeHoldPanicStickMovement, ALTITUDE_PANIC_ADR);
 409:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(minThrottleAdjust, ALTITUDE_MIN_THROTTLE_ADR);
 9460              		.loc 31 409 0
 9461 0038 7B4F     		ldr	r7, .L581+8
 391:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(ATTITUDE_GYRO_XAXIS_PID_IDX, LEVEL_GYRO_ROLL_PID_GAIN_ADR);
 9462              		.loc 31 391 0
 9463 003a 0620     		movs	r0, #6
 9464 003c 4821     		movs	r1, #72
 9465 003e FFF7FEFF 		bl	_Z11nvrWritePIDhj
 392:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(ATTITUDE_GYRO_YAXIS_PID_IDX, LEVEL_GYRO_PITCH_PID_GAIN_ADR);
 9466              		.loc 31 392 0
 9467 0042 0720     		movs	r0, #7
 9468 0044 5421     		movs	r1, #84
 9469 0046 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 394:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(rotationSpeedFactor,ROTATION_SPEED_FACTOR_ARD);
 9470              		.loc 31 394 0
 9471 004a 3068     		ldr	r0, [r6, #0]	@ float
 9472 004c 4FF4A071 		mov	r1, #320
 9473 0050 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 397:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writePID(BARO_ALTITUDE_HOLD_PID_IDX, ALTITUDE_PID_GAIN_ADR);
 9474              		.loc 31 397 0
 9475 0054 0820     		movs	r0, #8
 9476 0056 6021     		movs	r1, #96
 9477 0058 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 398:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard, ALTITUDE_WINDUP_ADR);
 9478              		.loc 31 398 0
 9479 005c 734A     		ldr	r2, .L581+12
 9480 005e 4FF49471 		mov	r1, #296
 9481 0062 D2F8F800 		ldr	r0, [r2, #248]	@ float
 9482 0066 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 403:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       writeFloat(baroSmoothFactor, ALTITUDE_SMOOTH_ADR);
 9483              		.loc 31 403 0
 9484 006a 7149     		ldr	r1, .L581+16
 9485 006c 0868     		ldr	r0, [r1, #0]	@ float
 9486 006e 4FF49271 		mov	r1, #292
 9487 0072 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 407:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(altitudeHoldBump, ALTITUDE_BUMP_ADR);
 9488              		.loc 31 407 0
 9489 0076 2C68     		ldr	r4, [r5, #0]
 410:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(maxThrottleAdjust, ALTITUDE_MAX_THROTTLE_ADR);
 411:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writePID(ZDAMPENING_PID_IDX, ZDAMP_PID_GAIN_ADR);
 412:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #else
 413:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(0.1, ALTITUDE_SMOOTH_ADR);
 414:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(90, ALTITUDE_BUMP_ADR);
 415:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(250, ALTITUDE_PANIC_ADR);
 416:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(-50, ALTITUDE_MIN_THROTTLE_ADR);
 417:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(50, ALTITUDE_MAX_THROTTLE_ADR);
 418:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(0.1, ALTITUDE_SMOOTH_ADR);
 419:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 420:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 421:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef HeadingMagHold
 422:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magBias[XAXIS], XAXIS_MAG_BIAS_ADR);
 9490              		.loc 31 422 0
 9491 0078 6E4D     		ldr	r5, .L581+20
 407:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(altitudeHoldBump, ALTITUDE_BUMP_ADR);
 9492              		.loc 31 407 0
 9493 007a 03EE104A 		fmsr	s6, r4	@ int
 9494 007e F8EEC32A 		fsitos	s5, s6
 9495 0082 4FF49671 		mov	r1, #300
 9496 0086 12EE900A 		fmrs	r0, s5
 9497 008a FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 408:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(altitudeHoldPanicStickMovement, ALTITUDE_PANIC_ADR);
 9498              		.loc 31 408 0
 9499 008e 6A48     		ldr	r0, .L581+24
 423:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magScale[XAXIS], XAXIS_MAG_SCALE_FACTOR_ADR);
 9500              		.loc 31 423 0
 9501 0090 6A4C     		ldr	r4, .L581+28
 408:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(altitudeHoldPanicStickMovement, ALTITUDE_PANIC_ADR);
 9502              		.loc 31 408 0
 9503 0092 0368     		ldr	r3, [r0, #0]
 9504 0094 02EE103A 		fmsr	s4, r3	@ int
 9505 0098 F8EEC21A 		fsitos	s3, s4
 9506 009c 4FF49871 		mov	r1, #304
 9507 00a0 11EE900A 		fmrs	r0, s3
 9508 00a4 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 409:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(minThrottleAdjust, ALTITUDE_MIN_THROTTLE_ADR);
 9509              		.loc 31 409 0
 9510 00a8 3E68     		ldr	r6, [r7, #0]
 424:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magBias[YAXIS], YAXIS_MAG_BIAS_ADR);
 425:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magScale[YAXIS], YAXIS_MAG_SCALE_FACTOR_ADR);
 426:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magBias[ZAXIS], ZAXIS_MAG_BIAS_ADR);
 427:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magScale[ZAXIS], ZAXIS_MAG_SCALE_FACTOR_ADR);
 428:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 429:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(windupGuard, WINDUPGUARD_ADR);
 430:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(receiverXmitFactor, XMITFACTOR_ADR);
 9511              		.loc 31 430 0
 9512 00aa 654F     		ldr	r7, .L581+32
 409:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(minThrottleAdjust, ALTITUDE_MIN_THROTTLE_ADR);
 9513              		.loc 31 409 0
 9514 00ac 01EE106A 		fmsr	s2, r6	@ int
 9515 00b0 F8EEC10A 		fsitos	s1, s2
 9516 00b4 4FF49071 		mov	r1, #288
 9517 00b8 10EE900A 		fmrs	r0, s1
 9518 00bc FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 410:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(maxThrottleAdjust, ALTITUDE_MAX_THROTTLE_ADR);
 9519              		.loc 31 410 0
 9520 00c0 604A     		ldr	r2, .L581+36
 9521              		.loc 31 430 0
 9522 00c2 614E     		ldr	r6, .L581+40
 410:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(maxThrottleAdjust, ALTITUDE_MAX_THROTTLE_ADR);
 9523              		.loc 31 410 0
 9524 00c4 1168     		ldr	r1, [r2, #0]
 9525 00c6 00EE101A 		fmsr	s0, r1	@ int
 9526 00ca F8EEC07A 		fsitos	s15, s0
 9527 00ce 4FF48E71 		mov	r1, #284
 9528 00d2 17EE900A 		fmrs	r0, s15
 9529 00d6 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 411:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writePID(ZDAMPENING_PID_IDX, ZDAMP_PID_GAIN_ADR);
 9530              		.loc 31 411 0
 9531 00da 0920     		movs	r0, #9
 9532 00dc 6C21     		movs	r1, #108
 9533 00de FFF7FEFF 		bl	_Z11nvrWritePIDhj
 422:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magBias[XAXIS], XAXIS_MAG_BIAS_ADR);
 9534              		.loc 31 422 0
 9535 00e2 2868     		ldr	r0, [r5, #0]	@ float
 9536 00e4 4FF4AE71 		mov	r1, #348
 9537 00e8 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 423:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magScale[XAXIS], XAXIS_MAG_SCALE_FACTOR_ADR);
 9538              		.loc 31 423 0
 9539 00ec 2068     		ldr	r0, [r4, #0]	@ float
 9540 00ee 4FF4B071 		mov	r1, #352
 9541 00f2 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 424:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magBias[YAXIS], YAXIS_MAG_BIAS_ADR);
 9542              		.loc 31 424 0
 9543 00f6 6868     		ldr	r0, [r5, #4]	@ float
 9544 00f8 4FF4B271 		mov	r1, #356
 9545 00fc FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 425:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magScale[YAXIS], YAXIS_MAG_SCALE_FACTOR_ADR);
 9546              		.loc 31 425 0
 9547 0100 6068     		ldr	r0, [r4, #4]	@ float
 9548 0102 4FF4B471 		mov	r1, #360
 9549 0106 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 426:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magBias[ZAXIS], ZAXIS_MAG_BIAS_ADR);
 9550              		.loc 31 426 0
 9551 010a A868     		ldr	r0, [r5, #8]	@ float
 9552              		.loc 31 430 0
 9553 010c 4F4D     		ldr	r5, .L581+44
 426:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magBias[ZAXIS], ZAXIS_MAG_BIAS_ADR);
 9554              		.loc 31 426 0
 9555 010e 4FF4B671 		mov	r1, #364
 9556 0112 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 427:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magScale[ZAXIS], ZAXIS_MAG_SCALE_FACTOR_ADR);
 9557              		.loc 31 427 0
 9558 0116 A068     		ldr	r0, [r4, #8]	@ float
 9559 0118 4FF4B871 		mov	r1, #368
 9560 011c FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 429:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(windupGuard, WINDUPGUARD_ADR);
 9561              		.loc 31 429 0
 9562 0120 4B48     		ldr	r0, .L581+48
 9563 0122 4FF48071 		mov	r1, #256
 9564 0126 0068     		ldr	r0, [r0, #0]	@ float
 9565 0128 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 9566              		.loc 31 430 0
 9567 012c 494B     		ldr	r3, .L581+52
 9568 012e 4FF48271 		mov	r1, #260
 9569 0132 1868     		ldr	r0, [r3, #0]	@ float
 9570 0134 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 9571              	.LVL442:
 9572 0138 0024     		movs	r4, #0
 9573              	.LVL443:
 9574              	.L579:
 9575              	.LBB294:
 431:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 432:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for(byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 433:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(receiverSlope[channel],  RECEIVER_DATA[channel].slope);
 9576              		.loc 31 433 0 discriminator 2
 9577 013a 04F19C01 		add	r1, r4, #156
 9578 013e 57F8040F 		ldr	r0, [r7, #4]!	@ float
 9579 0142 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 434:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(receiverOffset[channel], RECEIVER_DATA[channel].offset);
 9580              		.loc 31 434 0 discriminator 2
 9581 0146 04F1A001 		add	r1, r4, #160
 9582 014a 56F8040F 		ldr	r0, [r6, #4]!	@ float
 9583 014e FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 435:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(receiverSmoothFactor[channel], RECEIVER_DATA[channel].smooth_factor);
 9584              		.loc 31 435 0 discriminator 2
 9585 0152 04F1A401 		add	r1, r4, #164
 9586 0156 55F8040F 		ldr	r0, [r5, #4]!	@ float
 9587 015a 0C34     		adds	r4, r4, #12
 9588 015c FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 432:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for(byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 9589              		.loc 31 432 0 discriminator 2
 9590 0160 602C     		cmp	r4, #96
 9591 0162 EAD1     		bne	.L579
 9592              	.LBE294:
 436:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
 437:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 438:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(minArmedThrottle, MINARMEDTHROTTLE_ADR);
 9593              		.loc 31 438 0
 9594 0164 3C4B     		ldr	r3, .L581+56
 9595 0166 1A68     		ldr	r2, [r3, #0]
 9596 0168 00EE102A 		fmsr	s0, r2	@ int
 9597 016c F8EEC07A 		fsitos	s15, s0
 9598 0170 4FF48471 		mov	r1, #264
 9599 0174 17EE900A 		fmrs	r0, s15
 9600 0178 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 439:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(aref, AREF_ADR);
 9601              		.loc 31 439 0
 9602 017c 3749     		ldr	r1, .L581+60
 9603 017e 0868     		ldr	r0, [r1, #0]	@ float
 9604 0180 4FF48671 		mov	r1, #268
 9605 0184 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 440:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(flightMode, FLIGHTMODE_ADR);
 9606              		.loc 31 440 0
 9607 0188 3548     		ldr	r0, .L581+64
 9608 018a 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 9609 018c 07EE103A 		fmsr	s14, r3	@ int
 9610 0190 F8EE476A 		fuitos	s13, s14
 9611 0194 4FF48871 		mov	r1, #272
 9612 0198 16EE900A 		fmrs	r0, s13
 9613 019c FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 441:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(headingHoldConfig, HEADINGHOLD_ADR);
 9614              		.loc 31 441 0
 9615 01a0 304A     		ldr	r2, .L581+68
 9616 01a2 1178     		ldrb	r1, [r2, #0]	@ zero_extendqisi2
 9617 01a4 06EE101A 		fmsr	s12, r1	@ int
 9618 01a8 F8EE465A 		fuitos	s11, s12
 9619 01ac 4FF48A71 		mov	r1, #276
 9620 01b0 15EE900A 		fmrs	r0, s11
 9621 01b4 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 442:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(accelOneG, ACCEL_1G_ADR);
 9622              		.loc 31 442 0
 9623 01b8 2B48     		ldr	r0, .L581+72
 9624 01ba 4FF48C71 		mov	r1, #280
 9625 01be 0068     		ldr	r0, [r0, #0]	@ float
 9626 01c0 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 443:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(SOFTWARE_VERSION, SOFTWARE_VERSION_ADR);
 9627              		.loc 31 443 0
 9628 01c4 FC21     		movs	r1, #252
 9629 01c6 2948     		ldr	r0, .L581+76
 9630 01c8 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 444:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 445:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Battery Monitor
 446:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef BattMonitor
 447:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(batteryMonitorAlarmVoltage, BATT_ALARM_VOLTAGE_ADR);
 9631              		.loc 31 447 0
 9632 01cc 284B     		ldr	r3, .L581+80
 9633 01ce 4FF4BA71 		mov	r1, #372
 9634 01d2 1868     		ldr	r0, [r3, #0]	@ float
 9635 01d4 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 448:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(batteryMonitorThrottleTarget, BATT_THROTTLE_TARGET_ADR);
 9636              		.loc 31 448 0
 9637 01d8 264A     		ldr	r2, .L581+84
 9638 01da 1168     		ldr	r1, [r2, #0]
 9639 01dc 05EE101A 		fmsr	s10, r1	@ int
 9640 01e0 F8EEC54A 		fsitos	s9, s10
 9641 01e4 4FF4BC71 		mov	r1, #376
 9642 01e8 14EE900A 		fmrs	r0, s9
 9643 01ec FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 449:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(batteryMonitorGoingDownTime, BATT_DOWN_TIME_ADR);
 9644              		.loc 31 449 0
 9645 01f0 2148     		ldr	r0, .L581+88
 9646 01f2 0368     		ldr	r3, [r0, #0]
 9647 01f4 04EE103A 		fmsr	s8, r3	@ int
 9648 01f8 F8EE443A 		fuitos	s7, s8
 9649 01fc 4FF4BE71 		mov	r1, #380
 9650 0200 13EE900A 		fmrs	r0, s7
 9651 0204 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 450:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 451:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 452:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Range Finder
 453:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined (AltitudeHoldRangeFinder)
 454:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(maxRangeFinderRange, RANGE_FINDER_MAX_ADR);
 455:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(minRangeFinderRange, RANGE_FINDER_MIN_ADR);
 456:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #else
 457:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(0, RANGE_FINDER_MAX_ADR);
 9652              		.loc 31 457 0
 9653 0208 0020     		movs	r0, #0
 9654 020a 4FF4C071 		mov	r1, #384
 9655 020e FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 458:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(0, RANGE_FINDER_MIN_ADR);
 9656              		.loc 31 458 0
 9657 0212 0020     		movs	r0, #0
 9658 0214 4FF4C271 		mov	r1, #388
 9659 0218 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 9660              	.LBB295:
 9661              	.LBB296:
 185:../Libmaple/libmaple/libmaple/nvic.h ****     asm volatile("cpsie i");
 9662              		.loc 32 185 0
 9663              	@ 185 "../Libmaple/libmaple/libmaple/nvic.h" 1
 9664 021c 62B6     		cpsie i
 9665              	@ 0 "" 2
 9666              		.thumb
 9667              	.LBE296:
 9668              	.LBE295:
 9669              	.LBE291:
 459:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 460:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 461:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined (UseGPSNavigator)
 462:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(missionNbPoint, GPS_MISSION_NB_POINT_ADR);
 463:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writePID(GPSROLL_PID_IDX, GPSROLL_PID_GAIN_ADR);
 464:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writePID(GPSPITCH_PID_IDX, GPSPITCH_PID_GAIN_ADR);
 465:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writePID(GPSYAW_PID_IDX, GPSYAW_PID_GAIN_ADR);
 466:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     
 467:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     for (byte location = 0; location < MAX_WAYPOINTS; location++) {
 468:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       writeLong(waypoint[location].longitude, WAYPOINT_ADR[location].longitude);
 469:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       writeLong(waypoint[location].latitude, WAYPOINT_ADR[location].latitude);
 470:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       writeLong(waypoint[location].altitude, WAYPOINT_ADR[location].altitude);
 471:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     }       
 472:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 473:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 474:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     // Camera Control
 475:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef CameraControl
 476:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(cameraMode, CAMERAMODE_ADR);
 477:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(mCameraPitch, MCAMERAPITCH_ADR);
 478:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(mCameraRoll, MCAMERAROLL_ADR);    
 479:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(mCameraYaw, MCAMERAYAW_ADR);
 480:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoCenterPitch, SERVOCENTERPITCH_ADR);
 481:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoCenterRoll, SERVOCENTERROLL_ADR);
 482:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoCenterYaw, SERVOCENTERYAW_ADR);
 483:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoMinPitch, SERVOMINPITCH_ADR);
 484:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoMinRoll, SERVOMINROLL_ADR);
 485:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoMinYaw, SERVOMINYAW_ADR);
 486:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoMaxPitch, SERVOMAXPITCH_ADR);
 487:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoMaxRoll, SERVOMAXROLL_ADR);
 488:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoMaxYaw, SERVOMAXYAW_ADR);
 489:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif 
 490:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   sei(); // Restart interrupts
 491:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** }
 9670              		.loc 31 491 0
 9671 021e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 9672              	.L582:
 9673              		.align	2
 9674              	.L581:
 9675 0220 00000000 		.word	.LANCHOR127
 9676 0224 00000000 		.word	.LANCHOR8
 9677 0228 00000000 		.word	.LANCHOR124
 9678 022c 00000000 		.word	.LANCHOR17
 9679 0230 00000000 		.word	.LANCHOR97
 9680 0234 00000000 		.word	.LANCHOR76
 9681 0238 00000000 		.word	.LANCHOR126
 9682 023c 00000000 		.word	.LANCHOR75
 9683 0240 FCFFFFFF 		.word	.LANCHOR12-4
 9684 0244 00000000 		.word	.LANCHOR125
 9685 0248 FCFFFFFF 		.word	.LANCHOR13-4
 9686 024c FCFFFFFF 		.word	.LANCHOR14-4
 9687 0250 00000000 		.word	.LANCHOR142
 9688 0254 00000000 		.word	.LANCHOR61
 9689 0258 00000000 		.word	.LANCHOR132
 9690 025c 00000000 		.word	.LANCHOR143
 9691 0260 00000000 		.word	.LANCHOR120
 9692 0264 00000000 		.word	.LANCHOR135
 9693 0268 00000000 		.word	.LANCHOR39
 9694 026c 66664640 		.word	1078355558
 9695 0270 00000000 		.word	.LANCHOR144
 9696 0274 00000000 		.word	.LANCHOR145
 9697 0278 00000000 		.word	.LANCHOR146
 9698              		.cfi_endproc
 9699              	.LFE251:
 9701              		.section	.text._Z25initSensorsZeroFromEEPROMv,"ax",%progbits
 9702              		.align	1
 9703              		.global	_Z25initSensorsZeroFromEEPROMv
 9704              		.thumb
 9705              		.thumb_func
 9707              	_Z25initSensorsZeroFromEEPROMv:
 9708              	.LFB252:
 492:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 493:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void initSensorsZeroFromEEPROM() {
 9709              		.loc 31 493 0
 9710              		.cfi_startproc
 9711              		@ args = 0, pretend = 0, frame = 0
 9712              		@ frame_needed = 0, uses_anonymous_args = 0
 9713 0000 38B5     		push	{r3, r4, r5, lr}
 9714              	.LCFI93:
 9715              		.cfi_def_cfa_offset 16
 9716              		.cfi_offset 14, -4
 9717              		.cfi_offset 5, -8
 9718              		.cfi_offset 4, -12
 9719              		.cfi_offset 3, -16
 494:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Gyro initialization from EEPROM
 495:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[XAXIS] = readFloat(GYRO_ROLL_ZERO_ADR);
 9720              		.loc 31 495 0
 9721 0002 4FF49A70 		mov	r0, #308
 9722 0006 FFF7FEFF 		bl	_Z12nvrReadFloati
 9723 000a 02EE100A 		fmsr	s4, r0
 9724 000e 204C     		ldr	r4, .L584
 496:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[YAXIS] = readFloat(GYRO_PITCH_ZERO_ADR);
 497:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[ZAXIS] = readFloat(GYRO_YAW_ZERO_ADR);
 498:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 499:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Accel initialization from EEPROM
 500:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelOneG = readFloat(ACCEL_1G_ADR);
 501:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Accel calibration
 502:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[XAXIS] = readFloat(XAXIS_ACCEL_SCALE_FACTOR_ADR);
 9725              		.loc 31 502 0
 9726 0010 204D     		ldr	r5, .L584+4
 495:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[XAXIS] = readFloat(GYRO_ROLL_ZERO_ADR);
 9727              		.loc 31 495 0
 9728 0012 FDEEC21A 		ftosizs	s3, s4
 496:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[YAXIS] = readFloat(GYRO_PITCH_ZERO_ADR);
 9729              		.loc 31 496 0
 9730 0016 4FF49C70 		mov	r0, #312
 495:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[XAXIS] = readFloat(GYRO_ROLL_ZERO_ADR);
 9731              		.loc 31 495 0
 9732 001a C4ED001A 		fsts	s3, [r4, #0]	@ int
 496:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[YAXIS] = readFloat(GYRO_PITCH_ZERO_ADR);
 9733              		.loc 31 496 0
 9734 001e FFF7FEFF 		bl	_Z12nvrReadFloati
 9735 0022 01EE100A 		fmsr	s2, r0
 9736 0026 FDEEC10A 		ftosizs	s1, s2
 497:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[ZAXIS] = readFloat(GYRO_YAW_ZERO_ADR);
 9737              		.loc 31 497 0
 9738 002a 4FF49E70 		mov	r0, #316
 496:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[YAXIS] = readFloat(GYRO_PITCH_ZERO_ADR);
 9739              		.loc 31 496 0
 9740 002e C4ED010A 		fsts	s1, [r4, #4]	@ int
 497:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[ZAXIS] = readFloat(GYRO_YAW_ZERO_ADR);
 9741              		.loc 31 497 0
 9742 0032 FFF7FEFF 		bl	_Z12nvrReadFloati
 9743 0036 00EE100A 		fmsr	s0, r0
 9744 003a FDEEC07A 		ftosizs	s15, s0
 500:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelOneG = readFloat(ACCEL_1G_ADR);
 9745              		.loc 31 500 0
 9746 003e 4FF48C70 		mov	r0, #280
 497:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[ZAXIS] = readFloat(GYRO_YAW_ZERO_ADR);
 9747              		.loc 31 497 0
 9748 0042 C4ED027A 		fsts	s15, [r4, #8]	@ int
 500:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelOneG = readFloat(ACCEL_1G_ADR);
 9749              		.loc 31 500 0
 9750 0046 FFF7FEFF 		bl	_Z12nvrReadFloati
 9751 004a 134B     		ldr	r3, .L584+8
 503:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[XAXIS] = readFloat(XAXIS_ACCEL_BIAS_ADR);
 9752              		.loc 31 503 0
 9753 004c 134C     		ldr	r4, .L584+12
 500:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelOneG = readFloat(ACCEL_1G_ADR);
 9754              		.loc 31 500 0
 9755 004e 1860     		str	r0, [r3, #0]	@ float
 502:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[XAXIS] = readFloat(XAXIS_ACCEL_SCALE_FACTOR_ADR);
 9756              		.loc 31 502 0
 9757 0050 4FF4A470 		mov	r0, #328
 9758 0054 FFF7FEFF 		bl	_Z12nvrReadFloati
 9759 0058 2860     		str	r0, [r5, #0]	@ float
 9760              		.loc 31 503 0
 9761 005a 4FF4A270 		mov	r0, #324
 9762 005e FFF7FEFF 		bl	_Z12nvrReadFloati
 9763 0062 2060     		str	r0, [r4, #0]	@ float
 504:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[YAXIS] = readFloat(YAXIS_ACCEL_SCALE_FACTOR_ADR);
 9764              		.loc 31 504 0
 9765 0064 4FF4A870 		mov	r0, #336
 9766 0068 FFF7FEFF 		bl	_Z12nvrReadFloati
 9767 006c 6860     		str	r0, [r5, #4]	@ float
 505:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[YAXIS] = readFloat(YAXIS_ACCEL_BIAS_ADR);
 9768              		.loc 31 505 0
 9769 006e 4FF4A670 		mov	r0, #332
 9770 0072 FFF7FEFF 		bl	_Z12nvrReadFloati
 9771 0076 6060     		str	r0, [r4, #4]	@ float
 506:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[ZAXIS] = readFloat(ZAXIS_ACCEL_SCALE_FACTOR_ADR);
 9772              		.loc 31 506 0
 9773 0078 4FF4AC70 		mov	r0, #344
 9774 007c FFF7FEFF 		bl	_Z12nvrReadFloati
 9775 0080 A860     		str	r0, [r5, #8]	@ float
 507:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[ZAXIS] = readFloat(ZAXIS_ACCEL_BIAS_ADR);
 9776              		.loc 31 507 0
 9777 0082 4FF4AA70 		mov	r0, #340
 9778 0086 FFF7FEFF 		bl	_Z12nvrReadFloati
 9779 008a A060     		str	r0, [r4, #8]	@ float
 508:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** }
 9780              		.loc 31 508 0
 9781 008c 38BD     		pop	{r3, r4, r5, pc}
 9782              	.L585:
 9783 008e 00BF     		.align	2
 9784              	.L584:
 9785 0090 00000000 		.word	.LANCHOR31
 9786 0094 00000000 		.word	.LANCHOR35
 9787 0098 00000000 		.word	.LANCHOR39
 9788 009c 00000000 		.word	.LANCHOR36
 9789              		.cfi_endproc
 9790              	.LFE252:
 9792              		.section	.text._Z24storeSensorsZeroToEEPROMv,"ax",%progbits
 9793              		.align	1
 9794              		.global	_Z24storeSensorsZeroToEEPROMv
 9795              		.thumb
 9796              		.thumb_func
 9798              	_Z24storeSensorsZeroToEEPROMv:
 9799              	.LFB253:
 509:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 510:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void storeSensorsZeroToEEPROM() {
 9800              		.loc 31 510 0
 9801              		.cfi_startproc
 9802              		@ args = 0, pretend = 0, frame = 0
 9803              		@ frame_needed = 0, uses_anonymous_args = 0
 9804 0000 38B5     		push	{r3, r4, r5, lr}
 9805              	.LCFI94:
 9806              		.cfi_def_cfa_offset 16
 9807              		.cfi_offset 14, -4
 9808              		.cfi_offset 5, -8
 9809              		.cfi_offset 4, -12
 9810              		.cfi_offset 3, -16
 511:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Store gyro data to EEPROM
 512:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(gyroZero[XAXIS], GYRO_ROLL_ZERO_ADR);
 9811              		.loc 31 512 0
 9812 0002 244C     		ldr	r4, .L587
 513:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(gyroZero[YAXIS], GYRO_PITCH_ZERO_ADR);
 514:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(gyroZero[ZAXIS], GYRO_YAW_ZERO_ADR);
 515:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 516:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Store accel data to EEPROM
 517:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(accelOneG, ACCEL_1G_ADR);
 518:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Accel Cal
 519:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(accelScaleFactor[XAXIS], XAXIS_ACCEL_SCALE_FACTOR_ADR);
 9813              		.loc 31 519 0
 9814 0004 244D     		ldr	r5, .L587+4
 512:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(gyroZero[XAXIS], GYRO_ROLL_ZERO_ADR);
 9815              		.loc 31 512 0
 9816 0006 94ED002A 		flds	s4, [r4, #0]	@ int
 9817 000a F8EEC21A 		fsitos	s3, s4
 9818 000e 4FF49A71 		mov	r1, #308
 9819 0012 11EE900A 		fmrs	r0, s3
 9820 0016 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 513:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(gyroZero[YAXIS], GYRO_PITCH_ZERO_ADR);
 9821              		.loc 31 513 0
 9822 001a 94ED011A 		flds	s2, [r4, #4]	@ int
 9823 001e F8EEC10A 		fsitos	s1, s2
 9824 0022 4FF49C71 		mov	r1, #312
 9825 0026 10EE900A 		fmrs	r0, s1
 9826 002a FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 514:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(gyroZero[ZAXIS], GYRO_YAW_ZERO_ADR);
 9827              		.loc 31 514 0
 9828 002e A068     		ldr	r0, [r4, #8]
 520:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(runTimeAccelBias[XAXIS], XAXIS_ACCEL_BIAS_ADR);
 9829              		.loc 31 520 0
 9830 0030 1A4C     		ldr	r4, .L587+8
 514:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(gyroZero[ZAXIS], GYRO_YAW_ZERO_ADR);
 9831              		.loc 31 514 0
 9832 0032 00EE100A 		fmsr	s0, r0	@ int
 9833 0036 F8EEC07A 		fsitos	s15, s0
 9834 003a 4FF49E71 		mov	r1, #316
 9835 003e 17EE900A 		fmrs	r0, s15
 9836 0042 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 517:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(accelOneG, ACCEL_1G_ADR);
 9837              		.loc 31 517 0
 9838 0046 164B     		ldr	r3, .L587+12
 9839 0048 4FF48C71 		mov	r1, #280
 9840 004c 1868     		ldr	r0, [r3, #0]	@ float
 9841 004e FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 519:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(accelScaleFactor[XAXIS], XAXIS_ACCEL_SCALE_FACTOR_ADR);
 9842              		.loc 31 519 0
 9843 0052 2868     		ldr	r0, [r5, #0]	@ float
 9844 0054 4FF4A471 		mov	r1, #328
 9845 0058 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 9846              		.loc 31 520 0
 9847 005c 2068     		ldr	r0, [r4, #0]	@ float
 9848 005e 4FF4A271 		mov	r1, #324
 9849 0062 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 521:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(accelScaleFactor[YAXIS], YAXIS_ACCEL_SCALE_FACTOR_ADR);
 9850              		.loc 31 521 0
 9851 0066 6868     		ldr	r0, [r5, #4]	@ float
 9852 0068 4FF4A871 		mov	r1, #336
 9853 006c FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 522:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(runTimeAccelBias[YAXIS], YAXIS_ACCEL_BIAS_ADR);
 9854              		.loc 31 522 0
 9855 0070 6068     		ldr	r0, [r4, #4]	@ float
 9856 0072 4FF4A671 		mov	r1, #332
 9857 0076 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 523:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(accelScaleFactor[ZAXIS], ZAXIS_ACCEL_SCALE_FACTOR_ADR);
 9858              		.loc 31 523 0
 9859 007a A868     		ldr	r0, [r5, #8]	@ float
 9860 007c 4FF4AC71 		mov	r1, #344
 9861 0080 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 524:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(runTimeAccelBias[ZAXIS], ZAXIS_ACCEL_BIAS_ADR);
 9862              		.loc 31 524 0
 9863 0084 A068     		ldr	r0, [r4, #8]	@ float
 9864 0086 4FF4AA71 		mov	r1, #340
 525:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** }
 9865              		.loc 31 525 0
 9866 008a BDE83840 		pop	{r3, r4, r5, lr}
 524:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(runTimeAccelBias[ZAXIS], ZAXIS_ACCEL_BIAS_ADR);
 9867              		.loc 31 524 0
 9868 008e FFF7FEBF 		b	_Z13nvrWriteFloatfi
 9869              	.L588:
 9870 0092 00BF     		.align	2
 9871              	.L587:
 9872 0094 00000000 		.word	.LANCHOR31
 9873 0098 00000000 		.word	.LANCHOR35
 9874 009c 00000000 		.word	.LANCHOR36
 9875 00a0 00000000 		.word	.LANCHOR39
 9876              		.cfi_endproc
 9877              	.LFE253:
 9879              		.section	.text._Z17readPilotCommandsv,"ax",%progbits
 9880              		.align	1
 9881              		.global	_Z17readPilotCommandsv
 9882              		.thumb
 9883              		.thumb_func
 9885              	_Z17readPilotCommandsv:
 9886              	.LFB241:
 9887              		.file 33 "C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad/FlightCommandProcessor.h"
   1:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** /*
   2:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   AeroQuad v3.0.1 - February 2012
   3:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   www.AeroQuad.com
   4:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   An Open Source Arduino based multicopter.
   6:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  
   7:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   This program is free software: you can redistribute it and/or modify 
   8:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   it under the terms of the GNU General Public License as published by 
   9:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   (at your option) any later version. 
  11:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  12:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   This program is distributed in the hope that it will be useful, 
  13:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   GNU General Public License for more details. 
  16:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  17:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   You should have received a copy of the GNU General Public License 
  18:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** */
  20:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  21:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** // FlightCommand.pde is responsible for decoding transmitter stick combinations
  22:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** // for setting up AeroQuad modes such as motor arming and disarming
  23:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  24:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** #ifndef _AQ_FLIGHT_COMMAND_READER_
  25:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** #define _AQ_FLIGHT_COMMAND_READER_
  26:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  27:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  28:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** /**
  29:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  * readPilotCommands
  30:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  * 
  31:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  * This function is responsible to read receiver
  32:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  * and process command from the users
  33:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  */
  34:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** void readPilotCommands() {
 9888              		.loc 33 34 0
 9889              		.cfi_startproc
 9890              		@ args = 0, pretend = 0, frame = 0
 9891              		@ frame_needed = 0, uses_anonymous_args = 0
 9892 0000 70B5     		push	{r4, r5, r6, lr}
 9893              	.LCFI95:
 9894              		.cfi_def_cfa_offset 16
 9895              		.cfi_offset 14, -4
 9896              		.cfi_offset 6, -8
 9897              		.cfi_offset 5, -12
 9898              		.cfi_offset 4, -16
 9899              	.LBB297:
 9900              	.LBB298:
  35:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   
  36:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   readReceiver(); 
  37:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   if (receiverCommand[THROTTLE] < MINCHECK) {
 9901              		.loc 33 37 0
 9902 0002 444C     		ldr	r4, .L598
 9903 0004 444D     		ldr	r5, .L598+4
 9904              	.LBE298:
  36:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   readReceiver(); 
 9905              		.loc 33 36 0
 9906 0006 FFF7FEFF 		bl	_Z12readReceiverv
 9907              	.LBB304:
 9908              		.loc 33 37 0
 9909 000a E268     		ldr	r2, [r4, #12]
 9910 000c 40F24B43 		movw	r3, #1099
 9911 0010 9A42     		cmp	r2, r3
 9912 0012 44DC     		bgt	.L590
 9913              	.LBB299:
  38:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     // Disarm motors (left stick lower left corner)
  39:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     if (receiverCommand[ZAXIS] < MINCHECK && motorArmed == ON) {
 9914              		.loc 33 39 0
 9915 0014 A068     		ldr	r0, [r4, #8]
 9916 0016 9842     		cmp	r0, r3
 9917 0018 0ADC     		bgt	.L591
 9918              		.loc 33 39 0 is_stmt 0 discriminator 1
 9919 001a 404E     		ldr	r6, .L598+8
 9920 001c 3378     		ldrb	r3, [r6, #0]	@ zero_extendqisi2
 9921 001e 012B     		cmp	r3, #1
 9922 0020 06D1     		bne	.L591
  40:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       commandAllMotors(MINCOMMAND);
 9923              		.loc 33 40 0 is_stmt 1
 9924 0022 4FF47A70 		mov	r0, #1000
 9925 0026 FFF7FEFF 		bl	_Z16commandAllMotorsi
  41:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       motorArmed = OFF;
 9926              		.loc 33 41 0
 9927 002a 0021     		movs	r1, #0
 9928 002c 3170     		strb	r1, [r6, #0]
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       inFlight = false;
 9929              		.loc 33 42 0
 9930 002e 2970     		strb	r1, [r5, #0]
 9931              	.L591:
  43:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             
  44:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       #ifdef OSD
  45:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         notifyOSD(OSD_CENTER|OSD_WARN, "MOTORS UNARMED");
  46:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       #endif
  47:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       
  48:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       #if defined BattMonitorAutoDescent
  49:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         batteryMonitorAlarmCounter = 0;
  50:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         batteryMonitorStartThrottle = 0;
  51:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         batteyMonitorThrottleCorrection = 0.0;
  52:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       #endif
  53:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     }    
  54:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     
  55:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     // Zero Gyro and Accel sensors (left stick lower left, right stick lower right corner)
  56:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     if ((receiverCommand[ZAXIS] < MINCHECK) && (receiverCommand[XAXIS] > MAXCHECK) && (receiverComm
 9932              		.loc 33 56 0
 9933 0030 A068     		ldr	r0, [r4, #8]
 9934 0032 384A     		ldr	r2, .L598
 9935 0034 40F24B43 		movw	r3, #1099
 9936 0038 9842     		cmp	r0, r3
 9937 003a 12DC     		bgt	.L592
 9938              		.loc 33 56 0 is_stmt 0 discriminator 1
 9939 003c 1068     		ldr	r0, [r2, #0]
 9940 003e 40F26C7C 		movw	ip, #1900
 9941 0042 6045     		cmp	r0, ip
 9942 0044 0DDD     		ble	.L592
 9943              		.loc 33 56 0 discriminator 2
 9944 0046 5268     		ldr	r2, [r2, #4]
 9945 0048 9A42     		cmp	r2, r3
 9946 004a 0ADC     		bgt	.L592
  57:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       calibrateGyro();
 9947              		.loc 33 57 0 is_stmt 1
 9948 004c FFF7FEFF 		bl	_Z13calibrateGyrov
  58:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       computeAccelBias();
 9949              		.loc 33 58 0
 9950 0050 FFF7FEFF 		bl	_Z16computeAccelBiasv
  59:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       storeSensorsZeroToEEPROM();
 9951              		.loc 33 59 0
 9952 0054 FFF7FEFF 		bl	_Z24storeSensorsZeroToEEPROMv
  60:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       calibrateKinematics();
  61:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       zeroIntegralError();
 9953              		.loc 33 61 0
 9954 0058 FFF7FEFF 		bl	_Z17zeroIntegralErrorv
  62:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       pulseMotors(3);
 9955              		.loc 33 62 0
 9956 005c 0320     		movs	r0, #3
 9957 005e FFF7FEFF 		bl	_Z11pulseMotorsh
 9958              	.L592:
 9959              	.LBB300:
  63:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     }   
  64:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     
  65:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     // Arm motors (left stick lower right corner)
  66:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     if (receiverCommand[ZAXIS] > MAXCHECK && motorArmed == OFF && safetyCheck == ON) {
 9960              		.loc 33 66 0
 9961 0062 A168     		ldr	r1, [r4, #8]
 9962 0064 40F26C7E 		movw	lr, #1900
 9963 0068 7145     		cmp	r1, lr
 9964 006a 10DD     		ble	.L593
 9965              		.loc 33 66 0 is_stmt 0 discriminator 1
 9966 006c 2B4B     		ldr	r3, .L598+8
 9967 006e 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 9968 0070 68B9     		cbnz	r0, .L593
 9969              		.loc 33 66 0 discriminator 2
 9970 0072 2B4A     		ldr	r2, .L598+12
 9971 0074 1278     		ldrb	r2, [r2, #0]	@ zero_extendqisi2
 9972 0076 012A     		cmp	r2, #1
 9973 0078 09D1     		bne	.L593
 9974              	.LVL444:
 9975              	.LBB301:
 9976              	.LBB302:
  67:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       #ifdef OSD_SYSTEM_MENU
  69:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         if (menuOwnsSticks) {
  70:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           return;
  71:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         }
  72:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       #endif
  73:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       for (byte motor = 0; motor < LASTMOTOR; motor++) {
  75:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         motorCommand[motor] = MINTHROTTLE;
 9977              		.loc 33 75 0 is_stmt 1 discriminator 1
 9978 007a 2A49     		ldr	r1, .L598+16
 9979              	.LBE302:
  76:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       }
  77:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       motorArmed = ON;
 9980              		.loc 33 77 0 discriminator 1
 9981 007c 1A70     		strb	r2, [r3, #0]
 9982              	.LBB303:
  75:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         motorCommand[motor] = MINTHROTTLE;
 9983              		.loc 33 75 0 discriminator 1
 9984 007e 40F24C40 		movw	r0, #1100
 9985 0082 0860     		str	r0, [r1, #0]
 9986              	.LVL445:
 9987 0084 4860     		str	r0, [r1, #4]
 9988              	.LVL446:
 9989 0086 8860     		str	r0, [r1, #8]
 9990              	.LVL447:
 9991 0088 C860     		str	r0, [r1, #12]
 9992              	.LVL448:
 9993              	.LBE303:
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     
  79:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       #ifdef OSD
  80:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         notifyOSD(OSD_CENTER|OSD_WARN, "!MOTORS ARMED!");
  81:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       #endif  
  82:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  83:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       zeroIntegralError();
 9994              		.loc 33 83 0 discriminator 1
 9995 008a FFF7FEFF 		bl	_Z17zeroIntegralErrorv
 9996              	.LVL449:
 9997              	.L593:
 9998              	.LBE301:
 9999              	.LBE300:
  84:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  85:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     }
  86:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     // Prevents accidental arming of motor output if no transmitter command received
  87:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     if (receiverCommand[ZAXIS] > MINCHECK) {
 10000              		.loc 33 87 0
 10001 008e A268     		ldr	r2, [r4, #8]
 10002 0090 40F24C43 		movw	r3, #1100
 10003 0094 9A42     		cmp	r2, r3
 10004 0096 02DD     		ble	.L590
  88:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       safetyCheck = ON; 
 10005              		.loc 33 88 0
 10006 0098 2149     		ldr	r1, .L598+12
 10007 009a 0120     		movs	r0, #1
 10008 009c 0870     		strb	r0, [r1, #0]
 10009              	.L590:
 10010              	.LBE299:
 10011              	.LBE304:
  89:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     }
  90:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   }
  91:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   if (!inFlight) {
 10012              		.loc 33 92 0
 10013 009e 2A78     		ldrb	r2, [r5, #0]	@ zero_extendqisi2
 10014 00a0 52B9     		cbnz	r2, .L594
  93:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     if (motorArmed == ON && receiverCommand[THROTTLE] > minArmedThrottle) {
 10015              		.loc 33 93 0
 10016 00a2 1E4B     		ldr	r3, .L598+8
 10017 00a4 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 10018 00a6 012B     		cmp	r3, #1
 10019 00a8 06D1     		bne	.L594
 10020              		.loc 33 93 0 is_stmt 0 discriminator 1
 10021 00aa 1F4A     		ldr	r2, .L598+20
 10022 00ac E168     		ldr	r1, [r4, #12]
 10023 00ae 1068     		ldr	r0, [r2, #0]
 10024 00b0 8142     		cmp	r1, r0
  94:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       inFlight = true;
 10025              		.loc 33 94 0 is_stmt 1 discriminator 1
 10026 00b2 C4BF     		itt	gt
 10027 00b4 1848     		ldrgt	r0, .L598+4
 10028 00b6 0370     		strbgt	r3, [r0, #0]
 10029              	.L594:
  95:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     }
  96:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   }
  97:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   
  98:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   // Check Mode switch for Acro or Stable
  99:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   if (receiverCommand[MODE] > 1500) {
 100:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     flightMode = ATTITUDE_FLIGHT_MODE;
 10030              		.loc 33 100 0
 10031 00b8 2069     		ldr	r0, [r4, #16]
 101:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   }
 102:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   else {
 103:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     flightMode = RATE_FLIGHT_MODE;
 104:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   }
 105:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 106:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   
 107:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 108:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****      if (receiverCommand[AUX1] < 1750) {
 10032              		.loc 33 108 0
 10033 00ba 6469     		ldr	r4, [r4, #20]
 100:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     flightMode = ATTITUDE_FLIGHT_MODE;
 10034              		.loc 33 100 0
 10035 00bc 1B4B     		ldr	r3, .L598+24
 10036 00be 40F2DC51 		movw	r1, #1500
 10037 00c2 8842     		cmp	r0, r1
 10038              		.loc 33 108 0
 10039 00c4 40F2D56C 		movw	ip, #1749
 100:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     flightMode = ATTITUDE_FLIGHT_MODE;
 10040              		.loc 33 100 0
 10041 00c8 D4BF     		ite	le
 10042 00ca 0020     		movle	r0, #0
 10043 00cc 0120     		movgt	r0, #1
 10044              		.loc 33 108 0
 10045 00ce 6445     		cmp	r4, ip
 100:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     flightMode = ATTITUDE_FLIGHT_MODE;
 10046              		.loc 33 100 0
 10047 00d0 1870     		strb	r0, [r3, #0]
 10048 00d2 174C     		ldr	r4, .L598+28
 10049              		.loc 33 108 0
 10050 00d4 18DC     		bgt	.L595
 109:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       if (altitudeHoldState != ALTPANIC ) {  // check for special condition with manditory override
 10051              		.loc 33 109 0
 10052 00d6 2278     		ldrb	r2, [r4, #0]	@ zero_extendqisi2
 10053 00d8 022A     		cmp	r2, #2
 10054 00da 1AD0     		beq	.L589
 110:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         if (isStoreAltitudeNeeded) {
 10055              		.loc 33 110 0
 10056 00dc 154D     		ldr	r5, .L598+32
 10057 00de 2878     		ldrb	r0, [r5, #0]	@ zero_extendqisi2
 10058 00e0 78B1     		cbz	r0, .L597
 111:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           #if defined AltitudeHoldBaro
 112:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             baroAltitudeToHoldTarget = getBaroAltitude();
 10059              		.loc 33 112 0
 10060 00e2 FFF7FEFF 		bl	_Z15getBaroAltitudev
 113:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             PID[BARO_ALTITUDE_HOLD_PID_IDX].integratedError = 0;
 10061              		.loc 33 113 0
 10062 00e6 144B     		ldr	r3, .L598+36
 112:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             baroAltitudeToHoldTarget = getBaroAltitude();
 10063              		.loc 33 112 0
 10064 00e8 144A     		ldr	r2, .L598+40
 114:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             PID[BARO_ALTITUDE_HOLD_PID_IDX].lastError = baroAltitudeToHoldTarget;
 10065              		.loc 33 114 0
 10066 00ea C3F8EC00 		str	r0, [r3, #236]	@ float
 112:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             baroAltitudeToHoldTarget = getBaroAltitude();
 10067              		.loc 33 112 0
 10068 00ee 1060     		str	r0, [r2, #0]	@ float
 115:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           #endif
 116:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           #if defined AltitudeHoldRangeFinder
 117:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             sonarAltitudeToHoldTarget = rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX];
 118:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             PID[SONAR_ALTITUDE_HOLD_PID_IDX].integratedError = 0;
 119:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             PID[SONAR_ALTITUDE_HOLD_PID_IDX].lastError = sonarAltitudeToHoldTarget;
 120:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           #endif
 121:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           altitudeHoldThrottle = receiverCommand[THROTTLE];
 10069              		.loc 33 121 0
 10070 00f0 0848     		ldr	r0, .L598
 10071 00f2 134A     		ldr	r2, .L598+44
 113:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             PID[BARO_ALTITUDE_HOLD_PID_IDX].integratedError = 0;
 10072              		.loc 33 113 0
 10073 00f4 0021     		movs	r1, #0
 10074 00f6 C3F8F410 		str	r1, [r3, #244]	@ float
 10075              		.loc 33 121 0
 10076 00fa C168     		ldr	r1, [r0, #12]
 122:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           isStoreAltitudeNeeded = false;
 10077              		.loc 33 122 0
 10078 00fc 0023     		movs	r3, #0
 121:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           altitudeHoldThrottle = receiverCommand[THROTTLE];
 10079              		.loc 33 121 0
 10080 00fe 1160     		str	r1, [r2, #0]
 10081              		.loc 33 122 0
 10082 0100 2B70     		strb	r3, [r5, #0]
 10083              	.L597:
 123:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         }
 124:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         altitudeHoldState = ON;
 10084              		.loc 33 124 0
 10085 0102 0120     		movs	r0, #1
 10086 0104 2070     		strb	r0, [r4, #0]
 10087 0106 70BD     		pop	{r4, r5, r6, pc}
 10088              	.L595:
 125:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       }
 126:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     } 
 127:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     else {
 128:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       isStoreAltitudeNeeded = true;
 10089              		.loc 33 128 0
 10090 0108 0A4A     		ldr	r2, .L598+32
 10091 010a 0121     		movs	r1, #1
 129:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       altitudeHoldState = OFF;
 10092              		.loc 33 129 0
 10093 010c 0023     		movs	r3, #0
 128:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       isStoreAltitudeNeeded = true;
 10094              		.loc 33 128 0
 10095 010e 1170     		strb	r1, [r2, #0]
 10096              		.loc 33 129 0
 10097 0110 2370     		strb	r3, [r4, #0]
 10098              	.L589:
 10099 0112 70BD     		pop	{r4, r5, r6, pc}
 10100              	.L599:
 10101              		.align	2
 10102              	.L598:
 10103 0114 00000000 		.word	.LANCHOR6
 10104 0118 00000000 		.word	.LANCHOR16
 10105 011c 00000000 		.word	.LANCHOR116
 10106 0120 00000000 		.word	.LANCHOR131
 10107 0124 00000000 		.word	.LANCHOR63
 10108 0128 00000000 		.word	.LANCHOR132
 10109 012c 00000000 		.word	.LANCHOR120
 10110 0130 00000000 		.word	.LANCHOR5
 10111 0134 00000000 		.word	.LANCHOR147
 10112 0138 00000000 		.word	.LANCHOR17
 10113 013c 00000000 		.word	.LANCHOR123
 10114 0140 00000000 		.word	.LANCHOR7
 10115              	.LBE297:
 10116              		.cfi_endproc
 10117              	.LFE241:
 10119              		.section	.text._Z22initReceiverFromEEPROMv,"ax",%progbits
 10120              		.align	1
 10121              		.global	_Z22initReceiverFromEEPROMv
 10122              		.thumb
 10123              		.thumb_func
 10125              	_Z22initReceiverFromEEPROMv:
 10126              	.LFB254:
 526:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 527:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void initReceiverFromEEPROM() {
 10127              		.loc 31 527 0
 10128              		.cfi_startproc
 10129              		@ args = 0, pretend = 0, frame = 0
 10130              		@ frame_needed = 0, uses_anonymous_args = 0
 10131 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 10132              	.LCFI96:
 10133              		.cfi_def_cfa_offset 24
 10134              		.cfi_offset 14, -4
 10135              		.cfi_offset 7, -8
 10136              		.cfi_offset 6, -12
 10137              		.cfi_offset 5, -16
 10138              		.cfi_offset 4, -20
 10139              		.cfi_offset 3, -24
 10140              	.LBB305:
 528:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   receiverXmitFactor = readFloat(XMITFACTOR_ADR);
 10141              		.loc 31 528 0
 10142 0002 4FF48270 		mov	r0, #260
 10143 0006 FFF7FEFF 		bl	_Z12nvrReadFloati
 10144 000a 0E4B     		ldr	r3, .L603
 10145 000c 0E4F     		ldr	r7, .L603+4
 10146 000e 0F4E     		ldr	r6, .L603+8
 10147 0010 0F4D     		ldr	r5, .L603+12
 10148 0012 1860     		str	r0, [r3, #0]	@ float
 10149              	.LVL450:
 10150 0014 0024     		movs	r4, #0
 10151              	.LVL451:
 10152              	.L601:
 10153              	.LBB306:
 529:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 530:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for(byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 531:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     receiverSlope[channel] = readFloat(RECEIVER_DATA[channel].slope);
 10154              		.loc 31 531 0 discriminator 2
 10155 0016 04F19C00 		add	r0, r4, #156
 10156 001a FFF7FEFF 		bl	_Z12nvrReadFloati
 10157 001e 47F8040F 		str	r0, [r7, #4]!	@ float
 532:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     receiverOffset[channel] = readFloat(RECEIVER_DATA[channel].offset);
 10158              		.loc 31 532 0 discriminator 2
 10159 0022 04F1A000 		add	r0, r4, #160
 10160 0026 FFF7FEFF 		bl	_Z12nvrReadFloati
 10161 002a 46F8040F 		str	r0, [r6, #4]!	@ float
 533:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     receiverSmoothFactor[channel] = readFloat(RECEIVER_DATA[channel].smooth_factor);
 10162              		.loc 31 533 0 discriminator 2
 10163 002e 04F1A400 		add	r0, r4, #164
 10164 0032 FFF7FEFF 		bl	_Z12nvrReadFloati
 10165 0036 0C34     		adds	r4, r4, #12
 530:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for(byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 10166              		.loc 31 530 0 discriminator 2
 10167 0038 602C     		cmp	r4, #96
 10168              		.loc 31 533 0 discriminator 2
 10169 003a 45F8040F 		str	r0, [r5, #4]!	@ float
 530:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for(byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 10170              		.loc 31 530 0 discriminator 2
 10171 003e EAD1     		bne	.L601
 10172              	.LBE306:
 10173              	.LBE305:
 534:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
 535:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** }
 10174              		.loc 31 535 0
 10175 0040 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 10176              	.L604:
 10177 0042 00BF     		.align	2
 10178              	.L603:
 10179 0044 00000000 		.word	.LANCHOR61
 10180 0048 FCFFFFFF 		.word	.LANCHOR12-4
 10181 004c FCFFFFFF 		.word	.LANCHOR13-4
 10182 0050 FCFFFFFF 		.word	.LANCHOR14-4
 10183              		.cfi_endproc
 10184              	.LFE254:
 10186              		.section	.text._Z17initCommunicationv,"ax",%progbits
 10187              		.align	1
 10188              		.global	_Z17initCommunicationv
 10189              		.thumb
 10190              		.thumb_func
 10192              	_Z17initCommunicationv:
 10193              	.LFB255:
 10194              		.file 34 "C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad/SerialCom.h"
   1:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** /*
   2:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   AeroQuad v3.0.1 - February 2012
   3:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   www.AeroQuad.com
   4:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   An Open Source Arduino based multicopter.
   6:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****  
   7:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   This program is free software: you can redistribute it and/or modify 
   8:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   it under the terms of the GNU General Public License as published by 
   9:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   (at your option) any later version. 
  11:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****  
  12:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   This program is distributed in the hope that it will be useful, 
  13:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   GNU General Public License for more details. 
  16:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****  
  17:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   You should have received a copy of the GNU General Public License 
  18:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** */
  20:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
  21:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** // SerialCom.pde is responsible for the serial communication for commands and telemetry from the Ae
  22:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** // This comtains readSerialCommand() which listens for a serial command and it's arguments
  23:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** // This also contains readSerialTelemetry() which listens for a telemetry request and responds with
  24:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** // For more information on each command/telemetry look at: http://aeroquad.com/content.php?117
  25:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
  26:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** // Includes re-write / fixes from Aadamson and ala42, special thanks to those guys!
  27:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** // http://aeroquad.com/showthread.php?1461-We-have-some-hidden-warnings&p=14618&viewfull=1#post1461
  28:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
  29:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** #ifndef _AQ_SERIAL_COMM_
  30:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** #define _AQ_SERIAL_COMM_
  31:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
  32:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** char queryType = 'X';
  33:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
  34:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void initCommunication() {
 10195              		.loc 34 34 0
 10196              		.cfi_startproc
 10197              		@ args = 0, pretend = 0, frame = 0
 10198              		@ frame_needed = 0, uses_anonymous_args = 0
 10199              		@ link register save eliminated.
  35:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // do nothing here for now
  36:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10200              		.loc 34 36 0
 10201 0000 7047     		bx	lr
 10202              		.cfi_endproc
 10203              	.LFE255:
 10205              		.section	.text._Z15readValueSerialPch,"ax",%progbits
 10206              		.align	1
 10207              		.global	_Z15readValueSerialPch
 10208              		.thumb
 10209              		.thumb_func
 10211              	_Z15readValueSerialPch:
 10212              	.LFB268:
  37:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
  38:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** //*************************************************************************************************
  39:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** //********************************** Serial Commands **********************************************
  40:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** //*************************************************************************************************
  41:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** bool validateCalibrateCommand(byte command)
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
  43:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   if (readFloatSerial() == 123.45) {// use a specific float value to validate full throttle call is
  44:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     motorArmed = OFF;
  45:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     calibrateESC = command;
  46:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     return true;
  47:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   } 
  48:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   else {
  49:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     calibrateESC = 0;
  50:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     testCommand = 1000;
  51:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     return false;
  52:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   }
  53:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
  54:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
  55:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void readSerialPID(unsigned char PIDid) {
  56:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   struct PIDdata* pid = &PID[PIDid];
  57:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->P = readFloatSerial();
  58:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->I = readFloatSerial();
  59:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->D = readFloatSerial();
  60:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->lastError = 0;
  61:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->integratedError = 0;
  62:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
  63:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
  64:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void readSerialCommand() {
  65:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // Check for serial message
  66:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   if (SERIAL_AVAILABLE()) {
  67:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = SERIAL_READ();
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     switch (queryType) {
  69:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'A': // Receive roll and pitch rate mode PID
  70:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(RATE_XAXIS_PID_IDX);
  71:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(RATE_YAXIS_PID_IDX);
  72:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       rotationSpeedFactor = readFloatSerial();
  73:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
  75:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'B': // Receive roll/pitch attitude mode PID
  76:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ATTITUDE_XAXIS_PID_IDX);
  77:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ATTITUDE_YAXIS_PID_IDX);
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ATTITUDE_GYRO_XAXIS_PID_IDX);
  79:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ATTITUDE_GYRO_YAXIS_PID_IDX);
  80:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       windupGuard = readFloatSerial(); // defaults found in setup() of AeroQuad.pde
  81:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
  82:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
  83:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'C': // Receive yaw PID
  84:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ZAXIS_PID_IDX);
  85:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(HEADING_HOLD_PID_IDX);
  86:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readFloatSerial();
  87:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
  88:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
  89:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'D': // Altitude hold PID
  90:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
  91:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readSerialPID(BARO_ALTITUDE_HOLD_PID_IDX);
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard = readFloatSerial();
  93:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         altitudeHoldBump = readFloatSerial();
  94:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         altitudeHoldPanicStickMovement = readFloatSerial();
  95:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         minThrottleAdjust = readFloatSerial();
  96:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         maxThrottleAdjust = readFloatSerial();
  97:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         #if defined AltitudeHoldBaro
  98:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           baroSmoothFactor = readFloatSerial();
  99:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         #else
 100:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           readFloatSerial();
 101:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         #endif
 102:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readSerialPID(ZDAMPENING_PID_IDX);
 103:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 104:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 105:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 106:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'E': // Receive sensor filtering values
 107:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       aref = readFloatSerial();
 108:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       minArmedThrottle = readFloatSerial();
 109:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 110:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 111:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'F': // Receive transmitter smoothing values
 112:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       receiverXmitFactor = readFloatSerial();
 113:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       for(byte channel = XAXIS; channel<LASTCHANNEL; channel++) {
 114:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         receiverSmoothFactor[channel] = readFloatSerial();
 115:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       }
 116:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 117:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 118:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'G': // Receive transmitter calibration values
 119:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       channelCal = (int)readFloatSerial();
 120:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       receiverSlope[channelCal] = readFloatSerial();
 121:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 122:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 123:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'H': // Receive transmitter calibration values
 124:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       channelCal = (int)readFloatSerial();
 125:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       receiverOffset[channelCal] = readFloatSerial();
 126:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 127:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 128:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'I': // Initialize EEPROM with default values
 129:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       initializeEEPROM(); // defined in DataStorage.h
 130:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       writeEEPROM();
 131:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       storeSensorsZeroToEEPROM();
 132:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       calibrateGyro();
 133:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       computeAccelBias();
 134:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       zeroIntegralError();
 135:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #ifdef HeadingMagHold
 136:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         initializeMagnetometer();
 137:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 138:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #ifdef AltitudeHoldBaro
 139:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         initializeBaro();
 140:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 141:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 142:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 143:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'J': // calibrate gyros
 144:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       calibrateGyro();
 145:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       storeSensorsZeroToEEPROM();
 146:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 147:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 148:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'K': // Write accel calibration values
 149:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       accelScaleFactor[XAXIS] = readFloatSerial();
 150:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       runTimeAccelBias[XAXIS] = readFloatSerial();      
 151:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       accelScaleFactor[YAXIS] = readFloatSerial();
 152:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       runTimeAccelBias[YAXIS] = readFloatSerial();      
 153:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       accelScaleFactor[ZAXIS] = readFloatSerial();
 154:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       runTimeAccelBias[ZAXIS] = readFloatSerial();
 155:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       storeSensorsZeroToEEPROM();
 156:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 157:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 158:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'L': // generate accel bias
 159:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       computeAccelBias();
 160:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #if defined(AeroQuadMega_CHR6DM) || defined(APM_OP_CHR6DM)
 161:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         calibrateKinematics();
 162:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         accelOneG = meterPerSecSec[ZAXIS];
 163:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 164:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       storeSensorsZeroToEEPROM();
 165:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 166:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 167:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'M': // calibrate magnetometer
 168:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #ifdef HeadingMagHold
 169:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         magBias[XAXIS]  = readFloatSerial();      
 170:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         magBias[YAXIS]  = readFloatSerial();
 171:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         magBias[ZAXIS]  = readFloatSerial();
 172:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         writeEEPROM();
 173:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 174:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         for(int c=0;c<3;c++) {
 175:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           readFloatSerial();
 176:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         }
 177:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 178:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 179:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 180:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'N': // battery monitor
 181:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #ifdef BattMonitor
 182:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         batteryMonitorAlarmVoltage = readFloatSerial();
 183:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         batteryMonitorThrottleTarget = readFloatSerial();
 184:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         batteryMonitorGoingDownTime = readFloatSerial();
 185:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         setBatteryCellVoltageThreshold(batteryMonitorAlarmVoltage);
 186:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 187:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readFloatSerial();
 188:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readFloatSerial();
 189:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readFloatSerial();
 190:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 191:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 192:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 193:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'O': // define waypoints
 194:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #ifdef UseGPSNavigator
 195:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         missionNbPoint = readIntegerSerial();
 196:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         waypoint[missionNbPoint].latitude = readIntegerSerial();
 197:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         waypoint[missionNbPoint].longitude = readIntegerSerial();
 198:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         waypoint[missionNbPoint].altitude = readIntegerSerial();
 199:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 200:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readIntegerSerial();
 201:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readIntegerSerial();
 202:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readIntegerSerial();
 203:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readIntegerSerial();
 204:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 205:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 206:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'P': //  read Camera values
 207:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #ifdef CameraControl
 208:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         cameraMode = readFloatSerial();
 209:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         servoCenterPitch = readFloatSerial();
 210:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         servoCenterRoll = readFloatSerial();
 211:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         servoCenterYaw = readFloatSerial();
 212:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         mCameraPitch = readFloatSerial();
 213:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         mCameraRoll = readFloatSerial();
 214:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         mCameraYaw = readFloatSerial();
 215:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         servoMinPitch = readFloatSerial();
 216:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         servoMinRoll = readFloatSerial();
 217:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         servoMinYaw = readFloatSerial();
 218:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         servoMaxPitch = readFloatSerial();
 219:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         servoMaxRoll = readFloatSerial();
 220:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         servoMaxYaw = readFloatSerial();
 221:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 222:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         for (byte values = 0; values < 13; values++)
 223:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           readFloatSerial();
 224:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 225:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 226:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 227:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'U': // Range Finder
 228:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #if defined (AltitudeHoldRangeFinder)
 229:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         maxRangeFinderRange = readFloatSerial();
 230:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         minRangeFinderRange = readFloatSerial();
 231:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 232:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readFloatSerial();
 233:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readFloatSerial();
 234:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 235:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 236:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 237:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'V': // GPS
 238:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #if defined (UseGPS)
 239:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readSerialPID(GPSROLL_PID_IDX);
 240:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readSerialPID(GPSPITCH_PID_IDX);
 241:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readSerialPID(GPSYAW_PID_IDX);
 242:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         writeEEPROM();
 243:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 244:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         for (byte values = 0; values < 6; values++) {
 245:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           readFloatSerial();
 246:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         }
 247:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 248:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 249:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 250:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'W': // Write all user configurable values to EEPROM
 251:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       writeEEPROM(); // defined in DataStorage.h
 252:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       zeroIntegralError();
 253:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 254:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 255:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'X': // Stop sending messages
 256:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 257:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 258:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case '1': // Calibrate ESCS's by setting Throttle high on all channels
 259:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         validateCalibrateCommand(1);
 260:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 261:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 262:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case '2': // Calibrate ESC's by setting Throttle low on all channels
 263:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         validateCalibrateCommand(2);
 264:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 265:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 266:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case '3': // Test ESC calibration
 267:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       if (validateCalibrateCommand(3)) {
 268:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         testCommand = readFloatSerial();
 269:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       }
 270:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 271:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 272:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case '4': // Turn off ESC calibration
 273:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       if (validateCalibrateCommand(4)) {
 274:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         calibrateESC = 0;
 275:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         testCommand = 1000;
 276:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       }
 277:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 278:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 279:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case '5': // Send individual motor commands (motor, command)
 280:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       if (validateCalibrateCommand(5)) {
 281:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         for (byte motor = 0; motor < LASTMOTOR; motor++)
 282:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           motorConfiguratorCommand[motor] = (int)readFloatSerial();
 283:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       }
 284:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 285:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 286:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'Z': // fast telemetry transfer <--- get rid if this?
 287:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       if (readFloatSerial() == 1.0)
 288:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         fastTransfer = ON;
 289:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       else
 290:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         fastTransfer = OFF;
 291:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 292:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 293:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   }
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 295:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 296:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** //*************************************************************************************************
 297:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** //********************************* Serial Telemetry **********************************************
 298:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** //*************************************************************************************************
 299:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 300:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(float val) {
 301:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 302:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 303:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 304:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 305:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(double val) {
 306:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 307:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 308:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 309:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 310:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(char val) {
 311:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 312:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 313:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 314:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 315:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(int val) {
 316:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 317:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 318:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 319:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 320:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(unsigned long val)
 321:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 322:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 323:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 324:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 325:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 326:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(byte val)
 327:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 328:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 329:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 330:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 331:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 332:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(long int val)
 333:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 334:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 335:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 336:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 337:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 338:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintPID(unsigned char IDPid)
 339:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 340:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   PrintValueComma(PID[IDPid].P);
 341:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   PrintValueComma(PID[IDPid].I);
 342:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   PrintValueComma(PID[IDPid].D);
 343:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 344:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 345:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void sendSerialTelemetry() {
 346:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   switch (queryType) {
 347:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case '=': // Reserved debug command to view any variable from Serial Monitor
 348:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 349:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 350:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'a': // Send roll and pitch rate mode PID values
 351:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(RATE_XAXIS_PID_IDX);
 352:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(RATE_YAXIS_PID_IDX);
 353:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(rotationSpeedFactor);
 354:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 355:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 356:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 357:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 358:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'b': // Send roll and pitch attitude mode PID values
 359:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ATTITUDE_XAXIS_PID_IDX);
 360:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ATTITUDE_YAXIS_PID_IDX);
 361:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ATTITUDE_GYRO_XAXIS_PID_IDX);
 362:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ATTITUDE_GYRO_YAXIS_PID_IDX);
 363:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(windupGuard);
 364:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 365:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 366:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 367:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'c': // Send yaw PID values
 368:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ZAXIS_PID_IDX);
 369:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(HEADING_HOLD_PID_IDX);
 370:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN((int)headingHoldConfig);
 371:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 372:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 373:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 374:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'd': // Altitude Hold
 375:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 376:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintPID(BARO_ALTITUDE_HOLD_PID_IDX);
 377:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard);
 378:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(altitudeHoldBump);
 379:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(altitudeHoldPanicStickMovement);
 380:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(minThrottleAdjust);
 381:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(maxThrottleAdjust);
 382:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #if defined AltitudeHoldBaro
 383:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(baroSmoothFactor);
 384:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 385:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(0);
 386:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 387:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintPID(ZDAMPENING_PID_IDX);
 388:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 389:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       for(byte i=0; i<10; i++) {
 390:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(0);
 391:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       }
 392:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 393:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 394:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 395:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 396:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 397:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'e': // miscellaneous config values
 398:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(aref);
 399:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(minArmedThrottle);
 400:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 401:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 402:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 403:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'f': // Send transmitter smoothing values
 404:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(receiverXmitFactor);
 405:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 406:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(receiverSmoothFactor[axis]);
 407:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 408:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 409:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 410:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 411:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 412:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'g': // Send transmitter calibration data
 413:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 414:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(receiverSlope[axis], 6);
 415:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(',');
 416:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 417:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 418:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 419:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 420:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 421:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'h': // Send transmitter calibration data
 422:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 423:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(receiverOffset[axis], 6);
 424:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(',');
 425:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 426:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 427:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 428:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 429:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 430:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'i': // Send sensor data
 431:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 432:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(gyroRate[axis]);
 433:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 434:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 435:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(filteredAccel[axis]);
 436:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 437:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 438:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #if defined(HeadingMagHold)
 439:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(getMagnetometerData(axis));
 440:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 441:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(0);
 442:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 443:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 444:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 445:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 446:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 447:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'j': // Send raw mag values
 448:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #ifdef HeadingMagHold
 449:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(getMagnetometerRawData(XAXIS));
 450:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(getMagnetometerRawData(YAXIS));
 451:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(getMagnetometerRawData(ZAXIS));
 452:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 453:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 454:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 455:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'k': // Send accelerometer cal values
 456:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[XAXIS], 6);
 457:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 458:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(runTimeAccelBias[XAXIS], 6);
 459:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 460:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[YAXIS], 6);
 461:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 462:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(runTimeAccelBias[YAXIS], 6);
 463:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 464:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[ZAXIS], 6);
 465:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 466:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(runTimeAccelBias[ZAXIS], 6);
 467:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 468:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 469:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 470:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'l': // Send raw accel values
 471:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     measureAccelSum();
 472:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma((int)(accelSample[XAXIS]/accelSampleCount));
 473:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     accelSample[XAXIS] = 0;
 474:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma((int)(accelSample[YAXIS]/accelSampleCount));
 475:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     accelSample[YAXIS] = 0;
 476:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN ((int)(accelSample[ZAXIS]/accelSampleCount));
 477:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     accelSample[ZAXIS] = 0;
 478:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     accelSampleCount = 0;
 479:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 480:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 481:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'm': // Send magnetometer cal values
 482:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #ifdef HeadingMagHold
 483:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINT(magBias[XAXIS], 6);
 484:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       comma();
 485:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINT(magBias[YAXIS], 6);
 486:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       comma();
 487:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(magBias[ZAXIS], 6);
 488:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 489:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 490:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 491:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 492:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'n': // battery monitor
 493:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #ifdef BattMonitor
 494:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(batteryMonitorAlarmVoltage);
 495:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(batteryMonitorThrottleTarget);
 496:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(batteryMonitorGoingDownTime);
 497:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 498:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 499:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 500:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(0);
 501:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 502:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 503:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 504:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 505:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'o': // send waypoints
 506:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #ifdef UseGPSNavigator
 507:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       for (byte index = 0; index < MAX_WAYPOINTS; index++) {
 508:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(index);
 509:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(waypoint[index].latitude);
 510:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(waypoint[index].longitude);
 511:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(waypoint[index].altitude);
 512:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       }
 513:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN();
 514:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 515:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 516:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 517:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 518:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(0);
 519:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 520:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 521:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 522:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 523:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'p': // Send Camera values
 524:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #ifdef CameraControl
 525:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(cameraMode);
 526:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(servoCenterPitch);
 527:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(servoCenterRoll);
 528:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(servoCenterYaw);
 529:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(mCameraPitch);
 530:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(mCameraRoll);
 531:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(mCameraYaw);
 532:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(servoMinPitch);
 533:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(servoMinRoll);
 534:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(servoMinYaw);
 535:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(servoMaxPitch);
 536:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(servoMaxRoll);
 537:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(servoMaxYaw);
 538:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 539:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       for (byte index=0; index < 12; index++) {
 540:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(0);
 541:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       }
 542:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(0);
 543:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 544:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 545:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 546:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 547:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'q': // Send Vehicle State Value
 548:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(vehicleState);
 549:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 550:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 551:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 552:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'r': // Vehicle attitude
 553:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[XAXIS]);
 554:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[YAXIS]);
 555:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #if defined(HeadingMagHold) || defined(AeroQuadMega_CHR6DM) || defined(APM_OP_CHR6DM)
 556:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(trueNorthHeading);
 557:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 558:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(gyroHeading);
 559:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 560:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 561:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 562:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 's': // Send all flight data
 563:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(motorArmed);
 564:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[XAXIS]);
 565:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[YAXIS]);
 566:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #if defined(HeadingMagHold) || defined(AeroQuadMega_CHR6DM) || defined(APM_OP_CHR6DM)
 567:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(trueNorthHeading);
 568:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 569:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(gyroHeading);
 570:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 571:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 572:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #if defined AltitudeHoldBaro
 573:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(getBaroAltitude());
 574:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #elif defined AltitudeHoldRangeFinder
 575:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX] != INVALID_RANGE ? rangeFinde
 576:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif  
 577:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma((int)altitudeHoldState);
 578:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 579:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 580:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 581:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 582:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 583:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(receiverCommand[channel]);
 584:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 585:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte channel = 0; channel < (8 - LASTCHANNEL); channel++) {// max of 8 transmitter channel
 586:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0); // zero out unused transmitter channels
 587:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 588:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 589:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(motorCommand[motor]);
 590:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 591:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte motor = 0; motor < (8 - (LASTMOTOR)); motor++) {// max of 8 motor outputs supported
 592:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0); // zero out unused motor channels
 593:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 594:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #ifdef BattMonitor
 595:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma((float)batteryData[0].voltage/100.0); // voltage internally stored at 10mV:s
 596:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 597:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 598:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 599:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(flightMode);
 600:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 601:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 602:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 603:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 't': // Send processed transmitter values
 604:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = 0; axis < LASTCHANNEL; axis++) {
 605:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(receiverCommand[axis]);
 606:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 607:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 608:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 609:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 610:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'u': // Send range finder values
 611:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #if defined (AltitudeHoldRangeFinder)
 612:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(maxRangeFinderRange);
 613:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(minRangeFinderRange);
 614:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 615:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 616:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(0);
 617:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 618:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 619:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 620:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 621:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'v': // Send GPS PIDs
 622:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #if defined (UseGPS)
 623:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintPID(GPSROLL_PID_IDX);
 624:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintPID(GPSPITCH_PID_IDX);
 625:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintPID(GPSYAW_PID_IDX);
 626:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN();
 627:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       queryType = 'X';
 628:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 629:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       for (byte values=0; values < 5; values++)
 630:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(0);
 631:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(0);
 632:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 633:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 634:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 635:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 636:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'x': // Stop sending messages
 637:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 638:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 639:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case '!': // Send flight software version
 640:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(SOFTWARE_VERSION, 1);
 641:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 642:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 643:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 644:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case '#': // Send configuration
 645:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     reportVehicleState();
 646:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 647:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 648:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 649:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case '6': // Report remote commands
 650:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 651:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(motorCommand[motor]);
 652:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 653:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 654:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 655:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 656:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   }
 657:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 658:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 659:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void readValueSerial(char *data, byte size) {
 10213              		.loc 34 659 0
 10214              		.cfi_startproc
 10215              		@ args = 0, pretend = 0, frame = 0
 10216              		@ frame_needed = 0, uses_anonymous_args = 0
 10217              	.LVL452:
 10218 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 10219              	.LCFI97:
 10220              		.cfi_def_cfa_offset 24
 10221              		.cfi_offset 14, -4
 10222              		.cfi_offset 7, -8
 10223              		.cfi_offset 6, -12
 10224              		.cfi_offset 5, -16
 10225              		.cfi_offset 4, -20
 10226              		.cfi_offset 3, -24
 10227              	.LBB307:
 660:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   byte index = 0;
 661:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   byte timeout = 0;
 662:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   data[0] = '\0';
 10228              		.loc 34 662 0
 10229 0002 0026     		movs	r6, #0
 10230              	.LBE307:
 659:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void readValueSerial(char *data, byte size) {
 10231              		.loc 34 659 0
 10232 0004 0446     		mov	r4, r0
 10233 0006 0F46     		mov	r7, r1
 10234              	.LBB308:
 10235              		.loc 34 662 0
 10236 0008 0670     		strb	r6, [r0, #0]
 660:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   byte index = 0;
 10237              		.loc 34 660 0
 10238 000a 3546     		mov	r5, r6
 10239              	.LVL453:
 10240              	.L611:
 663:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 664:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   do {
 665:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     if (SERIAL_AVAILABLE() == 0) {
 10241              		.loc 34 665 0
 10242 000c 0F48     		ldr	r0, .L613
 10243 000e FFF7FEFF 		bl	_ZN9USBSerial9availableEv
 10244 0012 28B9     		cbnz	r0, .L607
 666:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       delay(1);
 10245              		.loc 34 666 0
 10246 0014 0120     		movs	r0, #1
 667:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       timeout++;
 10247              		.loc 34 667 0
 10248 0016 0136     		adds	r6, r6, #1
 10249              	.LVL454:
 666:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       delay(1);
 10250              		.loc 34 666 0
 10251 0018 FFF7FEFF 		bl	_Z5delaym
 10252              		.loc 34 667 0
 10253 001c F6B2     		uxtb	r6, r6
 10254              	.LVL455:
 10255 001e 06E0     		b	.L608
 10256              	.L607:
 668:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     } else {
 669:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       data[index] = SERIAL_READ();
 10257              		.loc 34 669 0
 10258 0020 0A48     		ldr	r0, .L613
 10259 0022 FFF7FEFF 		bl	_ZN9USBSerial4readEv
 10260 0026 6055     		strb	r0, [r4, r5]
 10261              	.LVL456:
 670:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       timeout = 0;
 671:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       index++;
 10262              		.loc 34 671 0
 10263 0028 0135     		adds	r5, r5, #1
 10264              	.LVL457:
 10265 002a EDB2     		uxtb	r5, r5
 10266              	.LVL458:
 670:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       timeout = 0;
 10267              		.loc 34 670 0
 10268 002c 0026     		movs	r6, #0
 10269              	.LVL459:
 10270              	.L608:
 664:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   do {
 10271              		.loc 34 664 0
 10272 002e 25B1     		cbz	r5, .L609
 664:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   do {
 10273              		.loc 34 664 0 is_stmt 0 discriminator 2
 10274 0030 6019     		adds	r0, r4, r5
 10275 0032 10F8013C 		ldrb	r3, [r0, #-1]	@ zero_extendqisi2
 10276 0036 3B2B     		cmp	r3, #59
 10277 0038 04D0     		beq	.L610
 10278              	.L609:
 664:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   do {
 10279              		.loc 34 664 0 discriminator 1
 10280 003a 092E     		cmp	r6, #9
 10281 003c 02D8     		bhi	.L610
 664:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   do {
 10282              		.loc 34 664 0 discriminator 4
 10283 003e 791E     		subs	r1, r7, #1
 10284 0040 8D42     		cmp	r5, r1
 10285 0042 E3DB     		blt	.L611
 10286              	.L610:
 672:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 673:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   } while ((index == 0 || data[index-1] != ';') && (timeout < 10) && (index < size-1));
 674:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 675:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   data[index] = '\0';
 10287              		.loc 34 675 0 is_stmt 1
 10288 0044 0022     		movs	r2, #0
 10289 0046 6255     		strb	r2, [r4, r5]
 10290              	.LBE308:
 676:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10291              		.loc 34 676 0
 10292 0048 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 10293              	.L614:
 10294 004a 00BF     		.align	2
 10295              	.L613:
 10296 004c 00000000 		.word	SerialUSB
 10297              		.cfi_endproc
 10298              	.LFE268:
 10300              		.section	.text._Z15readFloatSerialv,"ax",%progbits
 10301              		.align	1
 10302              		.global	_Z15readFloatSerialv
 10303              		.thumb
 10304              		.thumb_func
 10306              	_Z15readFloatSerialv:
 10307              	.LFB269:
 677:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 678:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 679:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** // Used to read floating point values from the serial port
 680:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** float readFloatSerial() {
 10308              		.loc 34 680 0
 10309              		.cfi_startproc
 10310              		@ args = 0, pretend = 0, frame = 16
 10311              		@ frame_needed = 0, uses_anonymous_args = 0
 10312 0000 1FB5     		push	{r0, r1, r2, r3, r4, lr}
 10313              	.LCFI98:
 10314              		.cfi_def_cfa_offset 24
 10315              		.cfi_offset 14, -4
 10316              		.cfi_offset 4, -8
 10317              		.cfi_offset 3, -12
 10318              		.cfi_offset 2, -16
 10319              		.cfi_offset 1, -20
 10320              		.cfi_offset 0, -24
 10321              	.LBB309:
 681:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   char data[15] = "";
 10322              		.loc 34 681 0
 10323 0002 0021     		movs	r1, #0
 10324 0004 0B22     		movs	r2, #11
 10325 0006 01A8     		add	r0, sp, #4
 10326 0008 0091     		str	r1, [sp, #0]
 10327 000a FFF7FEFF 		bl	memset
 682:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 683:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   readValueSerial(data, sizeof(data));
 10328              		.loc 34 683 0
 10329 000e 6846     		mov	r0, sp
 10330 0010 0F21     		movs	r1, #15
 10331 0012 FFF7FEFF 		bl	_Z15readValueSerialPch
 684:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   return atof(data);
 10332              		.loc 34 684 0
 10333 0016 6846     		mov	r0, sp
 10334 0018 FFF7FEFF 		bl	atof
 10335 001c FFF7FEFF 		bl	__aeabi_d2f
 10336              	.LBE309:
 685:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10337              		.loc 34 685 0
 10338 0020 05B0     		add	sp, sp, #20
 10339 0022 00BD     		pop	{pc}
 10340              		.cfi_endproc
 10341              	.LFE269:
 10343              		.section	.text._Z13readSerialPIDh,"ax",%progbits
 10344              		.align	1
 10345              		.global	_Z13readSerialPIDh
 10346              		.thumb
 10347              		.thumb_func
 10349              	_Z13readSerialPIDh:
 10350              	.LFB257:
  55:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void readSerialPID(unsigned char PIDid) {
 10351              		.loc 34 55 0
 10352              		.cfi_startproc
 10353              		@ args = 0, pretend = 0, frame = 0
 10354              		@ frame_needed = 0, uses_anonymous_args = 0
 10355              	.LVL460:
 10356              	.LBB310:
  56:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   struct PIDdata* pid = &PID[PIDid];
 10357              		.loc 34 56 0
 10358 0000 0849     		ldr	r1, .L617
 10359              	.LBE310:
  55:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void readSerialPID(unsigned char PIDid) {
 10360              		.loc 34 55 0
 10361 0002 10B5     		push	{r4, lr}
 10362              	.LCFI99:
 10363              		.cfi_def_cfa_offset 8
 10364              		.cfi_offset 14, -4
 10365              		.cfi_offset 4, -8
 10366              	.LBB311:
  56:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   struct PIDdata* pid = &PID[PIDid];
 10367              		.loc 34 56 0
 10368 0004 1C24     		movs	r4, #28
 10369 0006 04FB0014 		mla	r4, r4, r0, r1
 10370              	.LVL461:
  57:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->P = readFloatSerial();
 10371              		.loc 34 57 0
 10372 000a FFF7FEFF 		bl	_Z15readFloatSerialv
 10373              	.LVL462:
 10374 000e 2060     		str	r0, [r4, #0]	@ float
  58:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->I = readFloatSerial();
 10375              		.loc 34 58 0
 10376 0010 FFF7FEFF 		bl	_Z15readFloatSerialv
 10377 0014 6060     		str	r0, [r4, #4]	@ float
  59:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->D = readFloatSerial();
 10378              		.loc 34 59 0
 10379 0016 FFF7FEFF 		bl	_Z15readFloatSerialv
  60:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->lastError = 0;
 10380              		.loc 34 60 0
 10381 001a 0023     		movs	r3, #0
  59:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->D = readFloatSerial();
 10382              		.loc 34 59 0
 10383 001c A060     		str	r0, [r4, #8]	@ float
  60:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->lastError = 0;
 10384              		.loc 34 60 0
 10385 001e E360     		str	r3, [r4, #12]	@ float
  61:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->integratedError = 0;
 10386              		.loc 34 61 0
 10387 0020 6361     		str	r3, [r4, #20]	@ float
 10388              	.LBE311:
  62:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10389              		.loc 34 62 0
 10390 0022 10BD     		pop	{r4, pc}
 10391              	.L618:
 10392              		.align	2
 10393              	.L617:
 10394 0024 00000000 		.word	.LANCHOR17
 10395              		.cfi_endproc
 10396              	.LFE257:
 10398              		.section	.text._Z24validateCalibrateCommandh,"ax",%progbits
 10399              		.align	1
 10400              		.global	_Z24validateCalibrateCommandh
 10401              		.thumb
 10402              		.thumb_func
 10404              	_Z24validateCalibrateCommandh:
 10405              	.LFB256:
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 10406              		.loc 34 42 0
 10407              		.cfi_startproc
 10408              		@ args = 0, pretend = 0, frame = 0
 10409              		@ frame_needed = 0, uses_anonymous_args = 0
 10410              	.LVL463:
 10411 0000 10B5     		push	{r4, lr}
 10412              	.LCFI100:
 10413              		.cfi_def_cfa_offset 8
 10414              		.cfi_offset 14, -4
 10415              		.cfi_offset 4, -8
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 10416              		.loc 34 42 0
 10417 0002 0446     		mov	r4, r0
  43:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   if (readFloatSerial() == 123.45) {// use a specific float value to validate full throttle call is
 10418              		.loc 34 43 0
 10419 0004 FFF7FEFF 		bl	_Z15readFloatSerialv
 10420              	.LVL464:
 10421 0008 DFED0B7A 		flds	s15, .L622
 10422 000c 07EE100A 		fmsr	s14, r0
 10423 0010 B4EE677A 		fcmps	s14, s15
 10424 0014 F1EE10FA 		fmstat
 10425 0018 4FF00000 		mov	r0, #0
 10426 001c 074B     		ldr	r3, .L622+4
 10427 001e 04D1     		bne	.L620
  44:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     motorArmed = OFF;
 10428              		.loc 34 44 0
 10429 0020 074A     		ldr	r2, .L622+8
  45:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     calibrateESC = command;
 10430              		.loc 34 45 0
 10431 0022 1C70     		strb	r4, [r3, #0]
  44:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     motorArmed = OFF;
 10432              		.loc 34 44 0
 10433 0024 1070     		strb	r0, [r2, #0]
  46:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     return true;
 10434              		.loc 34 46 0
 10435 0026 0120     		movs	r0, #1
 10436 0028 10BD     		pop	{r4, pc}
 10437              	.L620:
  49:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     calibrateESC = 0;
 10438              		.loc 34 49 0
 10439 002a 1870     		strb	r0, [r3, #0]
  50:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     testCommand = 1000;
 10440              		.loc 34 50 0
 10441 002c 054B     		ldr	r3, .L622+12
 10442 002e 4FF47A71 		mov	r1, #1000
 10443 0032 1960     		str	r1, [r3, #0]
  53:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10444              		.loc 34 53 0
 10445 0034 10BD     		pop	{r4, pc}
 10446              	.L623:
 10447 0036 00BF     		.align	2
 10448              	.L622:
 10449 0038 66E6F642 		.word	1123477094
 10450 003c 00000000 		.word	.LANCHOR128
 10451 0040 00000000 		.word	.LANCHOR116
 10452 0044 00000000 		.word	.LANCHOR129
 10453              		.cfi_endproc
 10454              	.LFE256:
 10456              		.section	.text._Z17readIntegerSerialv,"ax",%progbits
 10457              		.align	1
 10458              		.global	_Z17readIntegerSerialv
 10459              		.thumb
 10460              		.thumb_func
 10462              	_Z17readIntegerSerialv:
 10463              	.LFB270:
 686:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 687:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** // Used to read integer values from the serial port
 688:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** long readIntegerSerial() {
 10464              		.loc 34 688 0
 10465              		.cfi_startproc
 10466              		@ args = 0, pretend = 0, frame = 16
 10467              		@ frame_needed = 0, uses_anonymous_args = 0
 10468 0000 1FB5     		push	{r0, r1, r2, r3, r4, lr}
 10469              	.LCFI101:
 10470              		.cfi_def_cfa_offset 24
 10471              		.cfi_offset 14, -4
 10472              		.cfi_offset 4, -8
 10473              		.cfi_offset 3, -12
 10474              		.cfi_offset 2, -16
 10475              		.cfi_offset 1, -20
 10476              		.cfi_offset 0, -24
 10477              	.LBB312:
 689:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   char data[16] = "";
 10478              		.loc 34 689 0
 10479 0002 0021     		movs	r1, #0
 10480 0004 0C22     		movs	r2, #12
 10481 0006 01A8     		add	r0, sp, #4
 10482 0008 0091     		str	r1, [sp, #0]
 10483 000a FFF7FEFF 		bl	memset
 690:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 691:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   readValueSerial(data, sizeof(data));
 10484              		.loc 34 691 0
 10485 000e 6846     		mov	r0, sp
 10486 0010 1021     		movs	r1, #16
 10487 0012 FFF7FEFF 		bl	_Z15readValueSerialPch
 692:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   return atol(data);
 10488              		.loc 34 692 0
 10489 0016 6846     		mov	r0, sp
 10490 0018 FFF7FEFF 		bl	atol
 10491              	.LBE312:
 693:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10492              		.loc 34 693 0
 10493 001c 05B0     		add	sp, sp, #20
 10494 001e 00BD     		pop	{pc}
 10495              		.cfi_endproc
 10496              	.LFE270:
 10498              		.section	.text._Z17readSerialCommandv,"ax",%progbits
 10499              		.align	1
 10500              		.global	_Z17readSerialCommandv
 10501              		.thumb
 10502              		.thumb_func
 10504              	_Z17readSerialCommandv:
 10505              	.LFB258:
  64:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void readSerialCommand() {
 10506              		.loc 34 64 0
 10507              		.cfi_startproc
 10508              		@ args = 0, pretend = 0, frame = 0
 10509              		@ frame_needed = 0, uses_anonymous_args = 0
 10510 0000 38B5     		push	{r3, r4, r5, lr}
 10511              	.LCFI102:
 10512              		.cfi_def_cfa_offset 16
 10513              		.cfi_offset 14, -4
 10514              		.cfi_offset 5, -8
 10515              		.cfi_offset 4, -12
 10516              		.cfi_offset 3, -16
 10517              	.LBB313:
  66:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   if (SERIAL_AVAILABLE()) {
 10518              		.loc 34 66 0
 10519 0002 8648     		ldr	r0, .L667
 10520 0004 FFF7FEFF 		bl	_ZN9USBSerial9availableEv
 10521 0008 0028     		cmp	r0, #0
 10522 000a 00F0B781 		beq	.L625
 10523              	.LBB314:
  67:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = SERIAL_READ();
 10524              		.loc 34 67 0
 10525 000e 8348     		ldr	r0, .L667
 10526 0010 FFF7FEFF 		bl	_ZN9USBSerial4readEv
 10527 0014 824B     		ldr	r3, .L667+4
 10528 0016 1870     		strb	r0, [r3, #0]
 10529              	.LBB315:
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     switch (queryType) {
 10530              		.loc 34 68 0
 10531 0018 3138     		subs	r0, r0, #49
 10532 001a 2928     		cmp	r0, #41
 10533 001c 00F2AE81 		bhi	.L625
 10534 0020 DFE810F0 		tbh	[pc, r0, lsl #1]
 10535              	.L652:
 10536 0024 6501     		.2byte	(.L627-.L652)/2
 10537 0026 6701     		.2byte	(.L628-.L652)/2
 10538 0028 6C01     		.2byte	(.L629-.L652)/2
 10539 002a 7B01     		.2byte	(.L630-.L652)/2
 10540 002c 8801     		.2byte	(.L631-.L652)/2
 10541 002e AC01     		.2byte	(.L625-.L652)/2
 10542 0030 AC01     		.2byte	(.L625-.L652)/2
 10543 0032 AC01     		.2byte	(.L625-.L652)/2
 10544 0034 AC01     		.2byte	(.L625-.L652)/2
 10545 0036 AC01     		.2byte	(.L625-.L652)/2
 10546 0038 AC01     		.2byte	(.L625-.L652)/2
 10547 003a AC01     		.2byte	(.L625-.L652)/2
 10548 003c AC01     		.2byte	(.L625-.L652)/2
 10549 003e AC01     		.2byte	(.L625-.L652)/2
 10550 0040 AC01     		.2byte	(.L625-.L652)/2
 10551 0042 AC01     		.2byte	(.L625-.L652)/2
 10552 0044 2A00     		.2byte	(.L632-.L652)/2
 10553 0046 3400     		.2byte	(.L633-.L652)/2
 10554 0048 4500     		.2byte	(.L634-.L652)/2
 10555 004a 4C00     		.2byte	(.L635-.L652)/2
 10556 004c 8100     		.2byte	(.L636-.L652)/2
 10557 004e 8F00     		.2byte	(.L637-.L652)/2
 10558 0050 9D00     		.2byte	(.L638-.L652)/2
 10559 0052 AC00     		.2byte	(.L639-.L652)/2
 10560 0054 BE00     		.2byte	(.L640-.L652)/2
 10561 0056 D000     		.2byte	(.L641-.L652)/2
 10562 0058 D300     		.2byte	(.L642-.L652)/2
 10563 005a EB00     		.2byte	(.L643-.L652)/2
 10564 005c EE00     		.2byte	(.L644-.L652)/2
 10565 005e 2401     		.2byte	(.L645-.L652)/2
 10566 0060 3F01     		.2byte	(.L646-.L652)/2
 10567 0062 4901     		.2byte	(.L656-.L652)/2
 10568 0064 AC01     		.2byte	(.L625-.L652)/2
 10569 0066 AC01     		.2byte	(.L625-.L652)/2
 10570 0068 AC01     		.2byte	(.L625-.L652)/2
 10571 006a AC01     		.2byte	(.L625-.L652)/2
 10572 006c 5101     		.2byte	(.L648-.L652)/2
 10573 006e 5701     		.2byte	(.L657-.L652)/2
 10574 0070 5F01     		.2byte	(.L650-.L652)/2
 10575 0072 AC01     		.2byte	(.L625-.L652)/2
 10576 0074 AC01     		.2byte	(.L625-.L652)/2
 10577 0076 9B01     		.2byte	(.L651-.L652)/2
 10578              	.L632:
 10579              	.LBB316:
  70:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(RATE_XAXIS_PID_IDX);
 10580              		.loc 34 70 0
 10581 0078 0020     		movs	r0, #0
 10582 007a FFF7FEFF 		bl	_Z13readSerialPIDh
  71:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(RATE_YAXIS_PID_IDX);
 10583              		.loc 34 71 0
 10584 007e 0120     		movs	r0, #1
 10585 0080 FFF7FEFF 		bl	_Z13readSerialPIDh
  72:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       rotationSpeedFactor = readFloatSerial();
 10586              		.loc 34 72 0
 10587 0084 FFF7FEFF 		bl	_Z15readFloatSerialv
 10588 0088 664B     		ldr	r3, .L667+8
 10589 008a 0EE0     		b	.L665
 10590              	.L633:
  76:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ATTITUDE_XAXIS_PID_IDX);
 10591              		.loc 34 76 0
 10592 008c 0320     		movs	r0, #3
 10593 008e FFF7FEFF 		bl	_Z13readSerialPIDh
  77:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ATTITUDE_YAXIS_PID_IDX);
 10594              		.loc 34 77 0
 10595 0092 0420     		movs	r0, #4
 10596 0094 FFF7FEFF 		bl	_Z13readSerialPIDh
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ATTITUDE_GYRO_XAXIS_PID_IDX);
 10597              		.loc 34 78 0
 10598 0098 0620     		movs	r0, #6
 10599 009a FFF7FEFF 		bl	_Z13readSerialPIDh
  79:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ATTITUDE_GYRO_YAXIS_PID_IDX);
 10600              		.loc 34 79 0
 10601 009e 0720     		movs	r0, #7
 10602 00a0 FFF7FEFF 		bl	_Z13readSerialPIDh
  80:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       windupGuard = readFloatSerial(); // defaults found in setup() of AeroQuad.pde
 10603              		.loc 34 80 0
 10604 00a4 FFF7FEFF 		bl	_Z15readFloatSerialv
 10605 00a8 5F4B     		ldr	r3, .L667+12
 10606              	.L665:
 10607 00aa 1860     		str	r0, [r3, #0]	@ float
  81:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 10608              		.loc 34 81 0
 10609 00ac 38BD     		pop	{r3, r4, r5, pc}
 10610              	.L634:
  84:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ZAXIS_PID_IDX);
 10611              		.loc 34 84 0
 10612 00ae 0220     		movs	r0, #2
 10613 00b0 FFF7FEFF 		bl	_Z13readSerialPIDh
  85:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(HEADING_HOLD_PID_IDX);
 10614              		.loc 34 85 0
 10615 00b4 0520     		movs	r0, #5
 10616 00b6 FFF7FEFF 		bl	_Z13readSerialPIDh
 10617 00ba 06E1     		b	.L662
 10618              	.L635:
  91:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readSerialPID(BARO_ALTITUDE_HOLD_PID_IDX);
 10619              		.loc 34 91 0
 10620 00bc 0820     		movs	r0, #8
 10621 00be FFF7FEFF 		bl	_Z13readSerialPIDh
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard = readFloatSerial();
 10622              		.loc 34 92 0
 10623 00c2 FFF7FEFF 		bl	_Z15readFloatSerialv
 10624 00c6 594A     		ldr	r2, .L667+16
 10625 00c8 C2F8F800 		str	r0, [r2, #248]	@ float
  93:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         altitudeHoldBump = readFloatSerial();
 10626              		.loc 34 93 0
 10627 00cc FFF7FEFF 		bl	_Z15readFloatSerialv
 10628 00d0 02EE900A 		fmsr	s5, r0
 10629 00d4 5649     		ldr	r1, .L667+20
 10630 00d6 BDEEE22A 		ftosizs	s4, s5
 10631 00da 81ED002A 		fsts	s4, [r1, #0]	@ int
  94:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         altitudeHoldPanicStickMovement = readFloatSerial();
 10632              		.loc 34 94 0
 10633 00de FFF7FEFF 		bl	_Z15readFloatSerialv
 10634 00e2 01EE900A 		fmsr	s3, r0
 10635 00e6 534B     		ldr	r3, .L667+24
 10636 00e8 BDEEE11A 		ftosizs	s2, s3
 10637 00ec 83ED001A 		fsts	s2, [r3, #0]	@ int
  95:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         minThrottleAdjust = readFloatSerial();
 10638              		.loc 34 95 0
 10639 00f0 FFF7FEFF 		bl	_Z15readFloatSerialv
 10640 00f4 00EE900A 		fmsr	s1, r0
 10641 00f8 4F4A     		ldr	r2, .L667+28
 10642 00fa BDEEE07A 		ftosizs	s14, s1
 10643 00fe 82ED007A 		fsts	s14, [r2, #0]	@ int
  96:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         maxThrottleAdjust = readFloatSerial();
 10644              		.loc 34 96 0
 10645 0102 FFF7FEFF 		bl	_Z15readFloatSerialv
 10646 0106 00EE100A 		fmsr	s0, r0
 10647 010a 4C48     		ldr	r0, .L667+32
 10648 010c FDEEC07A 		ftosizs	s15, s0
 10649 0110 C0ED007A 		fsts	s15, [r0, #0]	@ int
  98:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           baroSmoothFactor = readFloatSerial();
 10650              		.loc 34 98 0
 10651 0114 FFF7FEFF 		bl	_Z15readFloatSerialv
 10652 0118 4949     		ldr	r1, .L667+36
 10653 011a 0860     		str	r0, [r1, #0]	@ float
 102:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readSerialPID(ZDAMPENING_PID_IDX);
 10654              		.loc 34 102 0
 10655 011c 0920     		movs	r0, #9
 10656              	.LBE316:
 10657              	.LBE315:
 10658              	.LBE314:
 10659              	.LBE313:
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10660              		.loc 34 294 0
 10661 011e BDE83840 		pop	{r3, r4, r5, lr}
 10662              	.LBB351:
 10663              	.LBB342:
 10664              	.LBB333:
 10665              	.LBB322:
 102:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readSerialPID(ZDAMPENING_PID_IDX);
 10666              		.loc 34 102 0
 10667 0122 FFF7FEBF 		b	_Z13readSerialPIDh
 10668              	.L636:
 107:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       aref = readFloatSerial();
 10669              		.loc 34 107 0
 10670 0126 FFF7FEFF 		bl	_Z15readFloatSerialv
 10671 012a 464B     		ldr	r3, .L667+40
 10672 012c 1860     		str	r0, [r3, #0]	@ float
 108:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       minArmedThrottle = readFloatSerial();
 10673              		.loc 34 108 0
 10674 012e FFF7FEFF 		bl	_Z15readFloatSerialv
 10675 0132 03EE900A 		fmsr	s7, r0
 10676 0136 4448     		ldr	r0, .L667+44
 10677 0138 BDEEE33A 		ftosizs	s6, s7
 10678 013c 80ED003A 		fsts	s6, [r0, #0]	@ int
 109:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 10679              		.loc 34 109 0
 10680 0140 38BD     		pop	{r3, r4, r5, pc}
 10681              	.L637:
 112:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       receiverXmitFactor = readFloatSerial();
 10682              		.loc 34 112 0
 10683 0142 FFF7FEFF 		bl	_Z15readFloatSerialv
 10684 0146 414C     		ldr	r4, .L667+48
 10685 0148 2060     		str	r0, [r4, #0]	@ float
 10686              	.LVL465:
 10687 014a 414C     		ldr	r4, .L667+52
  64:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void readSerialCommand() {
 10688              		.loc 34 64 0
 10689 014c 04F12005 		add	r5, r4, #32
 10690              	.LVL466:
 10691              	.L653:
 10692              	.LBB317:
 114:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         receiverSmoothFactor[channel] = readFloatSerial();
 10693              		.loc 34 114 0 discriminator 2
 10694 0150 FFF7FEFF 		bl	_Z15readFloatSerialv
 10695 0154 44F8040F 		str	r0, [r4, #4]!	@ float
 113:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       for(byte channel = XAXIS; channel<LASTCHANNEL; channel++) {
 10696              		.loc 34 113 0 discriminator 2
 10697 0158 AC42     		cmp	r4, r5
 10698 015a F9D1     		bne	.L653
 10699 015c 38BD     		pop	{r3, r4, r5, pc}
 10700              	.L638:
 10701              	.LBE317:
 119:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       channelCal = (int)readFloatSerial();
 10702              		.loc 34 119 0
 10703 015e FFF7FEFF 		bl	_Z15readFloatSerialv
 10704 0162 04EE900A 		fmsr	s9, r0
 10705 0166 3B49     		ldr	r1, .L667+56
 10706 0168 BDEEE44A 		ftosizs	s8, s9
 10707 016c 81ED004A 		fsts	s8, [r1, #0]	@ int
 10708 0170 14EE104A 		fmrs	r4, s8	@ int
 120:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       receiverSlope[channelCal] = readFloatSerial();
 10709              		.loc 34 120 0
 10710 0174 FFF7FEFF 		bl	_Z15readFloatSerialv
 10711 0178 374B     		ldr	r3, .L667+60
 10712 017a 0DE0     		b	.L666
 10713              	.L639:
 124:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       channelCal = (int)readFloatSerial();
 10714              		.loc 34 124 0
 10715 017c FFF7FEFF 		bl	_Z15readFloatSerialv
 10716 0180 05EE900A 		fmsr	s11, r0
 10717 0184 334A     		ldr	r2, .L667+56
 10718 0186 BDEEE55A 		ftosizs	s10, s11
 10719 018a 82ED005A 		fsts	s10, [r2, #0]	@ int
 10720 018e 15EE104A 		fmrs	r4, s10	@ int
 125:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       receiverOffset[channelCal] = readFloatSerial();
 10721              		.loc 34 125 0
 10722 0192 FFF7FEFF 		bl	_Z15readFloatSerialv
 10723 0196 314B     		ldr	r3, .L667+64
 10724              	.L666:
 10725 0198 03EB8404 		add	r4, r3, r4, lsl #2
 10726 019c 2060     		str	r0, [r4, #0]	@ float
 126:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 10727              		.loc 34 126 0
 10728 019e 38BD     		pop	{r3, r4, r5, pc}
 10729              	.L640:
 129:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       initializeEEPROM(); // defined in DataStorage.h
 10730              		.loc 34 129 0
 10731 01a0 FFF7FEFF 		bl	_Z16initializeEEPROMv
 130:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       writeEEPROM();
 10732              		.loc 34 130 0
 10733 01a4 FFF7FEFF 		bl	_Z11writeEEPROMv
 131:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       storeSensorsZeroToEEPROM();
 10734              		.loc 34 131 0
 10735 01a8 FFF7FEFF 		bl	_Z24storeSensorsZeroToEEPROMv
 132:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       calibrateGyro();
 10736              		.loc 34 132 0
 10737 01ac FFF7FEFF 		bl	_Z13calibrateGyrov
 133:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       computeAccelBias();
 10738              		.loc 34 133 0
 10739 01b0 FFF7FEFF 		bl	_Z16computeAccelBiasv
 134:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       zeroIntegralError();
 10740              		.loc 34 134 0
 10741 01b4 FFF7FEFF 		bl	_Z17zeroIntegralErrorv
 136:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         initializeMagnetometer();
 10742              		.loc 34 136 0
 10743 01b8 FFF7FEFF 		bl	_Z22initializeMagnetometerv
 10744              	.LBE322:
 10745              	.LBE333:
 10746              	.LBE342:
 10747              	.LBE351:
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10748              		.loc 34 294 0
 10749 01bc BDE83840 		pop	{r3, r4, r5, lr}
 10750              	.LBB352:
 10751              	.LBB343:
 10752              	.LBB334:
 10753              	.LBB323:
 139:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         initializeBaro();
 10754              		.loc 34 139 0
 10755 01c0 FFF7FEBF 		b	_Z14initializeBarov
 10756              	.L641:
 144:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       calibrateGyro();
 10757              		.loc 34 144 0
 10758 01c4 FFF7FEFF 		bl	_Z13calibrateGyrov
 10759 01c8 13E0     		b	.L663
 10760              	.L642:
 149:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       accelScaleFactor[XAXIS] = readFloatSerial();
 10761              		.loc 34 149 0
 10762 01ca FFF7FEFF 		bl	_Z15readFloatSerialv
 10763 01ce 244D     		ldr	r5, .L667+68
 150:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       runTimeAccelBias[XAXIS] = readFloatSerial();      
 10764              		.loc 34 150 0
 10765 01d0 244C     		ldr	r4, .L667+72
 149:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       accelScaleFactor[XAXIS] = readFloatSerial();
 10766              		.loc 34 149 0
 10767 01d2 2860     		str	r0, [r5, #0]	@ float
 150:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       runTimeAccelBias[XAXIS] = readFloatSerial();      
 10768              		.loc 34 150 0
 10769 01d4 FFF7FEFF 		bl	_Z15readFloatSerialv
 10770 01d8 2060     		str	r0, [r4, #0]	@ float
 151:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       accelScaleFactor[YAXIS] = readFloatSerial();
 10771              		.loc 34 151 0
 10772 01da FFF7FEFF 		bl	_Z15readFloatSerialv
 10773 01de 6860     		str	r0, [r5, #4]	@ float
 152:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       runTimeAccelBias[YAXIS] = readFloatSerial();      
 10774              		.loc 34 152 0
 10775 01e0 FFF7FEFF 		bl	_Z15readFloatSerialv
 10776 01e4 6060     		str	r0, [r4, #4]	@ float
 153:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       accelScaleFactor[ZAXIS] = readFloatSerial();
 10777              		.loc 34 153 0
 10778 01e6 FFF7FEFF 		bl	_Z15readFloatSerialv
 10779 01ea A860     		str	r0, [r5, #8]	@ float
 154:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       runTimeAccelBias[ZAXIS] = readFloatSerial();
 10780              		.loc 34 154 0
 10781 01ec FFF7FEFF 		bl	_Z15readFloatSerialv
 10782 01f0 A060     		str	r0, [r4, #8]	@ float
 10783              	.L663:
 10784              	.LBE323:
 10785              	.LBE334:
 10786              	.LBE343:
 10787              	.LBE352:
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10788              		.loc 34 294 0
 10789 01f2 BDE83840 		pop	{r3, r4, r5, lr}
 10790              	.LBB353:
 10791              	.LBB344:
 10792              	.LBB335:
 10793              	.LBB324:
 155:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       storeSensorsZeroToEEPROM();
 10794              		.loc 34 155 0
 10795 01f6 FFF7FEBF 		b	_Z24storeSensorsZeroToEEPROMv
 10796              	.L643:
 159:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       computeAccelBias();
 10797              		.loc 34 159 0
 10798 01fa FFF7FEFF 		bl	_Z16computeAccelBiasv
 10799 01fe F8E7     		b	.L663
 10800              	.L644:
 169:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         magBias[XAXIS]  = readFloatSerial();      
 10801              		.loc 34 169 0
 10802 0200 FFF7FEFF 		bl	_Z15readFloatSerialv
 10803 0204 184C     		ldr	r4, .L667+76
 10804 0206 2060     		str	r0, [r4, #0]	@ float
 170:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         magBias[YAXIS]  = readFloatSerial();
 10805              		.loc 34 170 0
 10806 0208 FFF7FEFF 		bl	_Z15readFloatSerialv
 10807 020c 6060     		str	r0, [r4, #4]	@ float
 171:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         magBias[ZAXIS]  = readFloatSerial();
 10808              		.loc 34 171 0
 10809 020e FFF7FEFF 		bl	_Z15readFloatSerialv
 10810 0212 A060     		str	r0, [r4, #8]	@ float
 10811              	.LBE324:
 10812              	.LBE335:
 10813              	.LBE344:
 10814              	.LBE353:
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10815              		.loc 34 294 0
 10816 0214 BDE83840 		pop	{r3, r4, r5, lr}
 10817              	.LBB354:
 10818              	.LBB345:
 10819              	.LBB336:
 10820              	.LBB325:
 172:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         writeEEPROM();
 10821              		.loc 34 172 0
 10822 0218 FFF7FEBF 		b	_Z11writeEEPROMv
 10823              	.L668:
 10824              		.align	2
 10825              	.L667:
 10826 021c 00000000 		.word	SerialUSB
 10827 0220 00000000 		.word	.LANCHOR148
 10828 0224 00000000 		.word	.LANCHOR127
 10829 0228 00000000 		.word	.LANCHOR142
 10830 022c 00000000 		.word	.LANCHOR17
 10831 0230 00000000 		.word	.LANCHOR8
 10832 0234 00000000 		.word	.LANCHOR126
 10833 0238 00000000 		.word	.LANCHOR124
 10834 023c 00000000 		.word	.LANCHOR125
 10835 0240 00000000 		.word	.LANCHOR97
 10836 0244 00000000 		.word	.LANCHOR143
 10837 0248 00000000 		.word	.LANCHOR132
 10838 024c 00000000 		.word	.LANCHOR61
 10839 0250 FCFFFFFF 		.word	.LANCHOR14-4
 10840 0254 00000000 		.word	.LANCHOR149
 10841 0258 00000000 		.word	.LANCHOR12
 10842 025c 00000000 		.word	.LANCHOR13
 10843 0260 00000000 		.word	.LANCHOR35
 10844 0264 00000000 		.word	.LANCHOR36
 10845 0268 00000000 		.word	.LANCHOR76
 10846              	.L645:
 182:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         batteryMonitorAlarmVoltage = readFloatSerial();
 10847              		.loc 34 182 0
 10848 026c FFF7FEFF 		bl	_Z15readFloatSerialv
 10849 0270 434C     		ldr	r4, .L669
 10850 0272 2060     		str	r0, [r4, #0]	@ float
 183:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         batteryMonitorThrottleTarget = readFloatSerial();
 10851              		.loc 34 183 0
 10852 0274 FFF7FEFF 		bl	_Z15readFloatSerialv
 10853 0278 00EE100A 		fmsr	s0, r0
 10854 027c 414B     		ldr	r3, .L669+4
 10855 027e FDEEC07A 		ftosizs	s15, s0
 10856 0282 C3ED007A 		fsts	s15, [r3, #0]	@ int
 184:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         batteryMonitorGoingDownTime = readFloatSerial();
 10857              		.loc 34 184 0
 10858 0286 FFF7FEFF 		bl	_Z15readFloatSerialv
 10859 028a 06EE900A 		fmsr	s13, r0
 10860 028e 3E48     		ldr	r0, .L669+8
 10861 0290 BCEEE66A 		ftouizs	s12, s13
 10862 0294 80ED006A 		fsts	s12, [r0, #0]	@ int
 185:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         setBatteryCellVoltageThreshold(batteryMonitorAlarmVoltage);
 10863              		.loc 34 185 0
 10864 0298 2068     		ldr	r0, [r4, #0]	@ float
 10865              	.LBE325:
 10866              	.LBE336:
 10867              	.LBE345:
 10868              	.LBE354:
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10869              		.loc 34 294 0
 10870 029a BDE83840 		pop	{r3, r4, r5, lr}
 10871              	.LBB355:
 10872              	.LBB346:
 10873              	.LBB337:
 10874              	.LBB326:
 185:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         setBatteryCellVoltageThreshold(batteryMonitorAlarmVoltage);
 10875              		.loc 34 185 0
 10876 029e FFF7FEBF 		b	_Z30setBatteryCellVoltageThresholdf
 10877              	.L646:
 200:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readIntegerSerial();
 10878              		.loc 34 200 0
 10879 02a2 FFF7FEFF 		bl	_Z17readIntegerSerialv
 201:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readIntegerSerial();
 10880              		.loc 34 201 0
 10881 02a6 FFF7FEFF 		bl	_Z17readIntegerSerialv
 202:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readIntegerSerial();
 10882              		.loc 34 202 0
 10883 02aa FFF7FEFF 		bl	_Z17readIntegerSerialv
 10884              	.LBE326:
 10885              	.LBE337:
 10886              	.LBE346:
 10887              	.LBE355:
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10888              		.loc 34 294 0
 10889 02ae BDE83840 		pop	{r3, r4, r5, lr}
 10890              	.LBB356:
 10891              	.LBB347:
 10892              	.LBB338:
 10893              	.LBB327:
 203:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readIntegerSerial();
 10894              		.loc 34 203 0
 10895 02b2 FFF7FEBF 		b	_Z17readIntegerSerialv
 10896              	.L656:
 10897              	.LBE327:
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     switch (queryType) {
 10898              		.loc 34 68 0
 10899 02b6 0D24     		movs	r4, #13
 10900              	.L647:
 10901              	.LBB328:
 10902              	.LBB318:
 223:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           readFloatSerial();
 10903              		.loc 34 223 0 discriminator 2
 10904 02b8 013C     		subs	r4, r4, #1
 10905 02ba E4B2     		uxtb	r4, r4
 10906 02bc FFF7FEFF 		bl	_Z15readFloatSerialv
 222:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         for (byte values = 0; values < 13; values++)
 10907              		.loc 34 222 0 discriminator 2
 10908 02c0 002C     		cmp	r4, #0
 10909 02c2 F9D1     		bne	.L647
 10910 02c4 38BD     		pop	{r3, r4, r5, pc}
 10911              	.LVL467:
 10912              	.L648:
 10913              	.LBE318:
 232:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readFloatSerial();
 10914              		.loc 34 232 0
 10915 02c6 FFF7FEFF 		bl	_Z15readFloatSerialv
 10916              	.L662:
 10917              	.LBE328:
 10918              	.LBE338:
 10919              	.LBE347:
 10920              	.LBE356:
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10921              		.loc 34 294 0
 10922 02ca BDE83840 		pop	{r3, r4, r5, lr}
 10923              	.LBB357:
 10924              	.LBB348:
 10925              	.LBB339:
 10926              	.LBB329:
 233:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readFloatSerial();
 10927              		.loc 34 233 0
 10928 02ce FFF7FEBF 		b	_Z15readFloatSerialv
 10929              	.L657:
 10930              	.LBE329:
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     switch (queryType) {
 10931              		.loc 34 68 0
 10932 02d2 0624     		movs	r4, #6
 10933              	.L649:
 10934              	.LBB330:
 10935              	.LBB319:
 245:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           readFloatSerial();
 10936              		.loc 34 245 0 discriminator 2
 10937 02d4 FFF7FEFF 		bl	_Z15readFloatSerialv
 10938 02d8 611E     		subs	r1, r4, #1
 10939 02da CCB2     		uxtb	r4, r1
 244:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         for (byte values = 0; values < 6; values++) {
 10940              		.loc 34 244 0 discriminator 2
 10941 02dc 002C     		cmp	r4, #0
 10942 02de F9D1     		bne	.L649
 10943 02e0 38BD     		pop	{r3, r4, r5, pc}
 10944              	.LVL468:
 10945              	.L650:
 10946              	.LBE319:
 251:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       writeEEPROM(); // defined in DataStorage.h
 10947              		.loc 34 251 0
 10948 02e2 FFF7FEFF 		bl	_Z11writeEEPROMv
 10949              	.LBE330:
 10950              	.LBE339:
 10951              	.LBE348:
 10952              	.LBE357:
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10953              		.loc 34 294 0
 10954 02e6 BDE83840 		pop	{r3, r4, r5, lr}
 10955              	.LBB358:
 10956              	.LBB349:
 10957              	.LBB340:
 10958              	.LBB331:
 252:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       zeroIntegralError();
 10959              		.loc 34 252 0
 10960 02ea FFF7FEBF 		b	_Z17zeroIntegralErrorv
 10961              	.L627:
 259:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         validateCalibrateCommand(1);
 10962              		.loc 34 259 0
 10963 02ee 0120     		movs	r0, #1
 10964 02f0 00E0     		b	.L664
 10965              	.L628:
 263:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         validateCalibrateCommand(2);
 10966              		.loc 34 263 0
 10967 02f2 0220     		movs	r0, #2
 10968              	.L664:
 10969              	.LBE331:
 10970              	.LBE340:
 10971              	.LBE349:
 10972              	.LBE358:
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10973              		.loc 34 294 0
 10974 02f4 BDE83840 		pop	{r3, r4, r5, lr}
 10975              	.LBB359:
 10976              	.LBB350:
 10977              	.LBB341:
 10978              	.LBB332:
 263:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         validateCalibrateCommand(2);
 10979              		.loc 34 263 0
 10980 02f8 FFF7FEBF 		b	_Z24validateCalibrateCommandh
 10981              	.L629:
 267:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       if (validateCalibrateCommand(3)) {
 10982              		.loc 34 267 0
 10983 02fc 0320     		movs	r0, #3
 10984 02fe FFF7FEFF 		bl	_Z24validateCalibrateCommandh
 10985 0302 0028     		cmp	r0, #0
 10986 0304 3AD0     		beq	.L625
 268:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         testCommand = readFloatSerial();
 10987              		.loc 34 268 0
 10988 0306 FFF7FEFF 		bl	_Z15readFloatSerialv
 10989 030a 00EE900A 		fmsr	s1, r0
 10990 030e 1F4A     		ldr	r2, .L669+12
 10991 0310 BDEEE07A 		ftosizs	s14, s1
 10992 0314 82ED007A 		fsts	s14, [r2, #0]	@ int
 10993 0318 38BD     		pop	{r3, r4, r5, pc}
 10994              	.L630:
 273:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       if (validateCalibrateCommand(4)) {
 10995              		.loc 34 273 0
 10996 031a 0420     		movs	r0, #4
 10997 031c FFF7FEFF 		bl	_Z24validateCalibrateCommandh
 10998 0320 0028     		cmp	r0, #0
 10999 0322 2BD0     		beq	.L625
 274:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         calibrateESC = 0;
 11000              		.loc 34 274 0
 11001 0324 1A4A     		ldr	r2, .L669+16
 275:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         testCommand = 1000;
 11002              		.loc 34 275 0
 11003 0326 194B     		ldr	r3, .L669+12
 274:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         calibrateESC = 0;
 11004              		.loc 34 274 0
 11005 0328 0021     		movs	r1, #0
 275:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         testCommand = 1000;
 11006              		.loc 34 275 0
 11007 032a 4FF47A70 		mov	r0, #1000
 274:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         calibrateESC = 0;
 11008              		.loc 34 274 0
 11009 032e 1170     		strb	r1, [r2, #0]
 275:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         testCommand = 1000;
 11010              		.loc 34 275 0
 11011 0330 1860     		str	r0, [r3, #0]
 11012 0332 38BD     		pop	{r3, r4, r5, pc}
 11013              	.L631:
 11014              	.LBB320:
 280:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       if (validateCalibrateCommand(5)) {
 11015              		.loc 34 280 0
 11016 0334 0520     		movs	r0, #5
 11017 0336 FFF7FEFF 		bl	_Z24validateCalibrateCommandh
 11018 033a F8B1     		cbz	r0, .L625
 11019 033c 0024     		movs	r4, #0
 11020              	.L654:
 11021              	.LBB321:
 282:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           motorConfiguratorCommand[motor] = (int)readFloatSerial();
 11022              		.loc 34 282 0 discriminator 2
 11023 033e FFF7FEFF 		bl	_Z15readFloatSerialv
 11024 0342 01EE900A 		fmsr	s3, r0
 11025 0346 BDEEE11A 		ftosizs	s2, s3
 11026 034a 124B     		ldr	r3, .L669+20
 11027 034c 11EE100A 		fmrs	r0, s2	@ int
 11028 0350 E050     		str	r0, [r4, r3]
 11029 0352 0434     		adds	r4, r4, #4
 281:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         for (byte motor = 0; motor < LASTMOTOR; motor++)
 11030              		.loc 34 281 0 discriminator 2
 11031 0354 102C     		cmp	r4, #16
 11032 0356 F2D1     		bne	.L654
 11033 0358 38BD     		pop	{r3, r4, r5, pc}
 11034              	.LVL469:
 11035              	.L651:
 11036              	.LBE321:
 11037              	.LBE320:
 287:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       if (readFloatSerial() == 1.0)
 11038              		.loc 34 287 0
 11039 035a FFF7FEFF 		bl	_Z15readFloatSerialv
 11040 035e 02EE100A 		fmsr	s4, r0
 11041 0362 F7EE002A 		fconsts	s5, #112
 11042 0366 B4EE622A 		fcmps	s4, s5
 11043 036a F1EE10FA 		fmstat
 11044 036e 0A4B     		ldr	r3, .L669+24
 11045 0370 02D1     		bne	.L655
 288:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         fastTransfer = ON;
 11046              		.loc 34 288 0
 11047 0372 0121     		movs	r1, #1
 11048 0374 1970     		strb	r1, [r3, #0]
 11049 0376 38BD     		pop	{r3, r4, r5, pc}
 11050              	.L655:
 290:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         fastTransfer = OFF;
 11051              		.loc 34 290 0
 11052 0378 0022     		movs	r2, #0
 11053 037a 1A70     		strb	r2, [r3, #0]
 11054              	.L625:
 11055 037c 38BD     		pop	{r3, r4, r5, pc}
 11056              	.L670:
 11057 037e 00BF     		.align	2
 11058              	.L669:
 11059 0380 00000000 		.word	.LANCHOR144
 11060 0384 00000000 		.word	.LANCHOR145
 11061 0388 00000000 		.word	.LANCHOR146
 11062 038c 00000000 		.word	.LANCHOR129
 11063 0390 00000000 		.word	.LANCHOR128
 11064 0394 00000000 		.word	.LANCHOR130
 11065 0398 00000000 		.word	.LANCHOR150
 11066              	.LBE332:
 11067              	.LBE341:
 11068              	.LBE350:
 11069              	.LBE359:
 11070              		.cfi_endproc
 11071              	.LFE258:
 11073              		.section	.text._Z5commav,"ax",%progbits
 11074              		.align	1
 11075              		.global	_Z5commav
 11076              		.thumb
 11077              		.thumb_func
 11079              	_Z5commav:
 11080              	.LFB271:
 694:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 695:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void comma() {
 11081              		.loc 34 695 0
 11082              		.cfi_startproc
 11083              		@ args = 0, pretend = 0, frame = 0
 11084              		@ frame_needed = 0, uses_anonymous_args = 0
 11085              		@ link register save eliminated.
 696:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(',');
 11086              		.loc 34 696 0
 11087 0000 0148     		ldr	r0, .L672
 11088 0002 2C21     		movs	r1, #44
 697:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 11089              		.loc 34 697 0
 696:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(',');
 11090              		.loc 34 696 0
 11091 0004 FFF7FEBF 		b	_ZN5Print5printEc
 11092              	.L673:
 11093              		.align	2
 11094              	.L672:
 11095 0008 00000000 		.word	SerialUSB
 11096              		.cfi_endproc
 11097              	.LFE271:
 11099              		.section	.text._Z15PrintValueCommal,"ax",%progbits
 11100              		.align	1
 11101              		.global	_Z15PrintValueCommal
 11102              		.thumb
 11103              		.thumb_func
 11105              	_Z15PrintValueCommal:
 11106              	.LFB265:
 333:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 11107              		.loc 34 333 0
 11108              		.cfi_startproc
 11109              		@ args = 0, pretend = 0, frame = 0
 11110              		@ frame_needed = 0, uses_anonymous_args = 0
 11111              	.LVL470:
 11112 0000 08B5     		push	{r3, lr}
 11113              	.LCFI103:
 11114              		.cfi_def_cfa_offset 8
 11115              		.cfi_offset 14, -4
 11116              		.cfi_offset 3, -8
 333:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 11117              		.loc 34 333 0
 11118 0002 0146     		mov	r1, r0
 334:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 11119              		.loc 34 334 0
 11120 0004 0A22     		movs	r2, #10
 11121 0006 0348     		ldr	r0, .L675
 11122              	.LVL471:
 11123 0008 FFF7FEFF 		bl	_ZN5Print5printEli
 11124              	.LVL472:
 336:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 11125              		.loc 34 336 0
 11126 000c BDE80840 		pop	{r3, lr}
 335:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 11127              		.loc 34 335 0
 11128 0010 FFF7FEBF 		b	_Z5commav
 11129              	.L676:
 11130              		.align	2
 11131              	.L675:
 11132 0014 00000000 		.word	SerialUSB
 11133              		.cfi_endproc
 11134              	.LFE265:
 11136              		.section	.text._Z15PrintValueCommah,"ax",%progbits
 11137              		.align	1
 11138              		.global	_Z15PrintValueCommah
 11139              		.thumb
 11140              		.thumb_func
 11142              	_Z15PrintValueCommah:
 11143              	.LFB264:
 327:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 11144              		.loc 34 327 0
 11145              		.cfi_startproc
 11146              		@ args = 0, pretend = 0, frame = 0
 11147              		@ frame_needed = 0, uses_anonymous_args = 0
 11148              	.LVL473:
 11149 0000 08B5     		push	{r3, lr}
 11150              	.LCFI104:
 11151              		.cfi_def_cfa_offset 8
 11152              		.cfi_offset 14, -4
 11153              		.cfi_offset 3, -8
 327:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 11154              		.loc 34 327 0
 11155 0002 0146     		mov	r1, r0
 328:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 11156              		.loc 34 328 0
 11157 0004 0A22     		movs	r2, #10
 11158 0006 0348     		ldr	r0, .L678
 11159              	.LVL474:
 11160 0008 FFF7FEFF 		bl	_ZN5Print5printEhi
 330:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 11161              		.loc 34 330 0
 11162 000c BDE80840 		pop	{r3, lr}
 329:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 11163              		.loc 34 329 0
 11164 0010 FFF7FEBF 		b	_Z5commav
 11165              	.L679:
 11166              		.align	2
 11167              	.L678:
 11168 0014 00000000 		.word	SerialUSB
 11169              		.cfi_endproc
 11170              	.LFE264:
 11172              		.section	.text._Z15PrintValueCommam,"ax",%progbits
 11173              		.align	1
 11174              		.global	_Z15PrintValueCommam
 11175              		.thumb
 11176              		.thumb_func
 11178              	_Z15PrintValueCommam:
 11179              	.LFB263:
 321:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 11180              		.loc 34 321 0
 11181              		.cfi_startproc
 11182              		@ args = 0, pretend = 0, frame = 0
 11183              		@ frame_needed = 0, uses_anonymous_args = 0
 11184              	.LVL475:
 11185 0000 08B5     		push	{r3, lr}
 11186              	.LCFI105:
 11187              		.cfi_def_cfa_offset 8
 11188              		.cfi_offset 14, -4
 11189              		.cfi_offset 3, -8
 321:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 11190              		.loc 34 321 0
 11191 0002 0146     		mov	r1, r0
 322:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 11192              		.loc 34 322 0
 11193 0004 0A22     		movs	r2, #10
 11194 0006 0348     		ldr	r0, .L681
 11195              	.LVL476:
 11196 0008 FFF7FEFF 		bl	_ZN5Print5printEmi
 11197              	.LVL477:
 324:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 11198              		.loc 34 324 0
 11199 000c BDE80840 		pop	{r3, lr}
 323:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 11200              		.loc 34 323 0
 11201 0010 FFF7FEBF 		b	_Z5commav
 11202              	.L682:
 11203              		.align	2
 11204              	.L681:
 11205 0014 00000000 		.word	SerialUSB
 11206              		.cfi_endproc
 11207              	.LFE263:
 11209              		.section	.text._Z15PrintValueCommai,"ax",%progbits
 11210              		.align	1
 11211              		.global	_Z15PrintValueCommai
 11212              		.thumb
 11213              		.thumb_func
 11215              	_Z15PrintValueCommai:
 11216              	.LFB262:
 315:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(int val) {
 11217              		.loc 34 315 0
 11218              		.cfi_startproc
 11219              		@ args = 0, pretend = 0, frame = 0
 11220              		@ frame_needed = 0, uses_anonymous_args = 0
 11221              	.LVL478:
 11222 0000 08B5     		push	{r3, lr}
 11223              	.LCFI106:
 11224              		.cfi_def_cfa_offset 8
 11225              		.cfi_offset 14, -4
 11226              		.cfi_offset 3, -8
 315:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(int val) {
 11227              		.loc 34 315 0
 11228 0002 0146     		mov	r1, r0
 316:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 11229              		.loc 34 316 0
 11230 0004 0A22     		movs	r2, #10
 11231 0006 0348     		ldr	r0, .L684
 11232              	.LVL479:
 11233 0008 FFF7FEFF 		bl	_ZN5Print5printEii
 11234              	.LVL480:
 318:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 11235              		.loc 34 318 0
 11236 000c BDE80840 		pop	{r3, lr}
 317:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 11237              		.loc 34 317 0
 11238 0010 FFF7FEBF 		b	_Z5commav
 11239              	.L685:
 11240              		.align	2
 11241              	.L684:
 11242 0014 00000000 		.word	SerialUSB
 11243              		.cfi_endproc
 11244              	.LFE262:
 11246              		.section	.text._Z15PrintValueCommac,"ax",%progbits
 11247              		.align	1
 11248              		.global	_Z15PrintValueCommac
 11249              		.thumb
 11250              		.thumb_func
 11252              	_Z15PrintValueCommac:
 11253              	.LFB261:
 310:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(char val) {
 11254              		.loc 34 310 0
 11255              		.cfi_startproc
 11256              		@ args = 0, pretend = 0, frame = 0
 11257              		@ frame_needed = 0, uses_anonymous_args = 0
 11258              	.LVL481:
 11259 0000 08B5     		push	{r3, lr}
 11260              	.LCFI107:
 11261              		.cfi_def_cfa_offset 8
 11262              		.cfi_offset 14, -4
 11263              		.cfi_offset 3, -8
 310:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(char val) {
 11264              		.loc 34 310 0
 11265 0002 0146     		mov	r1, r0
 311:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 11266              		.loc 34 311 0
 11267 0004 0348     		ldr	r0, .L687
 11268              	.LVL482:
 11269 0006 FFF7FEFF 		bl	_ZN5Print5printEc
 313:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 11270              		.loc 34 313 0
 11271 000a BDE80840 		pop	{r3, lr}
 312:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 11272              		.loc 34 312 0
 11273 000e FFF7FEBF 		b	_Z5commav
 11274              	.L688:
 11275 0012 00BF     		.align	2
 11276              	.L687:
 11277 0014 00000000 		.word	SerialUSB
 11278              		.cfi_endproc
 11279              	.LFE261:
 11281              		.section	.text._Z15PrintValueCommad,"ax",%progbits
 11282              		.align	1
 11283              		.global	_Z15PrintValueCommad
 11284              		.thumb
 11285              		.thumb_func
 11287              	_Z15PrintValueCommad:
 11288              	.LFB260:
 305:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(double val) {
 11289              		.loc 34 305 0
 11290              		.cfi_startproc
 11291              		@ args = 0, pretend = 0, frame = 0
 11292              		@ frame_needed = 0, uses_anonymous_args = 0
 11293              	.LVL483:
 11294 0000 07B5     		push	{r0, r1, r2, lr}
 11295              	.LCFI108:
 11296              		.cfi_def_cfa_offset 16
 11297              		.cfi_offset 14, -4
 11298              		.cfi_offset 2, -8
 11299              		.cfi_offset 1, -12
 11300              		.cfi_offset 0, -16
 305:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(double val) {
 11301              		.loc 34 305 0
 11302 0002 0B46     		mov	r3, r1
 11303 0004 0246     		mov	r2, r0
 306:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 11304              		.loc 34 306 0
 11305 0006 0221     		movs	r1, #2
 11306 0008 0448     		ldr	r0, .L690
 11307              	.LVL484:
 11308 000a 0091     		str	r1, [sp, #0]
 11309 000c FFF7FEFF 		bl	_ZN5Print5printEdi
 308:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 11310              		.loc 34 308 0
 11311 0010 03B0     		add	sp, sp, #12
 11312 0012 5DF804EB 		pop	{lr}
 307:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 11313              		.loc 34 307 0
 11314 0016 FFF7FEBF 		b	_Z5commav
 11315              	.L691:
 11316 001a 00BF     		.align	2
 11317              	.L690:
 11318 001c 00000000 		.word	SerialUSB
 11319              		.cfi_endproc
 11320              	.LFE260:
 11322              		.section	.text._Z15PrintValueCommaf,"ax",%progbits
 11323              		.align	1
 11324              		.global	_Z15PrintValueCommaf
 11325              		.thumb
 11326              		.thumb_func
 11328              	_Z15PrintValueCommaf:
 11329              	.LFB259:
 300:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(float val) {
 11330              		.loc 34 300 0
 11331              		.cfi_startproc
 11332              		@ args = 0, pretend = 0, frame = 0
 11333              		@ frame_needed = 0, uses_anonymous_args = 0
 11334              	.LVL485:
 11335 0000 07B5     		push	{r0, r1, r2, lr}
 11336              	.LCFI109:
 11337              		.cfi_def_cfa_offset 16
 11338              		.cfi_offset 14, -4
 11339              		.cfi_offset 2, -8
 11340              		.cfi_offset 1, -12
 11341              		.cfi_offset 0, -16
 301:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 11342              		.loc 34 301 0
 11343 0002 FFF7FEFF 		bl	__aeabi_f2d
 11344              	.LVL486:
 11345 0006 0246     		mov	r2, r0
 11346 0008 0B46     		mov	r3, r1
 11347 000a 0548     		ldr	r0, .L693
 11348 000c 0221     		movs	r1, #2
 11349 000e 0091     		str	r1, [sp, #0]
 11350 0010 FFF7FEFF 		bl	_ZN5Print5printEdi
 303:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 11351              		.loc 34 303 0
 11352 0014 03B0     		add	sp, sp, #12
 11353 0016 5DF804EB 		pop	{lr}
 302:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 11354              		.loc 34 302 0
 11355 001a FFF7FEBF 		b	_Z5commav
 11356              	.L694:
 11357 001e 00BF     		.align	2
 11358              	.L693:
 11359 0020 00000000 		.word	SerialUSB
 11360              		.cfi_endproc
 11361              	.LFE259:
 11363              		.section	.text._Z8PrintPIDh,"ax",%progbits
 11364              		.align	1
 11365              		.global	_Z8PrintPIDh
 11366              		.thumb
 11367              		.thumb_func
 11369              	_Z8PrintPIDh:
 11370              	.LFB266:
 339:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 11371              		.loc 34 339 0
 11372              		.cfi_startproc
 11373              		@ args = 0, pretend = 0, frame = 0
 11374              		@ frame_needed = 0, uses_anonymous_args = 0
 11375              	.LVL487:
 340:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   PrintValueComma(PID[IDPid].P);
 11376              		.loc 34 340 0
 11377 0000 074B     		ldr	r3, .L696
 339:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 11378              		.loc 34 339 0
 11379 0002 10B5     		push	{r4, lr}
 11380              	.LCFI110:
 11381              		.cfi_def_cfa_offset 8
 11382              		.cfi_offset 14, -4
 11383              		.cfi_offset 4, -8
 340:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   PrintValueComma(PID[IDPid].P);
 11384              		.loc 34 340 0
 11385 0004 1C24     		movs	r4, #28
 11386 0006 04FB0034 		mla	r4, r4, r0, r3
 11387 000a 2068     		ldr	r0, [r4, #0]	@ float
 11388              	.LVL488:
 11389 000c FFF7FEFF 		bl	_Z15PrintValueCommaf
 341:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   PrintValueComma(PID[IDPid].I);
 11390              		.loc 34 341 0
 11391 0010 6068     		ldr	r0, [r4, #4]	@ float
 11392 0012 FFF7FEFF 		bl	_Z15PrintValueCommaf
 342:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   PrintValueComma(PID[IDPid].D);
 11393              		.loc 34 342 0
 11394 0016 A068     		ldr	r0, [r4, #8]	@ float
 343:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 11395              		.loc 34 343 0
 11396 0018 BDE81040 		pop	{r4, lr}
 342:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   PrintValueComma(PID[IDPid].D);
 11397              		.loc 34 342 0
 11398 001c FFF7FEBF 		b	_Z15PrintValueCommaf
 11399              	.L697:
 11400              		.align	2
 11401              	.L696:
 11402 0020 00000000 		.word	.LANCHOR17
 11403              		.cfi_endproc
 11404              	.LFE266:
 11406              		.section	.text._Z17printVehicleStatePKcmS0_,"ax",%progbits
 11407              		.align	1
 11408              		.global	_Z17printVehicleStatePKcmS0_
 11409              		.thumb
 11410              		.thumb_func
 11412              	_Z17printVehicleStatePKcmS0_:
 11413              	.LFB272:
 698:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 699:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 700:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** #ifdef BinaryWrite
 701:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void printInt(int data) {
 702:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   byte msb, lsb;
 703:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 704:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   msb = data >> 8;
 705:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   lsb = data & 0xff;
 706:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 707:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(msb);
 708:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(lsb);
 709:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 710:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 711:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void sendBinaryFloat(float data) {
 712:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   union binaryFloatType {
 713:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     byte floatByte[4];
 714:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     float floatVal;
 715:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   } binaryFloat;
 716:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 717:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryFloat.floatVal = data;
 718:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(binaryFloat.floatByte[3]);
 719:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(binaryFloat.floatByte[2]);
 720:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(binaryFloat.floatByte[1]);
 721:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(binaryFloat.floatByte[0]);
 722:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 723:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 724:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void sendBinaryuslong(unsigned long data) {
 725:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   union binaryuslongType {
 726:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     byte uslongByte[4];
 727:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     unsigned long uslongVal;
 728:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   } binaryuslong;
 729:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 730:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryuslong.uslongVal = data;
 731:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(binaryuslong.uslongByte[3]);
 732:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(binaryuslong.uslongByte[2]);
 733:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(binaryuslong.uslongByte[1]);
 734:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(binaryuslong.uslongByte[0]);
 735:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 736:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 737:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 738:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void fastTelemetry()
 739:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 740:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // **************************************************************
 741:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // ***************** Fast Transfer Of Sensor Data ***************
 742:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // **************************************************************
 743:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // AeroQuad.h defines the output rate to be 10ms
 744:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // Since writing to UART is done by hardware, unable to measure data rate directly
 745:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // Through analysis:  115200 baud = 115200 bits/second = 14400 bytes/second
 746:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // If float = 4 bytes, then 3600 floats/second
 747:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // If 10 ms output rate, then 36 floats/10ms
 748:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // Number of floats written using sendBinaryFloat is 15
 749:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 750:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   if (motorArmed == ON) {
 751:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #ifdef OpenlogBinaryWrite
 752:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        printInt(21845); // Start word of 0x5555
 753:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        sendBinaryuslong(currentTime);
 754:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         printInt((int)flightMode);
 755:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 756:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(gyroRate[axis]);
 757:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        }
 758:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 759:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(meterPerSecSec[axis]);
 760:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        }
 761:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        sendBinaryFloat(accelOneG);
 762:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        #ifdef HeadingMagHold
 763:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           sendBinaryFloat(hdgX);
 764:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           sendBinaryFloat(hdgY);
 765:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 		  for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 766:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 		       #if defined(HeadingMagHold)
 767:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 			      sendBinaryFloat(getMagnetometerData(axis));
 768:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 		       #endif
 769:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           }  
 770:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        #else
 771:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(0.0);
 772:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(0.0);
 773:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(0.0);
 774:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        #endif
 775:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 776:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           sendBinaryFloat(kinematicsAngle[axis]);
 777:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         }
 778:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         printInt(32767); // Stop word of 0x7FFF
 779:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 780:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        printInt(21845); // Start word of 0x5555
 781:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 782:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(gyroRate[axis]);
 783:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        }
 784:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 785:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(meterPerSecSec[axis]);
 786:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        }
 787:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++)
 788:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        #if defined(HeadingMagHold)
 789:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(getMagnetometerData(axis));
 790:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        #else
 791:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(0);
 792:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        #endif
 793:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 794:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(getGyroUnbias(axis));
 795:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        }
 796:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 797:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(kinematicsAngle[axis]);
 798:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        }
 799:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        printInt(32767); // Stop word of 0x7FFF
 800:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 801:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   }
 802:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 803:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** #endif // BinaryWrite
 804:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 805:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void printVehicleState(const char *sensorName, unsigned long state, const char *message) {
 11414              		.loc 34 805 0
 11415              		.cfi_startproc
 11416              		@ args = 0, pretend = 0, frame = 0
 11417              		@ frame_needed = 0, uses_anonymous_args = 0
 11418              	.LVL489:
 11419 0000 8446     		mov	ip, r0
 11420 0002 38B5     		push	{r3, r4, r5, lr}
 11421              	.LCFI111:
 11422              		.cfi_def_cfa_offset 16
 11423              		.cfi_offset 14, -4
 11424              		.cfi_offset 5, -8
 11425              		.cfi_offset 4, -12
 11426              		.cfi_offset 3, -16
 806:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(sensorName);
 11427              		.loc 34 806 0
 11428 0004 0B48     		ldr	r0, .L700
 11429              	.LVL490:
 805:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void printVehicleState(const char *sensorName, unsigned long state, const char *message) {
 11430              		.loc 34 805 0
 11431 0006 0C46     		mov	r4, r1
 11432              		.loc 34 806 0
 11433 0008 6146     		mov	r1, ip
 11434              	.LVL491:
 805:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void printVehicleState(const char *sensorName, unsigned long state, const char *message) {
 11435              		.loc 34 805 0
 11436 000a 1546     		mov	r5, r2
 11437              		.loc 34 806 0
 11438 000c FFF7FEFF 		bl	_ZN5Print5printEPKc
 11439              	.LVL492:
 807:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(": ");
 11440              		.loc 34 807 0
 11441 0010 0848     		ldr	r0, .L700
 11442 0012 0949     		ldr	r1, .L700+4
 11443 0014 FFF7FEFF 		bl	_ZN5Print5printEPKc
 808:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   if (!(vehicleState & state))
 11444              		.loc 34 808 0
 11445 0018 0848     		ldr	r0, .L700+8
 11446 001a 0368     		ldr	r3, [r0, #0]
 11447 001c 1C42     		tst	r4, r3
 11448 001e 03D1     		bne	.L699
 809:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT("Not ");
 11449              		.loc 34 809 0
 11450 0020 0448     		ldr	r0, .L700
 11451 0022 0749     		ldr	r1, .L700+12
 11452 0024 FFF7FEFF 		bl	_ZN5Print5printEPKc
 11453              	.L699:
 810:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN(message);
 11454              		.loc 34 810 0
 11455 0028 0248     		ldr	r0, .L700
 11456 002a 2946     		mov	r1, r5
 811:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 11457              		.loc 34 811 0
 11458 002c BDE83840 		pop	{r3, r4, r5, lr}
 810:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN(message);
 11459              		.loc 34 810 0
 11460 0030 FFF7FEBF 		b	_ZN5Print7printlnEPKc
 11461              	.L701:
 11462              		.align	2
 11463              	.L700:
 11464 0034 00000000 		.word	SerialUSB
 11465 0038 B8000000 		.word	.LC8
 11466 003c 00000000 		.word	.LANCHOR21
 11467 0040 BB000000 		.word	.LC9
 11468              		.cfi_endproc
 11469              	.LFE272:
 11471              		.section	.text._Z18reportVehicleStatev,"ax",%progbits
 11472              		.align	1
 11473              		.global	_Z18reportVehicleStatev
 11474              		.thumb
 11475              		.thumb_func
 11477              	_Z18reportVehicleStatev:
 11478              	.LFB273:
 812:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 813:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void reportVehicleState() {
 11479              		.loc 34 813 0
 11480              		.cfi_startproc
 11481              		@ args = 0, pretend = 0, frame = 0
 11482              		@ frame_needed = 0, uses_anonymous_args = 0
 11483 0000 13B5     		push	{r0, r1, r4, lr}
 11484              	.LCFI112:
 11485              		.cfi_def_cfa_offset 16
 11486              		.cfi_offset 14, -4
 11487              		.cfi_offset 4, -8
 11488              		.cfi_offset 1, -12
 11489              		.cfi_offset 0, -16
 814:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // Tell Configurator how many vehicle state values to expect
 815:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN(14);
 11490              		.loc 34 815 0
 11491 0002 0A22     		movs	r2, #10
 11492 0004 0E21     		movs	r1, #14
 11493 0006 3448     		ldr	r0, .L703+8
 11494 0008 FFF7FEFF 		bl	_ZN5Print7printlnEii
 816:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT("Software Version: ");
 11495              		.loc 34 816 0
 11496 000c 3349     		ldr	r1, .L703+12
 11497 000e 3248     		ldr	r0, .L703+8
 11498 0010 FFF7FEFF 		bl	_ZN5Print5printEPKc
 817:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN(SOFTWARE_VERSION, 1);
 11499              		.loc 34 817 0
 11500 0014 0124     		movs	r4, #1
 11501 0016 2EA3     		adr	r3, .L703
 11502 0018 D3E90023 		ldrd	r2, [r3]
 11503 001c 2E48     		ldr	r0, .L703+8
 11504 001e 0094     		str	r4, [sp, #0]
 11505 0020 FFF7FEFF 		bl	_ZN5Print7printlnEdi
 818:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT("Board Type: ");
 11506              		.loc 34 818 0
 11507 0024 2C48     		ldr	r0, .L703+8
 11508 0026 2E49     		ldr	r1, .L703+16
 11509 0028 FFF7FEFF 		bl	_ZN5Print5printEPKc
 819:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #if defined(AeroQuad_v1)
 820:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("v1.x");
 821:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuad_v1_IDG)
 822:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("v1.x IDG");
 823:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuadMega_v1)
 824:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Mega v1.x");
 825:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuad_v18)
 826:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("v1.8 and greater");
 827:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuadMega_v2)
 828:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Mega v2");
 829:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuadMega_v21)
 830:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Mega v21");
 831:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuadMega_v21)
 832:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("AutoNav");
 833:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AutonavShield)
 834:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("AutonavShield");
 835:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuad_Wii)
 836:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Wii");
 837:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuadMega_Wii)
 838:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Mega Wii");
 839:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(ArduCopter)
 840:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("ArduCopter");
 841:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuadMega_CHR6DM)
 842:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("CHR6DM");
 843:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(APM_OP_CHR6DM)
 844:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("APM w/ CHR6DM");
 845:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuad_Mini)
 846:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Mini");
 847:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuadSTM32)
 848:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("STM32");    
 11510              		.loc 34 848 0
 11511 002c 2A48     		ldr	r0, .L703+8
 11512 002e 2D49     		ldr	r1, .L703+20
 11513 0030 FFF7FEFF 		bl	_ZN5Print7printlnEPKc
 849:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #endif
 850:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT("Flight Config: ");
 11514              		.loc 34 850 0
 11515 0034 2848     		ldr	r0, .L703+8
 11516 0036 2C49     		ldr	r1, .L703+24
 11517 0038 FFF7FEFF 		bl	_ZN5Print5printEPKc
 851:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #if defined(quadPlusConfig)
 852:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Quad +");
 853:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(quadXConfig) 
 854:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Quad X");
 11518              		.loc 34 854 0
 11519 003c 2648     		ldr	r0, .L703+8
 11520 003e 2B49     		ldr	r1, .L703+28
 11521 0040 FFF7FEFF 		bl	_ZN5Print7printlnEPKc
 855:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined (quadY4Config)
 856:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Quad Y4");
 857:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined (triConfig)
 858:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Tri");
 859:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(hexPlusConfig)
 860:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Hex +");
 861:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(hexXConfig)
 862:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Hex X");
 863:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(hexY6Config)
 864:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Hex Y6");
 865:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(octoX8Config)
 866:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Octo X8");
 867:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(octoXConfig)
 868:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Octo X");
 869:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // *** For next rev, updat OctoPlus config name here and in Configurator
 870:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(octoPlusConfig)
 871:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Octo X+");
 872:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #endif
 873:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT("Receiver Channels: ");
 11522              		.loc 34 873 0
 11523 0044 2448     		ldr	r0, .L703+8
 11524 0046 2A49     		ldr	r1, .L703+32
 11525 0048 FFF7FEFF 		bl	_ZN5Print5printEPKc
 874:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN(LASTCHANNEL);
 11526              		.loc 34 874 0
 11527 004c 0A22     		movs	r2, #10
 11528 004e 0821     		movs	r1, #8
 11529 0050 2148     		ldr	r0, .L703+8
 11530 0052 FFF7FEFF 		bl	_ZN5Print7printlnEii
 875:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT("Motors: ");
 11531              		.loc 34 875 0
 11532 0056 2048     		ldr	r0, .L703+8
 11533 0058 2649     		ldr	r1, .L703+36
 11534 005a FFF7FEFF 		bl	_ZN5Print5printEPKc
 876:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN(LASTMOTOR);
 11535              		.loc 34 876 0
 11536 005e 0421     		movs	r1, #4
 11537 0060 0A22     		movs	r2, #10
 11538 0062 1D48     		ldr	r0, .L703+8
 11539 0064 FFF7FEFF 		bl	_ZN5Print7printlnEii
 877:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Gyroscope", GYRO_DETECTED, "Detected");
 11540              		.loc 34 877 0
 11541 0068 2146     		mov	r1, r4
 11542 006a 2348     		ldr	r0, .L703+40
 11543 006c 234A     		ldr	r2, .L703+44
 11544 006e FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 878:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Accelerometer", ACCEL_DETECTED, "Detected");
 11545              		.loc 34 878 0
 11546 0072 0221     		movs	r1, #2
 11547 0074 2248     		ldr	r0, .L703+48
 11548 0076 214A     		ldr	r2, .L703+44
 11549 0078 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 879:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Barometer", BARO_DETECTED, "Detected");
 11550              		.loc 34 879 0
 11551 007c 0821     		movs	r1, #8
 11552 007e 2148     		ldr	r0, .L703+52
 11553 0080 1E4A     		ldr	r2, .L703+44
 11554 0082 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 880:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Magnetometer", MAG_DETECTED, "Detected");
 11555              		.loc 34 880 0
 11556 0086 0421     		movs	r1, #4
 11557 0088 1F48     		ldr	r0, .L703+56
 11558 008a 1C4A     		ldr	r2, .L703+44
 11559 008c FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 881:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Heading Hold", HEADINGHOLD_ENABLED, "Enabled");
 11560              		.loc 34 881 0
 11561 0090 1021     		movs	r1, #16
 11562 0092 1E48     		ldr	r0, .L703+60
 11563 0094 1E4A     		ldr	r2, .L703+64
 11564 0096 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 882:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Altitude Hold", ALTITUDEHOLD_ENABLED, "Enabled");
 11565              		.loc 34 882 0
 11566 009a 2021     		movs	r1, #32
 11567 009c 1D48     		ldr	r0, .L703+68
 11568 009e 1C4A     		ldr	r2, .L703+64
 11569 00a0 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 883:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Battery Monitor", BATTMONITOR_ENABLED, "Enabled");
 11570              		.loc 34 883 0
 11571 00a4 4021     		movs	r1, #64
 11572 00a6 1C48     		ldr	r0, .L703+72
 11573 00a8 194A     		ldr	r2, .L703+64
 11574 00aa FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 884:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Camera Stability", CAMERASTABLE_ENABLED, "Enabled");
 11575              		.loc 34 884 0
 11576 00ae 8021     		movs	r1, #128
 11577 00b0 1A48     		ldr	r0, .L703+76
 11578 00b2 174A     		ldr	r2, .L703+64
 11579 00b4 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 885:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Range Detection", RANGE_ENABLED, "Enabled");
 11580              		.loc 34 885 0
 11581 00b8 1948     		ldr	r0, .L703+80
 11582 00ba 154A     		ldr	r2, .L703+64
 11583 00bc 4FF48071 		mov	r1, #256
 886:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 11584              		.loc 34 886 0
 11585 00c0 02B0     		add	sp, sp, #8
 11586 00c2 BDE81040 		pop	{r4, lr}
 885:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Range Detection", RANGE_ENABLED, "Enabled");
 11587              		.loc 34 885 0
 11588 00c6 FFF7FEBF 		b	_Z17printVehicleStatePKcmS0_
 11589              	.L704:
 11590 00ca 00BFAFF3 		.align	3
 11590      0080
 11591              	.L703:
 11592 00d0 000000C0 		.word	-1073741824
 11593 00d4 CCCC0840 		.word	1074318540
 11594 00d8 00000000 		.word	SerialUSB
 11595 00dc C0000000 		.word	.LC10
 11596 00e0 D3000000 		.word	.LC11
 11597 00e4 E0000000 		.word	.LC12
 11598 00e8 E6000000 		.word	.LC13
 11599 00ec F6000000 		.word	.LC14
 11600 00f0 FD000000 		.word	.LC15
 11601 00f4 11010000 		.word	.LC16
 11602 00f8 1A010000 		.word	.LC17
 11603 00fc 24010000 		.word	.LC18
 11604 0100 2D010000 		.word	.LC19
 11605 0104 3B010000 		.word	.LC20
 11606 0108 45010000 		.word	.LC21
 11607 010c 52010000 		.word	.LC22
 11608 0110 5F010000 		.word	.LC23
 11609 0114 67010000 		.word	.LC24
 11610 0118 75010000 		.word	.LC25
 11611 011c 85010000 		.word	.LC26
 11612 0120 96010000 		.word	.LC27
 11613              		.cfi_endproc
 11614              	.LFE273:
 11616 0124 AFF30080 		.section	.text._Z19sendSerialTelemetryv,"ax",%progbits
 11617              		.align	1
 11618              		.global	_Z19sendSerialTelemetryv
 11619              		.thumb
 11620              		.thumb_func
 11622              	_Z19sendSerialTelemetryv:
 11623              	.LFB267:
 345:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void sendSerialTelemetry() {
 11624              		.loc 34 345 0
 11625              		.cfi_startproc
 11626              		@ args = 0, pretend = 0, frame = 0
 11627              		@ frame_needed = 0, uses_anonymous_args = 0
 11628 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 11629              	.LCFI113:
 11630              		.cfi_def_cfa_offset 32
 11631              		.cfi_offset 14, -4
 11632              		.cfi_offset 7, -8
 11633              		.cfi_offset 6, -12
 11634              		.cfi_offset 5, -16
 11635              		.cfi_offset 4, -20
 11636              		.cfi_offset 2, -24
 11637              		.cfi_offset 1, -28
 11638              		.cfi_offset 0, -32
 11639              	.LBB360:
 346:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   switch (queryType) {
 11640              		.loc 34 346 0
 11641 0002 8E4C     		ldr	r4, .L775
 11642 0004 2378     		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 11643 0006 6A2B     		cmp	r3, #106
 11644 0008 2646     		mov	r6, r4
 11645 000a 00F00181 		beq	.L719
 11646 000e 28D8     		bhi	.L732
 11647 0010 642B     		cmp	r3, #100
 11648 0012 00F09080 		beq	.L713
 11649 0016 12D8     		bhi	.L733
 11650 0018 612B     		cmp	r3, #97
 11651 001a 62D0     		beq	.L710
 11652 001c 09D8     		bhi	.L734
 11653 001e 232B     		cmp	r3, #35
 11654 0020 00F05782 		beq	.L708
 11655 0024 362B     		cmp	r3, #54
 11656 0026 00F05982 		beq	.L745
 11657 002a 212B     		cmp	r3, #33
 11658 002c 40F06382 		bne	.L705
 11659 0030 46E2     		b	.L768
 11660              	.L734:
 11661 0032 622B     		cmp	r3, #98
 11662 0034 60D0     		beq	.L711
 11663 0036 632B     		cmp	r3, #99
 11664 0038 40F05D82 		bne	.L705
 11665 003c 71E0     		b	.L769
 11666              	.L733:
 11667 003e 672B     		cmp	r3, #103
 11668 0040 00F0B280 		beq	.L716
 11669 0044 06D8     		bhi	.L735
 11670 0046 652B     		cmp	r3, #101
 11671 0048 00F09880 		beq	.L714
 11672 004c 662B     		cmp	r3, #102
 11673 004e 40F05282 		bne	.L705
 11674 0052 9BE0     		b	.L770
 11675              	.L735:
 11676 0054 682B     		cmp	r3, #104
 11677 0056 00F0BC80 		beq	.L717
 11678 005a 692B     		cmp	r3, #105
 11679 005c 40F04B82 		bne	.L705
 11680 0060 29E0     		b	.L771
 11681              	.L732:
 11682 0062 702B     		cmp	r3, #112
 11683 0064 00F09B81 		beq	.L746
 11684 0068 11D8     		bhi	.L736
 11685 006a 6D2B     		cmp	r3, #109
 11686 006c 00F06C81 		beq	.L722
 11687 0070 06D8     		bhi	.L737
 11688 0072 6B2B     		cmp	r3, #107
 11689 0074 00F00881 		beq	.L720
 11690 0078 6C2B     		cmp	r3, #108
 11691 007a 40F03C82 		bne	.L705
 11692 007e 44E1     		b	.L772
 11693              	.L737:
 11694 0080 6E2B     		cmp	r3, #110
 11695 0082 00F08181 		beq	.L723
 11696 0086 6F2B     		cmp	r3, #111
 11697 0088 40F03582 		bne	.L705
 11698 008c 09E2     		b	.L767
 11699              	.L736:
 11700 008e 732B     		cmp	r3, #115
 11701 0090 00F0AD81 		beq	.L728
 11702 0094 06D8     		bhi	.L738
 11703 0096 712B     		cmp	r3, #113
 11704 0098 00F08F81 		beq	.L726
 11705 009c 722B     		cmp	r3, #114
 11706 009e 40F02A82 		bne	.L705
 11707 00a2 91E1     		b	.L773
 11708              	.L738:
 11709 00a4 752B     		cmp	r3, #117
 11710 00a6 00F00282 		beq	.L761
 11711 00aa C0F0E681 		bcc	.L747
 11712 00ae 762B     		cmp	r3, #118
 11713 00b0 40F02182 		bne	.L705
 11714 00b4 EFE1     		b	.L774
 11715              	.L771:
 11716              	.LVL493:
 11717              	.LBB361:
 11718              	.LBB362:
 432:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(gyroRate[axis]);
 11719              		.loc 34 432 0 discriminator 1
 11720 00b6 624C     		ldr	r4, .L775+4
 11721 00b8 2068     		ldr	r0, [r4, #0]	@ float
 11722 00ba FFF7FEFF 		bl	_Z15PrintValueCommaf
 11723              	.LVL494:
 11724 00be 6068     		ldr	r0, [r4, #4]	@ float
 11725 00c0 FFF7FEFF 		bl	_Z15PrintValueCommaf
 11726              	.LVL495:
 11727 00c4 A068     		ldr	r0, [r4, #8]	@ float
 11728              	.LBE362:
 11729              	.LBB363:
 435:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(filteredAccel[axis]);
 11730              		.loc 34 435 0 discriminator 1
 11731 00c6 5F4C     		ldr	r4, .L775+8
 11732              	.LBE363:
 11733              	.LBB364:
 432:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(gyroRate[axis]);
 11734              		.loc 34 432 0 discriminator 1
 11735 00c8 FFF7FEFF 		bl	_Z15PrintValueCommaf
 11736              	.LVL496:
 11737              	.LBE364:
 11738              	.LBB365:
 435:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(filteredAccel[axis]);
 11739              		.loc 34 435 0 discriminator 1
 11740 00cc 2068     		ldr	r0, [r4, #0]	@ float
 11741 00ce FFF7FEFF 		bl	_Z15PrintValueCommaf
 11742              	.LVL497:
 11743 00d2 6068     		ldr	r0, [r4, #4]	@ float
 11744 00d4 FFF7FEFF 		bl	_Z15PrintValueCommaf
 11745              	.LVL498:
 11746 00d8 A068     		ldr	r0, [r4, #8]	@ float
 11747 00da FFF7FEFF 		bl	_Z15PrintValueCommaf
 11748              	.LVL499:
 11749 00de 0024     		movs	r4, #0
 11750 00e0 8CE0     		b	.L739
 11751              	.LVL500:
 11752              	.L710:
 11753              	.LBE365:
 351:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(RATE_XAXIS_PID_IDX);
 11754              		.loc 34 351 0
 11755 00e2 0020     		movs	r0, #0
 11756 00e4 FFF7FEFF 		bl	_Z8PrintPIDh
 352:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(RATE_YAXIS_PID_IDX);
 11757              		.loc 34 352 0
 11758 00e8 0120     		movs	r0, #1
 11759 00ea FFF7FEFF 		bl	_Z8PrintPIDh
 353:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(rotationSpeedFactor);
 11760              		.loc 34 353 0
 11761 00ee 564B     		ldr	r3, .L775+12
 11762 00f0 1868     		ldr	r0, [r3, #0]	@ float
 11763 00f2 FFF7FEFF 		bl	_Z15PrintValueCommaf
 11764 00f6 3DE0     		b	.L760
 11765              	.L711:
 359:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ATTITUDE_XAXIS_PID_IDX);
 11766              		.loc 34 359 0
 11767 00f8 0320     		movs	r0, #3
 11768 00fa FFF7FEFF 		bl	_Z8PrintPIDh
 360:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ATTITUDE_YAXIS_PID_IDX);
 11769              		.loc 34 360 0
 11770 00fe 0420     		movs	r0, #4
 11771 0100 FFF7FEFF 		bl	_Z8PrintPIDh
 361:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ATTITUDE_GYRO_XAXIS_PID_IDX);
 11772              		.loc 34 361 0
 11773 0104 0620     		movs	r0, #6
 11774 0106 FFF7FEFF 		bl	_Z8PrintPIDh
 362:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ATTITUDE_GYRO_YAXIS_PID_IDX);
 11775              		.loc 34 362 0
 11776 010a 0720     		movs	r0, #7
 11777 010c FFF7FEFF 		bl	_Z8PrintPIDh
 363:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(windupGuard);
 11778              		.loc 34 363 0
 11779 0110 4E48     		ldr	r0, .L775+16
 11780 0112 0068     		ldr	r0, [r0, #0]	@ float
 11781 0114 FFF7FEFF 		bl	__aeabi_f2d
 11782 0118 0B46     		mov	r3, r1
 11783 011a 0221     		movs	r1, #2
 11784 011c 0246     		mov	r2, r0
 11785 011e 0091     		str	r1, [sp, #0]
 11786 0120 30E1     		b	.L766
 11787              	.L769:
 368:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ZAXIS_PID_IDX);
 11788              		.loc 34 368 0
 11789 0122 0220     		movs	r0, #2
 11790 0124 FFF7FEFF 		bl	_Z8PrintPIDh
 369:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(HEADING_HOLD_PID_IDX);
 11791              		.loc 34 369 0
 11792 0128 0520     		movs	r0, #5
 11793 012a FFF7FEFF 		bl	_Z8PrintPIDh
 370:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN((int)headingHoldConfig);
 11794              		.loc 34 370 0
 11795 012e 484A     		ldr	r2, .L775+20
 11796 0130 4848     		ldr	r0, .L775+24
 11797 0132 1178     		ldrb	r1, [r2, #0]	@ zero_extendqisi2
 11798 0134 C0E1     		b	.L762
 11799              	.L713:
 376:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintPID(BARO_ALTITUDE_HOLD_PID_IDX);
 11800              		.loc 34 376 0
 11801 0136 0820     		movs	r0, #8
 11802 0138 FFF7FEFF 		bl	_Z8PrintPIDh
 377:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard);
 11803              		.loc 34 377 0
 11804 013c 4649     		ldr	r1, .L775+28
 11805 013e D1F8F800 		ldr	r0, [r1, #248]	@ float
 11806 0142 FFF7FEFF 		bl	_Z15PrintValueCommaf
 378:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(altitudeHoldBump);
 11807              		.loc 34 378 0
 11808 0146 454B     		ldr	r3, .L775+32
 11809 0148 1868     		ldr	r0, [r3, #0]
 11810 014a FFF7FEFF 		bl	_Z15PrintValueCommai
 379:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(altitudeHoldPanicStickMovement);
 11811              		.loc 34 379 0
 11812 014e 444A     		ldr	r2, .L775+36
 11813 0150 1068     		ldr	r0, [r2, #0]
 11814 0152 FFF7FEFF 		bl	_Z15PrintValueCommai
 380:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(minThrottleAdjust);
 11815              		.loc 34 380 0
 11816 0156 4348     		ldr	r0, .L775+40
 11817 0158 0068     		ldr	r0, [r0, #0]
 11818 015a FFF7FEFF 		bl	_Z15PrintValueCommai
 381:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(maxThrottleAdjust);
 11819              		.loc 34 381 0
 11820 015e 4249     		ldr	r1, .L775+44
 11821 0160 0868     		ldr	r0, [r1, #0]
 11822 0162 FFF7FEFF 		bl	_Z15PrintValueCommai
 383:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(baroSmoothFactor);
 11823              		.loc 34 383 0
 11824 0166 414B     		ldr	r3, .L775+48
 11825 0168 1868     		ldr	r0, [r3, #0]	@ float
 11826 016a FFF7FEFF 		bl	_Z15PrintValueCommaf
 387:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintPID(ZDAMPENING_PID_IDX);
 11827              		.loc 34 387 0
 11828 016e 0920     		movs	r0, #9
 11829 0170 FFF7FEFF 		bl	_Z8PrintPIDh
 11830              	.L760:
 393:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 11831              		.loc 34 393 0
 11832 0174 3748     		ldr	r0, .L775+24
 11833 0176 FFF7FEFF 		bl	_ZN5Print7printlnEv
 11834 017a ACE1     		b	.L757
 11835              	.L714:
 398:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(aref);
 11836              		.loc 34 398 0
 11837 017c 3C48     		ldr	r0, .L775+52
 11838 017e 0068     		ldr	r0, [r0, #0]	@ float
 11839 0180 FFF7FEFF 		bl	_Z15PrintValueCommaf
 399:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(minArmedThrottle);
 11840              		.loc 34 399 0
 11841 0184 3B4A     		ldr	r2, .L775+56
 11842 0186 3348     		ldr	r0, .L775+24
 11843 0188 1168     		ldr	r1, [r2, #0]
 11844 018a 95E1     		b	.L762
 11845              	.L770:
 404:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(receiverXmitFactor);
 11846              		.loc 34 404 0
 11847 018c 3A4D     		ldr	r5, .L775+60
 11848 018e 3B4C     		ldr	r4, .L775+64
 11849 0190 2868     		ldr	r0, [r5, #0]	@ float
 11850 0192 FFF7FEFF 		bl	_Z15PrintValueCommaf
 11851              	.LVL501:
 345:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void sendSerialTelemetry() {
 11852              		.loc 34 345 0
 11853 0196 04F12005 		add	r5, r4, #32
 11854              	.LVL502:
 11855              	.L740:
 11856              	.LBB366:
 406:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(receiverSmoothFactor[axis]);
 11857              		.loc 34 406 0 discriminator 2
 11858 019a 54F8040F 		ldr	r0, [r4, #4]!	@ float
 11859 019e FFF7FEFF 		bl	_Z15PrintValueCommaf
 405:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 11860              		.loc 34 405 0 discriminator 2
 11861 01a2 AC42     		cmp	r4, r5
 11862 01a4 F9D1     		bne	.L740
 11863 01a6 A1E1     		b	.L765
 11864              	.L716:
 11865              	.LBE366:
 410:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 11866              		.loc 34 410 0
 11867 01a8 354C     		ldr	r4, .L775+68
 345:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void sendSerialTelemetry() {
 11868              		.loc 34 345 0
 11869 01aa 04F12005 		add	r5, r4, #32
 11870              	.L741:
 11871              	.LBB367:
 414:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(receiverSlope[axis], 6);
 11872              		.loc 34 414 0 discriminator 2
 11873 01ae 54F8040F 		ldr	r0, [r4, #4]!	@ float
 11874 01b2 FFF7FEFF 		bl	__aeabi_f2d
 11875 01b6 0246     		mov	r2, r0
 11876 01b8 0B46     		mov	r3, r1
 11877 01ba 2648     		ldr	r0, .L775+24
 11878 01bc 0621     		movs	r1, #6
 11879 01be 0091     		str	r1, [sp, #0]
 11880 01c0 FFF7FEFF 		bl	_ZN5Print5printEdi
 415:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(',');
 11881              		.loc 34 415 0 discriminator 2
 11882 01c4 2C21     		movs	r1, #44
 11883 01c6 2348     		ldr	r0, .L775+24
 11884 01c8 FFF7FEFF 		bl	_ZN5Print5printEc
 413:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 11885              		.loc 34 413 0 discriminator 2
 11886 01cc AC42     		cmp	r4, r5
 11887 01ce EED1     		bne	.L741
 11888 01d0 8CE1     		b	.L765
 11889              	.LVL503:
 11890              	.L717:
 11891              	.LBE367:
 419:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 11892              		.loc 34 419 0
 11893 01d2 2C4C     		ldr	r4, .L775+72
 345:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void sendSerialTelemetry() {
 11894              		.loc 34 345 0
 11895 01d4 04F12005 		add	r5, r4, #32
 11896              	.L742:
 11897              	.LBB368:
 423:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(receiverOffset[axis], 6);
 11898              		.loc 34 423 0 discriminator 2
 11899 01d8 54F8040F 		ldr	r0, [r4, #4]!	@ float
 11900 01dc FFF7FEFF 		bl	__aeabi_f2d
 11901 01e0 0246     		mov	r2, r0
 11902 01e2 0620     		movs	r0, #6
 11903 01e4 0B46     		mov	r3, r1
 11904 01e6 0090     		str	r0, [sp, #0]
 11905 01e8 1A48     		ldr	r0, .L775+24
 11906 01ea FFF7FEFF 		bl	_ZN5Print5printEdi
 424:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(',');
 11907              		.loc 34 424 0 discriminator 2
 11908 01ee 2C21     		movs	r1, #44
 11909 01f0 1848     		ldr	r0, .L775+24
 11910 01f2 FFF7FEFF 		bl	_ZN5Print5printEc
 422:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 11911              		.loc 34 422 0 discriminator 2
 11912 01f6 AC42     		cmp	r4, r5
 11913 01f8 EED1     		bne	.L742
 11914 01fa 77E1     		b	.L765
 11915              	.LVL504:
 11916              	.L739:
 11917              	.LBE368:
 11918              	.LBB369:
 439:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(getMagnetometerData(axis));
 11919              		.loc 34 439 0 discriminator 2
 11920 01fc 2046     		mov	r0, r4
 437:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 11921              		.loc 34 437 0 discriminator 2
 11922 01fe 0134     		adds	r4, r4, #1
 439:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(getMagnetometerData(axis));
 11923              		.loc 34 439 0 discriminator 2
 11924 0200 FFF7FEFF 		bl	_Z19getMagnetometerDatah
 437:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 11925              		.loc 34 437 0 discriminator 2
 11926 0204 E4B2     		uxtb	r4, r4
 439:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(getMagnetometerData(axis));
 11927              		.loc 34 439 0 discriminator 2
 11928 0206 FFF7FEFF 		bl	_Z15PrintValueCommai
 11929              	.LVL505:
 437:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 11930              		.loc 34 437 0 discriminator 2
 11931 020a 032C     		cmp	r4, #3
 11932 020c F6D1     		bne	.L739
 11933 020e 3CE1     		b	.L759
 11934              	.LVL506:
 11935              	.L719:
 11936              	.LBE369:
 449:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(getMagnetometerRawData(XAXIS));
 11937              		.loc 34 449 0
 11938 0210 0020     		movs	r0, #0
 11939 0212 FFF7FEFF 		bl	_Z22getMagnetometerRawDatah
 11940 0216 FFF7FEFF 		bl	_Z15PrintValueCommai
 450:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(getMagnetometerRawData(YAXIS));
 11941              		.loc 34 450 0
 11942 021a 0120     		movs	r0, #1
 11943 021c FFF7FEFF 		bl	_Z22getMagnetometerRawDatah
 11944 0220 FFF7FEFF 		bl	_Z15PrintValueCommai
 451:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(getMagnetometerRawData(ZAXIS));
 11945              		.loc 34 451 0
 11946 0224 0220     		movs	r0, #2
 11947 0226 FFF7FEFF 		bl	_Z22getMagnetometerRawDatah
 11948 022a 0146     		mov	r1, r0
 11949 022c 0948     		ldr	r0, .L775+24
 11950 022e 0A22     		movs	r2, #10
 11951              	.LBE361:
 11952              	.LBE360:
 657:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 11953              		.loc 34 657 0
 11954 0230 03B0     		add	sp, sp, #12
 11955 0232 BDE8F040 		pop	{r4, r5, r6, r7, lr}
 11956              	.LBB382:
 11957              	.LBB377:
 451:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(getMagnetometerRawData(ZAXIS));
 11958              		.loc 34 451 0
 11959 0236 FFF7FEBF 		b	_ZN5Print7printlnEii
 11960              	.L776:
 11961 023a 00BF     		.align	2
 11962              	.L775:
 11963 023c 00000000 		.word	.LANCHOR148
 11964 0240 00000000 		.word	.LANCHOR27
 11965 0244 00000000 		.word	.LANCHOR151
 11966 0248 00000000 		.word	.LANCHOR127
 11967 024c 00000000 		.word	.LANCHOR142
 11968 0250 00000000 		.word	.LANCHOR135
 11969 0254 00000000 		.word	SerialUSB
 11970 0258 00000000 		.word	.LANCHOR17
 11971 025c 00000000 		.word	.LANCHOR8
 11972 0260 00000000 		.word	.LANCHOR126
 11973 0264 00000000 		.word	.LANCHOR124
 11974 0268 00000000 		.word	.LANCHOR125
 11975 026c 00000000 		.word	.LANCHOR97
 11976 0270 00000000 		.word	.LANCHOR143
 11977 0274 00000000 		.word	.LANCHOR132
 11978 0278 00000000 		.word	.LANCHOR61
 11979 027c FCFFFFFF 		.word	.LANCHOR14-4
 11980 0280 FCFFFFFF 		.word	.LANCHOR12-4
 11981 0284 FCFFFFFF 		.word	.LANCHOR13-4
 11982              	.L720:
 456:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[XAXIS], 6);
 11983              		.loc 34 456 0
 11984 0288 9F4E     		ldr	r6, .L777+8
 458:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(runTimeAccelBias[XAXIS], 6);
 11985              		.loc 34 458 0
 11986 028a A04F     		ldr	r7, .L777+12
 456:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[XAXIS], 6);
 11987              		.loc 34 456 0
 11988 028c 3068     		ldr	r0, [r6, #0]	@ float
 11989 028e FFF7FEFF 		bl	__aeabi_f2d
 11990 0292 0625     		movs	r5, #6
 11991 0294 0246     		mov	r2, r0
 11992 0296 0B46     		mov	r3, r1
 11993 0298 9D48     		ldr	r0, .L777+16
 11994 029a 0095     		str	r5, [sp, #0]
 11995 029c FFF7FEFF 		bl	_ZN5Print5printEdi
 457:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 11996              		.loc 34 457 0
 11997 02a0 FFF7FEFF 		bl	_Z5commav
 458:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(runTimeAccelBias[XAXIS], 6);
 11998              		.loc 34 458 0
 11999 02a4 3868     		ldr	r0, [r7, #0]	@ float
 12000 02a6 FFF7FEFF 		bl	__aeabi_f2d
 12001 02aa 0246     		mov	r2, r0
 12002 02ac 0B46     		mov	r3, r1
 12003 02ae 9848     		ldr	r0, .L777+16
 12004 02b0 0095     		str	r5, [sp, #0]
 12005 02b2 FFF7FEFF 		bl	_ZN5Print5printEdi
 459:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 12006              		.loc 34 459 0
 12007 02b6 FFF7FEFF 		bl	_Z5commav
 460:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[YAXIS], 6);
 12008              		.loc 34 460 0
 12009 02ba 7068     		ldr	r0, [r6, #4]	@ float
 12010 02bc FFF7FEFF 		bl	__aeabi_f2d
 12011 02c0 0246     		mov	r2, r0
 12012 02c2 0B46     		mov	r3, r1
 12013 02c4 9248     		ldr	r0, .L777+16
 12014 02c6 0095     		str	r5, [sp, #0]
 12015 02c8 FFF7FEFF 		bl	_ZN5Print5printEdi
 461:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 12016              		.loc 34 461 0
 12017 02cc FFF7FEFF 		bl	_Z5commav
 462:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(runTimeAccelBias[YAXIS], 6);
 12018              		.loc 34 462 0
 12019 02d0 7868     		ldr	r0, [r7, #4]	@ float
 12020 02d2 FFF7FEFF 		bl	__aeabi_f2d
 12021 02d6 0246     		mov	r2, r0
 12022 02d8 0B46     		mov	r3, r1
 12023 02da 8D48     		ldr	r0, .L777+16
 12024 02dc 0095     		str	r5, [sp, #0]
 12025 02de FFF7FEFF 		bl	_ZN5Print5printEdi
 463:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 12026              		.loc 34 463 0
 12027 02e2 FFF7FEFF 		bl	_Z5commav
 464:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[ZAXIS], 6);
 12028              		.loc 34 464 0
 12029 02e6 B068     		ldr	r0, [r6, #8]	@ float
 12030 02e8 FFF7FEFF 		bl	__aeabi_f2d
 12031 02ec 0246     		mov	r2, r0
 12032 02ee 0B46     		mov	r3, r1
 12033 02f0 8748     		ldr	r0, .L777+16
 12034 02f2 0095     		str	r5, [sp, #0]
 12035 02f4 FFF7FEFF 		bl	_ZN5Print5printEdi
 465:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 12036              		.loc 34 465 0
 12037 02f8 FFF7FEFF 		bl	_Z5commav
 466:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(runTimeAccelBias[ZAXIS], 6);
 12038              		.loc 34 466 0
 12039 02fc B868     		ldr	r0, [r7, #8]	@ float
 12040 02fe FFF7FEFF 		bl	__aeabi_f2d
 12041 0302 0095     		str	r5, [sp, #0]
 12042 0304 0246     		mov	r2, r0
 12043 0306 0B46     		mov	r3, r1
 12044 0308 3CE0     		b	.L766
 12045              	.L772:
 472:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma((int)(accelSample[XAXIS]/accelSampleCount));
 12046              		.loc 34 472 0
 12047 030a 824C     		ldr	r4, .L777+20
 12048 030c 824D     		ldr	r5, .L777+24
 471:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     measureAccelSum();
 12049              		.loc 34 471 0
 12050 030e FFF7FEFF 		bl	_Z15measureAccelSumv
 472:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma((int)(accelSample[XAXIS]/accelSampleCount));
 12051              		.loc 34 472 0
 12052 0312 2668     		ldr	r6, [r4, #0]
 12053 0314 2878     		ldrb	r0, [r5, #0]	@ zero_extendqisi2
 12054 0316 96FBF0F0 		sdiv	r0, r6, r0
 12055 031a FFF7FEFF 		bl	_Z15PrintValueCommai
 474:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma((int)(accelSample[YAXIS]/accelSampleCount));
 12056              		.loc 34 474 0
 12057 031e 2B78     		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 12058 0320 6168     		ldr	r1, [r4, #4]
 473:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     accelSample[XAXIS] = 0;
 12059              		.loc 34 473 0
 12060 0322 0026     		movs	r6, #0
 474:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma((int)(accelSample[YAXIS]/accelSampleCount));
 12061              		.loc 34 474 0
 12062 0324 91FBF3F0 		sdiv	r0, r1, r3
 473:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     accelSample[XAXIS] = 0;
 12063              		.loc 34 473 0
 12064 0328 2660     		str	r6, [r4, #0]
 474:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma((int)(accelSample[YAXIS]/accelSampleCount));
 12065              		.loc 34 474 0
 12066 032a FFF7FEFF 		bl	_Z15PrintValueCommai
 476:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN ((int)(accelSample[ZAXIS]/accelSampleCount));
 12067              		.loc 34 476 0
 12068 032e A268     		ldr	r2, [r4, #8]
 12069 0330 95F800C0 		ldrb	ip, [r5, #0]	@ zero_extendqisi2
 475:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     accelSample[YAXIS] = 0;
 12070              		.loc 34 475 0
 12071 0334 6660     		str	r6, [r4, #4]
 476:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN ((int)(accelSample[ZAXIS]/accelSampleCount));
 12072              		.loc 34 476 0
 12073 0336 92FBFCF1 		sdiv	r1, r2, ip
 12074 033a 7548     		ldr	r0, .L777+16
 12075 033c 0A22     		movs	r2, #10
 12076 033e FFF7FEFF 		bl	_ZN5Print7printlnEii
 477:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     accelSample[ZAXIS] = 0;
 12077              		.loc 34 477 0
 12078 0342 A660     		str	r6, [r4, #8]
 478:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     accelSampleCount = 0;
 12079              		.loc 34 478 0
 12080 0344 2E70     		strb	r6, [r5, #0]
 479:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 12081              		.loc 34 479 0
 12082 0346 D6E0     		b	.L705
 12083              	.L722:
 483:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINT(magBias[XAXIS], 6);
 12084              		.loc 34 483 0
 12085 0348 744D     		ldr	r5, .L777+28
 12086 034a 2868     		ldr	r0, [r5, #0]	@ float
 12087 034c FFF7FEFF 		bl	__aeabi_f2d
 12088 0350 0626     		movs	r6, #6
 12089 0352 0246     		mov	r2, r0
 12090 0354 0B46     		mov	r3, r1
 12091 0356 6E48     		ldr	r0, .L777+16
 12092 0358 0096     		str	r6, [sp, #0]
 12093 035a FFF7FEFF 		bl	_ZN5Print5printEdi
 484:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       comma();
 12094              		.loc 34 484 0
 12095 035e FFF7FEFF 		bl	_Z5commav
 485:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINT(magBias[YAXIS], 6);
 12096              		.loc 34 485 0
 12097 0362 6868     		ldr	r0, [r5, #4]	@ float
 12098 0364 FFF7FEFF 		bl	__aeabi_f2d
 12099 0368 0246     		mov	r2, r0
 12100 036a 0B46     		mov	r3, r1
 12101 036c 6848     		ldr	r0, .L777+16
 12102 036e 0096     		str	r6, [sp, #0]
 12103 0370 FFF7FEFF 		bl	_ZN5Print5printEdi
 486:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       comma();
 12104              		.loc 34 486 0
 12105 0374 FFF7FEFF 		bl	_Z5commav
 487:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(magBias[ZAXIS], 6);
 12106              		.loc 34 487 0
 12107 0378 A868     		ldr	r0, [r5, #8]	@ float
 12108 037a FFF7FEFF 		bl	__aeabi_f2d
 12109 037e 0096     		str	r6, [sp, #0]
 12110 0380 0246     		mov	r2, r0
 12111 0382 0B46     		mov	r3, r1
 12112              	.L766:
 12113 0384 6248     		ldr	r0, .L777+16
 12114 0386 A1E0     		b	.L763
 12115              	.L723:
 494:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(batteryMonitorAlarmVoltage);
 12116              		.loc 34 494 0
 12117 0388 6549     		ldr	r1, .L777+32
 12118 038a 0868     		ldr	r0, [r1, #0]	@ float
 12119 038c FFF7FEFF 		bl	_Z15PrintValueCommaf
 495:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(batteryMonitorThrottleTarget);
 12120              		.loc 34 495 0
 12121 0390 644A     		ldr	r2, .L777+36
 12122 0392 1068     		ldr	r0, [r2, #0]
 12123 0394 FFF7FEFF 		bl	_Z15PrintValueCommai
 496:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(batteryMonitorGoingDownTime);
 12124              		.loc 34 496 0
 12125 0398 5D48     		ldr	r0, .L777+16
 12126 039a 634B     		ldr	r3, .L777+40
 12127 039c 0FE0     		b	.L764
 12128              	.L746:
 12129              	.LBE377:
 346:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   switch (queryType) {
 12130              		.loc 34 346 0
 12131 039e 0C24     		movs	r4, #12
 12132              	.L725:
 12133              	.LBB378:
 12134              	.LBB370:
 540:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(0);
 12135              		.loc 34 540 0 discriminator 2
 12136 03a0 013C     		subs	r4, r4, #1
 12137 03a2 0020     		movs	r0, #0
 12138 03a4 E4B2     		uxtb	r4, r4
 12139 03a6 FFF7FEFF 		bl	_Z15PrintValueCommai
 539:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       for (byte index=0; index < 12; index++) {
 12140              		.loc 34 539 0 discriminator 2
 12141 03aa 002C     		cmp	r4, #0
 12142 03ac F8D1     		bne	.L725
 12143              	.LBE370:
 542:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(0);
 12144              		.loc 34 542 0
 12145 03ae 5848     		ldr	r0, .L777+16
 12146 03b0 2146     		mov	r1, r4
 12147 03b2 0A22     		movs	r2, #10
 12148 03b4 FFF7FEFF 		bl	_ZN5Print7printlnEii
 12149 03b8 9BE0     		b	.L758
 12150              	.LVL507:
 12151              	.L726:
 548:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(vehicleState);
 12152              		.loc 34 548 0
 12153 03ba 5548     		ldr	r0, .L777+16
 12154 03bc 5B4B     		ldr	r3, .L777+44
 12155              	.L764:
 12156 03be 1968     		ldr	r1, [r3, #0]
 12157 03c0 0A22     		movs	r2, #10
 12158 03c2 FFF7FEFF 		bl	_ZN5Print7printlnEmi
 12159 03c6 86E0     		b	.L757
 12160              	.L773:
 553:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[XAXIS]);
 12161              		.loc 34 553 0
 12162 03c8 594C     		ldr	r4, .L777+48
 12163 03ca 2068     		ldr	r0, [r4, #0]	@ float
 12164 03cc FFF7FEFF 		bl	_Z15PrintValueCommaf
 554:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[YAXIS]);
 12165              		.loc 34 554 0
 12166 03d0 6068     		ldr	r0, [r4, #4]	@ float
 12167 03d2 FFF7FEFF 		bl	_Z15PrintValueCommaf
 556:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(trueNorthHeading);
 12168              		.loc 34 556 0
 12169 03d6 574B     		ldr	r3, .L777+52
 12170 03d8 1868     		ldr	r0, [r3, #0]	@ float
 12171 03da FFF7FEFF 		bl	__aeabi_f2d
 12172 03de 0246     		mov	r2, r0
 12173 03e0 0220     		movs	r0, #2
 12174 03e2 0090     		str	r0, [sp, #0]
 12175 03e4 0B46     		mov	r3, r1
 12176 03e6 4A48     		ldr	r0, .L777+16
 12177 03e8 FFF7FEFF 		bl	_ZN5Print7printlnEdi
 560:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 12178              		.loc 34 560 0
 12179 03ec 83E0     		b	.L705
 12180              	.L728:
 563:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(motorArmed);
 12181              		.loc 34 563 0
 12182 03ee 5248     		ldr	r0, .L777+56
 564:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[XAXIS]);
 12183              		.loc 34 564 0
 12184 03f0 4F4C     		ldr	r4, .L777+48
 563:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(motorArmed);
 12185              		.loc 34 563 0
 12186 03f2 0078     		ldrb	r0, [r0, #0]	@ zero_extendqisi2
 12187 03f4 FFF7FEFF 		bl	_Z15PrintValueCommah
 564:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[XAXIS]);
 12188              		.loc 34 564 0
 12189 03f8 2068     		ldr	r0, [r4, #0]	@ float
 12190 03fa FFF7FEFF 		bl	_Z15PrintValueCommaf
 565:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[YAXIS]);
 12191              		.loc 34 565 0
 12192 03fe 6068     		ldr	r0, [r4, #4]	@ float
 12193 0400 FFF7FEFF 		bl	_Z15PrintValueCommaf
 567:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(trueNorthHeading);
 12194              		.loc 34 567 0
 12195 0404 4B49     		ldr	r1, .L777+52
 12196 0406 0868     		ldr	r0, [r1, #0]	@ float
 12197 0408 FFF7FEFF 		bl	_Z15PrintValueCommaf
 573:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(getBaroAltitude());
 12198              		.loc 34 573 0
 12199 040c FFF7FEFF 		bl	_Z15getBaroAltitudev
 12200 0410 FFF7FEFF 		bl	_Z15PrintValueCommaf
 577:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma((int)altitudeHoldState);
 12201              		.loc 34 577 0
 12202 0414 494A     		ldr	r2, .L777+60
 12203 0416 1078     		ldrb	r0, [r2, #0]	@ zero_extendqisi2
 12204 0418 FFF7FEFF 		bl	_Z15PrintValueCommai
 12205              	.LVL508:
 12206 041c 0024     		movs	r4, #0
 12207              	.LVL509:
 12208              	.L743:
 12209              	.LBB371:
 583:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(receiverCommand[channel]);
 12210              		.loc 34 583 0 discriminator 2
 12211 041e 484B     		ldr	r3, .L777+64
 12212 0420 E058     		ldr	r0, [r4, r3]
 12213 0422 0434     		adds	r4, r4, #4
 12214 0424 FFF7FEFF 		bl	_Z15PrintValueCommai
 582:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 12215              		.loc 34 582 0 discriminator 2
 12216 0428 202C     		cmp	r4, #32
 12217 042a F8D1     		bne	.L743
 582:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 12218              		.loc 34 582 0 is_stmt 0
 12219 042c 0024     		movs	r4, #0
 12220              	.L744:
 12221              	.LBE371:
 12222              	.LBB372:
 589:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(motorCommand[motor]);
 12223              		.loc 34 589 0 is_stmt 1 discriminator 2
 12224 042e 454A     		ldr	r2, .L777+68
 12225 0430 A058     		ldr	r0, [r4, r2]
 12226 0432 0434     		adds	r4, r4, #4
 12227 0434 FFF7FEFF 		bl	_Z15PrintValueCommai
 588:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 12228              		.loc 34 588 0 discriminator 2
 12229 0438 102C     		cmp	r4, #16
 12230 043a F8D1     		bne	.L744
 12231              	.LVL510:
 12232              	.LBE372:
 12233              	.LBB373:
 592:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0); // zero out unused motor channels
 12234              		.loc 34 592 0 discriminator 1
 12235 043c 0020     		movs	r0, #0
 12236 043e FFF7FEFF 		bl	_Z15PrintValueCommai
 12237              	.LVL511:
 12238 0442 0020     		movs	r0, #0
 12239 0444 FFF7FEFF 		bl	_Z15PrintValueCommai
 12240              	.LVL512:
 12241 0448 0020     		movs	r0, #0
 12242 044a FFF7FEFF 		bl	_Z15PrintValueCommai
 12243              	.LVL513:
 12244 044e 0020     		movs	r0, #0
 12245 0450 FFF7FEFF 		bl	_Z15PrintValueCommai
 12246              	.LVL514:
 12247              	.LBE373:
 595:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma((float)batteryData[0].voltage/100.0); // voltage internally stored at 10mV:s
 12248              		.loc 34 595 0 discriminator 1
 12249 0454 3C4B     		ldr	r3, .L777+72
 12250 0456 D888     		ldrh	r0, [r3, #6]
 12251 0458 00EE100A 		fmsr	s0, r0	@ int
 12252 045c DFED3B7A 		flds	s15, .L777+76
 12253 0460 B8EE407A 		fuitos	s14, s0
 12254 0464 C7EE276A 		fdivs	s13, s14, s15
 12255 0468 16EE900A 		fmrs	r0, s13
 12256 046c FFF7FEFF 		bl	_Z15PrintValueCommaf
 599:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(flightMode);
 12257              		.loc 34 599 0 discriminator 1
 12258 0470 3749     		ldr	r1, .L777+80
 12259 0472 0878     		ldrb	r0, [r1, #0]	@ zero_extendqisi2
 12260 0474 FFF7FEFF 		bl	_Z15PrintValueCommah
 12261 0478 07E0     		b	.L759
 12262              	.LVL515:
 12263              	.L747:
 12264              	.LBE378:
 346:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   switch (queryType) {
 12265              		.loc 34 346 0
 12266 047a 0024     		movs	r4, #0
 12267              	.L729:
 12268              	.LBB379:
 12269              	.LBB374:
 605:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(receiverCommand[axis]);
 12270              		.loc 34 605 0 discriminator 2
 12271 047c 304A     		ldr	r2, .L777+64
 12272 047e A058     		ldr	r0, [r4, r2]
 12273 0480 0434     		adds	r4, r4, #4
 12274 0482 FFF7FEFF 		bl	_Z15PrintValueCommai
 604:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = 0; axis < LASTCHANNEL; axis++) {
 12275              		.loc 34 604 0 discriminator 2
 12276 0486 202C     		cmp	r4, #32
 12277 0488 F8D1     		bne	.L729
 12278              	.LVL516:
 12279              	.L759:
 12280              	.LBE374:
 607:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 12281              		.loc 34 607 0
 12282 048a 2148     		ldr	r0, .L777+16
 12283              	.LBE379:
 12284              	.LBE382:
 657:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 12285              		.loc 34 657 0
 12286 048c 03B0     		add	sp, sp, #12
 12287 048e BDE8F040 		pop	{r4, r5, r6, r7, lr}
 12288              	.LBB383:
 12289              	.LBB380:
 607:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 12290              		.loc 34 607 0
 12291 0492 FFF7FEBF 		b	_ZN5Print7printlnEv
 12292              	.L774:
 12293              	.LBB375:
 630:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(0);
 12294              		.loc 34 630 0
 12295 0496 0020     		movs	r0, #0
 12296 0498 FFF7FEFF 		bl	_Z15PrintValueCommai
 12297              	.LVL517:
 12298 049c 0020     		movs	r0, #0
 12299 049e FFF7FEFF 		bl	_Z15PrintValueCommai
 12300              	.LVL518:
 12301              	.L767:
 12302 04a2 0020     		movs	r0, #0
 12303 04a4 FFF7FEFF 		bl	_Z15PrintValueCommai
 12304 04a8 0020     		movs	r0, #0
 12305 04aa FFF7FEFF 		bl	_Z15PrintValueCommai
 12306              	.L761:
 12307              	.LVL519:
 12308 04ae 0020     		movs	r0, #0
 12309 04b0 FFF7FEFF 		bl	_Z15PrintValueCommai
 12310              	.LVL520:
 12311              	.LBE375:
 631:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(0);
 12312              		.loc 34 631 0
 12313 04b4 1648     		ldr	r0, .L777+16
 12314 04b6 0021     		movs	r1, #0
 12315              	.LVL521:
 12316              	.L762:
 12317 04b8 0A22     		movs	r2, #10
 12318 04ba FFF7FEFF 		bl	_ZN5Print7printlnEii
 12319 04be 0AE0     		b	.L757
 12320              	.L768:
 640:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(SOFTWARE_VERSION, 1);
 12321              		.loc 34 640 0
 12322 04c0 0FA3     		adr	r3, .L777
 12323 04c2 D3E90023 		ldrd	r2, [r3]
 12324 04c6 0121     		movs	r1, #1
 12325 04c8 1148     		ldr	r0, .L777+16
 12326 04ca 0091     		str	r1, [sp, #0]
 12327              	.L763:
 12328 04cc FFF7FEFF 		bl	_ZN5Print7printlnEdi
 12329 04d0 01E0     		b	.L757
 12330              	.L708:
 645:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     reportVehicleState();
 12331              		.loc 34 645 0
 12332 04d2 FFF7FEFF 		bl	_Z18reportVehicleStatev
 12333              	.L757:
 646:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 12334              		.loc 34 646 0
 12335 04d6 5820     		movs	r0, #88
 12336 04d8 2070     		strb	r0, [r4, #0]
 647:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 12337              		.loc 34 647 0
 12338 04da 0CE0     		b	.L705
 12339              	.L745:
 12340              	.LBE380:
 346:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   switch (queryType) {
 12341              		.loc 34 346 0
 12342 04dc 0024     		movs	r4, #0
 12343              	.L709:
 12344              	.LBB381:
 12345              	.LBB376:
 651:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(motorCommand[motor]);
 12346              		.loc 34 651 0 discriminator 2
 12347 04de 194B     		ldr	r3, .L777+68
 12348 04e0 E058     		ldr	r0, [r4, r3]
 12349 04e2 0434     		adds	r4, r4, #4
 12350 04e4 FFF7FEFF 		bl	_Z15PrintValueCommai
 650:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 12351              		.loc 34 650 0 discriminator 2
 12352 04e8 102C     		cmp	r4, #16
 12353 04ea F8D1     		bne	.L709
 12354              	.LVL522:
 12355              	.L765:
 12356              	.LBE376:
 653:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 12357              		.loc 34 653 0
 12358 04ec 0848     		ldr	r0, .L777+16
 12359 04ee FFF7FEFF 		bl	_ZN5Print7printlnEv
 12360              	.L758:
 654:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 12361              		.loc 34 654 0
 12362 04f2 5822     		movs	r2, #88
 12363 04f4 3270     		strb	r2, [r6, #0]
 12364              	.L705:
 12365              	.LBE381:
 12366              	.LBE383:
 657:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 12367              		.loc 34 657 0
 12368 04f6 03B0     		add	sp, sp, #12
 12369 04f8 F0BD     		pop	{r4, r5, r6, r7, pc}
 12370              	.L778:
 12371 04fa 00BFAFF3 		.align	3
 12371      0080
 12372              	.L777:
 12373 0500 000000C0 		.word	-1073741824
 12374 0504 CCCC0840 		.word	1074318540
 12375 0508 00000000 		.word	.LANCHOR35
 12376 050c 00000000 		.word	.LANCHOR36
 12377 0510 00000000 		.word	SerialUSB
 12378 0514 00000000 		.word	.LANCHOR37
 12379 0518 00000000 		.word	.LANCHOR38
 12380 051c 00000000 		.word	.LANCHOR76
 12381 0520 00000000 		.word	.LANCHOR144
 12382 0524 00000000 		.word	.LANCHOR145
 12383 0528 00000000 		.word	.LANCHOR146
 12384 052c 00000000 		.word	.LANCHOR21
 12385 0530 00000000 		.word	.LANCHOR42
 12386 0534 00000000 		.word	.LANCHOR74
 12387 0538 00000000 		.word	.LANCHOR116
 12388 053c 00000000 		.word	.LANCHOR5
 12389 0540 00000000 		.word	.LANCHOR6
 12390 0544 00000000 		.word	.LANCHOR63
 12391 0548 00000000 		.word	.LANCHOR103
 12392 054c 0000C842 		.word	1120403456
 12393 0550 00000000 		.word	.LANCHOR120
 12394              		.cfi_endproc
 12395              	.LFE267:
 12397 0554 AFF30080 		.section	.text._Z16processLedStatusv,"ax",%progbits
 12398              		.align	1
 12399              		.global	_Z16processLedStatusv
 12400              		.thumb
 12401              		.thumb_func
 12403              	_Z16processLedStatusv:
 12404              	.LFB274:
 12405              		.file 35 "C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad/LedStatusProcessor.h"
   1:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** /*
   2:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   AeroQuad v3.0 - Febuary 2012
   3:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   www.AeroQuad.com
   4:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   Copyright (c) 2011 Ted Carancho.  All rights reserved.
   5:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   An Open Source Arduino based multicopter.
   6:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****  
   7:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   This program is free software: you can redistribute it and/or modify 
   8:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   it under the terms of the GNU General Public License as published by 
   9:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   (at your option) any later version. 
  11:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****  
  12:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   This program is distributed in the hope that it will be useful, 
  13:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   GNU General Public License for more details. 
  16:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****  
  17:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   You should have received a copy of the GNU General Public License 
  18:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** */
  20:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 
  21:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** // Led Status Processor controls the LED:s on the shield according to vehicle status
  22:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 
  23:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 
  24:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** #ifndef _AQ_LedProcessor_H_
  25:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** #define _AQ_LedProcessor_H_
  26:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 
  27:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** byte flashingLedState = 0; // this counter increments by one at 10Hz
  28:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 
  29:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** void processLedStatus() {
 12406              		.loc 35 29 0
 12407              		.cfi_startproc
 12408              		@ args = 0, pretend = 0, frame = 0
 12409              		@ frame_needed = 0, uses_anonymous_args = 0
 12410 0000 10B5     		push	{r4, lr}
 12411              	.LCFI114:
 12412              		.cfi_def_cfa_offset 8
 12413              		.cfi_offset 14, -4
 12414              		.cfi_offset 4, -8
  30:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 
  31:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   
  32:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   //
  33:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   // process ready state light in case we use GPS
  34:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   //
  35:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   #if defined (UseGPS)
  36:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****     if (haveAGpsLock()) {
  37:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****       if (isHomeBaseInitialized()) {
  38:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****         digitalWrite(LED_Green, HIGH);
  39:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****       }
  40:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****       else {
  41:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****         digitalWrite(LED_Green, (flashingLedState & 4));
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****       }
  43:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****     }
  44:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****     else { 
  45:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****       digitalWrite(LED_Green, (flashingLedState & 2));
  46:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****     }
  47:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   #endif
  48:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   
  49:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   //
  50:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   // process ready state light in case we use Batt monitor
  51:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   //
  52:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** #if defined (BattMonitor)
  53:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 	if(motorArmed) {
 12415              		.loc 35 53 0
 12416 0002 124B     		ldr	r3, .L788
 12417 0004 124C     		ldr	r4, .L788+4
 12418 0006 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 12419 0008 88B1     		cbz	r0, .L780
  54:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 		if (batteryAlarm) {
 12420              		.loc 35 54 0
 12421 000a 1248     		ldr	r0, .L788+8
 12422 000c 0078     		ldrb	r0, [r0, #0]	@ zero_extendqisi2
 12423 000e 20B1     		cbz	r0, .L781
  55:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 			digitalWrite(BuzzerPin, (flashingLedState & 2));
 12424              		.loc 35 55 0
 12425 0010 2178     		ldrb	r1, [r4, #0]	@ zero_extendqisi2
 12426 0012 0020     		movs	r0, #0
 12427 0014 01F00201 		and	r1, r1, #2
 12428 0018 0AE0     		b	.L786
 12429              	.L781:
  56:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 			} else if (batteryWarning) {
 12430              		.loc 35 56 0
 12431 001a 0F4A     		ldr	r2, .L788+12
 12432 001c 1378     		ldrb	r3, [r2, #0]	@ zero_extendqisi2
 12433 001e 1BB1     		cbz	r3, .L783
  57:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 				digitalWrite(BuzzerPin, (flashingLedState & 6));
 12434              		.loc 35 57 0
 12435 0020 2378     		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 12436 0022 03F00601 		and	r1, r3, #6
 12437 0026 03E0     		b	.L786
 12438              	.L783:
  58:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 			} else {
  59:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 				digitalWrite(BuzzerPin, LOW);
 12439              		.loc 35 59 0
 12440 0028 1846     		mov	r0, r3
 12441 002a 1946     		mov	r1, r3
 12442 002c 00E0     		b	.L786
 12443              	.L780:
  60:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 				}
  61:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 		}
  62:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 	else {
  63:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 		digitalWrite(BuzzerPin, LOW);
 12444              		.loc 35 63 0
 12445 002e 0146     		mov	r1, r0
 12446              	.L786:
 12447 0030 FFF7FEFF 		bl	_Z12digitalWritehh
  64:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 		}
  65:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** #endif  
  66:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 
  67:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   //
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   // process mode light
  69:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   //
  70:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   if (flightMode == ATTITUDE_FLIGHT_MODE) {
 12448              		.loc 35 70 0
 12449 0034 094A     		ldr	r2, .L788+16
 12450 0036 1178     		ldrb	r1, [r2, #0]	@ zero_extendqisi2
  71:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****     digitalWrite(LED_Yellow, HIGH);
 12451              		.loc 35 71 0
 12452 0038 4520     		movs	r0, #69
  70:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   if (flightMode == ATTITUDE_FLIGHT_MODE) {
 12453              		.loc 35 70 0
 12454 003a 0129     		cmp	r1, #1
  72:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   }
  73:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   else {
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****     digitalWrite(LED_Yellow, LOW);
 12455              		.loc 35 74 0
 12456 003c 18BF     		it	ne
 12457 003e 0021     		movne	r1, #0
 12458 0040 FFF7FEFF 		bl	_Z12digitalWritehh
  75:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   }
  76:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 
  77:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   flashingLedState++;
 12459              		.loc 35 77 0
 12460 0044 2178     		ldrb	r1, [r4, #0]	@ zero_extendqisi2
 12461 0046 481C     		adds	r0, r1, #1
 12462 0048 2070     		strb	r0, [r4, #0]
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 
  79:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** }
 12463              		.loc 35 79 0
 12464 004a 10BD     		pop	{r4, pc}
 12465              	.L789:
 12466              		.align	2
 12467              	.L788:
 12468 004c 00000000 		.word	.LANCHOR116
 12469 0050 00000000 		.word	.LANCHOR152
 12470 0054 00000000 		.word	.LANCHOR104
 12471 0058 00000000 		.word	.LANCHOR105
 12472 005c 00000000 		.word	.LANCHOR120
 12473              		.cfi_endproc
 12474              	.LFE274:
 12476              		.section	.text._Z5setupv,"ax",%progbits
 12477              		.align	1
 12478              		.global	_Z5setupv
 12479              		.thumb
 12480              		.thumb_func
 12482              	_Z5setupv:
 12483              	.LFB275:
 12484              		.file 36 "C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad/AeroQuad.ino"
   1:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** /*
   2:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   AeroQuad v3.0.1 - February 2012
   3:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   www.AeroQuad.com
   4:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   An Open Source Arduino based multicopter.
   6:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
   7:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   This program is free software: you can redistribute it and/or modify
   8:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   it under the terms of the GNU General Public License as published by
   9:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   the Free Software Foundation, either version 3 of the License, or
  10:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   (at your option) any later version.
  11:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  12:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   This program is distributed in the hope that it will be useful,
  13:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   GNU General Public License for more details.
  16:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  17:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   You should have received a copy of the GNU General Public License
  18:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** */
  20:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  21:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** /****************************************************************************
  22:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    Before flight, select the different user options for your AeroQuad by
  23:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    editing UserConfiguration.h.
  24:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  25:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    If you need additional assistance go to http://www.aeroquad.com/forum.php
  26:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    or talk to us live on IRC #aeroquad
  27:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** *****************************************************************************/
  28:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  29:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "UserConfiguration.h" // Edit this file first before uploading to the AeroQuad
  30:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  31:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //
  32:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** // Define Security Checks
  33:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //
  34:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  35:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //
  36:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** // In order to use the DIYDrone libraries, this have to be declared here this way
  37:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** // @see Kenny9999 for details
  38:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //
  39:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(UseGPS_NMEA) || defined(UseGPS_UBLOX) || defined(UseGPS_MTK) || defined(UseGPS_406)
  40:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****  #define UseGPS
  41:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif 
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  43:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined (UseGPSNavigator) && !defined (AltitudeHoldBaro)
  44:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #error GpsNavigation NEED AltitudeHoldBaro defined
  45:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
  46:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  47:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined (AutoLanding) && (!defined (AltitudeHoldBaro) || !defined (AltitudeHoldRangeFinder))
  48:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #error AutoLanding NEED AltitudeHoldBaro and AltitudeHoldRangeFinder defined
  49:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
  50:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  51:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined (ReceiverSBUS) && defined (SlowTelemetry)
  52:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #error Receiver SWBUS and SlowTelemetry are in conflict for Serial2, they can not be used togethe
  53:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
  54:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  55:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined UseGPS
  56:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // needed here to use DIYDrone GPS libraries
  57:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <FastSerial.h>
  58:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <AP_Common.h>
  59:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <AP_GPS.h>
  60:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
  61:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   FastSerialPort0(Serial);
  62:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   FastSerialPort1(Serial1);
  63:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   FastSerialPort2(Serial2);
  64:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   FastSerialPort3(Serial3);
  65:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
  66:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  67:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include <EEPROM.h>
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include <Wire.h>
  69:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include <GlobalDefined.h>
  70:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "AeroQuad.h"
  71:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "PID.h"
  72:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include <AQMath.h>
  73:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include <FourtOrderFilter.h>
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef BattMonitor
  75:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <BatteryMonitorTypes.h>
  76:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
  77:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
  79:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
  80:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********* PLATFORM SPECIFIC SECTION ********************
  81:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
  82:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
  83:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuad_v1
  84:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
  85:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 12
  86:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 12
  87:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  88:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
  89:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_IDG_IDZ500.h>
  90:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  91:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_ADXL500.h>
  93:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  94:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver declaration
  95:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_328P
  96:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  97:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
  98:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_PWM
  99:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 100:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // unsupported in v1
 101:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldBaro
 102:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldRangeFinder
 103:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef HeadingMagHold
 104:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef BattMonitor
 105:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef BattMonitorAutoDescent
 106:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef POWERED_BY_VIN        
 107:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef CameraControl
 108:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef OSD
 109:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPS
 110:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPSNavigator
 111:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 112:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 113:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 114:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuad_v1 specific initialization need here
 115:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 116:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 117:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     setGyroAref(aref);
 118:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 119:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 120:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 121:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 122:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 123:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 124:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     if (deltaTime >= 10000) {
 125:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureGyro();
 126:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureAccel();
 127:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
 128:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 129:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 130:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 131:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuad_v1_IDG
 132:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
 133:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 12
 134:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 12
 135:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 136:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 137:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_IDG_IDZ500.h>
 138:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 139:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 140:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_ADXL500.h>
 141:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 142:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver declaration
 143:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_328P
 144:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 145:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 146:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_PWM
 147:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 148:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // unsupported in v1
 149:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldBaro
 150:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldRangeFinder
 151:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef HeadingMagHold
 152:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef BattMonitor
 153:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef BattMonitorAutoDescent
 154:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef POWERED_BY_VIN        
 155:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef CameraControl
 156:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef OSD
 157:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPS
 158:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPSNavigator
 159:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 160:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 161:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuad_v1_IDG specific initialization need here
 162:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 163:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 164:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     setGyroAref(aref);
 165:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 166:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 167:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 168:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 169:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 170:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 171:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     if (deltaTime >= 10000) {
 172:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureGyro();
 173:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureAccel();
 174:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
 175:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 176:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 177:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 178:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuad_v18
 179:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
 180:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 12
 181:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 12
 182:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 183:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_I2C.h>
 184:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 185:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 186:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_ITG3200.h>
 187:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 188:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 189:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_BMA180.h>
 190:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 191:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver declaration
 192:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_328P
 193:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 194:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 195:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_PWM_Timer
 196:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 197:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // heading mag hold declaration
 198:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef HeadingMagHold
 199:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define HMC5843
 200:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 201:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 202:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Battery Monitor declaration
 203:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef BattMonitor
 204:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15, 0.9, BM_NOPIN, 0, 0)
 205:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
 206:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef BattMonitorAutoDescent
 207:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef POWERED_BY_VIN        
 208:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 209:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 210:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldBaro
 211:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldRangeFinder
 212:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef CameraControl
 213:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef OSD
 214:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPS
 215:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPSNavigator
 216:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 217:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 218:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuad_v18 specific initialization need here
 219:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 220:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 221:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 222:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Red, OUTPUT);
 223:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Red, LOW);
 224:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Yellow, OUTPUT);
 225:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Yellow, LOW);
 226:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 227:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Wire.begin();
 228:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     TWBR = 12;
 229:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 230:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 231:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 232:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 233:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 234:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 235:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureGyroSum();
 236:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureAccelSum();
 237:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 238:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 239:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 240:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 241:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuad_Mini
 242:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
 243:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 12
 244:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 12
 245:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 246:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_I2C.h>
 247:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 248:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 249:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define ITG3200_ADDRESS_ALTERNATE
 250:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_ITG3200.h>
 251:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 252:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 253:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_ADXL345.h>
 254:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 255:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver declaration
 256:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_328P
 257:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 258:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 259:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_PWM
 260:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 261:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // heading mag hold declaration
 262:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef HeadingMagHold
 263:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define HMC5843
 264:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 265:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 266:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Battery Monitor declaration
 267:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef BattMonitor
 268:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0.53, BM_NOPIN, 0, 0)
 269:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
 270:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef BattMonitorAutoDescent
 271:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef POWERED_BY_VIN        
 272:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 273:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 274:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // unsupported in mini
 275:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldBaro
 276:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldRangeFinder  
 277:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef CameraControl
 278:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef OSD
 279:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPS
 280:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPSNavigator
 281:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 282:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 283:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuad_Mini specific initialization need here
 284:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 285:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 286:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 287:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Red, OUTPUT);
 288:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Red, LOW);
 289:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Yellow, OUTPUT);
 290:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Yellow, LOW);
 291:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 292:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Wire.begin();
 293:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     TWBR = 12;
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 295:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 296:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 297:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 298:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 299:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 300:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureGyroSum();
 301:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureAccelSum();
 302:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 303:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 304:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 305:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuadMega_v1
 306:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
 307:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 4
 308:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 31
 309:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 310:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Special thanks to Wilafau for fixes for this setup
 311:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // http://aeroquad.com/showthread.php?991-AeroQuad-Flight-Software-v2.0&p=11466&viewfull=1#post11
 312:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 313:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_IDG_IDZ500.h>
 314:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 315:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 316:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_ADXL500.h>
 317:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 318:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Reveiver declaration
 319:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define OLD_RECEIVER_PIN_ORDER
 320:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_MEGA
 321:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 322:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 323:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_PWM
 324:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 325:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // unsupported on mega v1
 326:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldBaro
 327:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldRangeFinder  
 328:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef HeadingMagHold
 329:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef BattMonitor
 330:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef BattMonitorAutoDescent
 331:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef POWERED_BY_VIN        
 332:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef CameraControl
 333:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef OSD
 334:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 335:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 336:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuadMega_v1 specific initialization need here
 337:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 338:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 339:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     setGyroAref(aref);
 340:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 341:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 342:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 343:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 344:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 345:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 346:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     if (deltaTime >= 10000) {
 347:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureGyro();
 348:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureAccel();
 349:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
 350:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 351:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 352:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 353:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuadMega_v2
 354:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
 355:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 4
 356:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 31
 357:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 358:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_I2C.h>
 359:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 360:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 361:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_ITG3200.h>
 362:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 363:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 364:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_BMA180.h>
 365:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 366:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver Declaration
 367:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_MEGA
 368:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 369:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 370:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_PWM_Timer
 371:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 372:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // heading mag hold declaration
 373:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef HeadingMagHold
 374:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //    #define SPARKFUN_5883L_BOB
 375:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define HMC5843
 376:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 377:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 378:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Altitude declaration
 379:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldBaro    
 380:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BMP085
 381:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 382:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
 383:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define XLMAXSONAR 
 384:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 385:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 386:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Battery Monitor declaration
 387:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef BattMonitor
 388:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #ifdef POWERED_BY_VIN
 389:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0, BM_NOPIN, 0, 0) // v2 shield powered 
 390:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #else
 391:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0.82, BM_NOPIN, 0, 0) // v2 shield power
 392:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
 393:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
 394:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef BattMonitorAutoDescent
 395:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef POWERED_BY_VIN        
 396:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 397:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 398:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef OSD
 399:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define MAX7456_OSD
 400:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif  
 401:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 402:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifndef UseGPS
 403:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef UseGPSNavigator
 404:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 405:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 406:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 407:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuadMega_v2 specific initialization need here
 408:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 409:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 410:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 411:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Red, OUTPUT);
 412:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Red, LOW);
 413:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Yellow, OUTPUT);
 414:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Yellow, LOW);
 415:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 416:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // pins set to INPUT for camera stabilization so won't interfere with new camera class
 417:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(33, INPUT); // disable SERVO 1, jumper D12 for roll
 418:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(34, INPUT); // disable SERVO 2, jumper D11 for pitch
 419:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(35, INPUT); // disable SERVO 3, jumper D13 for yaw
 420:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(43, OUTPUT); // LED 1
 421:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(44, OUTPUT); // LED 2
 422:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(45, OUTPUT); // LED 3
 423:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(46, OUTPUT); // LED 4
 424:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(43, HIGH); // LED 1 on
 425:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(44, HIGH); // LED 2 on
 426:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(45, HIGH); // LED 3 on
 427:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(46, HIGH); // LED 4 on
 428:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 429:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Wire.begin();
 430:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     TWBR = 12;
 431:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 432:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 433:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 434:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 435:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 436:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 437:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureGyroSum();
 438:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureAccelSum();
 439:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 440:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 441:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 442:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuadMega_v21
 443:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
 444:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 4
 445:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 31
 446:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 447:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_I2C.h>
 448:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 449:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 450:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define ITG3200_ADDRESS_ALTERNATE
 451:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_ITG3200_9DOF.h>
 452:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 453:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 454:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_ADXL345_9DOF.h>
 455:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 456:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver Declaration
 457:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_MEGA
 458:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 459:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 460:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_PWM_Timer
 461:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 462:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // heading mag hold declaration
 463:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef HeadingMagHold
 464:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define SPARKFUN_9DOF_5883L
 465:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 466:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 467:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Altitude declaration
 468:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldBaro
 469:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BMP085
 470:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 471:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
 472:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define XLMAXSONAR 
 473:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 474:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 475:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 476:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Battery Monitor declaration
 477:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef BattMonitor
 478:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #ifdef POWERED_BY_VIN
 479:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0, BM_NOPIN, 0, 0) // v2 shield powered 
 480:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #else
 481:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0.82, BM_NOPIN, 0, 0) // v2 shield power
 482:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
 483:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
 484:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef BattMonitorAutoDescent
 485:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef POWERED_BY_VIN        
 486:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 487:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 488:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef OSD
 489:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define MAX7456_OSD
 490:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif  
 491:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 492:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifndef UseGPS
 493:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef UseGPSNavigator
 494:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 495:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 496:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 497:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 498:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuadMega_v21 specific initialization need here
 499:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 500:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 501:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 502:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Red, OUTPUT);
 503:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Red, LOW);
 504:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Yellow, OUTPUT);
 505:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Yellow, LOW);
 506:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 507:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // pins set to INPUT for camera stabilization so won't interfere with new camera class
 508:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(33, INPUT); // disable SERVO 1, jumper D12 for roll
 509:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(34, INPUT); // disable SERVO 2, jumper D11 for pitch
 510:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(35, INPUT); // disable SERVO 3, jumper D13 for yaw
 511:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(43, OUTPUT); // LED 1
 512:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(44, OUTPUT); // LED 2
 513:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(45, OUTPUT); // LED 3
 514:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(46, OUTPUT); // LED 4
 515:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(43, HIGH); // LED 1 on
 516:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(44, HIGH); // LED 2 on
 517:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(45, HIGH); // LED 3 on
 518:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(46, HIGH); // LED 4 on
 519:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 520:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Wire.begin();
 521:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     TWBR = 12;
 522:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 523:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 524:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 525:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 526:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 527:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 528:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureGyroSum();
 529:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureAccelSum();
 530:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 531:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 532:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 533:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 534:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AutonavShield
 535:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
 536:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 4
 537:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 31
 538:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 539:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_I2C.h>
 540:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 541:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 542:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_ITG3200.h>
 543:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 544:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 545:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_BMA180.h>
 546:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 547:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver Declaration
 548:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_MEGA
 549:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 550:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 551:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_PWM_Timer
 552:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 553:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // heading mag hold declaration
 554:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef HeadingMagHold
 555:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //    #define SPARKFUN_5883L_BOB
 556:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define AutonavShield_5883L
 557:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //    #define HMC5843
 558:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 559:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 560:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Altitude declaration
 561:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldBaro    
 562:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BMP085
 563:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 564:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
 565:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define XLMAXSONAR 
 566:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 567:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 568:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Battery Monitor declaration
 569:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef BattMonitor
 570:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #ifdef POWERED_BY_VIN
 571:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0, BM_NOPIN, 0, 0) // v2 shield powered 
 572:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #else
 573:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0.82, BM_NOPIN, 0, 0) // v2 shield power
 574:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
 575:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
 576:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef BattMonitorAutoDescent
 577:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef POWERED_BY_VIN        
 578:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 579:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 580:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef OSD
 581:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define MAX7456_OSD
 582:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif  
 583:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 584:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifndef UseGPS
 585:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef UseGPSNavigator
 586:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 587:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 588:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 589:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuadMega_v2 specific initialization need here
 590:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 591:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 592:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 593:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Red, OUTPUT);
 594:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Red, LOW);
 595:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Yellow, OUTPUT);
 596:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Yellow, LOW);
 597:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 598:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // pins set to INPUT for camera stabilization so won't interfere with new camera class
 599:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(33, INPUT); // disable SERVO 1, jumper D12 for roll
 600:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(34, INPUT); // disable SERVO 2, jumper D11 for pitch
 601:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(35, INPUT); // disable SERVO 3, jumper D13 for yaw
 602:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(43, OUTPUT); // LED 1
 603:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(44, OUTPUT); // LED 2
 604:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(45, OUTPUT); // LED 3
 605:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(46, OUTPUT); // LED 4
 606:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(43, HIGH); // LED 1 on
 607:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(44, HIGH); // LED 2 on
 608:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(45, HIGH); // LED 3 on
 609:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(46, HIGH); // LED 4 on
 610:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 611:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Wire.begin();
 612:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     TWBR = 12;
 613:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 614:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 615:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 616:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 617:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 618:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 619:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureGyroSum();
 620:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureAccelSum();
 621:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 622:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 623:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 624:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef ArduCopter
 625:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 37
 626:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 35
 627:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 36
 628:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 629:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <APM_ADC.h>
 630:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <APM_RC.h>
 631:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_I2C.h>
 632:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 633:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 634:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_APM.h>
 635:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 636:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer Declaration
 637:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_APM.h>
 638:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 639:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver Declaration
 640:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_APM
 641:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 642:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor Declaration
 643:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_APM
 644:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 645:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // heading mag hold declaration
 646:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef HeadingMagHold
 647:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define HMC5843
 648:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 649:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
 650:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define XLMAXSONAR 
 651:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 652:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 653:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 654:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Altitude declaration
 655:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldBaro
 656:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BMP085
 657:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 658:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 659:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Battery monitor declaration
 660:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef BattMonitor
 661:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BattDefaultConfig DEFINE_BATTERY(0, 0, 13.35, 0.31, BM_NOPIN, 0, 0)
 662:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
 663:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef BattMonitorAutoDescent
 664:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef POWERED_BY_VIN        
 665:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 666:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 667:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef CameraControl
 668:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef OSD
 669:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifndef UseGPS
 670:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef UseGPSNavigator
 671:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 672:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 673:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 674:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 675:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put ArduCopter specific initialization need here
 676:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 677:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 678:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Red, OUTPUT);
 679:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Yellow, OUTPUT);
 680:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Green, OUTPUT);
 681:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 682:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeADC();
 683:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initRC();
 684:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 685:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Wire.begin();
 686:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     TWBR = 12;
 687:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 688:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 689:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 690:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 691:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 692:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 693:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     evaluateADC();
 694:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureGyroSum();
 695:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureAccelSum();
 696:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 697:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 698:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 699:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuad_Wii
 700:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
 701:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 12
 702:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 12
 703:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 704:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_I2C.h>
 705:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 706:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Platform Wii declaration
 707:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Platform_Wii.h>
 708:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 709:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 710:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_Wii.h>
 711:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 712:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 713:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_WII.h>
 714:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 715:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver declaration
 716:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_328P
 717:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 718:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 719:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_PWM
 720:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 721:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // heading mag hold declaration
 722:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // unsupported on mega v1
 723:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldBaro
 724:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldRangeFinder  
 725:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef HeadingMagHold
 726:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef BattMonitor
 727:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef BattMonitorAutoDescent
 728:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef POWERED_BY_VIN        
 729:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef CameraControl
 730:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef OSD
 731:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPS
 732:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPSNavigator
 733:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 734:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 735:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 736:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuad_Wii specific initialization need here
 737:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 738:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 739:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****      Wire.begin();
 740:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 741:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****      #if defined(AeroQuad_Paris_v3)
 742:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****        initializeWiiSensors(true);
 743:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****      #else
 744:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****        initializeWiiSensors();
 745:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****      #endif
 746:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 747:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 748:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 749:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 750:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 751:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 752:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     if (deltaTime >= 10000) {
 753:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       readWiiSensors();
 754:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureGyro();
 755:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureAccel();
 756:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
 757:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 758:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 759:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 760:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuadMega_Wii
 761:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
 762:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 4
 763:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 31
 764:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 765:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_I2C.h>
 766:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 767:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Platform Wii declaration
 768:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Platform_Wii.h>
 769:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 770:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 771:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_Wii.h>
 772:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 773:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 774:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_WII.h>
 775:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 776:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver declaration
 777:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_MEGA
 778:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 779:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 780:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_PWM
 781:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 782:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // heading mag hold declaration
 783:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef HeadingMagHold
 784:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define HMC5843
 785:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 786:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 787:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Altitude declaration
 788:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldBaro
 789:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BMP085
 790:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 791:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
 792:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define XLMAXSONAR 
 793:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 794:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 795:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Battery monitor declaration
 796:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef BattMonitor
 797:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0.9, BM_NOPIN, 0, 0)
 798:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
 799:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef BattMonitorAutoDescent
 800:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef POWERED_BY_VIN        
 801:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 802:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 803:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef OSD
 804:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define MAX7456_OSD
 805:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 806:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 807:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPS        // Wii not enough stable to use gps
 808:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPSNavigator
 809:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 810:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 811:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 812:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuadMega_Wii specific initialization need here
 813:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 814:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 815:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Wire.begin();
 816:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 817:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeWiiSensors();
 818:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 819:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 820:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 821:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 822:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 823:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 824:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     if (deltaTime >= 10000) {
 825:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       readWiiSensors();
 826:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureGyro();
 827:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureAccel();
 828:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
 829:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 830:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 831:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 832:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuadMega_CHR6DM
 833:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
 834:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 4
 835:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 31
 836:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 837:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_I2C.h>
 838:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Platform_CHR6DM.h>
 839:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   CHR6DM chr6dm;
 840:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 841:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 842:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_CHR6DM.h>
 843:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 844:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 845:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_CHR6DM.h>
 846:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 847:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver declaration
 848:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_MEGA
 849:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 850:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 851:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_PWM
 852:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 853:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Kinematics declaration
 854:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "Kinematics_CHR6DM.h"
 855:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 856:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Compass declaration
 857:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define HeadingMagHold
 858:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define COMPASS_CHR6DM
 859:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Magnetometer_CHR6DM.h>
 860:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 861:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef OSD
 862:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define MAX7456_OSD
 863:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 864:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 865:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Altitude declaration
 866:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldBaro
 867:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BMP085
 868:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 869:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
 870:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define XLMAXSONAR 
 871:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 872:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 873:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Battery monitor declaration
 874:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef BattMonitor
 875:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BattDefaultConfig DEFINE_BATTERY(0, 0, 13.35, 0.9, BM_NOPIN, 0, 0)
 876:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
 877:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef BattMonitorAutoDescent
 878:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef POWERED_BY_VIN        
 879:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 880:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 881:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifndef UseGPS
 882:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef UseGPSNavigator
 883:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 884:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 885:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 886:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 887:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuadMega_CHR6DM specific initialization need here
 888:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 889:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 890:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Serial1.begin(BAUD);
 891:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     PORTD = B00000100;
 892:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 893:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Wire.begin();
 894:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 895:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     chr6dm.resetToFactory();
 896:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     chr6dm.setListenMode();
 897:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     chr6dm.setActiveChannels(CHANNEL_ALL_MASK);
 898:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     chr6dm.requestPacket();
 899:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 900:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     gyroChr6dm = &chr6dm;
 901:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     accelChr6dm = &chr6dm;
 902:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     kinematicsChr6dm = &chr6dm;
 903:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     compassChr6dm = &chr6dm;
 904:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 905:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 906:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 907:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 908:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 909:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 910:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     if (deltaTime >= 10000) {
 911:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       chr6dm.read();
 912:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureGyro();
 913:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureAccel();
 914:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
 915:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 916:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 917:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 918:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef APM_OP_CHR6DM
 919:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 37
 920:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 35
 921:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 36
 922:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 923:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_I2C.h>
 924:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Platform_CHR6DM.h>
 925:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   CHR6DM chr6dm;
 926:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 927:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 928:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_CHR6DM.h>
 929:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 930:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 931:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_CHR6DM.h>
 932:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 933:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver declaration
 934:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_APM
 935:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 936:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 937:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_APM
 938:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 939:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Kinematics declaration
 940:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "Kinematics_CHR6DM.h"
 941:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 942:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Compass declaration
 943:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define HeadingMagHold
 944:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define COMPASS_CHR6DM
 945:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Magnetometer_CHR6DM.h>
 946:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 947:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Altitude declaration
 948:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldBaro
 949:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BMP085
 950:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 951:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
 952:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define XLMAXSONAR 
 953:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 954:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 955:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 956:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Battery monitor declaration
 957:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef BattMonitor
 958:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BattDefaultConfig DEFINE_BATTERY(0, 0, 13.35, 0.31, BM_NOPIN, 0, 0)
 959:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
 960:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef BattMonitorAutoDescent
 961:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef POWERED_BY_VIN        
 962:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 963:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 964:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef CameraControl
 965:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef OSD
 966:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 967:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifndef UseGPS
 968:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef UseGPSNavigator
 969:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 970:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 971:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 972:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 973:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put APM_OP_CHR6DM specific initialization need here
 974:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 975:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 976:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Red, OUTPUT);
 977:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Yellow, OUTPUT);
 978:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Green, OUTPUT);
 979:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 980:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Serial1.begin(BAUD);
 981:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     PORTD = B00000100;
 982:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 983:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Wire.begin();
 984:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 985:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     chr6dm.resetToFactory();
 986:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     chr6dm.setListenMode();
 987:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     chr6dm.setActiveChannels(CHANNEL_ALL_MASK);
 988:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     chr6dm.requestPacket();
 989:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 990:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     gyroChr6dm = &chr6dm;
 991:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     accelChr6dm = &chr6dm;
 992:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     kinematicsChr6dm = &chr6dm;
 993:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //    tempKinematics.setGyroscope(&gyroSpecific);
 994:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     compassChr6dm = &chr6dm;
 995:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 996:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 997:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 998:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 999:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
1000:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
1001:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     if (deltaTime >= 10000) {
1002:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       chr6dm.read();
1003:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureGyro();
1004:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureAccel();
1005:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
1006:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
1007:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1008:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1009:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1010:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1011:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********* HARDWARE GENERALIZATION SECTION **************
1012:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1013:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1014:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1015:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuadSTM32
1016:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "AeroQuad_STM32.h"
1017:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1018:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1019:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** // default to 10bit ADC (AVR)
1020:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifndef ADC_NUMBER_OF_BITS
1021:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #define ADC_NUMBER_OF_BITS 10
1022:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1023:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1024:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1025:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //****************** KINEMATICS DECLARATION **************
1026:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1027:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "Kinematics.h"
1028:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(AeroQuadMega_CHR6DM) || defined(APM_OP_CHR6DM)
1029:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // CHR6DM have it's own kinematics, so, initialize in it's scope
1030:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #else
1031:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "Kinematics_ARG.h"
1032:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1033:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1034:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1035:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //******************** RECEIVER DECLARATION **************
1036:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1037:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(ReceiverHWPPM)
1038:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_HWPPM.h>
1039:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(ReceiverPPM)
1040:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_PPM.h>
1041:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(AeroQuad_Mini) && (defined(hexPlusConfig) || defined(hexXConfig) || defined(hexY6Conf
1042:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_PPM.h>
1043:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(RemotePCReceiver)
1044:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_RemotePC.h>
1045:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(ReceiverSBUS)
1046:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_SBUS.h>
1047:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(RECEIVER_328P)
1048:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_328p.h>
1049:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(RECEIVER_MEGA)
1050:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_MEGA.h>
1051:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(RECEIVER_APM)
1052:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_APM.h>
1053:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(RECEIVER_STM32PPM)
1054:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_STM32PPM.h>  
1055:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(RECEIVER_STM32)
1056:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_STM32.h>  
1057:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1058:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1059:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(UseAnalogRSSIReader) 
1060:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <AnalogRSSIReader.h>
1061:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(UseEzUHFRSSIReader)
1062:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <EzUHFRSSIReader.h>
1063:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1064:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1065:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1066:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1067:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1068:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************** MOTORS DECLARATION **************
1069:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1070:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(triConfig)
1071:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Motors_Tri.h>
1072:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(MOTOR_PWM)
1073:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Motors_PWM.h>
1074:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(MOTOR_PWM_Timer)
1075:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Motors_PWM_Timer.h>
1076:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(MOTOR_APM)
1077:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Motors_APM.h>
1078:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(MOTOR_I2C)
1079:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Motors_I2C.h>
1080:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(MOTOR_STM32)
1081:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Motors_STM32.h>    
1082:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1083:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1084:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1085:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //******* HEADING HOLD MAGNETOMETER DECLARATION **********
1086:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1087:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(HMC5843)
1088:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <HeadingFusionProcessorCompFilter.h>
1089:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Magnetometer_HMC5843.h>
1090:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(SPARKFUN_9DOF_5883L) || defined(SPARKFUN_5883L_BOB) || defined(HMC5883L)
1091:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <HeadingFusionProcessorCompFilter.h>
1092:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Magnetometer_HMC5883L.h>
1093:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(COMPASS_CHR6DM)
1094:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1095:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1096:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1097:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //******* ALTITUDE HOLD BAROMETER DECLARATION ************
1098:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1099:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined (BMP085)
1100:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <BarometricSensor_BMP085.h>
1101:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1102:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined (MS5611)
1103:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <BarometricSensor_MS5611.h>
1104:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1105:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined (XLMAXSONAR)
1106:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <MaxSonarRangeFinder.h>
1107:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif 
1108:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1109:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //*************** BATTERY MONITOR DECLARATION ************
1110:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1111:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef BattMonitor
1112:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <BatteryMonitor.h>
1113:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifndef BattCustomConfig
1114:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BattCustomConfig BattDefaultConfig
1115:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1116:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   struct BatteryData batteryData[] = {BattCustomConfig};
1117:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1118:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1119:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //************** CAMERA CONTROL DECLARATION **************
1120:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1121:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** // used only on mega for now
1122:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef CameraControl
1123:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <CameraStabilizer_Aeroquad.h>
1124:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1125:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1126:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1127:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1128:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //******** FLIGHT CONFIGURATION DECLARATION **************
1129:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1130:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined quadXConfig
1131:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlQuadX.h"
1132:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined quadPlusConfig
1133:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlQuadPlus.h"
1134:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined hexPlusConfig
1135:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlHexPlus.h"
1136:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined hexXConfig
1137:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlHexX.h"
1138:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined triConfig
1139:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlTri.h"
1140:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined quadY4Config
1141:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlQuadY4.h"
1142:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined hexY6Config
1143:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlHexY6.h"
1144:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined octoX8Config
1145:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlOctoX8.h"
1146:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined octoXConfig
1147:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlOctoX.h"
1148:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined octoPlusConfig
1149:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlOctoPlus.h"
1150:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1151:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1152:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1153:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //****************** GPS DECLARATION *********************
1154:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1155:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined (UseGPS)
1156:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if !defined HeadingMagHold
1157:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #error We need the magnetometer to use the GPS
1158:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif 
1159:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //  #if defined LASTCHANNEL 6
1160:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //    #error We need 7 receiver channel to use GPS navigator
1161:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //  #endif
1162:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <GpsAdapter.h>
1163:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "GpsNavigator.h"
1164:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1165:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1166:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1167:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //****************** OSD DEVICE DECLARATION **************
1168:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1169:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef MAX7456_OSD     // only OSD supported for now is the MAX7456
1170:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_SPI.h>
1171:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "OSDDisplayController.h"
1172:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "MAX7456.h"
1173:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef OSD_SYSTEM_MENU
1174:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #include "OSDMenu.h"
1175:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1176:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #else  
1177:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef OSD_SYSTEM_MENU  // can't use menu system without an OSD
1178:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1179:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1180:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1181:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //****************** SERIAL PORT DECLARATION *************
1182:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1183:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined (WirelessTelemetry) 
1184:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__)
1185:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define SERIAL_PORT Serial3
1186:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else    // force 328p to use the normal port
1187:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define SERIAL_PORT Serial
1188:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1189:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #else  
1190:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(SERIAL_USES_USB)   // STM32 Maple
1191:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define SERIAL_PORT SerialUSB
1192:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef BAUD
1193:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BAUD
1194:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
1195:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define SERIAL_PORT Serial
1196:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1197:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif  
1198:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1199:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef SlowTelemetry
1200:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <AQ_RSCode.h>
1201:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1202:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1203:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef GraupnerHoTTTelemetry
1204:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <HoTT.h>
1205:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <HoTT_Telemetry.h>
1206:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1207:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1208:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1209:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** // Include this last as it contains objects from above declarations
1210:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "AltitudeControlProcessor.h"
1211:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "FlightControlProcessor.h"
1212:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "FlightCommandProcessor.h"
1213:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "HeadingHoldProcessor.h"
1214:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "DataStorage.h"
1215:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "SerialCom.h"
1216:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined (UseGPS) || defined (BattMonitor)
1217:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "LedStatusProcessor.h"
1218:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif  
1219:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1220:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1221:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** /**
1222:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****  * Main setup function, called one time at bootup
1223:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****  * initialize all system and sub system of the
1224:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****  * Aeroquad
1225:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****  */
1226:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** void setup() {
 12485              		.loc 36 1226 0
 12486              		.cfi_startproc
 12487              		@ args = 0, pretend = 0, frame = 0
 12488              		@ frame_needed = 0, uses_anonymous_args = 0
 12489 0000 10B5     		push	{r4, lr}
 12490              	.LCFI115:
 12491              		.cfi_def_cfa_offset 8
 12492              		.cfi_offset 14, -4
 12493              		.cfi_offset 4, -8
1227:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   SERIAL_BEGIN(BAUD);
 12494              		.loc 36 1227 0
 12495 0002 3148     		ldr	r0, .L792
 12496 0004 4FF4E131 		mov	r1, #115200
 12497 0008 FFF7FEFF 		bl	_ZN9USBSerial5beginEi
1228:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   pinMode(LED_Green, OUTPUT);
 12498              		.loc 36 1228 0
 12499 000c 4620     		movs	r0, #70
 12500 000e 0021     		movs	r1, #0
 12501 0010 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
1229:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   digitalWrite(LED_Green, LOW);
 12502              		.loc 36 1229 0
 12503 0014 4620     		movs	r0, #70
 12504 0016 0021     		movs	r1, #0
 12505 0018 FFF7FEFF 		bl	_Z12digitalWritehh
1230:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1231:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   initCommunication();
1232:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1233:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Read user values from EEPROM
1234:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   readEEPROM(); // defined in DataStorage.h
 12506              		.loc 36 1234 0
 12507 001c FFF7FEFF 		bl	_Z10readEEPROMv
1235:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   if (readFloat(SOFTWARE_VERSION_ADR) != SOFTWARE_VERSION) { // If we detect the wrong soft version
 12508              		.loc 36 1235 0
 12509 0020 FC20     		movs	r0, #252
 12510 0022 FFF7FEFF 		bl	_Z12nvrReadFloati
 12511 0026 DFED297A 		flds	s15, .L792+4
 12512 002a 07EE100A 		fmsr	s14, r0
 12513 002e B4EE677A 		fcmps	s14, s15
 12514 0032 F1EE10FA 		fmstat
 12515 0036 03D0     		beq	.L791
1236:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeEEPROM();
 12516              		.loc 36 1236 0
 12517 0038 FFF7FEFF 		bl	_Z16initializeEEPROMv
1237:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     writeEEPROM();
 12518              		.loc 36 1237 0
 12519 003c FFF7FEFF 		bl	_Z11writeEEPROMv
 12520              	.L791:
1238:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
1239:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1240:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   initPlatform();
 12521              		.loc 36 1240 0
 12522 0040 FFF7FEFF 		bl	_Z12initPlatformv
1241:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1242:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Configure motors
1243:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(quadXConfig) || defined(quadPlusConfig) || defined(quadY4Config) || defined(triConfig
1244:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****      initializeMotors(FOUR_Motors);
 12523              		.loc 36 1244 0
 12524 0044 0420     		movs	r0, #4
 12525 0046 FFF7FEFF 		bl	_Z16initializeMotors9NB_Motors
1245:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #elif defined(hexPlusConfig) || defined(hexXConfig) || defined(hexY6Config)
1246:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****      initializeMotors(SIX_Motors);
1247:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #elif defined(octoX8Config) || defined(octoXConfig) || defined(octoPlusConfig)
1248:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****      initializeMotors(EIGHT_Motors);
1249:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1250:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1251:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Setup receiver pins for pin change interrupts
1252:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   initializeReceiver(LASTCHANNEL);
 12526              		.loc 36 1252 0
 12527 004a 0820     		movs	r0, #8
 12528 004c FFF7FEFF 		bl	_Z18initializeReceiveri
1253:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   initReceiverFromEEPROM();
 12529              		.loc 36 1253 0
 12530 0050 FFF7FEFF 		bl	_Z22initReceiverFromEEPROMv
1254:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1255:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   initializeKinematics();
 12531              		.loc 36 1255 0
 12532 0054 FFF7FEFF 		bl	_Z20initializeKinematicsv
1256:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1257:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Integral Limit for attitude mode
1258:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // This overrides default set in readEEPROM()
1259:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Set for 1/2 max attitude command (+/-0.75 radians)
1260:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Rate integral not used for now
1261:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   PID[ATTITUDE_XAXIS_PID_IDX].windupGuard = 0.375;
 12533              		.loc 36 1261 0
 12534 0058 1D49     		ldr	r1, .L792+8
 12535 005a 4FF07B54 		mov	r4, #1052770304
 12536 005e CC66     		str	r4, [r1, #108]	@ float
1262:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   PID[ATTITUDE_YAXIS_PID_IDX].windupGuard = 0.375;
 12537              		.loc 36 1262 0
 12538 0060 C1F88840 		str	r4, [r1, #136]	@ float
1263:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
1264:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Optional Sensors
1265:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldBaro
1266:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeBaro();
1267:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     vehicleState |= ALTITUDEHOLD_ENABLED;
 12539              		.loc 36 1267 0
 12540 0064 1B4C     		ldr	r4, .L792+12
1266:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeBaro();
 12541              		.loc 36 1266 0
 12542 0066 FFF7FEFF 		bl	_Z14initializeBarov
 12543              		.loc 36 1267 0
 12544 006a 2368     		ldr	r3, [r4, #0]
1268:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1269:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
1270:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     inititalizeRangeFinders();
1271:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     vehicleState |= RANGE_ENABLED;
1272:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].P = PID[BARO_ALTITUDE_HOLD_PID_IDX].P*2;
1273:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].I = PID[BARO_ALTITUDE_HOLD_PID_IDX].I;
1274:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].D = PID[BARO_ALTITUDE_HOLD_PID_IDX].D;
1275:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].windupGuard = PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard;
1276:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1277:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1278:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Battery Monitor
1279:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef BattMonitor
1280:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // batteryMonitorAlarmVoltage updated in readEEPROM()
1281:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeBatteryMonitor(sizeof(batteryData) / sizeof(struct BatteryData), batteryMonitorAlarmV
 12545              		.loc 36 1281 0
 12546 006c 1A4A     		ldr	r2, .L792+16
1267:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     vehicleState |= ALTITUDEHOLD_ENABLED;
 12547              		.loc 36 1267 0
 12548 006e 43F02000 		orr	r0, r3, #32
 12549              		.loc 36 1281 0
 12550 0072 1168     		ldr	r1, [r2, #0]	@ float
1267:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     vehicleState |= ALTITUDEHOLD_ENABLED;
 12551              		.loc 36 1267 0
 12552 0074 2060     		str	r0, [r4, #0]
 12553              		.loc 36 1281 0
 12554 0076 0120     		movs	r0, #1
 12555 0078 FFF7FEFF 		bl	_Z24initializeBatteryMonitorhf
1282:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     vehicleState |= BATTMONITOR_ENABLED;
 12556              		.loc 36 1282 0
 12557 007c 2168     		ldr	r1, [r4, #0]
 12558 007e 41F04003 		orr	r3, r1, #64
 12559 0082 2360     		str	r3, [r4, #0]
1283:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1284:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
1285:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1286:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Camera stabilization setup
1287:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(CameraControl)
1288:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeCameraStabilization();
1289:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     vehicleState |= CAMERASTABLE_ENABLED;
1290:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1291:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1292:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(MAX7456_OSD)
1293:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeSPI();
1294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeOSD();
1295:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1296:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
1297:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(SERIAL_LCD)
1298:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     InitSerialLCD();
1299:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1300:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1301:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(BinaryWrite) || defined(BinaryWritePID)
1302:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #ifdef OpenlogBinaryWrite
1303:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       binaryPort = &Serial1;
1304:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       binaryPort->begin(115200);
1305:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       delay(1000);
1306:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #else
1307:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****      binaryPort = &Serial;
1308:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
1309:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1310:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
1311:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(UseGPS)
1312:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeGps();
1313:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif 
1314:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1315:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef SlowTelemetry
1316:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****      initSlowTelemetry();
1317:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1318:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1319:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   setupFourthOrder();
 12560              		.loc 36 1319 0
 12561 0084 FFF7FEFF 		bl	_Z16setupFourthOrderv
1320:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
1321:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Initialize sensors
1322:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // If sensors have a common initialization routine
1323:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // insert it into the gyro class because it executes first
1324:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   initializeGyro(); // defined in Gyro.h
 12562              		.loc 36 1324 0
 12563 0088 FFF7FEFF 		bl	_Z14initializeGyrov
1325:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   initializeAccel(); // defined in Accel.h
 12564              		.loc 36 1325 0
 12565 008c FFF7FEFF 		bl	_Z15initializeAccelv
1326:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   initSensorsZeroFromEEPROM();
 12566              		.loc 36 1326 0
 12567 0090 FFF7FEFF 		bl	_Z25initSensorsZeroFromEEPROMv
1327:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1328:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Calibrate sensors
1329:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   calibrateGyro();
 12568              		.loc 36 1329 0
 12569 0094 FFF7FEFF 		bl	_Z13calibrateGyrov
1330:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //  computeAccelBias();
1331:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Flight angle estimation
1332:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef HeadingMagHold
1333:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     vehicleState |= HEADINGHOLD_ENABLED;
 12570              		.loc 36 1333 0
 12571 0098 2268     		ldr	r2, [r4, #0]
 12572 009a 42F01000 		orr	r0, r2, #16
 12573 009e 2060     		str	r0, [r4, #0]
1334:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeMagnetometer();
 12574              		.loc 36 1334 0
 12575 00a0 FFF7FEFF 		bl	_Z22initializeMagnetometerv
1335:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeHeadingFusion();
 12576              		.loc 36 1335 0
 12577 00a4 FFF7FEFF 		bl	_Z23initializeHeadingFusionv
1336:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1337:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1338:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef GraupnerHoTTTelemetry
1339:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 	hottv4Init(&Serial3);
 12578              		.loc 36 1339 0
 12579 00a8 0C48     		ldr	r0, .L792+20
 12580 00aa FFF7FEFF 		bl	_Z10hottv4InitP14HardwareSerial
1340:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1341:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1342:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1343:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
1344:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   previousTime = micros();
 12581              		.loc 36 1344 0
 12582 00ae FFF7FEFF 		bl	_ZL6microsv
 12583 00b2 0B49     		ldr	r1, .L792+24
 12584 00b4 0860     		str	r0, [r1, #0]
1345:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   digitalWrite(LED_Green, HIGH);
 12585              		.loc 36 1345 0
 12586 00b6 4620     		movs	r0, #70
 12587 00b8 0121     		movs	r1, #1
 12588 00ba FFF7FEFF 		bl	_Z12digitalWritehh
1346:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   safetyCheck = 0;
 12589              		.loc 36 1346 0
 12590 00be 094B     		ldr	r3, .L792+28
 12591 00c0 0022     		movs	r2, #0
 12592 00c2 1A70     		strb	r2, [r3, #0]
1347:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** }
 12593              		.loc 36 1347 0
 12594 00c4 10BD     		pop	{r4, pc}
 12595              	.L793:
 12596 00c6 00BF     		.align	2
 12597              	.L792:
 12598 00c8 00000000 		.word	SerialUSB
 12599 00cc 66664640 		.word	1078355558
 12600 00d0 00000000 		.word	.LANCHOR17
 12601 00d4 00000000 		.word	.LANCHOR21
 12602 00d8 00000000 		.word	.LANCHOR144
 12603 00dc 00000000 		.word	Serial3
 12604 00e0 00000000 		.word	.LANCHOR153
 12605 00e4 00000000 		.word	.LANCHOR131
 12606              		.cfi_endproc
 12607              	.LFE275:
 12609              		.section	.text._Z4loopv,"ax",%progbits
 12610              		.align	1
 12611              		.global	_Z4loopv
 12612              		.thumb
 12613              		.thumb_func
 12615              	_Z4loopv:
 12616              	.LFB276:
1348:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1349:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** /*******************************************************************
1350:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // tasks (microseconds of interval)
1351:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   ReadGyro        readGyro      (as fast as we can depending of the platform)
1352:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   ReadAccel       readAccel     (as fast as we can depending of the platform)
1353:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   RunDCM          runKinematics (  10000); // 100hz
1354:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   FlightControls  flightControls(  10000); // 100hz
1355:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   ReadBaro        readBaro      (  10000); // 100hz
1356:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   ReadReceiver    readReceiver  (  20000); //  50hz
1357:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   ReadCompass     readCompass   ( 100000); //  10Hz
1358:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   ProcessTelem    processTelem  ( 100000); //  10Hz
1359:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   ReadBattery     readBattery   ( 100000); //  10Hz
1360:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1361:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   Task *tasks[] = {&readGyro, &readAccel, &runDCM, &flightControls,   \
1362:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****                    &readReceiver, &readBaro, &readCompass,            \
1363:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****                    &processTelem, &readBattery};
1364:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1365:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   TaskScheduler sched(tasks, NUM_TASKS(tasks));
1366:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1367:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   sched.run();
1368:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** *******************************************************************/
1369:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** void loop () {
 12617              		.loc 36 1369 0
 12618              		.cfi_startproc
 12619              		@ args = 0, pretend = 0, frame = 0
 12620              		@ frame_needed = 0, uses_anonymous_args = 0
 12621 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, sl, lr}
 12622              	.LCFI116:
 12623              		.cfi_def_cfa_offset 32
 12624              		.cfi_offset 14, -4
 12625              		.cfi_offset 10, -8
 12626              		.cfi_offset 9, -12
 12627              		.cfi_offset 8, -16
 12628              		.cfi_offset 7, -20
 12629              		.cfi_offset 6, -24
 12630              		.cfi_offset 5, -28
 12631              		.cfi_offset 4, -32
 12632 0004 2DED028B 		fstmfdd	sp!, {d8}
 12633              	.LCFI117:
 12634              		.cfi_def_cfa_offset 40
 12635              		.cfi_offset 80, -40
 12636              	.LBB384:
1370:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
1371:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   currentTime = micros();
1372:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   deltaTime = currentTime - previousTime;
 12637              		.loc 36 1372 0
 12638 0008 624F     		ldr	r7, .L803
1371:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   currentTime = micros();
 12639              		.loc 36 1371 0
 12640 000a 634D     		ldr	r5, .L803+4
 12641              		.loc 36 1372 0
 12642 000c 634C     		ldr	r4, .L803+8
 12643              	.LBE384:
1369:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** void loop () {
 12644              		.loc 36 1369 0
 12645 000e 84B0     		sub	sp, sp, #16
 12646              	.LCFI118:
 12647              		.cfi_def_cfa_offset 56
 12648              	.LBB388:
1371:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   currentTime = micros();
 12649              		.loc 36 1371 0
 12650 0010 FFF7FEFF 		bl	_ZL6microsv
 12651              		.loc 36 1372 0
 12652 0014 3968     		ldr	r1, [r7, #0]
1371:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   currentTime = micros();
 12653              		.loc 36 1371 0
 12654 0016 2860     		str	r0, [r5, #0]
 12655              		.loc 36 1372 0
 12656 0018 401A     		subs	r0, r0, r1
 12657 001a 2060     		str	r0, [r4, #0]
1373:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1374:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   measureCriticalSensors();
 12658              		.loc 36 1374 0
 12659 001c FFF7FEFF 		bl	_Z22measureCriticalSensorsv
 12660              	.LBB385:
1375:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1376:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // ================================================================
1377:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // 100Hz task loop
1378:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // ================================================================
1379:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   if (deltaTime >= 10000) {
 12661              		.loc 36 1379 0
 12662 0020 2268     		ldr	r2, [r4, #0]
 12663 0022 5F4C     		ldr	r4, .L803+12
 12664 0024 42F20F73 		movw	r3, #9999
 12665 0028 9A42     		cmp	r2, r3
 12666 002a 40F2A580 		bls	.L795
 12667              	.LBB386:
1380:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     
1381:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     frameCounter++;
 12668              		.loc 36 1381 0
 12669 002e 2268     		ldr	r2, [r4, #0]
1382:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     
1383:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     G_Dt = (currentTime - hundredHZpreviousTime) / 1000000.0;
 12670              		.loc 36 1383 0
 12671 0030 5C4B     		ldr	r3, .L803+16
1384:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     hundredHZpreviousTime = currentTime;
1385:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     
1386:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     evaluateGyroRate();
1387:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     evaluateMetersPerSec();
 12672              		.loc 36 1387 0
 12673 0032 DFF8A4A1 		ldr	sl, .L803+68
1383:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     G_Dt = (currentTime - hundredHZpreviousTime) / 1000000.0;
 12674              		.loc 36 1383 0
 12675 0036 1968     		ldr	r1, [r3, #0]
 12676              		.loc 36 1387 0
 12677 0038 DFF8A091 		ldr	r9, .L803+72
1381:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     frameCounter++;
 12678              		.loc 36 1381 0
 12679 003c 561C     		adds	r6, r2, #1
1383:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     G_Dt = (currentTime - hundredHZpreviousTime) / 1000000.0;
 12680              		.loc 36 1383 0
 12681 003e 2A68     		ldr	r2, [r5, #0]
1381:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     frameCounter++;
 12682              		.loc 36 1381 0
 12683 0040 2660     		str	r6, [r4, #0]
1383:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     G_Dt = (currentTime - hundredHZpreviousTime) / 1000000.0;
 12684              		.loc 36 1383 0
 12685 0042 501A     		subs	r0, r2, r1
 12686 0044 07EE100A 		fmsr	s14, r0	@ int
 12687 0048 9FED578A 		flds	s16, .L803+20
 12688 004c F8EE477A 		fuitos	s15, s14
 12689 0050 564E     		ldr	r6, .L803+24
1384:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     hundredHZpreviousTime = currentTime;
 12690              		.loc 36 1384 0
 12691 0052 1A60     		str	r2, [r3, #0]
1383:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     G_Dt = (currentTime - hundredHZpreviousTime) / 1000000.0;
 12692              		.loc 36 1383 0
 12693 0054 C7EE887A 		fdivs	s15, s15, s16
1388:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1389:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     for (int axis = XAXIS; axis <= ZAXIS; axis++) {
 12694              		.loc 36 1389 0
 12695 0058 4FF00008 		mov	r8, #0
1383:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     G_Dt = (currentTime - hundredHZpreviousTime) / 1000000.0;
 12696              		.loc 36 1383 0
 12697 005c C6ED007A 		fsts	s15, [r6, #0]
1386:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     evaluateGyroRate();
 12698              		.loc 36 1386 0
 12699 0060 FFF7FEFF 		bl	_Z16evaluateGyroRatev
1387:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     evaluateMetersPerSec();
 12700              		.loc 36 1387 0
 12701 0064 FFF7FEFF 		bl	_Z20evaluateMetersPerSecv
 12702              	.LVL523:
 12703              	.L796:
 12704              	.LBB387:
1390:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       filteredAccel[axis] = computeFourthOrder(meterPerSecSec[axis], &fourthOrder[axis]);
 12705              		.loc 36 1390 0 discriminator 2
 12706 0068 5149     		ldr	r1, .L803+28
 12707 006a 5AF8040F 		ldr	r0, [sl, #4]!	@ float
 12708 006e 4FEA481C 		lsl	ip, r8, #5
 12709 0072 6144     		add	r1, r1, ip
 12710 0074 FFF7FEFF 		bl	_Z18computeFourthOrderfP15fourthOrderData
1389:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     for (int axis = XAXIS; axis <= ZAXIS; axis++) {
 12711              		.loc 36 1389 0 discriminator 2
 12712 0078 08F10108 		add	r8, r8, #1
 12713              	.LVL524:
 12714 007c B8F1030F 		cmp	r8, #3
 12715              		.loc 36 1390 0 discriminator 2
 12716 0080 49F8040F 		str	r0, [r9, #4]!	@ float
1389:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     for (int axis = XAXIS; axis <= ZAXIS; axis++) {
 12717              		.loc 36 1389 0 discriminator 2
 12718 0084 F0D1     		bne	.L796
 12719              	.LBE387:
1391:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
1392:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       
1393:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     /* calculate kinematics */
1394:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     calculateKinematics(gyroRate[XAXIS],
1395:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****                         gyroRate[YAXIS],
1396:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****                         gyroRate[ZAXIS],
1397:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****                         filteredAccel[XAXIS],
1398:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****                         filteredAccel[YAXIS],
1399:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****                         filteredAccel[ZAXIS],
1400:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****                         G_Dt);
 12720              		.loc 36 1400 0
 12721 0086 4B4B     		ldr	r3, .L803+32
 12722 0088 4B4A     		ldr	r2, .L803+36
 12723 008a 5968     		ldr	r1, [r3, #4]	@ float
 12724 008c 0091     		str	r1, [sp, #0]	@ float
 12725 008e D3F808E0 		ldr	lr, [r3, #8]	@ float
 12726 0092 CDF804E0 		str	lr, [sp, #4]	@ float
 12727 0096 3068     		ldr	r0, [r6, #0]	@ float
 12728 0098 0290     		str	r0, [sp, #8]	@ float
 12729 009a 5168     		ldr	r1, [r2, #4]	@ float
 12730 009c 1068     		ldr	r0, [r2, #0]	@ float
 12731 009e 1B68     		ldr	r3, [r3, #0]	@ float
 12732 00a0 9268     		ldr	r2, [r2, #8]	@ float
 12733 00a2 FFF7FEFF 		bl	_Z19calculateKinematicsfffffff
1401:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1402:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1403:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // Evaluate are here because we want it to be synchronized with the processFlightControl
1404:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #if defined(AltitudeHoldBaro)
1405:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureBaroSum(); 
 12734              		.loc 36 1405 0
 12735 00a6 FFF7FEFF 		bl	_Z14measureBaroSumv
1406:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
1407:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****           
1408:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // Combines external pilot commands and measured sensor data to generate motor commands
1409:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     processFlightControl();
 12736              		.loc 36 1409 0
 12737 00aa FFF7FEFF 		bl	_Z20processFlightControlv
1410:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     
1411:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #if defined(BinaryWrite)
1412:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         if (fastTransfer == ON) {
1413:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****           // write out fastTelemetry to Configurator or openLog
1414:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****           fastTelemetry();
1415:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         }
1416:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif      
1417:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     
1418:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #ifdef SlowTelemetry
1419:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       updateSlowTelemetry100Hz();
1420:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
1421:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1422:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // ================================================================
1423:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // 50Hz task loop
1424:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // ================================================================
1425:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     if (frameCounter % TASK_50HZ == 0) {  //  50 Hz tasks
 12738              		.loc 36 1425 0
 12739 00ae 2368     		ldr	r3, [r4, #0]
 12740 00b0 D907     		lsls	r1, r3, #31
 12741 00b2 12D4     		bmi	.L797
1426:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1427:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       G_Dt = (currentTime - fiftyHZpreviousTime) / 1000000.0;
 12742              		.loc 36 1427 0
 12743 00b4 414B     		ldr	r3, .L803+40
 12744 00b6 2A68     		ldr	r2, [r5, #0]
 12745 00b8 1968     		ldr	r1, [r3, #0]
 12746 00ba 3C48     		ldr	r0, .L803+24
1428:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       fiftyHZpreviousTime = currentTime;
 12747              		.loc 36 1428 0
 12748 00bc 1A60     		str	r2, [r3, #0]
1427:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       G_Dt = (currentTime - fiftyHZpreviousTime) / 1000000.0;
 12749              		.loc 36 1427 0
 12750 00be C1EB020C 		rsb	ip, r1, r2
 12751 00c2 00EE90CA 		fmsr	s1, ip	@ int
 12752 00c6 B8EE600A 		fuitos	s0, s1
 12753 00ca 80EE080A 		fdivs	s0, s0, s16
 12754 00ce 80ED000A 		fsts	s0, [r0, #0]
1429:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1430:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       // Reads external pilot commands and performs functions based on stick configuration
1431:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       readPilotCommands(); 
 12755              		.loc 36 1431 0
 12756 00d2 FFF7FEFF 		bl	_Z17readPilotCommandsv
1432:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       
1433:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #if defined(AltitudeHoldBaro)
1434:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         evaluateBaroAltitude();
 12757              		.loc 36 1434 0
 12758 00d6 FFF7FEFF 		bl	_Z20evaluateBaroAltitudev
 12759              	.L797:
1435:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #endif
1436:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       
1437:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #if defined(UseAnalogRSSIReader) || defined(UseEzUHFRSSIReader)
1438:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         readRSSI();
1439:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #endif
1440:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1441:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #ifdef AltitudeHoldRangeFinder
1442:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         updateRangeFinders();
1443:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #endif
1444:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1445:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #if defined(UseGPS)
1446:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         readGps();
1447:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         if (haveAGpsLock() && !isHomeBaseInitialized()) {
1448:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****           initHomeBase();
1449:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         }
1450:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #endif      
1451:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       
1452:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #if defined(CameraControl)
1453:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         moveCamera(kinematicsAngle[YAXIS],kinematicsAngle[XAXIS],kinematicsAngle[ZAXIS]);
1454:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #endif      
1455:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
1456:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1457:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // ================================================================
1458:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // 10Hz task loop
1459:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // ================================================================
1460:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     if (frameCounter % TASK_10HZ == 0) {  //   10 Hz tasks
 12760              		.loc 36 1460 0
 12761 00da 2168     		ldr	r1, [r4, #0]
 12762 00dc 0A23     		movs	r3, #10
 12763 00de B1FBF3F0 		udiv	r0, r1, r3
 12764 00e2 03FB1012 		mls	r2, r3, r0, r1
 12765 00e6 AAB9     		cbnz	r2, .L798
1461:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1462:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #if defined(HeadingMagHold)
1463:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         G_Dt = (currentTime - tenHZpreviousTime) / 1000000.0;
 12766              		.loc 36 1463 0
 12767 00e8 354B     		ldr	r3, .L803+44
 12768 00ea 2868     		ldr	r0, [r5, #0]
 12769 00ec 1968     		ldr	r1, [r3, #0]
1464:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         tenHZpreviousTime = currentTime;
1465:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****          
1466:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         measureMagnetometer(kinematicsAngle[XAXIS], kinematicsAngle[YAXIS]);
 12770              		.loc 36 1466 0
 12771 00ee 354A     		ldr	r2, .L803+48
1464:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         tenHZpreviousTime = currentTime;
 12772              		.loc 36 1464 0
 12773 00f0 1860     		str	r0, [r3, #0]
1463:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         G_Dt = (currentTime - tenHZpreviousTime) / 1000000.0;
 12774              		.loc 36 1463 0
 12775 00f2 C1EB000E 		rsb	lr, r1, r0
 12776 00f6 01EE90EA 		fmsr	s3, lr	@ int
 12777 00fa B8EE611A 		fuitos	s2, s3
 12778              		.loc 36 1466 0
 12779 00fe 1068     		ldr	r0, [r2, #0]	@ float
 12780 0100 5168     		ldr	r1, [r2, #4]	@ float
1463:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         G_Dt = (currentTime - tenHZpreviousTime) / 1000000.0;
 12781              		.loc 36 1463 0
 12782 0102 81EE081A 		fdivs	s2, s2, s16
 12783 0106 86ED001A 		fsts	s2, [r6, #0]
 12784              		.loc 36 1466 0
 12785 010a FFF7FEFF 		bl	_Z19measureMagnetometerff
1467:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         
1468:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         calculateHeading();
 12786              		.loc 36 1468 0
 12787 010e FFF7FEFF 		bl	_Z16calculateHeadingv
 12788 0112 2FE0     		b	.L799
 12789              	.L798:
1469:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         
1470:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #endif
1471:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
1472:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     else if ((currentTime - lowPriorityTenHZpreviousTime) > 100000) {
 12790              		.loc 36 1472 0
 12791 0114 2C4A     		ldr	r2, .L803+52
 12792 0116 2B68     		ldr	r3, [r5, #0]
 12793 0118 1068     		ldr	r0, [r2, #0]
 12794 011a 191A     		subs	r1, r3, r0
 12795 011c 2B48     		ldr	r0, .L803+56
 12796 011e 8142     		cmp	r1, r0
 12797 0120 18D9     		bls	.L800
1473:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1474:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       G_Dt = (currentTime - lowPriorityTenHZpreviousTime) / 1000000.0;
 12798              		.loc 36 1474 0
 12799 0122 03EE901A 		fmsr	s7, r1	@ int
 12800 0126 F8EE632A 		fuitos	s5, s7
1475:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       lowPriorityTenHZpreviousTime = currentTime;
1476:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       
1477:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #if defined(BattMonitor)
1478:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         measureBatteryVoltage(G_Dt*1000.0);
 12801              		.loc 36 1478 0
 12802 012a 9FED293A 		flds	s6, .L803+60
1474:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       G_Dt = (currentTime - lowPriorityTenHZpreviousTime) / 1000000.0;
 12803              		.loc 36 1474 0
 12804 012e C2EE882A 		fdivs	s5, s5, s16
1475:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       lowPriorityTenHZpreviousTime = currentTime;
 12805              		.loc 36 1475 0
 12806 0132 1360     		str	r3, [r2, #0]
1474:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       G_Dt = (currentTime - lowPriorityTenHZpreviousTime) / 1000000.0;
 12807              		.loc 36 1474 0
 12808 0134 C6ED002A 		fsts	s5, [r6, #0]
 12809              		.loc 36 1478 0
 12810 0138 62EE832A 		fmuls	s5, s5, s6
 12811 013c BCEEE22A 		ftouizs	s4, s5
 12812 0140 12EE102A 		fmrs	r2, s4	@ int
 12813 0144 90B2     		uxth	r0, r2
 12814 0146 FFF7FEFF 		bl	_Z21measureBatteryVoltaget
1479:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #endif
1480:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1481:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       // Listen for configuration commands and reports telemetry
1482:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       readSerialCommand();
 12815              		.loc 36 1482 0
 12816 014a FFF7FEFF 		bl	_Z17readSerialCommandv
1483:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       sendSerialTelemetry();
 12817              		.loc 36 1483 0
 12818 014e FFF7FEFF 		bl	_Z19sendSerialTelemetryv
 12819 0152 0FE0     		b	.L799
 12820              	.L800:
1484:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
1485:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     else if ((currentTime - lowPriorityTenHZpreviousTime2) > 100000) {
 12821              		.loc 36 1485 0
 12822 0154 1F4A     		ldr	r2, .L803+64
 12823 0156 1168     		ldr	r1, [r2, #0]
 12824 0158 591A     		subs	r1, r3, r1
 12825 015a 8142     		cmp	r1, r0
 12826 015c 0AD9     		bls	.L799
1486:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       
1487:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       G_Dt = (currentTime - lowPriorityTenHZpreviousTime2) / 1000000.0;
 12827              		.loc 36 1487 0
 12828 015e 04EE901A 		fmsr	s9, r1	@ int
 12829 0162 B8EE644A 		fuitos	s8, s9
1488:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       lowPriorityTenHZpreviousTime2 = currentTime;
 12830              		.loc 36 1488 0
 12831 0166 1360     		str	r3, [r2, #0]
1487:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       G_Dt = (currentTime - lowPriorityTenHZpreviousTime2) / 1000000.0;
 12832              		.loc 36 1487 0
 12833 0168 84EE084A 		fdivs	s8, s8, s16
 12834 016c 86ED004A 		fsts	s8, [r6, #0]
1489:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1490:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #ifdef OSD_SYSTEM_MENU
1491:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         updateOSDMenu();
1492:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #endif
1493:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1494:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #ifdef MAX7456_OSD
1495:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         updateOSD();
1496:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #endif
1497:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       
1498:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #if defined(UseGPS) || defined(BattMonitor)
1499:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         processLedStatus();
 12835              		.loc 36 1499 0
 12836 0170 FFF7FEFF 		bl	_Z16processLedStatusv
 12837              	.L799:
1500:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #endif
1501:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       
1502:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #ifdef SlowTelemetry
1503:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         updateSlowTelemetry10Hz();
1504:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #endif
1505:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
1506:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1507:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #ifdef MavLink
1508:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****      if (frameCounter % TASK_1HZ == 0) {  //  1 Hz tasks
1509:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1510:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         G_Dt = (currentTime - oneHZpreviousTime) / 1000000.0;
1511:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         oneHZpreviousTime = currentTime;
1512:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         
1513:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         sendSerialHeartbeat();   
1514:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****      }
1515:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
1516:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     previousTime = currentTime;
 12838              		.loc 36 1516 0
 12839 0174 2B68     		ldr	r3, [r5, #0]
 12840 0176 3B60     		str	r3, [r7, #0]
 12841              	.LVL525:
 12842              	.L795:
 12843              	.LBE386:
 12844              	.LBE385:
1517:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
1518:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
1519:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined (GraupnerHoTTTelemetry)
1520:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 	hottHandler();
 12845              		.loc 36 1520 0
 12846 0178 FFF7FEFF 		bl	_Z11hottHandlerv
1521:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1522:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1523:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   if (frameCounter >= 100) {
 12847              		.loc 36 1523 0
 12848 017c 2068     		ldr	r0, [r4, #0]
 12849 017e 6328     		cmp	r0, #99
 12850 0180 02D9     		bls	.L794
1524:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       frameCounter = 0;
 12851              		.loc 36 1524 0
 12852 0182 0749     		ldr	r1, .L803+12
 12853 0184 0022     		movs	r2, #0
 12854 0186 0A60     		str	r2, [r1, #0]
 12855              	.L794:
 12856              	.LBE388:
1525:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
1526:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** }
 12857              		.loc 36 1526 0
 12858 0188 04B0     		add	sp, sp, #16
 12859 018a BDEC028B 		fldmfdd	sp!, {d8}
 12860 018e BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, sl, pc}
 12861              	.L804:
 12862 0192 00BF     		.align	2
 12863              	.L803:
 12864 0194 00000000 		.word	.LANCHOR153
 12865 0198 00000000 		.word	.LANCHOR15
 12866 019c 00000000 		.word	.LANCHOR154
 12867 01a0 00000000 		.word	.LANCHOR41
 12868 01a4 00000000 		.word	.LANCHOR155
 12869 01a8 00247449 		.word	1232348160
 12870 01ac 00000000 		.word	.LANCHOR57
 12871 01b0 00000000 		.word	.LANCHOR18
 12872 01b4 00000000 		.word	.LANCHOR151
 12873 01b8 00000000 		.word	.LANCHOR27
 12874 01bc 00000000 		.word	.LANCHOR156
 12875 01c0 00000000 		.word	.LANCHOR157
 12876 01c4 00000000 		.word	.LANCHOR42
 12877 01c8 00000000 		.word	.LANCHOR158
 12878 01cc A0860100 		.word	100000
 12879 01d0 00007A44 		.word	1148846080
 12880 01d4 00000000 		.word	.LANCHOR159
 12881 01d8 FCFFFFFF 		.word	.LANCHOR34-4
 12882 01dc FCFFFFFF 		.word	.LANCHOR151-4
 12883              		.cfi_endproc
 12884              	.LFE276:
 12886              		.section	.text.startup.main,"ax",%progbits
 12887              		.align	1
 12888              		.global	main
 12889              		.thumb
 12890              		.thumb_func
 12892              	main:
 12893              	.LFB114:
   7:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp **** 
   8:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp **** int main(void)
   9:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp **** {
 12894              		.loc 6 9 0
 12895              		.cfi_startproc
 12896              		@ args = 0, pretend = 0, frame = 0
 12897              		@ frame_needed = 0, uses_anonymous_args = 0
 12898 0000 08B5     		push	{r3, lr}
 12899              	.LCFI119:
 12900              		.cfi_def_cfa_offset 8
 12901              		.cfi_offset 14, -4
 12902              		.cfi_offset 3, -8
  10:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp **** 	//init();
  11:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp ****   	setup();
 12903              		.loc 6 11 0
 12904 0002 FFF7FEFF 		bl	_Z5setupv
 12905              	.L806:
  12:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp **** 
  13:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp **** 	for (;;)
  14:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp **** 		loop();
 12906              		.loc 6 14 0 discriminator 1
 12907 0006 FFF7FEFF 		bl	_Z4loopv
 12908 000a FCE7     		b	.L806
 12909              		.cfi_endproc
 12910              	.LFE114:
 12912              		.section	.text.startup._GLOBAL__sub_I__Z7premainv,"ax",%progbits
 12913              		.align	1
 12914              		.thumb
 12915              		.thumb_func
 12917              	_GLOBAL__sub_I__Z7premainv:
 12918              	.LFB278:
 12919              		.loc 36 1526 0
 12920              		.cfi_startproc
 12921              		@ args = 0, pretend = 0, frame = 0
 12922              		@ frame_needed = 0, uses_anonymous_args = 0
 12923              	.LVL526:
 12924 0000 08B5     		push	{r3, lr}
 12925              	.LCFI120:
 12926              		.cfi_def_cfa_offset 8
 12927              		.cfi_offset 14, -4
 12928              		.cfi_offset 3, -8
 12929              	.LBB391:
 12930              	.LBB392:
 116:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	HardwareSPIExt spiMPU6000(4);
 12931              		.loc 11 116 0
 12932 0002 0421     		movs	r1, #4
 12933 0004 0848     		ldr	r0, .L808
 12934 0006 FFF7FEFF 		bl	_ZN14HardwareSPIExtC1Ej
  42:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** float filter2 = 1 - filter1;
 12935              		.loc 21 42 0
 12936 000a 0849     		ldr	r1, .L808+4
 12937 000c 0848     		ldr	r0, .L808+8
 12938 000e 91ED000A 		flds	s0, [r1, #0]
 12939 0012 B7EE007A 		fconsts	s14, #112
 12940 0016 77EE407A 		fsubs	s15, s14, s0
 12941 001a C0ED007A 		fsts	s15, [r0, #0]
  27:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** unsigned long headingTime = micros();
 12942              		.loc 30 27 0
 12943 001e FFF7FEFF 		bl	_ZL6microsv
 12944 0022 044B     		ldr	r3, .L808+12
 12945 0024 1860     		str	r0, [r3, #0]
 12946              	.LBE392:
 12947              	.LBE391:
 12948              		.loc 36 1526 0
 12949 0026 08BD     		pop	{r3, pc}
 12950              	.L809:
 12951              		.align	2
 12952              	.L808:
 12953 0028 00000000 		.word	.LANCHOR19
 12954 002c 00000000 		.word	.LANCHOR72
 12955 0030 00000000 		.word	.LANCHOR73
 12956 0034 00000000 		.word	.LANCHOR141
 12957              		.cfi_endproc
 12958              	.LFE278:
 12960              		.section	.init_array,"aw",%init_array
 12961              		.align	2
 12962 0004 00000000 		.word	_GLOBAL__sub_I__Z7premainv(target1)
 12963              		.global	flashingLedState
 12964              		.global	queryType
 12965              		.global	headingTime
 12966              		.global	setHeading
 12967              		.global	hottTime
 12968              		.global	hottState
 12969              		.global	SpeakHoTT
 12970              		.global	CountMilliseconds
 12971              		.global	hottV4Serial
 12972              		.global	motorConfiguratorCommand
 12973              		.global	motorMinCommand
 12974              		.global	motorMaxCommand
 12975              		.global	motorAxisCommandYaw
 12976              		.global	motorAxisCommandPitch
 12977              		.global	motorAxisCommandRoll
 12978              		.global	batteryData
 12979              		.global	batteryWarningCellVoltage
 12980              		.global	batteryAlarmCellVoltage
 12981              		.global	buzzerState
 12982              		.global	batteryWarning
 12983              		.global	batteryAlarm
 12984              		.global	numberOfBatteries
 12985              		.global	MS5611_first_read
 12986              		.global	baroStartTime
 12987              		.global	baroGroundUpdateDone
 12988              		.global	rawPressureSumCount
 12989              		.global	rawPressureSum
 12990              		.global	isReadPressure
 12991              		.global	pressureFactor
 12992              		.global	pressureCount
 12993              		.global	rawTemperature
 12994              		.global	rawPressure
 12995              		.global	pressure
 12996              		.global	MS5611_offset
 12997              		.global	MS5611_sens
 12998              		.global	MS5611lastRawPressure
 12999              		.global	MS5611lastRawTemperature
 13000              		.global	MS5611Prom
 13001              		.global	baroSmoothFactor
 13002              		.global	baroGroundAltitude
 13003              		.global	baroRawAltitude
 13004              		.global	baroAltitude
 13005              		.global	localHeading
 13006              		.global	headingGyroZero
 13007              		.global	filter2
 13008              		.global	filter1
 13009              		.global	compassDeclination
 13010              		.global	trueNorthHeading
 13011              		.global	magScale
 13012              		.global	magBias
 13013              		.global	rawMag
 13014              		.global	measuredMag
 13015              		.global	measuredMagZ
 13016              		.global	measuredMagY
 13017              		.global	measuredMagX
 13018              		.global	hdgY
 13019              		.global	hdgX
 13020              		.global	MotorInfo
 13021              		.global	motorCommand
 13022              		.global	numberOfMotors
 13023              		.global	FrqData
 13024              		.global	currentChannel
 13025              		.global	rawChannelValue
 13026              		.global	previousEz
 13027              		.global	previousEy
 13028              		.global	previousEx
 13029              		.global	ezInt
 13030              		.global	eyInt
 13031              		.global	exInt
 13032              		.global	q3
 13033              		.global	q2
 13034              		.global	q1
 13035              		.global	q0
 13036              		.global	halfT
 13037              		.global	Ki
 13038              		.global	Kp
 13039              		.global	accelCutoff
 13040              		.global	earthAccel
 13041              		.global	correctedRateVector
 13042              		.global	gyroAngle
 13043              		.global	kinematicsAngle
 13044              		.global	kinematicsType
 13045              		.global	previousMeasureCriticalSensorsTime
 13046              		.global	accelSampleCount
 13047              		.global	accelSample
 13048              		.global	meterPerSecSec
 13049              		.global	accelOneG
 13050              		.global	runTimeAccelBias
 13051              		.global	accelScaleFactor
 13052              		.global	gyroSampleCount
 13053              		.global	gyroLastMesuredTime
 13054              		.global	gyroHeading
 13055              		.global	gyroScaleFactor
 13056              		.global	gyroSample
 13057              		.global	gyroZero
 13058              		.global	gyroRate
 13059              		.global	readMPU6000GyroCount
 13060              		.global	readMPU6000AccelCount
 13061              		.global	readMPU6000Count
 13062              		.global	initializeMPU6000SensorsDone
 13063              		.global	spiMPU6000
 13064              		.global	MPU6000
 13065              		.global	vehicleState
 13066              		.global	gyroRaw
 13067              		.global	Serial
 13068              		.global	fourthOrder
 13069              		.global	windupGuard
 13070              		.global	PID
 13071              		.global	fastTransfer
 13072              		.global	baroAltitudeToHoldTarget
 13073              		.global	isStoreAltitudeNeeded
 13074              		.global	altitudeHoldThrottle
 13075              		.global	maxThrottleAdjust
 13076              		.global	minThrottleAdjust
 13077              		.global	altitudeHoldPanicStickMovement
 13078              		.global	altitudeHoldBump
 13079              		.global	altitudeHoldState
 13080              		.global	batteryMonitorGoingDownTime
 13081              		.global	batteryMonitorStartTime
 13082              		.global	batteryMonitorThrottleTarget
 13083              		.global	batteryMonitorStartThrottle
 13084              		.global	batteryMonitorAlarmVoltage
 13085              		.global	headingHoldState
 13086              		.global	relativeHeading
 13087              		.global	heading
 13088              		.global	headingHold
 13089              		.global	headingHoldConfig
 13090              		.global	aref
 13091              		.global	hundredHZpreviousTime
 13092              		.global	fiftyHZpreviousTime
 13093              		.global	lowPriorityTenHZpreviousTime2
 13094              		.global	lowPriorityTenHZpreviousTime
 13095              		.global	tenHZpreviousTime
 13096              		.global	oneHZpreviousTime
 13097              		.global	deltaTime
 13098              		.global	currentTime
 13099              		.global	previousTime
 13100              		.global	rotationSpeedFactor
 13101              		.global	inFlight
 13102              		.global	filteredAccel
 13103              		.global	minLimit
 13104              		.global	maxLimit
 13105              		.global	safetyCheck
 13106              		.global	motorArmed
 13107              		.global	throttle
 13108              		.global	G_Dt
 13109              		.global	minArmedThrottle
 13110              		.global	frameCounter
 13111              		.global	flightMode
 13112              		.global	testCommand
 13113              		.global	calibrateESC
 13114              		.global	channelCal
 13115              		.global	receiverSmoothFactor
 13116              		.global	receiverOffset
 13117              		.global	receiverSlope
 13118              		.global	receiverCommandSmooth
 13119              		.global	receiverCommand
 13120              		.global	receiverZero
 13121              		.global	receiverData
 13122              		.global	receiverXmitFactor
 13123              		.global	lastReceiverChannel
 13124              		.weak	_ZN14HardwareSPIExtC1Ej
 13125              		.thumb_set _ZN14HardwareSPIExtC1Ej,_ZN14HardwareSPIExtC2Ej
 13126              		.section	.rodata
 13127              		.set	.LANCHOR119,. + 0
 13128              	.LC0:
 13129 0000 7C       		.byte	124
 13130 0001 89       		.byte	-119
 13131 0002 00       		.byte	0
 13132 0003 90       		.byte	-112
 13133 0004 00       		.byte	0
 13134 0005 F4       		.byte	-12
 13135 0006 01       		.byte	1
 13136 0007 F4       		.byte	-12
 13137 0008 01       		.byte	1
 13138 0009 F4       		.byte	-12
 13139 000a 01       		.byte	1
 13140 000b 30       		.byte	48
 13141 000c 75       		.byte	117
 13142 000d 30       		.byte	48
 13143 000e 75       		.byte	117
 13144 000f 30       		.byte	48
 13145 0010 75       		.byte	117
 13146 0011 00       		.byte	0
 13147 0012 00       		.byte	0
 13148 0013 00       		.byte	0
 13149 0014 00       		.byte	0
 13150 0015 00       		.byte	0
 13151 0016 00       		.byte	0
 13152 0017 00       		.byte	0
 13153 0018 00       		.byte	0
 13154 0019 00       		.byte	0
 13155 001a 00       		.byte	0
 13156 001b 00       		.byte	0
 13157 001c 00       		.byte	0
 13158 001d 00       		.byte	0
 13159 001e 00       		.byte	0
 13160 001f 00       		.byte	0
 13161 0020 00       		.byte	0
 13162 0021 00       		.byte	0
 13163 0022 00       		.byte	0
 13164 0023 00       		.byte	0
 13165 0024 00       		.byte	0
 13166 0025 00       		.byte	0
 13167 0026 00       		.byte	0
 13168 0027 00       		.byte	0
 13169 0028 00       		.byte	0
 13170 0029 00       		.byte	0
 13171 002a 00       		.byte	0
 13172 002b 7D       		.byte	125
 13173 002c 00       		.byte	0
 13174              		.section	.bss.CountMilliseconds,"aw",%nobits
 13175              		.align	2
 13176              		.set	.LANCHOR111,. + 0
 13179              	CountMilliseconds:
 13180 0000 00000000 		.space	4
 13181              		.section	.bss.receiverXmitFactor,"aw",%nobits
 13182              		.align	2
 13183              		.set	.LANCHOR61,. + 0
 13186              	receiverXmitFactor:
 13187 0000 00000000 		.space	4
 13188              		.section	.bss.receiverData,"aw",%nobits
 13189              		.align	2
 13190              		.set	.LANCHOR60,. + 0
 13193              	receiverData:
 13194 0000 00000000 		.space	32
 13194      00000000 
 13194      00000000 
 13194      00000000 
 13194      00000000 
 13195              		.section	.bss.MS5611_sens,"aw",%nobits
 13196              		.align	3
 13197              		.set	.LANCHOR87,. + 0
 13200              	MS5611_sens:
 13201 0000 00000000 		.space	8
 13201      00000000 
 13202              		.section	.bss.motorArmed,"aw",%nobits
 13203              		.set	.LANCHOR116,. + 0
 13206              	motorArmed:
 13207 0000 00       		.space	1
 13208              		.section	.bss.windupGuard,"aw",%nobits
 13209              		.align	2
 13210              		.set	.LANCHOR142,. + 0
 13213              	windupGuard:
 13214 0000 00000000 		.space	4
 13215              		.section	.data.baroSmoothFactor,"aw",%progbits
 13216              		.align	2
 13217              		.set	.LANCHOR97,. + 0
 13220              	baroSmoothFactor:
 13221 0000 0AD7A33C 		.word	1017370378
 13222              		.section	.bss._ZL26hottV4TelemetryBufferIndex,"aw",%nobits
 13223              		.set	.LANCHOR4,. + 0
 13226              	_ZL26hottV4TelemetryBufferIndex:
 13227 0000 00       		.space	1
 13228              		.section	.bss.pressureCount,"aw",%nobits
 13229              		.set	.LANCHOR92,. + 0
 13232              	pressureCount:
 13233 0000 00       		.space	1
 13234              		.section	.bss._ZZL11HoTTWarningvE10old_status,"aw",%nobits
 13235              		.set	.LANCHOR113,. + 0
 13238              	_ZZL11HoTTWarningvE10old_status:
 13239 0000 00       		.space	1
 13240              		.section	.bss.gyroHeading,"aw",%nobits
 13241              		.align	2
 13242              		.set	.LANCHOR28,. + 0
 13245              	gyroHeading:
 13246 0000 00000000 		.space	4
 13247              		.section	.bss.rawPressure,"aw",%nobits
 13248              		.align	2
 13251              	rawPressure:
 13252 0000 00000000 		.space	4
 13253              		.section	.bss.filteredAccel,"aw",%nobits
 13254              		.align	2
 13255              		.set	.LANCHOR151,. + 0
 13258              	filteredAccel:
 13259 0000 00000000 		.space	12
 13259      00000000 
 13259      00000000 
 13260              		.section	.data.altitudeHoldPanicStickMovement,"aw",%progbits
 13261              		.align	2
 13262              		.set	.LANCHOR126,. + 0
 13265              	altitudeHoldPanicStickMovement:
 13266 0000 FA000000 		.word	250
 13267              		.section	.bss.receiverSmoothFactor,"aw",%nobits
 13268              		.align	2
 13269              		.set	.LANCHOR14,. + 0
 13272              	receiverSmoothFactor:
 13273 0000 00000000 		.space	32
 13273      00000000 
 13273      00000000 
 13273      00000000 
 13273      00000000 
 13274              		.section	.bss.FrqData,"aw",%nobits
 13275              		.align	2
 13276              		.set	.LANCHOR0,. + 0
 13279              	FrqData:
 13280 0000 00000000 		.space	24
 13280      00000000 
 13280      00000000 
 13280      00000000 
 13280      00000000 
 13281              		.section	.bss.minLimit,"aw",%nobits
 13284              	minLimit:
 13285 0000 00       		.space	1
 13286              		.section	.bss.measuredMag,"aw",%nobits
 13287              		.align	2
 13288              		.set	.LANCHOR69,. + 0
 13291              	measuredMag:
 13292 0000 00000000 		.space	12
 13292      00000000 
 13292      00000000 
 13293              		.section	.bss.readMPU6000Count,"aw",%nobits
 13294              		.align	2
 13295              		.set	.LANCHOR24,. + 0
 13298              	readMPU6000Count:
 13299 0000 00000000 		.space	4
 13300              		.section	.bss.rawMag,"aw",%nobits
 13301              		.align	2
 13302              		.set	.LANCHOR68,. + 0
 13305              	rawMag:
 13306 0000 00000000 		.space	12
 13306      00000000 
 13306      00000000 
 13307              		.section	.bss.tenHZpreviousTime,"aw",%nobits
 13308              		.align	2
 13309              		.set	.LANCHOR157,. + 0
 13312              	tenHZpreviousTime:
 13313 0000 00000000 		.space	4
 13314              		.section	.bss.heading,"aw",%nobits
 13315              		.align	2
 13316              		.set	.LANCHOR136,. + 0
 13319              	heading:
 13320 0000 00000000 		.space	4
 13321              		.section	.rodata.Serial,"a",%progbits
 13322              		.align	2
 13325              	Serial:
 13326 0000 00000000 		.word	SerialUSB
 13327              		.section	.bss.accelCutoff,"aw",%nobits
 13328              		.align	2
 13331              	accelCutoff:
 13332 0000 00000000 		.space	4
 13333              		.section	.bss.currentTime,"aw",%nobits
 13334              		.align	2
 13335              		.set	.LANCHOR15,. + 0
 13338              	currentTime:
 13339 0000 00000000 		.space	4
 13340              		.section	.data.batteryMonitorAlarmVoltage,"aw",%progbits
 13341              		.align	2
 13342              		.set	.LANCHOR144,. + 0
 13345              	batteryMonitorAlarmVoltage:
 13346 0000 00002041 		.word	1092616192
 13347              		.section	.bss.previousMeasureCriticalSensorsTime,"aw",%nobits
 13348              		.align	2
 13349              		.set	.LANCHOR40,. + 0
 13352              	previousMeasureCriticalSensorsTime:
 13353 0000 00000000 		.space	4
 13354              		.section	.data.queryType,"aw",%progbits
 13355              		.set	.LANCHOR148,. + 0
 13358              	queryType:
 13359 0000 58       		.byte	88
 13360              		.section	.bss.motorMinCommand,"aw",%nobits
 13361              		.align	2
 13362              		.set	.LANCHOR133,. + 0
 13365              	motorMinCommand:
 13366 0000 00000000 		.space	16
 13366      00000000 
 13366      00000000 
 13366      00000000 
 13367              		.section	.bss.baroGroundAltitude,"aw",%nobits
 13368              		.align	2
 13369              		.set	.LANCHOR81,. + 0
 13372              	baroGroundAltitude:
 13373 0000 00000000 		.space	4
 13374              		.section	.bss.motorAxisCommandPitch,"aw",%nobits
 13375              		.align	2
 13376              		.set	.LANCHOR107,. + 0
 13379              	motorAxisCommandPitch:
 13380 0000 00000000 		.space	4
 13381              		.section	.bss.motorCommand,"aw",%nobits
 13382              		.align	2
 13383              		.set	.LANCHOR63,. + 0
 13386              	motorCommand:
 13387 0000 00000000 		.space	32
 13387      00000000 
 13387      00000000 
 13387      00000000 
 13387      00000000 
 13388              		.section	.data.altitudeHoldBump,"aw",%progbits
 13389              		.align	2
 13390              		.set	.LANCHOR8,. + 0
 13393              	altitudeHoldBump:
 13394 0000 5A000000 		.word	90
 13395              		.section	.bss.lowPriorityTenHZpreviousTime2,"aw",%nobits
 13396              		.align	2
 13397              		.set	.LANCHOR159,. + 0
 13400              	lowPriorityTenHZpreviousTime2:
 13401 0000 00000000 		.space	4
 13402              		.section	.data.MS5611_first_read,"aw",%progbits
 13403              		.set	.LANCHOR96,. + 0
 13406              	MS5611_first_read:
 13407 0000 01       		.byte	1
 13408              		.section	.bss.headingHoldConfig,"aw",%nobits
 13409              		.set	.LANCHOR135,. + 0
 13412              	headingHoldConfig:
 13413 0000 00       		.space	1
 13414              		.section	.bss.ezInt,"aw",%nobits
 13415              		.align	2
 13416              		.set	.LANCHOR54,. + 0
 13419              	ezInt:
 13420 0000 00000000 		.space	4
 13421              		.section	.data.numberOfMotors,"aw",%progbits
 13424              	numberOfMotors:
 13425 0000 04       		.byte	4
 13426              		.section	.data.rotationSpeedFactor,"aw",%progbits
 13427              		.align	2
 13428              		.set	.LANCHOR127,. + 0
 13431              	rotationSpeedFactor:
 13432 0000 0000803F 		.word	1065353216
 13433              		.section	.bss.headingHoldState,"aw",%nobits
 13434              		.set	.LANCHOR140,. + 0
 13437              	headingHoldState:
 13438 0000 00       		.space	1
 13439              		.section	.bss.MotorInfo,"aw",%nobits
 13440              		.align	2
 13441              		.set	.LANCHOR62,. + 0
 13444              	MotorInfo:
 13445 0000 00000000 		.space	96
 13445      00000000 
 13445      00000000 
 13445      00000000 
 13445      00000000 
 13446              		.section	.rodata._ZL19stm32_motor_mapping,"a",%progbits
 13447              		.set	.LANCHOR65,. + 0
 13450              	_ZL19stm32_motor_mapping:
 13451 0000 29       		.byte	41
 13452 0001 28       		.byte	40
 13453 0002 27       		.byte	39
 13454 0003 26       		.byte	38
 13455 0004 0F       		.byte	15
 13456 0005 13       		.byte	19
 13457 0006 14       		.byte	20
 13458 0007 15       		.byte	21
 13459              		.section	.bss.numberOfBatteries,"aw",%nobits
 13460              		.set	.LANCHOR102,. + 0
 13463              	numberOfBatteries:
 13464 0000 00       		.space	1
 13465              		.section	.bss.rawPressureSumCount,"aw",%nobits
 13466              		.set	.LANCHOR91,. + 0
 13469              	rawPressureSumCount:
 13470 0000 00       		.space	1
 13471              		.section	.bss.accelSampleCount,"aw",%nobits
 13472              		.set	.LANCHOR38,. + 0
 13475              	accelSampleCount:
 13476 0000 00       		.space	1
 13477              		.section	.bss.trueNorthHeading,"aw",%nobits
 13478              		.align	2
 13479              		.set	.LANCHOR74,. + 0
 13482              	trueNorthHeading:
 13483 0000 00000000 		.space	4
 13484              		.section	.bss.eyInt,"aw",%nobits
 13485              		.align	2
 13486              		.set	.LANCHOR52,. + 0
 13489              	eyInt:
 13490 0000 00000000 		.space	4
 13491              		.section	.bss.previousEx,"aw",%nobits
 13492              		.align	2
 13493              		.set	.LANCHOR51,. + 0
 13496              	previousEx:
 13497 0000 00000000 		.space	4
 13498              		.section	.bss.previousEy,"aw",%nobits
 13499              		.align	2
 13500              		.set	.LANCHOR53,. + 0
 13503              	previousEy:
 13504 0000 00000000 		.space	4
 13505              		.section	.bss.previousEz,"aw",%nobits
 13506              		.align	2
 13507              		.set	.LANCHOR55,. + 0
 13510              	previousEz:
 13511 0000 00000000 		.space	4
 13512              		.section	.data.pressureFactor,"aw",%progbits
 13513              		.align	2
 13514              		.set	.LANCHOR94,. + 0
 13517              	pressureFactor:
 13518 0000 AEDC423E 		.word	1044569262
 13519              		.section	.data._ZL11minAltitude,"aw",%progbits
 13520              		.align	2
 13521              		.set	.LANCHOR83,. + 0
 13524              	_ZL11minAltitude:
 13525 0000 F4010000 		.word	500
 13526              		.section	.bss.readMPU6000GyroCount,"aw",%nobits
 13527              		.align	2
 13528              		.set	.LANCHOR25,. + 0
 13531              	readMPU6000GyroCount:
 13532 0000 00000000 		.space	4
 13533              		.section	.bss.isReadPressure,"aw",%nobits
 13534              		.set	.LANCHOR89,. + 0
 13537              	isReadPressure:
 13538 0000 00       		.space	1
 13539              		.section	.bss.fastTransfer,"aw",%nobits
 13540              		.set	.LANCHOR150,. + 0
 13543              	fastTransfer:
 13544 0000 00       		.space	1
 13545              		.section	.bss._ZZL22hottv4UpdateFlightTimePhE17previousEAMUpdate,"aw",%nobits
 13546              		.align	2
 13547              		.set	.LANCHOR115,. + 0
 13550              	_ZZL22hottv4UpdateFlightTimePhE17previousEAMUpdate:
 13551 0000 00000000 		.space	4
 13552              		.section	.bss.filter2,"aw",%nobits
 13553              		.align	2
 13554              		.set	.LANCHOR73,. + 0
 13557              	filter2:
 13558 0000 00000000 		.space	4
 13559              		.section	.bss.minArmedThrottle,"aw",%nobits
 13560              		.align	2
 13561              		.set	.LANCHOR132,. + 0
 13564              	minArmedThrottle:
 13565 0000 00000000 		.space	4
 13566              		.section	.data.batteryWarningCellVoltage,"aw",%progbits
 13567              		.align	1
 13568              		.set	.LANCHOR101,. + 0
 13571              	batteryWarningCellVoltage:
 13572 0000 6E01     		.short	366
 13573              		.section	.bss.isStoreAltitudeNeeded,"aw",%nobits
 13574              		.set	.LANCHOR147,. + 0
 13577              	isStoreAltitudeNeeded:
 13578 0000 00       		.space	1
 13579              		.section	.bss.deltaTime,"aw",%nobits
 13580              		.align	2
 13581              		.set	.LANCHOR154,. + 0
 13584              	deltaTime:
 13585 0000 00000000 		.space	4
 13586              		.section	.bss.flashingLedState,"aw",%nobits
 13587              		.set	.LANCHOR152,. + 0
 13590              	flashingLedState:
 13591 0000 00       		.space	1
 13592              		.section	.bss.setHeading,"aw",%nobits
 13593              		.align	2
 13594              		.set	.LANCHOR137,. + 0
 13597              	setHeading:
 13598 0000 00000000 		.space	4
 13599              		.section	.bss.inFlight,"aw",%nobits
 13600              		.set	.LANCHOR16,. + 0
 13603              	inFlight:
 13604 0000 00       		.space	1
 13605              		.section	.bss.motorConfiguratorCommand,"aw",%nobits
 13606              		.align	2
 13607              		.set	.LANCHOR130,. + 0
 13610              	motorConfiguratorCommand:
 13611 0000 00000000 		.space	16
 13611      00000000 
 13611      00000000 
 13611      00000000 
 13612              		.section	.bss.hdgX,"aw",%nobits
 13613              		.align	2
 13614              		.set	.LANCHOR66,. + 0
 13617              	hdgX:
 13618 0000 00000000 		.space	4
 13619              		.section	.bss.hdgY,"aw",%nobits
 13620              		.align	2
 13621              		.set	.LANCHOR67,. + 0
 13624              	hdgY:
 13625 0000 00000000 		.space	4
 13626              		.section	.bss.measuredMagX,"aw",%nobits
 13627              		.align	2
 13628              		.set	.LANCHOR77,. + 0
 13631              	measuredMagX:
 13632 0000 00000000 		.space	4
 13633              		.section	.bss.measuredMagY,"aw",%nobits
 13634              		.align	2
 13635              		.set	.LANCHOR78,. + 0
 13638              	measuredMagY:
 13639 0000 00000000 		.space	4
 13640              		.section	.bss.measuredMagZ,"aw",%nobits
 13641              		.align	2
 13642              		.set	.LANCHOR79,. + 0
 13645              	measuredMagZ:
 13646 0000 00000000 		.space	4
 13647              		.section	.bss.magBias,"aw",%nobits
 13648              		.align	2
 13649              		.set	.LANCHOR76,. + 0
 13652              	magBias:
 13653 0000 00000000 		.space	12
 13653      00000000 
 13653      00000000 
 13654              		.section	.data.testCommand,"aw",%progbits
 13655              		.align	2
 13656              		.set	.LANCHOR129,. + 0
 13659              	testCommand:
 13660 0000 E8030000 		.word	1000
 13661              		.section	.bss.MS5611lastRawPressure,"aw",%nobits
 13662              		.align	2
 13663              		.set	.LANCHOR88,. + 0
 13666              	MS5611lastRawPressure:
 13667 0000 00000000 		.space	4
 13668              		.section	.data.magScale,"aw",%progbits
 13669              		.align	2
 13670              		.set	.LANCHOR75,. + 0
 13673              	magScale:
 13674 0000 0000803F 		.word	1065353216
 13675 0004 0000803F 		.word	1065353216
 13676 0008 0000803F 		.word	1065353216
 13677              		.section	.bss.q0,"aw",%nobits
 13678              		.align	2
 13679              		.set	.LANCHOR47,. + 0
 13682              	q0:
 13683 0000 00000000 		.space	4
 13684              		.section	.bss.q1,"aw",%nobits
 13685              		.align	2
 13686              		.set	.LANCHOR45,. + 0
 13689              	q1:
 13690 0000 00000000 		.space	4
 13691              		.section	.bss.q2,"aw",%nobits
 13692              		.align	2
 13693              		.set	.LANCHOR48,. + 0
 13696              	q2:
 13697 0000 00000000 		.space	4
 13698              		.section	.bss.q3,"aw",%nobits
 13699              		.align	2
 13700              		.set	.LANCHOR46,. + 0
 13703              	q3:
 13704 0000 00000000 		.space	4
 13705              		.section	.bss.MS5611_offset,"aw",%nobits
 13706              		.align	3
 13707              		.set	.LANCHOR86,. + 0
 13710              	MS5611_offset:
 13711 0000 00000000 		.space	8
 13711      00000000 
 13712              		.section	.bss.accelSample,"aw",%nobits
 13713              		.align	2
 13714              		.set	.LANCHOR37,. + 0
 13717              	accelSample:
 13718 0000 00000000 		.space	12
 13718      00000000 
 13718      00000000 
 13719              		.section	.bss.aref,"aw",%nobits
 13720              		.align	2
 13721              		.set	.LANCHOR143,. + 0
 13724              	aref:
 13725 0000 00000000 		.space	4
 13726              		.section	.bss.receiverCommand,"aw",%nobits
 13727              		.align	2
 13728              		.set	.LANCHOR6,. + 0
 13731              	receiverCommand:
 13732 0000 00000000 		.space	32
 13732      00000000 
 13732      00000000 
 13732      00000000 
 13732      00000000 
 13733              		.section	.bss.currentChannel,"aw",%nobits
 13734              		.set	.LANCHOR1,. + 0
 13737              	currentChannel:
 13738 0000 00       		.space	1
 13739              		.section	.bss.accelScaleFactor,"aw",%nobits
 13740              		.align	2
 13741              		.set	.LANCHOR35,. + 0
 13744              	accelScaleFactor:
 13745 0000 00000000 		.space	12
 13745      00000000 
 13745      00000000 
 13746              		.section	.data.minThrottleAdjust,"aw",%progbits
 13747              		.align	2
 13748              		.set	.LANCHOR124,. + 0
 13751              	minThrottleAdjust:
 13752 0000 CEFFFFFF 		.word	-50
 13753              		.section	.bss.halfT,"aw",%nobits
 13754              		.align	2
 13755              		.set	.LANCHOR44,. + 0
 13758              	halfT:
 13759 0000 00000000 		.space	4
 13760              		.section	.bss.headingHold,"aw",%nobits
 13761              		.align	2
 13762              		.set	.LANCHOR139,. + 0
 13765              	headingHold:
 13766 0000 00000000 		.space	4
 13767              		.section	.bss.compassDeclination,"aw",%nobits
 13768              		.align	2
 13771              	compassDeclination:
 13772 0000 00000000 		.space	4
 13773              		.section	.bss.correctedRateVector,"aw",%nobits
 13774              		.align	2
 13775              		.set	.LANCHOR58,. + 0
 13778              	correctedRateVector:
 13779 0000 00000000 		.space	12
 13779      00000000 
 13779      00000000 
 13780              		.section	.bss._ZL12milliseconds,"aw",%nobits
 13781              		.align	1
 13782              		.set	.LANCHOR117,. + 0
 13785              	_ZL12milliseconds:
 13786 0000 0000     		.space	2
 13787              		.section	.bss.fiftyHZpreviousTime,"aw",%nobits
 13788              		.align	2
 13789              		.set	.LANCHOR156,. + 0
 13792              	fiftyHZpreviousTime:
 13793 0000 00000000 		.space	4
 13794              		.section	.bss.frameCounter,"aw",%nobits
 13795              		.align	2
 13796              		.set	.LANCHOR41,. + 0
 13799              	frameCounter:
 13800 0000 00000000 		.space	4
 13801              		.section	.bss.Ki,"aw",%nobits
 13802              		.align	2
 13803              		.set	.LANCHOR50,. + 0
 13806              	Ki:
 13807 0000 00000000 		.space	4
 13808              		.section	.bss.receiverCommandSmooth,"aw",%nobits
 13809              		.align	2
 13810              		.set	.LANCHOR10,. + 0
 13813              	receiverCommandSmooth:
 13814 0000 00000000 		.space	32
 13814      00000000 
 13814      00000000 
 13814      00000000 
 13814      00000000 
 13815              		.section	.bss._ZL21hottV4TelemetryBuffer,"aw",%nobits
 13816              		.set	.LANCHOR3,. + 0
 13819              	_ZL21hottV4TelemetryBuffer:
 13820 0000 00000000 		.space	45
 13820      00000000 
 13820      00000000 
 13820      00000000 
 13820      00000000 
 13821              		.section	.bss.oneHZpreviousTime,"aw",%nobits
 13822              		.align	2
 13825              	oneHZpreviousTime:
 13826 0000 00000000 		.space	4
 13827              		.section	.bss.Kp,"aw",%nobits
 13828              		.align	2
 13829              		.set	.LANCHOR56,. + 0
 13832              	Kp:
 13833 0000 00000000 		.space	4
 13834              		.section	.bss.baroAltitudeToHoldTarget,"aw",%nobits
 13835              		.align	2
 13836              		.set	.LANCHOR123,. + 0
 13839              	baroAltitudeToHoldTarget:
 13840 0000 00000000 		.space	4
 13841              		.section	.bss.readMPU6000AccelCount,"aw",%nobits
 13842              		.align	2
 13843              		.set	.LANCHOR23,. + 0
 13846              	readMPU6000AccelCount:
 13847 0000 00000000 		.space	4
 13848              		.section	.bss.headingTime,"aw",%nobits
 13849              		.align	2
 13850              		.set	.LANCHOR141,. + 0
 13853              	headingTime:
 13854 0000 00000000 		.space	4
 13855              		.section	.rodata.str1.1,"aMS",%progbits,1
 13856              	.LC1:
 13857 0000 696E6974 		.ascii	"initializeMPU6000Sensors\000"
 13857      69616C69 
 13857      7A654D50 
 13857      55363030 
 13857      3053656E 
 13858              	.LC2:
 13859 0019 4D505536 		.ascii	"MPU6000 found\000"
 13859      30303020 
 13859      666F756E 
 13859      6400
 13860              	.LC3:
 13861 0027 4D505536 		.ascii	"MPU6000 not found\000"
 13861      30303020 
 13861      6E6F7420 
 13861      666F756E 
 13861      6400
 13862              	.LC4:
 13863 0039 0D0A4165 		.ascii	"\015\012AeroQuad STM32, board type aeroquad32, buil"
 13863      726F5175 
 13863      61642053 
 13863      544D3332 
 13863      2C20626F 
 13864 0066 64206461 		.ascii	"d date Aug 13 2012 00:08:27\000"
 13864      74652041 
 13864      75672031 
 13864      33203230 
 13864      31322030 
 13865              	.LC5:
 13866 0082 53544D33 		.ascii	"STM32 init done\015\012\000"
 13866      3220696E 
 13866      69742064 
 13866      6F6E650D 
 13866      0A00
 13867              	.LC6:
 13868 0094 4165726F 		.ascii	"AeroQuad (Attitude)\000"
 13868      51756164 
 13868      20284174 
 13868      74697475 
 13868      64652900 
 13869              	.LC7:
 13870 00a8 4165726F 		.ascii	"AeroQuad (Rate)\000"
 13870      51756164 
 13870      20285261 
 13870      74652900 
 13871              	.LC8:
 13872 00b8 3A2000   		.ascii	": \000"
 13873              	.LC9:
 13874 00bb 4E6F7420 		.ascii	"Not \000"
 13874      00
 13875              	.LC10:
 13876 00c0 536F6674 		.ascii	"Software Version: \000"
 13876      77617265 
 13876      20566572 
 13876      73696F6E 
 13876      3A2000
 13877              	.LC11:
 13878 00d3 426F6172 		.ascii	"Board Type: \000"
 13878      64205479 
 13878      70653A20 
 13878      00
 13879              	.LC12:
 13880 00e0 53544D33 		.ascii	"STM32\000"
 13880      3200
 13881              	.LC13:
 13882 00e6 466C6967 		.ascii	"Flight Config: \000"
 13882      68742043 
 13882      6F6E6669 
 13882      673A2000 
 13883              	.LC14:
 13884 00f6 51756164 		.ascii	"Quad X\000"
 13884      205800
 13885              	.LC15:
 13886 00fd 52656365 		.ascii	"Receiver Channels: \000"
 13886      69766572 
 13886      20436861 
 13886      6E6E656C 
 13886      733A2000 
 13887              	.LC16:
 13888 0111 4D6F746F 		.ascii	"Motors: \000"
 13888      72733A20 
 13888      00
 13889              	.LC17:
 13890 011a 4779726F 		.ascii	"Gyroscope\000"
 13890      73636F70 
 13890      6500
 13891              	.LC18:
 13892 0124 44657465 		.ascii	"Detected\000"
 13892      63746564 
 13892      00
 13893              	.LC19:
 13894 012d 41636365 		.ascii	"Accelerometer\000"
 13894      6C65726F 
 13894      6D657465 
 13894      7200
 13895              	.LC20:
 13896 013b 4261726F 		.ascii	"Barometer\000"
 13896      6D657465 
 13896      7200
 13897              	.LC21:
 13898 0145 4D61676E 		.ascii	"Magnetometer\000"
 13898      65746F6D 
 13898      65746572 
 13898      00
 13899              	.LC22:
 13900 0152 48656164 		.ascii	"Heading Hold\000"
 13900      696E6720 
 13900      486F6C64 
 13900      00
 13901              	.LC23:
 13902 015f 456E6162 		.ascii	"Enabled\000"
 13902      6C656400 
 13903              	.LC24:
 13904 0167 416C7469 		.ascii	"Altitude Hold\000"
 13904      74756465 
 13904      20486F6C 
 13904      6400
 13905              	.LC25:
 13906 0175 42617474 		.ascii	"Battery Monitor\000"
 13906      65727920 
 13906      4D6F6E69 
 13906      746F7200 
 13907              	.LC26:
 13908 0185 43616D65 		.ascii	"Camera Stability\000"
 13908      72612053 
 13908      74616269 
 13908      6C697479 
 13908      00
 13909              	.LC27:
 13910 0196 52616E67 		.ascii	"Range Detection\000"
 13910      65204465 
 13910      74656374 
 13910      696F6E00 
 13911              		.section	.bss.initializeMPU6000SensorsDone,"aw",%nobits
 13912              		.set	.LANCHOR20,. + 0
 13915              	initializeMPU6000SensorsDone:
 13916 0000 00       		.space	1
 13917              		.section	.bss.pressure,"aw",%nobits
 13918              		.align	2
 13919              		.set	.LANCHOR93,. + 0
 13922              	pressure:
 13923 0000 00000000 		.space	4
 13924              		.section	.bss.baroAltitude,"aw",%nobits
 13925              		.align	2
 13926              		.set	.LANCHOR80,. + 0
 13929              	baroAltitude:
 13930 0000 00000000 		.space	4
 13931              		.section	.bss.gyroRate,"aw",%nobits
 13932              		.align	2
 13933              		.set	.LANCHOR27,. + 0
 13936              	gyroRate:
 13937 0000 00000000 		.space	12
 13937      00000000 
 13937      00000000 
 13938              		.section	.bss.MS5611lastRawTemperature,"aw",%nobits
 13939              		.align	2
 13940              		.set	.LANCHOR85,. + 0
 13943              	MS5611lastRawTemperature:
 13944 0000 00000000 		.space	4
 13945              		.section	.bss.batteryMonitorStartThrottle,"aw",%nobits
 13946              		.align	2
 13949              	batteryMonitorStartThrottle:
 13950 0000 00000000 		.space	4
 13951              		.section	.bss.kinematicsAngle,"aw",%nobits
 13952              		.align	2
 13953              		.set	.LANCHOR42,. + 0
 13956              	kinematicsAngle:
 13957 0000 00000000 		.space	12
 13957      00000000 
 13957      00000000 
 13958              		.section	.data.maxThrottleAdjust,"aw",%progbits
 13959              		.align	2
 13960              		.set	.LANCHOR125,. + 0
 13963              	maxThrottleAdjust:
 13964 0000 32000000 		.word	50
 13965              		.section	.data.rawChannelValue,"aw",%progbits
 13966              		.align	1
 13967              		.set	.LANCHOR2,. + 0
 13970              	rawChannelValue:
 13971 0000 DC05     		.short	1500
 13972 0002 DC05     		.short	1500
 13973 0004 DC05     		.short	1500
 13974 0006 DC05     		.short	1500
 13975 0008 DC05     		.short	1500
 13976 000a DC05     		.short	1500
 13977 000c DC05     		.short	1500
 13978 000e DC05     		.short	1500
 13979              		.section	.bss.baroRawAltitude,"aw",%nobits
 13980              		.align	2
 13981              		.set	.LANCHOR95,. + 0
 13984              	baroRawAltitude:
 13985 0000 00000000 		.space	4
 13986              		.section	.bss.baroGroundUpdateDone,"aw",%nobits
 13987              		.set	.LANCHOR98,. + 0
 13990              	baroGroundUpdateDone:
 13991 0000 00       		.space	1
 13992              		.section	.bss.batteryMonitorStartTime,"aw",%nobits
 13993              		.align	2
 13996              	batteryMonitorStartTime:
 13997 0000 00000000 		.space	4
 13998              		.section	.bss.headingGyroZero,"aw",%nobits
 13999              		.align	2
 14000              		.set	.LANCHOR70,. + 0
 14003              	headingGyroZero:
 14004 0000 00000000 		.space	4
 14005              		.section	.bss.calibrateESC,"aw",%nobits
 14006              		.set	.LANCHOR128,. + 0
 14009              	calibrateESC:
 14010 0000 00       		.space	1
 14011              		.section	.bss.hottState,"aw",%nobits
 14012              		.set	.LANCHOR121,. + 0
 14015              	hottState:
 14016 0000 00       		.space	1
 14017              		.section	.bss.spiMPU6000,"aw",%nobits
 14018              		.align	2
 14019              		.set	.LANCHOR19,. + 0
 14022              	spiMPU6000:
 14023 0000 00000000 		.space	12
 14023      00000000 
 14023      00000000 
 14024              		.section	.bss.fourthOrder,"aw",%nobits
 14025              		.align	2
 14026              		.set	.LANCHOR18,. + 0
 14029              	fourthOrder:
 14030 0000 00000000 		.space	128
 14030      00000000 
 14030      00000000 
 14030      00000000 
 14030      00000000 
 14031              		.section	.data.throttle,"aw",%progbits
 14032              		.align	2
 14033              		.set	.LANCHOR106,. + 0
 14036              	throttle:
 14037 0000 E8030000 		.word	1000
 14038              		.section	.bss.gyroRaw,"aw",%nobits
 14039              		.align	2
 14040              		.set	.LANCHOR30,. + 0
 14043              	gyroRaw:
 14044 0000 00000000 		.space	12
 14044      00000000 
 14044      00000000 
 14045              		.section	.bss.rawTemperature,"aw",%nobits
 14046              		.align	2
 14049              	rawTemperature:
 14050 0000 00000000 		.space	4
 14051              		.section	.data.batteryData,"aw",%progbits
 14052              		.align	2
 14053              		.set	.LANCHOR103,. + 0
 14056              	batteryData:
 14057 0000 20       		.byte	32
 14058 0001 00       		.byte	0
 14059 0002 E209     		.short	2530
 14060 0004 0000     		.short	0
 14061 0006 0000     		.short	0
 14062 0008 0000     		.short	0
 14063 000a FF       		.byte	-1
 14064 000b 00       		.space	1
 14065 000c 0000     		.short	0
 14066 000e 0000     		.short	0
 14067 0010 0000     		.short	0
 14068 0012 0000     		.short	0
 14069 0014 00000000 		.word	0
 14070              		.section	.bss.exInt,"aw",%nobits
 14071              		.align	2
 14072              		.set	.LANCHOR49,. + 0
 14075              	exInt:
 14076 0000 00000000 		.space	4
 14077              		.section	.bss.altitudeHoldState,"aw",%nobits
 14078              		.set	.LANCHOR5,. + 0
 14081              	altitudeHoldState:
 14082 0000 00       		.space	1
 14083              		.section	.bss.gyroZero,"aw",%nobits
 14084              		.align	2
 14085              		.set	.LANCHOR31,. + 0
 14088              	gyroZero:
 14089 0000 00000000 		.space	12
 14089      00000000 
 14089      00000000 
 14090              		.section	.bss.accelOneG,"aw",%nobits
 14091              		.align	2
 14092              		.set	.LANCHOR39,. + 0
 14095              	accelOneG:
 14096 0000 00000000 		.space	4
 14097              		.section	.bss.earthAccel,"aw",%nobits
 14098              		.align	2
 14101              	earthAccel:
 14102 0000 00000000 		.space	12
 14102      00000000 
 14102      00000000 
 14103              		.section	.bss.batteryAlarm,"aw",%nobits
 14104              		.set	.LANCHOR104,. + 0
 14107              	batteryAlarm:
 14108 0000 00       		.space	1
 14109              		.section	.bss.batteryWarning,"aw",%nobits
 14110              		.set	.LANCHOR105,. + 0
 14113              	batteryWarning:
 14114 0000 00       		.space	1
 14115              		.section	.bss.gyroLastMesuredTime,"aw",%nobits
 14116              		.align	2
 14117              		.set	.LANCHOR29,. + 0
 14120              	gyroLastMesuredTime:
 14121 0000 00000000 		.space	4
 14122              		.section	.bss.gyroSampleCount,"aw",%nobits
 14123              		.set	.LANCHOR33,. + 0
 14126              	gyroSampleCount:
 14127 0000 00       		.space	1
 14128              		.section	.bss.lastReceiverChannel,"aw",%nobits
 14129              		.align	2
 14130              		.set	.LANCHOR9,. + 0
 14133              	lastReceiverChannel:
 14134 0000 00000000 		.space	4
 14135              		.section	.bss.MS5611Prom,"aw",%nobits
 14136              		.align	1
 14137              		.set	.LANCHOR84,. + 0
 14140              	MS5611Prom:
 14141 0000 00000000 		.space	16
 14141      00000000 
 14141      00000000 
 14141      00000000 
 14142              		.section	.bss.hottV4Serial,"aw",%nobits
 14143              		.align	2
 14144              		.set	.LANCHOR110,. + 0
 14147              	hottV4Serial:
 14148 0000 00000000 		.space	4
 14149              		.section	.data.batteryAlarmCellVoltage,"aw",%progbits
 14150              		.align	1
 14151              		.set	.LANCHOR100,. + 0
 14154              	batteryAlarmCellVoltage:
 14155 0000 4D01     		.short	333
 14156              		.section	.bss.motorMaxCommand,"aw",%nobits
 14157              		.align	2
 14158              		.set	.LANCHOR134,. + 0
 14161              	motorMaxCommand:
 14162 0000 00000000 		.space	16
 14162      00000000 
 14162      00000000 
 14162      00000000 
 14163              		.section	.bss.receiverZero,"aw",%nobits
 14164              		.align	2
 14165              		.set	.LANCHOR11,. + 0
 14168              	receiverZero:
 14169 0000 00000000 		.space	12
 14169      00000000 
 14169      00000000 
 14170              		.section	.bss.motorAxisCommandYaw,"aw",%nobits
 14171              		.align	2
 14172              		.set	.LANCHOR109,. + 0
 14175              	motorAxisCommandYaw:
 14176 0000 00000000 		.space	4
 14177              		.section	.bss._ZL7minutes,"aw",%nobits
 14178              		.set	.LANCHOR118,. + 0
 14181              	_ZL7minutes:
 14182 0000 00       		.space	1
 14183              		.section	.bss.lowPriorityTenHZpreviousTime,"aw",%nobits
 14184              		.align	2
 14185              		.set	.LANCHOR158,. + 0
 14188              	lowPriorityTenHZpreviousTime:
 14189 0000 00000000 		.space	4
 14190              		.section	.data.batteryMonitorThrottleTarget,"aw",%progbits
 14191              		.align	2
 14192              		.set	.LANCHOR145,. + 0
 14195              	batteryMonitorThrottleTarget:
 14196 0000 AA050000 		.word	1450
 14197              		.section	.data.SpeakHoTT,"aw",%progbits
 14198              		.set	.LANCHOR112,. + 0
 14201              	SpeakHoTT:
 14202 0000 15       		.byte	21
 14203              		.section	.bss.hottTime,"aw",%nobits
 14204              		.align	2
 14205              		.set	.LANCHOR122,. + 0
 14208              	hottTime:
 14209 0000 00000000 		.space	4
 14210              		.section	.bss.relativeHeading,"aw",%nobits
 14211              		.align	2
 14212              		.set	.LANCHOR138,. + 0
 14215              	relativeHeading:
 14216 0000 00000000 		.space	4
 14217              		.section	.bss.gyroAngle,"aw",%nobits
 14218              		.align	2
 14219              		.set	.LANCHOR43,. + 0
 14222              	gyroAngle:
 14223 0000 00000000 		.space	8
 14223      00000000 
 14224              		.section	.bss.localHeading,"aw",%nobits
 14225              		.align	2
 14226              		.set	.LANCHOR71,. + 0
 14229              	localHeading:
 14230 0000 00000000 		.space	4
 14231              		.section	.bss.receiverOffset,"aw",%nobits
 14232              		.align	2
 14233              		.set	.LANCHOR13,. + 0
 14236              	receiverOffset:
 14237 0000 00000000 		.space	32
 14237      00000000 
 14237      00000000 
 14237      00000000 
 14237      00000000 
 14238              		.section	.bss.baroStartTime,"aw",%nobits
 14239              		.align	2
 14240              		.set	.LANCHOR99,. + 0
 14243              	baroStartTime:
 14244 0000 00000000 		.space	4
 14245              		.section	.bss.kinematicsType,"aw",%nobits
 14248              	kinematicsType:
 14249 0000 00       		.space	1
 14250              		.section	.bss.PID,"aw",%nobits
 14251              		.align	2
 14252              		.set	.LANCHOR17,. + 0
 14255              	PID:
 14256 0000 00000000 		.space	280
 14256      00000000 
 14256      00000000 
 14256      00000000 
 14256      00000000 
 14257              		.section	.bss.meterPerSecSec,"aw",%nobits
 14258              		.align	2
 14259              		.set	.LANCHOR34,. + 0
 14262              	meterPerSecSec:
 14263 0000 00000000 		.space	12
 14263      00000000 
 14263      00000000 
 14264              		.section	.bss.MPU6000,"aw",%nobits
 14265              		.align	1
 14266              		.set	.LANCHOR22,. + 0
 14269              	MPU6000:
 14270 0000 00000000 		.space	14
 14270      00000000 
 14270      00000000 
 14270      0000
 14271              		.section	.data.filter1,"aw",%progbits
 14272              		.align	2
 14273              		.set	.LANCHOR72,. + 0
 14276              	filter1:
 14277 0000 317D7F3F 		.word	1065319729
 14278              		.section	.bss.receiverSlope,"aw",%nobits
 14279              		.align	2
 14280              		.set	.LANCHOR12,. + 0
 14283              	receiverSlope:
 14284 0000 00000000 		.space	32
 14284      00000000 
 14284      00000000 
 14284      00000000 
 14284      00000000 
 14285              		.section	.bss.flightMode,"aw",%nobits
 14286              		.set	.LANCHOR120,. + 0
 14289              	flightMode:
 14290 0000 00       		.space	1
 14291              		.section	.bss._ZZL11HoTTWarningvE6repeat,"aw",%nobits
 14292              		.align	2
 14293              		.set	.LANCHOR114,. + 0
 14296              	_ZZL11HoTTWarningvE6repeat:
 14297 0000 00000000 		.space	4
 14298              		.section	.bss.vehicleState,"aw",%nobits
 14299              		.align	2
 14300              		.set	.LANCHOR21,. + 0
 14303              	vehicleState:
 14304 0000 00000000 		.space	4
 14305              		.section	.bss.motorAxisCommandRoll,"aw",%nobits
 14306              		.align	2
 14307              		.set	.LANCHOR108,. + 0
 14310              	motorAxisCommandRoll:
 14311 0000 00000000 		.space	4
 14312              		.section	.data.altitudeHoldThrottle,"aw",%progbits
 14313              		.align	2
 14314              		.set	.LANCHOR7,. + 0
 14317              	altitudeHoldThrottle:
 14318 0000 E8030000 		.word	1000
 14319              		.section	.bss.safetyCheck,"aw",%nobits
 14320              		.set	.LANCHOR131,. + 0
 14323              	safetyCheck:
 14324 0000 00       		.space	1
 14325              		.section	.data.batteryMonitorGoingDownTime,"aw",%progbits
 14326              		.align	2
 14327              		.set	.LANCHOR146,. + 0
 14330              	batteryMonitorGoingDownTime:
 14331 0000 60EA0000 		.word	60000
 14332              		.section	.bss.previousTime,"aw",%nobits
 14333              		.align	2
 14334              		.set	.LANCHOR153,. + 0
 14337              	previousTime:
 14338 0000 00000000 		.space	4
 14339              		.section	.data.G_Dt,"aw",%progbits
 14340              		.align	2
 14341              		.set	.LANCHOR57,. + 0
 14344              	G_Dt:
 14345 0000 6F12033B 		.word	990057071
 14346              		.section	.bss.hundredHZpreviousTime,"aw",%nobits
 14347              		.align	2
 14348              		.set	.LANCHOR155,. + 0
 14351              	hundredHZpreviousTime:
 14352 0000 00000000 		.space	4
 14353              		.section	.bss.maxLimit,"aw",%nobits
 14356              	maxLimit:
 14357 0000 00       		.space	1
 14358              		.section	.bss.gyroScaleFactor,"aw",%nobits
 14359              		.align	2
 14360              		.set	.LANCHOR26,. + 0
 14363              	gyroScaleFactor:
 14364 0000 00000000 		.space	4
 14365              		.section	.bss.rawPressureSum,"aw",%nobits
 14366              		.align	2
 14367              		.set	.LANCHOR90,. + 0
 14370              	rawPressureSum:
 14371 0000 00000000 		.space	4
 14372              		.section	.bss.buzzerState,"aw",%nobits
 14375              	buzzerState:
 14376 0000 00       		.space	1
 14377              		.section	.bss.gyroSample,"aw",%nobits
 14378              		.align	2
 14379              		.set	.LANCHOR32,. + 0
 14382              	gyroSample:
 14383 0000 00000000 		.space	12
 14383      00000000 
 14383      00000000 
 14384              		.section	.bss._ZL19_stm32_motor_number,"aw",%nobits
 14385              		.align	2
 14386              		.set	.LANCHOR64,. + 0
 14389              	_ZL19_stm32_motor_number:
 14390 0000 00000000 		.space	4
 14391              		.section	.bss.channelCal,"aw",%nobits
 14392              		.align	2
 14393              		.set	.LANCHOR149,. + 0
 14396              	channelCal:
 14397 0000 00000000 		.space	4
 14398              		.section	.data._ZL11maxAltitude,"aw",%progbits
 14399              		.align	2
 14400              		.set	.LANCHOR82,. + 0
 14403              	_ZL11maxAltitude:
 14404 0000 F4010000 		.word	500
 14405              		.section	.rodata._ZL18ReceiverChannelMap,"a",%progbits
 14406              		.set	.LANCHOR59,. + 0
 14409              	_ZL18ReceiverChannelMap:
 14410 0000 01       		.byte	1
 14411 0001 02       		.byte	2
 14412 0002 03       		.byte	3
 14413 0003 00       		.byte	0
 14414 0004 04       		.byte	4
 14415 0005 05       		.byte	5
 14416 0006 06       		.byte	6
 14417 0007 07       		.byte	7
 14418              		.section	.bss.runTimeAccelBias,"aw",%nobits
 14419              		.align	2
 14420              		.set	.LANCHOR36,. + 0
 14423              	runTimeAccelBias:
 14424 0000 00000000 		.space	12
 14424      00000000 
 14424      00000000 
 14425              		.text
 14426              	.Letext0:
 14427              		.file 37 "c:\\program files (x86)\\codesourcery\\sourcery_codebench_lite_for_arm_eabi\\bin\\../lib
 14428              		.file 38 "../Libmaple/libmaple/libmaple/libmaple_types.h"
 14429              		.file 39 "../Libmaple/libmaple/libmaple/rccF2.h"
 14430              		.file 40 "../Libmaple/libmaple/libmaple/gpioF2.h"
 14431              		.file 41 "../Libmaple/libmaple/libmaple/adc.h"
 14432              		.file 42 "../Libmaple/libmaple/wirish/wirish_types.h"
 14433              		.file 43 "../Libmaple/libmaple/wirish/io.h"
 14434              		.file 44 "../Libmaple/libmaple/libmaple/spi.h"
 14435              		.file 45 "../Libmaple/libmaple/wirish/comm/HardwareSPI.h"
 14436              		.file 46 "../Libmaple/libmaple/wirish/wirish.h"
 14437              		.file 47 "../AeroQuad32/MapleCompatibility/WProgram.h"
 14438              		.file 48 "../AeroQuad32/MapleCompatibility/flash_stm32.h"
 14439              		.file 49 "../AeroQuad32/MapleCompatibility/EEPROM.h"
 14440              		.file 50 "../Libmaple/libmaple/libraries/Wire/Wire.h"
 14441              		.file 51 "../Libraries/AQ_Gps/GpsDataType.h"
 14442              		.file 52 "C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad/AeroQuad.h"
 14443              		.file 53 "../Libmaple/libmaple/wirish/Print.h"
 14444              		.file 54 "../Libraries/AQ_BatteryMonitor/BatteryMonitorTypes.h"
 14445              		.file 55 "../Libraries/AQ_HoTT/HoTT.h"
 14446              		.file 56 "../Libmaple/libmaple/wirish/boards.h"
 14447              		.file 57 "../Libmaple/libmaple/wirish/comm/HardwareSerial.h"
 14448              		.file 58 "../Libraries/AQ_Defines/SensorsStatus.h"
 14449              		.file 59 "../Libraries/AQ_Gyroscope/Gyroscope.h"
 14450              		.file 60 "../Libraries/AQ_Accelerometer/Accelerometer.h"
 14451              		.file 61 "../Libraries/AQ_FlightControlProcessor/FlightControlVariable.h"
DEFINED SYMBOLS
                            *ABS*:00000000 AeroQuadMain.cpp
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:20     .text.timer_set_compare:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:24     .text.timer_set_compare:00000000 timer_set_compare
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:49     .text._ZL6millisv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:53     .text._ZL6millisv:00000000 _ZL6millisv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:74     .text._ZL6millisv:00000008 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:79     .text._ZL6microsv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:83     .text._ZL6microsv:00000000 _ZL6microsv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:136    .text._ZL6microsv:0000002c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:141    .text._Z9FrqChangev:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:146    .text._Z9FrqChangev:00000000 _Z9FrqChangev
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:238    .text._Z9FrqChangev:00000060 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:245    .text._ZL16hottV4SendBinaryPh:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:249    .text._ZL16hottV4SendBinaryPh:00000000 _ZL16hottV4SendBinaryPh
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:301    .text._ZL16hottV4SendBinaryPh:00000024 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:307    .text._ZL20hottv4UpdateAltVariov:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:311    .text._ZL20hottv4UpdateAltVariov:00000000 _ZL20hottv4UpdateAltVariov
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:362    .text._ZL20hottv4UpdateAltVariov:0000003c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:370    .text.startup._Z7premainv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:375    .text.startup._Z7premainv:00000000 _Z7premainv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:390    .init_array:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:393    .text._Z23initializeReceiverParami:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:398    .text._Z23initializeReceiverParami:00000000 _Z23initializeReceiverParami
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:544    .text._Z23initializeReceiverParami:00000094 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:555    .text._Z17getReceiverSIDatah:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:560    .text._Z17getReceiverSIDatah:00000000 _Z17getReceiverSIDatah
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:587    .text._Z17getReceiverSIDatah:00000024 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:594    .text._Z9updatePIDffP7PIDdata:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:599    .text._Z9updatePIDffP7PIDdata:00000000 _Z9updatePIDffP7PIDdata
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:696    .text._Z9updatePIDffP7PIDdata:000000ac $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:704    .text._Z17zeroIntegralErrorv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:709    .text._Z17zeroIntegralErrorv:00000000 _Z17zeroIntegralErrorv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:758    .text._Z17zeroIntegralErrorv:00000034 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:764    .text._Z18computeFourthOrderfP15fourthOrderData:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:769    .text._Z18computeFourthOrderfP15fourthOrderData:00000000 _Z18computeFourthOrderfP15fourthOrderData
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:834    .text._Z18computeFourthOrderfP15fourthOrderData:00000088 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:845    .text._Z16setupFourthOrderv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:850    .text._Z16setupFourthOrderv:00000000 _Z16setupFourthOrderv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:915    .text._Z16setupFourthOrderv:00000038 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:921    .text._ZN14HardwareSPIExt5SetCSEi:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:926    .text._ZN14HardwareSPIExt5SetCSEi:00000000 _ZN14HardwareSPIExt5SetCSEi
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:943    .text._ZN14HardwareSPIExtC2Ej:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:948    .text._ZN14HardwareSPIExtC2Ej:00000000 _ZN14HardwareSPIExtC2Ej
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:982    .text._ZN14HardwareSPIExt5beginE12SPIFrequencyjj:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:987    .text._ZN14HardwareSPIExt5beginE12SPIFrequencyjj:00000000 _ZN14HardwareSPIExt5beginE12SPIFrequencyjj
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1034   .text._ZN14HardwareSPIExt4ReadEiPhi:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1039   .text._ZN14HardwareSPIExt4ReadEiPhi:00000000 _ZN14HardwareSPIExt4ReadEiPhi
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1104   .text._ZN14HardwareSPIExt4ReadEi:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1109   .text._ZN14HardwareSPIExt4ReadEi:00000000 _ZN14HardwareSPIExt4ReadEi
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1137   .text._ZN14HardwareSPIExt5WriteEiPhi:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1142   .text._ZN14HardwareSPIExt5WriteEiPhi:00000000 _ZN14HardwareSPIExt5WriteEiPhi
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1206   .text._ZN14HardwareSPIExt5WriteEih:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1211   .text._ZN14HardwareSPIExt5WriteEih:00000000 _ZN14HardwareSPIExt5WriteEih
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1242   .text._Z19MPU6000_SpiLowSpeedv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1247   .text._Z19MPU6000_SpiLowSpeedv:00000000 _Z19MPU6000_SpiLowSpeedv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1270   .text._Z19MPU6000_SpiLowSpeedv:00000010 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1275   .text._Z20MPU6000_SpiHighSpeedv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1280   .text._Z20MPU6000_SpiHighSpeedv:00000000 _Z20MPU6000_SpiHighSpeedv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1306   .text._Z20MPU6000_SpiHighSpeedv:00000018 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1311   .text._Z16MPU6000_WriteRegih:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1316   .text._Z16MPU6000_WriteRegih:00000000 _Z16MPU6000_WriteRegih
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1347   .text._Z16MPU6000_WriteRegih:00000018 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1352   .text._Z15MPU6000_ReadRegi:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1357   .text._Z15MPU6000_ReadRegi:00000000 _Z15MPU6000_ReadRegi
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1390   .text._Z15MPU6000_ReadRegi:00000018 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1395   .text._Z24initializeMPU6000Sensorsv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1400   .text._Z24initializeMPU6000Sensorsv:00000000 _Z24initializeMPU6000Sensorsv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1504   .text._Z24initializeMPU6000Sensorsv:00000098 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1515   .text._Z15MPU6000SwapDataPhi:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1520   .text._Z15MPU6000SwapDataPhi:00000000 _Z15MPU6000SwapDataPhi
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1564   .text._Z18readMPU6000Sensorsv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1569   .text._Z18readMPU6000Sensorsv:00000000 _Z18readMPU6000Sensorsv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1597   .text._Z18readMPU6000Sensorsv:0000001c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1603   .text._Z16readMPU6000Accelv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1608   .text._Z16readMPU6000Accelv:00000000 _Z16readMPU6000Accelv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1647   .text._Z16readMPU6000Accelv:00000020 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1653   .text._Z15readMPU6000Gyrov:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1658   .text._Z15readMPU6000Gyrov:00000000 _Z15readMPU6000Gyrov
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1696   .text._Z15readMPU6000Gyrov:00000020 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1702   .text._Z14initializeGyrov:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1707   .text._Z14initializeGyrov:00000000 _Z14initializeGyrov
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1729   .text._Z14initializeGyrov:0000000c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1736   .text._Z17gyroUpdateHeadingv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1741   .text._Z17gyroUpdateHeadingv:00000000 _Z17gyroUpdateHeadingv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1790   .text._Z17gyroUpdateHeadingv:00000050 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1800   .text._Z11measureGyrov:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1805   .text._Z11measureGyrov:00000000 _Z11measureGyrov
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1889   .text._Z11measureGyrov:00000074 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1899   .text._Z14measureGyroSumv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1904   .text._Z14measureGyroSumv:00000000 _Z14measureGyroSumv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1950   .text._Z14measureGyroSumv:0000003c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1958   .text._Z16evaluateGyroRatev:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:1963   .text._Z16evaluateGyroRatev:00000000 _Z16evaluateGyroRatev
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2059   .text._Z16evaluateGyroRatev:00000080 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2069   .text._Z13calibrateGyrov:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2074   .text._Z13calibrateGyrov:00000000 _Z13calibrateGyrov
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2171   .text._Z13calibrateGyrov:0000004c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2177   .text._Z15initializeAccelv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2182   .text._Z15initializeAccelv:00000000 _Z15initializeAccelv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2197   .text._Z12measureAccelv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2202   .text._Z12measureAccelv:00000000 _Z12measureAccelv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2259   .text._Z12measureAccelv:00000064 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2267   .text._Z15measureAccelSumv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2272   .text._Z15measureAccelSumv:00000000 _Z15measureAccelSumv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2316   .text._Z15measureAccelSumv:00000038 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2323   .text._Z20evaluateMetersPerSecv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2328   .text._Z20evaluateMetersPerSecv:00000000 _Z20evaluateMetersPerSecv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2388   .text._Z20evaluateMetersPerSecv:00000048 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2397   .text._Z16computeAccelBiasv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2402   .text._Z16computeAccelBiasv:00000000 _Z16computeAccelBiasv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2506   .text._Z16computeAccelBiasv:000000a0 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2519   .text._Z24HardCodedAxisCalibrationv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2524   .text._Z24HardCodedAxisCalibrationv:00000000 _Z24HardCodedAxisCalibrationv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2581   .text._Z24HardCodedAxisCalibrationv:00000064 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2588   .text._Z12initPlatformv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2593   .text._Z12initPlatformv:00000000 _Z12initPlatformv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2707   .text._Z12initPlatformv:000000b0 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2716   .text._Z11SignalAlivei:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2721   .text._Z11SignalAlivei:00000000 _Z11SignalAlivei
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2742   .text._Z22measureCriticalSensorsv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2747   .text._Z22measureCriticalSensorsv:00000000 _Z22measureCriticalSensorsv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2784   .text._Z22measureCriticalSensorsv:00000028 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2791   .text._Z29initializeBaseKinematicsParamv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2796   .text._Z29initializeBaseKinematicsParamv:00000000 _Z29initializeBaseKinematicsParamv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2832   .text._Z29initializeBaseKinematicsParamv:00000014 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2838   .text._Z27kinematicsGetDegreesHeadingh:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2843   .text._Z27kinematicsGetDegreesHeadingh:00000000 _Z27kinematicsGetDegreesHeadingh
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2875   .text._Z27kinematicsGetDegreesHeadingh:0000002c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2884   .text._Z9argUpdatefffffff:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:2889   .text._Z9argUpdatefffffff:00000000 _Z9argUpdatefffffff
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3205   .text._Z9argUpdatefffffff:0000024c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3222   .text._Z11eulerAnglesv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3227   .text._Z11eulerAnglesv:00000000 _Z11eulerAnglesv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3332   .text._Z11eulerAnglesv:000000f8 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3341   .text._Z20initializeKinematicsv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3346   .text._Z20initializeKinematicsv:00000000 _Z20initializeKinematicsv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3416   .text._Z20initializeKinematicsv:00000044 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3434   .text._Z19calculateKinematicsfffffff:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3439   .text._Z19calculateKinematicsfffffff:00000000 _Z19calculateKinematicsfffffff
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3473   .text._Z19calculateKinematicsfffffff:00000028 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3478   .text._Z13getGyroUnbiash:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3483   .text._Z13getGyroUnbiash:00000000 _Z13getGyroUnbiash
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3501   .text._Z13getGyroUnbiash:0000000c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3506   .text._Z19calibrateKinematicsv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3511   .text._Z19calibrateKinematicsv:00000000 _Z19calibrateKinematicsv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3524   .text._Z7FrqInitiP9timer_devi:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3529   .text._Z7FrqInitiP9timer_devi:00000000 _Z7FrqInitiP9timer_devi
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3651   .text._Z7FrqInitiP9timer_devi:00000094 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3657   .text._Z18InitFrqMeasurementv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3662   .text._Z18InitFrqMeasurementv:00000000 _Z18InitFrqMeasurementv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3715   .text._Z18InitFrqMeasurementv:00000040 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3723   .text._Z18initializeReceiveri:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3728   .text._Z18initializeReceiveri:00000000 _Z18initializeReceiveri
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3751   .text._Z18getRawChannelValueh:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3756   .text._Z18getRawChannelValueh:00000000 _Z18getRawChannelValueh
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3777   .text._Z18getRawChannelValueh:0000000c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3783   .text._Z12readReceiverv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3788   .text._Z12readReceiverv:00000000 _Z12readReceiverv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3909   .text._Z12readReceiverv:000000c4 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3922   .text._Z15setChannelValuehi:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3927   .text._Z15setChannelValuehi:00000000 _Z15setChannelValuehi
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3941   .text._Z14_initMotorInfoii:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3946   .text._Z14_initMotorInfoii:00000000 _Z14_initMotorInfoii
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3982   .text._Z14_initMotorInfoii:0000001c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3988   .text._Z11writeMotorsv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:3993   .text._Z11writeMotorsv:00000000 _Z11writeMotorsv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4037   .text._Z11writeMotorsv:0000002c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4044   .text._Z16commandAllMotorsi:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4049   .text._Z16commandAllMotorsi:00000000 _Z16commandAllMotorsi
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4093   .text._Z16commandAllMotorsi:00000028 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4099   .text._Z16initializeMotors9NB_Motors:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4104   .text._Z16initializeMotors9NB_Motors:00000000 _Z16initializeMotors9NB_Motors
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4257   .text._Z16initializeMotors9NB_Motors:00000080 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4266   .text._Z11pulseMotorsh:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4271   .text._Z11pulseMotorsh:00000000 _Z11pulseMotorsh
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4322   .text._Z8getHdgXYh:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4327   .text._Z8getHdgXYh:00000000 _Z8getHdgXYh
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4354   .text._Z8getHdgXYh:00000010 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4360   .text._Z22getMagnetometerRawDatah:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4365   .text._Z22getMagnetometerRawDatah:00000000 _Z22getMagnetometerRawDatah
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4385   .text._Z22getMagnetometerRawDatah:00000014 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4390   .text._Z19getMagnetometerDatah:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4395   .text._Z19getMagnetometerDatah:00000000 _Z19getMagnetometerDatah
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4415   .text._Z19getMagnetometerDatah:00000014 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4420   .text._Z18getAbsoluteHeadingv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4425   .text._Z18getAbsoluteHeadingv:00000000 _Z18getAbsoluteHeadingv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4475   .text._Z18getAbsoluteHeadingv:00000044 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4482   .text._Z23initializeHeadingFusionv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4487   .text._Z23initializeHeadingFusionv:00000000 _Z23initializeHeadingFusionv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4515   .text._Z23initializeHeadingFusionv:00000014 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4524   .text._Z16calculateHeadingv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4529   .text._Z16calculateHeadingv:00000000 _Z16calculateHeadingv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4666   .text._Z16calculateHeadingv:00000108 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4682   .text._Z15readSpecificMagPf:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4687   .text._Z15readSpecificMagPf:00000000 _Z15readSpecificMagPf
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4725   .text._Z19measureMagnetometerff:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4730   .text._Z19measureMagnetometerff:00000000 _Z19measureMagnetometerff
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4912   .text._Z19measureMagnetometerff:0000012c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4926   .text._Z22initializeMagnetometerv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4931   .text._Z22initializeMagnetometerv:00000000 _Z22initializeMagnetometerv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4984   .text._Z22initializeMagnetometerv:00000048 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4989   .text._Z15getBaroAltitudev:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:4994   .text._Z15getBaroAltitudev:00000000 _Z15getBaroAltitudev
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5014   .text._Z15getBaroAltitudev:00000018 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5020   .text._ZL15hottv4UpdateAltv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5024   .text._ZL15hottv4UpdateAltv:00000000 _ZL15hottv4UpdateAltv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5069   .text._ZL15hottv4UpdateAltv:00000030 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5075   .text._Z10MS5611crc4Pt:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5080   .text._Z10MS5611crc4Pt:00000000 _Z10MS5611crc4Pt
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5168   .text._Z14MS5611readPROMi:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5173   .text._Z14MS5611readPROMi:00000000 _Z14MS5611readPROMi
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5247   .text._Z14MS5611readPROMi:0000004c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5254   .text._Z11MS5611reseti:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5259   .text._Z11MS5611reseti:00000000 _Z11MS5611reseti
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5277   .text._Z20MS5611readConversioni:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5282   .text._Z20MS5611readConversioni:00000000 _Z20MS5611readConversioni
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5336   .text._Z20MS5611readConversioni:0000003c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5341   .text._Z21requestRawTemperaturev:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5346   .text._Z21requestRawTemperaturev:00000000 _Z21requestRawTemperaturev
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5363   .text._Z18readRawTemperaturev:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5368   .text._Z18readRawTemperaturev:00000000 _Z18readRawTemperaturev
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5443   .text._Z18readRawTemperaturev:0000006c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5452   .text._Z15readTemperaturev:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5457   .text._Z15readTemperaturev:00000000 _Z15readTemperaturev
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5501   .text._Z15readTemperaturev:0000004c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5508   .text._Z18requestRawPressurev:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5513   .text._Z18requestRawPressurev:00000000 _Z18requestRawPressurev
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5530   .text._Z15readRawPressurev:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5535   .text._Z15readRawPressurev:00000000 _Z15readRawPressurev
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5584   .text._Z15readRawPressurev:00000054 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5592   .text._Z14measureBaroSumv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5597   .text._Z14measureBaroSumv:00000000 _Z14measureBaroSumv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5673   .text._Z14measureBaroSumv:0000005c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5682   .text._Z20evaluateBaroAltitudev:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5687   .text._Z20evaluateBaroAltitudev:00000000 _Z20evaluateBaroAltitudev
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5799   .text._Z20evaluateBaroAltitudev:000000b0 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5820   .text._Z11measureBarov:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5825   .text._Z11measureBarov:00000000 _Z11measureBarov
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5846   .text._Z17measureGroundBarov:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5851   .text._Z17measureGroundBarov:00000000 _Z17measureGroundBarov
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5903   .text._Z17measureGroundBarov:00000038 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5910   .text._Z14initializeBarov:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5915   .text._Z14initializeBarov:00000000 _Z14initializeBarov
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:5998   .text._Z14initializeBarov:00000070 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6011   .text._Z30setBatteryCellVoltageThresholdf:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6016   .text._Z30setBatteryCellVoltageThresholdf:00000000 _Z30setBatteryCellVoltageThresholdf
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6058   .text._Z30setBatteryCellVoltageThresholdf:00000034 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6066   .text._Z12resetBatteryh:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6071   .text._Z12resetBatteryh:00000000 _Z12resetBatteryh
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6110   .text._Z12resetBatteryh:00000028 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6116   .text._Z19batteryGetCellCounth:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6121   .text._Z19batteryGetCellCounth:00000000 _Z19batteryGetCellCounth
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6155   .text._Z19batteryGetCellCounth:00000024 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6160   .text._Z14batteryIsAlarmh:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6165   .text._Z14batteryIsAlarmh:00000000 _Z14batteryIsAlarmh
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6198   .text._Z14batteryIsAlarmh:00000024 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6204   .text._Z16batteryIsWarningh:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6209   .text._Z16batteryIsWarningh:00000000 _Z16batteryIsWarningh
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6242   .text._Z16batteryIsWarningh:00000024 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6248   .text._Z21measureBatteryVoltaget:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6253   .text._Z21measureBatteryVoltaget:00000000 _Z21measureBatteryVoltaget
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6391   .text._Z21measureBatteryVoltaget:000000c0 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6399   .text._Z24initializeBatteryMonitorhf:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6404   .text._Z24initializeBatteryMonitorhf:00000000 _Z24initializeBatteryMonitorhf
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6456   .text._Z24initializeBatteryMonitorhf:00000028 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6462   .text._Z17applyMotorCommandv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6467   .text._Z17applyMotorCommandv:00000000 _Z17applyMotorCommandv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6525   .text._Z17applyMotorCommandv:00000038 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6534   .text._Z22hottV4SerialClearInputv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6539   .text._Z22hottV4SerialClearInputv:00000000 _Z22hottV4SerialClearInputv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6568   .text._Z22hottV4SerialClearInputv:00000018 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6573   .text._Z16hottV4SerialReadv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6578   .text._Z16hottV4SerialReadv:00000000 _Z16hottV4SerialReadv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6620   .text._Z16hottV4SerialReadv:0000002c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6625   .text._Z8SetDelayj:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6630   .text._Z8SetDelayj:00000000 _Z8SetDelayj
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6649   .text._Z8SetDelayj:0000000c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6654   .text._Z10CheckDelayj:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6659   .text._Z10CheckDelayj:00000000 _Z10CheckDelayj
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6680   .text._Z10CheckDelayj:00000014 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6685   .text._Z10hottv4InitP14HardwareSerial:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6690   .text._Z10hottv4InitP14HardwareSerial:00000000 _Z10hottv4InitP14HardwareSerial
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6711   .text._Z10hottv4InitP14HardwareSerial:0000000c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6716   .text._Z10hottV4Hookh:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:6721   .text._Z10hottV4Hookh:00000000 _Z10hottV4Hookh
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:7271   .text._Z10hottV4Hookh:000002f8 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:7296   .text._Z11hottHandlerv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:7301   .text._Z11hottHandlerv:00000000 _Z11hottHandlerv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:7322   .text._Z11hottHandlerv:0000000e $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:7326   .text._Z11hottHandlerv:00000012 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:7453   .text._Z11hottHandlerv:000000ac $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:7464   .text._Z19processAltitudeHoldv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:7469   .text._Z19processAltitudeHoldv:00000000 _Z19processAltitudeHoldv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:7581   .text._Z19processAltitudeHoldv:000000a4 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:7597   .text._Z20calculateFlightErrorv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:7602   .text._Z20calculateFlightErrorv:00000000 _Z20calculateFlightErrorv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:7731   .text._Z20calculateFlightErrorv:00000100 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:7750   .text._Z19processCalibrateESCv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:7755   .text._Z19processCalibrateESCv:00000000 _Z19processCalibrateESCv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:7857   .text._Z19processCalibrateESCv:00000070 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:7867   .text._Z25processThrottleCorrectionv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:7872   .text._Z25processThrottleCorrectionv:00000000 _Z25processThrottleCorrectionv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:7904   .text._Z25processThrottleCorrectionv:00000020 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:7909   .text._Z20processHardManueversv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:7914   .text._Z20processHardManueversv:00000000 _Z20processHardManueversv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:7968   .text._Z20processHardManueversv:00000040 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:7978   .text._Z20processMinMaxCommandv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:7983   .text._Z20processMinMaxCommandv:00000000 _Z20processMinMaxCommandv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8071   .text._Z20processMinMaxCommandv:00000058 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8079   .text._Z14processHeadingv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8084   .text._Z14processHeadingv:00000000 _Z14processHeadingv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8299   .text._Z14processHeadingv:00000174 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8327   .text._Z20processFlightControlv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8332   .text._Z20processFlightControlv:00000000 _Z20processFlightControlv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8476   .text._Z20processFlightControlv:000000ac $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8491   .text._Z12nvrReadFloati:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8496   .text._Z12nvrReadFloati:00000000 _Z12nvrReadFloati
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8538   .text._Z12nvrReadFloati:00000024 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8543   .text._Z13nvrWriteFloatfi:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8548   .text._Z13nvrWriteFloatfi:00000000 _Z13nvrWriteFloatfi
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8591   .text._Z13nvrWriteFloatfi:00000020 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8598   .text._Z11nvrReadLongi:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8603   .text._Z11nvrReadLongi:00000000 _Z11nvrReadLongi
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8643   .text._Z11nvrReadLongi:00000024 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8648   .text._Z12nvrWriteLongli:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8653   .text._Z12nvrWriteLongli:00000000 _Z12nvrWriteLongli
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8695   .text._Z12nvrWriteLongli:00000020 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8702   .text._Z10nvrReadPIDhj:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8707   .text._Z10nvrReadPIDhj:00000000 _Z10nvrReadPIDhj
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8763   .text._Z10nvrReadPIDhj:00000030 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8768   .text._Z11nvrWritePIDhj:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8773   .text._Z11nvrWritePIDhj:00000000 _Z11nvrWritePIDhj
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8818   .text._Z11nvrWritePIDhj:00000028 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8824   .text._Z16initializeEEPROMv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:8829   .text._Z16initializeEEPROMv:00000000 _Z16initializeEEPROMv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:9102   .text._Z16initializeEEPROMv:00000148 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:9143   .text._Z10readEEPROMv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:9148   .text._Z10readEEPROMv:00000000 _Z10readEEPROMv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:9379   .text._Z10readEEPROMv:000001d0 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:9401   .text._Z11writeEEPROMv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:9406   .text._Z11writeEEPROMv:00000000 _Z11writeEEPROMv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:9675   .text._Z11writeEEPROMv:00000220 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:9702   .text._Z25initSensorsZeroFromEEPROMv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:9707   .text._Z25initSensorsZeroFromEEPROMv:00000000 _Z25initSensorsZeroFromEEPROMv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:9785   .text._Z25initSensorsZeroFromEEPROMv:00000090 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:9793   .text._Z24storeSensorsZeroToEEPROMv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:9798   .text._Z24storeSensorsZeroToEEPROMv:00000000 _Z24storeSensorsZeroToEEPROMv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:9872   .text._Z24storeSensorsZeroToEEPROMv:00000094 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:9880   .text._Z17readPilotCommandsv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:9885   .text._Z17readPilotCommandsv:00000000 _Z17readPilotCommandsv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:10103  .text._Z17readPilotCommandsv:00000114 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:10120  .text._Z22initReceiverFromEEPROMv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:10125  .text._Z22initReceiverFromEEPROMv:00000000 _Z22initReceiverFromEEPROMv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:10179  .text._Z22initReceiverFromEEPROMv:00000044 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:10187  .text._Z17initCommunicationv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:10192  .text._Z17initCommunicationv:00000000 _Z17initCommunicationv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:10206  .text._Z15readValueSerialPch:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:10211  .text._Z15readValueSerialPch:00000000 _Z15readValueSerialPch
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:10296  .text._Z15readValueSerialPch:0000004c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:10301  .text._Z15readFloatSerialv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:10306  .text._Z15readFloatSerialv:00000000 _Z15readFloatSerialv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:10344  .text._Z13readSerialPIDh:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:10349  .text._Z13readSerialPIDh:00000000 _Z13readSerialPIDh
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:10394  .text._Z13readSerialPIDh:00000024 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:10399  .text._Z24validateCalibrateCommandh:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:10404  .text._Z24validateCalibrateCommandh:00000000 _Z24validateCalibrateCommandh
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:10449  .text._Z24validateCalibrateCommandh:00000038 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:10457  .text._Z17readIntegerSerialv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:10462  .text._Z17readIntegerSerialv:00000000 _Z17readIntegerSerialv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:10499  .text._Z17readSerialCommandv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:10504  .text._Z17readSerialCommandv:00000000 _Z17readSerialCommandv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:10536  .text._Z17readSerialCommandv:00000024 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:10581  .text._Z17readSerialCommandv:00000078 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:10826  .text._Z17readSerialCommandv:0000021c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:10848  .text._Z17readSerialCommandv:0000026c $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11059  .text._Z17readSerialCommandv:00000380 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11074  .text._Z5commav:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11079  .text._Z5commav:00000000 _Z5commav
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11095  .text._Z5commav:00000008 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11100  .text._Z15PrintValueCommal:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11105  .text._Z15PrintValueCommal:00000000 _Z15PrintValueCommal
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11132  .text._Z15PrintValueCommal:00000014 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11137  .text._Z15PrintValueCommah:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11142  .text._Z15PrintValueCommah:00000000 _Z15PrintValueCommah
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11168  .text._Z15PrintValueCommah:00000014 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11173  .text._Z15PrintValueCommam:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11178  .text._Z15PrintValueCommam:00000000 _Z15PrintValueCommam
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11205  .text._Z15PrintValueCommam:00000014 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11210  .text._Z15PrintValueCommai:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11215  .text._Z15PrintValueCommai:00000000 _Z15PrintValueCommai
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11242  .text._Z15PrintValueCommai:00000014 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11247  .text._Z15PrintValueCommac:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11252  .text._Z15PrintValueCommac:00000000 _Z15PrintValueCommac
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11277  .text._Z15PrintValueCommac:00000014 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11282  .text._Z15PrintValueCommad:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11287  .text._Z15PrintValueCommad:00000000 _Z15PrintValueCommad
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11318  .text._Z15PrintValueCommad:0000001c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11323  .text._Z15PrintValueCommaf:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11328  .text._Z15PrintValueCommaf:00000000 _Z15PrintValueCommaf
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11359  .text._Z15PrintValueCommaf:00000020 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11364  .text._Z8PrintPIDh:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11369  .text._Z8PrintPIDh:00000000 _Z8PrintPIDh
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11402  .text._Z8PrintPIDh:00000020 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11407  .text._Z17printVehicleStatePKcmS0_:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11412  .text._Z17printVehicleStatePKcmS0_:00000000 _Z17printVehicleStatePKcmS0_
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11464  .text._Z17printVehicleStatePKcmS0_:00000034 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11472  .text._Z18reportVehicleStatev:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11477  .text._Z18reportVehicleStatev:00000000 _Z18reportVehicleStatev
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11592  .text._Z18reportVehicleStatev:000000d0 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11617  .text._Z19sendSerialTelemetryv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11622  .text._Z19sendSerialTelemetryv:00000000 _Z19sendSerialTelemetryv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11963  .text._Z19sendSerialTelemetryv:0000023c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11984  .text._Z19sendSerialTelemetryv:00000288 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:12373  .text._Z19sendSerialTelemetryv:00000500 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:12398  .text._Z16processLedStatusv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:12403  .text._Z16processLedStatusv:00000000 _Z16processLedStatusv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:12468  .text._Z16processLedStatusv:0000004c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:12477  .text._Z5setupv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:12482  .text._Z5setupv:00000000 _Z5setupv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:12598  .text._Z5setupv:000000c8 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:12610  .text._Z4loopv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:12615  .text._Z4loopv:00000000 _Z4loopv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:12864  .text._Z4loopv:00000194 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:12887  .text.startup.main:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:12892  .text.startup.main:00000000 main
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:12913  .text.startup._GLOBAL__sub_I__Z7premainv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:12917  .text.startup._GLOBAL__sub_I__Z7premainv:00000000 _GLOBAL__sub_I__Z7premainv
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:948    .text._ZN14HardwareSPIExtC2Ej:00000000 _ZN14HardwareSPIExtC1Ej
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:12953  .text.startup._GLOBAL__sub_I__Z7premainv:00000028 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13590  .bss.flashingLedState:00000000 flashingLedState
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13358  .data.queryType:00000000 queryType
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13853  .bss.headingTime:00000000 headingTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13597  .bss.setHeading:00000000 setHeading
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14208  .bss.hottTime:00000000 hottTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14015  .bss.hottState:00000000 hottState
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14201  .data.SpeakHoTT:00000000 SpeakHoTT
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13179  .bss.CountMilliseconds:00000000 CountMilliseconds
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14147  .bss.hottV4Serial:00000000 hottV4Serial
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13610  .bss.motorConfiguratorCommand:00000000 motorConfiguratorCommand
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13365  .bss.motorMinCommand:00000000 motorMinCommand
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14161  .bss.motorMaxCommand:00000000 motorMaxCommand
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14175  .bss.motorAxisCommandYaw:00000000 motorAxisCommandYaw
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13379  .bss.motorAxisCommandPitch:00000000 motorAxisCommandPitch
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14310  .bss.motorAxisCommandRoll:00000000 motorAxisCommandRoll
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14056  .data.batteryData:00000000 batteryData
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13571  .data.batteryWarningCellVoltage:00000000 batteryWarningCellVoltage
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14154  .data.batteryAlarmCellVoltage:00000000 batteryAlarmCellVoltage
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14375  .bss.buzzerState:00000000 buzzerState
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14113  .bss.batteryWarning:00000000 batteryWarning
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14107  .bss.batteryAlarm:00000000 batteryAlarm
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13463  .bss.numberOfBatteries:00000000 numberOfBatteries
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13406  .data.MS5611_first_read:00000000 MS5611_first_read
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14243  .bss.baroStartTime:00000000 baroStartTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13990  .bss.baroGroundUpdateDone:00000000 baroGroundUpdateDone
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13469  .bss.rawPressureSumCount:00000000 rawPressureSumCount
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14370  .bss.rawPressureSum:00000000 rawPressureSum
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13537  .bss.isReadPressure:00000000 isReadPressure
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13517  .data.pressureFactor:00000000 pressureFactor
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13232  .bss.pressureCount:00000000 pressureCount
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14049  .bss.rawTemperature:00000000 rawTemperature
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13251  .bss.rawPressure:00000000 rawPressure
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13922  .bss.pressure:00000000 pressure
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13710  .bss.MS5611_offset:00000000 MS5611_offset
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13200  .bss.MS5611_sens:00000000 MS5611_sens
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13666  .bss.MS5611lastRawPressure:00000000 MS5611lastRawPressure
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13943  .bss.MS5611lastRawTemperature:00000000 MS5611lastRawTemperature
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14140  .bss.MS5611Prom:00000000 MS5611Prom
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13220  .data.baroSmoothFactor:00000000 baroSmoothFactor
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13372  .bss.baroGroundAltitude:00000000 baroGroundAltitude
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13984  .bss.baroRawAltitude:00000000 baroRawAltitude
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13929  .bss.baroAltitude:00000000 baroAltitude
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14229  .bss.localHeading:00000000 localHeading
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14003  .bss.headingGyroZero:00000000 headingGyroZero
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13557  .bss.filter2:00000000 filter2
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14276  .data.filter1:00000000 filter1
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13771  .bss.compassDeclination:00000000 compassDeclination
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13482  .bss.trueNorthHeading:00000000 trueNorthHeading
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13673  .data.magScale:00000000 magScale
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13652  .bss.magBias:00000000 magBias
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13305  .bss.rawMag:00000000 rawMag
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13291  .bss.measuredMag:00000000 measuredMag
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13645  .bss.measuredMagZ:00000000 measuredMagZ
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13638  .bss.measuredMagY:00000000 measuredMagY
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13631  .bss.measuredMagX:00000000 measuredMagX
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13624  .bss.hdgY:00000000 hdgY
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13617  .bss.hdgX:00000000 hdgX
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13444  .bss.MotorInfo:00000000 MotorInfo
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13386  .bss.motorCommand:00000000 motorCommand
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13424  .data.numberOfMotors:00000000 numberOfMotors
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13279  .bss.FrqData:00000000 FrqData
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13737  .bss.currentChannel:00000000 currentChannel
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13970  .data.rawChannelValue:00000000 rawChannelValue
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13510  .bss.previousEz:00000000 previousEz
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13503  .bss.previousEy:00000000 previousEy
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13496  .bss.previousEx:00000000 previousEx
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13419  .bss.ezInt:00000000 ezInt
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13489  .bss.eyInt:00000000 eyInt
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14075  .bss.exInt:00000000 exInt
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13703  .bss.q3:00000000 q3
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13696  .bss.q2:00000000 q2
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13689  .bss.q1:00000000 q1
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13682  .bss.q0:00000000 q0
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13758  .bss.halfT:00000000 halfT
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13806  .bss.Ki:00000000 Ki
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13832  .bss.Kp:00000000 Kp
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13331  .bss.accelCutoff:00000000 accelCutoff
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14101  .bss.earthAccel:00000000 earthAccel
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13778  .bss.correctedRateVector:00000000 correctedRateVector
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14222  .bss.gyroAngle:00000000 gyroAngle
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13956  .bss.kinematicsAngle:00000000 kinematicsAngle
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14248  .bss.kinematicsType:00000000 kinematicsType
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13352  .bss.previousMeasureCriticalSensorsTime:00000000 previousMeasureCriticalSensorsTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13475  .bss.accelSampleCount:00000000 accelSampleCount
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13717  .bss.accelSample:00000000 accelSample
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14262  .bss.meterPerSecSec:00000000 meterPerSecSec
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14095  .bss.accelOneG:00000000 accelOneG
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14423  .bss.runTimeAccelBias:00000000 runTimeAccelBias
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13744  .bss.accelScaleFactor:00000000 accelScaleFactor
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14126  .bss.gyroSampleCount:00000000 gyroSampleCount
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14120  .bss.gyroLastMesuredTime:00000000 gyroLastMesuredTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13245  .bss.gyroHeading:00000000 gyroHeading
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14363  .bss.gyroScaleFactor:00000000 gyroScaleFactor
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14382  .bss.gyroSample:00000000 gyroSample
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14088  .bss.gyroZero:00000000 gyroZero
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13936  .bss.gyroRate:00000000 gyroRate
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13531  .bss.readMPU6000GyroCount:00000000 readMPU6000GyroCount
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13846  .bss.readMPU6000AccelCount:00000000 readMPU6000AccelCount
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13298  .bss.readMPU6000Count:00000000 readMPU6000Count
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13915  .bss.initializeMPU6000SensorsDone:00000000 initializeMPU6000SensorsDone
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14022  .bss.spiMPU6000:00000000 spiMPU6000
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14269  .bss.MPU6000:00000000 MPU6000
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14303  .bss.vehicleState:00000000 vehicleState
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14043  .bss.gyroRaw:00000000 gyroRaw
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13325  .rodata.Serial:00000000 Serial
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14029  .bss.fourthOrder:00000000 fourthOrder
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13213  .bss.windupGuard:00000000 windupGuard
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14255  .bss.PID:00000000 PID
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13543  .bss.fastTransfer:00000000 fastTransfer
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13839  .bss.baroAltitudeToHoldTarget:00000000 baroAltitudeToHoldTarget
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13577  .bss.isStoreAltitudeNeeded:00000000 isStoreAltitudeNeeded
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14317  .data.altitudeHoldThrottle:00000000 altitudeHoldThrottle
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13963  .data.maxThrottleAdjust:00000000 maxThrottleAdjust
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13751  .data.minThrottleAdjust:00000000 minThrottleAdjust
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13265  .data.altitudeHoldPanicStickMovement:00000000 altitudeHoldPanicStickMovement
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13393  .data.altitudeHoldBump:00000000 altitudeHoldBump
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14081  .bss.altitudeHoldState:00000000 altitudeHoldState
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14330  .data.batteryMonitorGoingDownTime:00000000 batteryMonitorGoingDownTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13996  .bss.batteryMonitorStartTime:00000000 batteryMonitorStartTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14195  .data.batteryMonitorThrottleTarget:00000000 batteryMonitorThrottleTarget
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13949  .bss.batteryMonitorStartThrottle:00000000 batteryMonitorStartThrottle
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13345  .data.batteryMonitorAlarmVoltage:00000000 batteryMonitorAlarmVoltage
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13437  .bss.headingHoldState:00000000 headingHoldState
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14215  .bss.relativeHeading:00000000 relativeHeading
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13319  .bss.heading:00000000 heading
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13765  .bss.headingHold:00000000 headingHold
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13412  .bss.headingHoldConfig:00000000 headingHoldConfig
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13724  .bss.aref:00000000 aref
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14351  .bss.hundredHZpreviousTime:00000000 hundredHZpreviousTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13792  .bss.fiftyHZpreviousTime:00000000 fiftyHZpreviousTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13400  .bss.lowPriorityTenHZpreviousTime2:00000000 lowPriorityTenHZpreviousTime2
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14188  .bss.lowPriorityTenHZpreviousTime:00000000 lowPriorityTenHZpreviousTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13312  .bss.tenHZpreviousTime:00000000 tenHZpreviousTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13825  .bss.oneHZpreviousTime:00000000 oneHZpreviousTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13584  .bss.deltaTime:00000000 deltaTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13338  .bss.currentTime:00000000 currentTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14337  .bss.previousTime:00000000 previousTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13431  .data.rotationSpeedFactor:00000000 rotationSpeedFactor
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13603  .bss.inFlight:00000000 inFlight
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13258  .bss.filteredAccel:00000000 filteredAccel
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13284  .bss.minLimit:00000000 minLimit
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14356  .bss.maxLimit:00000000 maxLimit
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14323  .bss.safetyCheck:00000000 safetyCheck
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13206  .bss.motorArmed:00000000 motorArmed
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14036  .data.throttle:00000000 throttle
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14344  .data.G_Dt:00000000 G_Dt
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13564  .bss.minArmedThrottle:00000000 minArmedThrottle
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13799  .bss.frameCounter:00000000 frameCounter
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14289  .bss.flightMode:00000000 flightMode
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13659  .data.testCommand:00000000 testCommand
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14009  .bss.calibrateESC:00000000 calibrateESC
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14396  .bss.channelCal:00000000 channelCal
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13272  .bss.receiverSmoothFactor:00000000 receiverSmoothFactor
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14236  .bss.receiverOffset:00000000 receiverOffset
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14283  .bss.receiverSlope:00000000 receiverSlope
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13813  .bss.receiverCommandSmooth:00000000 receiverCommandSmooth
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13731  .bss.receiverCommand:00000000 receiverCommand
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14168  .bss.receiverZero:00000000 receiverZero
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13193  .bss.receiverData:00000000 receiverData
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13186  .bss.receiverXmitFactor:00000000 receiverXmitFactor
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14133  .bss.lastReceiverChannel:00000000 lastReceiverChannel
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13175  .bss.CountMilliseconds:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13182  .bss.receiverXmitFactor:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13189  .bss.receiverData:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13196  .bss.MS5611_sens:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13207  .bss.motorArmed:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13209  .bss.windupGuard:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13216  .data.baroSmoothFactor:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13226  .bss._ZL26hottV4TelemetryBufferIndex:00000000 _ZL26hottV4TelemetryBufferIndex
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13227  .bss._ZL26hottV4TelemetryBufferIndex:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13233  .bss.pressureCount:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13238  .bss._ZZL11HoTTWarningvE10old_status:00000000 _ZZL11HoTTWarningvE10old_status
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13239  .bss._ZZL11HoTTWarningvE10old_status:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13241  .bss.gyroHeading:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13248  .bss.rawPressure:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13254  .bss.filteredAccel:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13261  .data.altitudeHoldPanicStickMovement:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13268  .bss.receiverSmoothFactor:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13275  .bss.FrqData:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13285  .bss.minLimit:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13287  .bss.measuredMag:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13294  .bss.readMPU6000Count:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13301  .bss.rawMag:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13308  .bss.tenHZpreviousTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13315  .bss.heading:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13322  .rodata.Serial:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13328  .bss.accelCutoff:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13334  .bss.currentTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13341  .data.batteryMonitorAlarmVoltage:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13348  .bss.previousMeasureCriticalSensorsTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13361  .bss.motorMinCommand:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13368  .bss.baroGroundAltitude:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13375  .bss.motorAxisCommandPitch:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13382  .bss.motorCommand:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13389  .data.altitudeHoldBump:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13396  .bss.lowPriorityTenHZpreviousTime2:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13413  .bss.headingHoldConfig:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13415  .bss.ezInt:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13427  .data.rotationSpeedFactor:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13438  .bss.headingHoldState:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13440  .bss.MotorInfo:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13450  .rodata._ZL19stm32_motor_mapping:00000000 _ZL19stm32_motor_mapping
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13464  .bss.numberOfBatteries:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13470  .bss.rawPressureSumCount:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13476  .bss.accelSampleCount:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13478  .bss.trueNorthHeading:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13485  .bss.eyInt:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13492  .bss.previousEx:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13499  .bss.previousEy:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13506  .bss.previousEz:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13513  .data.pressureFactor:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13520  .data._ZL11minAltitude:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13524  .data._ZL11minAltitude:00000000 _ZL11minAltitude
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13527  .bss.readMPU6000GyroCount:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13538  .bss.isReadPressure:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13544  .bss.fastTransfer:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13546  .bss._ZZL22hottv4UpdateFlightTimePhE17previousEAMUpdate:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13550  .bss._ZZL22hottv4UpdateFlightTimePhE17previousEAMUpdate:00000000 _ZZL22hottv4UpdateFlightTimePhE17previousEAMUpdate
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13553  .bss.filter2:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13560  .bss.minArmedThrottle:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13567  .data.batteryWarningCellVoltage:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13578  .bss.isStoreAltitudeNeeded:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13580  .bss.deltaTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13591  .bss.flashingLedState:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13593  .bss.setHeading:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13604  .bss.inFlight:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13606  .bss.motorConfiguratorCommand:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13613  .bss.hdgX:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13620  .bss.hdgY:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13627  .bss.measuredMagX:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13634  .bss.measuredMagY:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13641  .bss.measuredMagZ:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13648  .bss.magBias:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13655  .data.testCommand:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13662  .bss.MS5611lastRawPressure:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13669  .data.magScale:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13678  .bss.q0:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13685  .bss.q1:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13692  .bss.q2:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13699  .bss.q3:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13706  .bss.MS5611_offset:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13713  .bss.accelSample:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13720  .bss.aref:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13727  .bss.receiverCommand:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13738  .bss.currentChannel:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13740  .bss.accelScaleFactor:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13747  .data.minThrottleAdjust:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13754  .bss.halfT:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13761  .bss.headingHold:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13768  .bss.compassDeclination:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13774  .bss.correctedRateVector:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13781  .bss._ZL12milliseconds:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13785  .bss._ZL12milliseconds:00000000 _ZL12milliseconds
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13788  .bss.fiftyHZpreviousTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13795  .bss.frameCounter:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13802  .bss.Ki:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13809  .bss.receiverCommandSmooth:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13819  .bss._ZL21hottV4TelemetryBuffer:00000000 _ZL21hottV4TelemetryBuffer
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13820  .bss._ZL21hottV4TelemetryBuffer:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13822  .bss.oneHZpreviousTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13828  .bss.Kp:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13835  .bss.baroAltitudeToHoldTarget:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13842  .bss.readMPU6000AccelCount:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13849  .bss.headingTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13916  .bss.initializeMPU6000SensorsDone:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13918  .bss.pressure:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13925  .bss.baroAltitude:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13932  .bss.gyroRate:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13939  .bss.MS5611lastRawTemperature:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13946  .bss.batteryMonitorStartThrottle:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13952  .bss.kinematicsAngle:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13959  .data.maxThrottleAdjust:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13966  .data.rawChannelValue:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13980  .bss.baroRawAltitude:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13991  .bss.baroGroundUpdateDone:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13993  .bss.batteryMonitorStartTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:13999  .bss.headingGyroZero:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14010  .bss.calibrateESC:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14016  .bss.hottState:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14018  .bss.spiMPU6000:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14025  .bss.fourthOrder:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14032  .data.throttle:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14039  .bss.gyroRaw:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14046  .bss.rawTemperature:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14052  .data.batteryData:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14071  .bss.exInt:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14082  .bss.altitudeHoldState:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14084  .bss.gyroZero:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14091  .bss.accelOneG:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14098  .bss.earthAccel:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14108  .bss.batteryAlarm:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14114  .bss.batteryWarning:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14116  .bss.gyroLastMesuredTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14127  .bss.gyroSampleCount:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14129  .bss.lastReceiverChannel:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14136  .bss.MS5611Prom:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14143  .bss.hottV4Serial:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14150  .data.batteryAlarmCellVoltage:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14157  .bss.motorMaxCommand:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14164  .bss.receiverZero:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14171  .bss.motorAxisCommandYaw:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14181  .bss._ZL7minutes:00000000 _ZL7minutes
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14182  .bss._ZL7minutes:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14184  .bss.lowPriorityTenHZpreviousTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14191  .data.batteryMonitorThrottleTarget:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14204  .bss.hottTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14211  .bss.relativeHeading:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14218  .bss.gyroAngle:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14225  .bss.localHeading:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14232  .bss.receiverOffset:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14239  .bss.baroStartTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14249  .bss.kinematicsType:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14251  .bss.PID:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14258  .bss.meterPerSecSec:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14265  .bss.MPU6000:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14272  .data.filter1:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14279  .bss.receiverSlope:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14290  .bss.flightMode:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14292  .bss._ZZL11HoTTWarningvE6repeat:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14296  .bss._ZZL11HoTTWarningvE6repeat:00000000 _ZZL11HoTTWarningvE6repeat
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14299  .bss.vehicleState:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14306  .bss.motorAxisCommandRoll:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14313  .data.altitudeHoldThrottle:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14324  .bss.safetyCheck:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14326  .data.batteryMonitorGoingDownTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14333  .bss.previousTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14340  .data.G_Dt:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14347  .bss.hundredHZpreviousTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14357  .bss.maxLimit:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14359  .bss.gyroScaleFactor:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14366  .bss.rawPressureSum:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14376  .bss.buzzerState:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14378  .bss.gyroSample:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14385  .bss._ZL19_stm32_motor_number:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14389  .bss._ZL19_stm32_motor_number:00000000 _ZL19_stm32_motor_number
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14392  .bss.channelCal:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14399  .data._ZL11maxAltitude:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14403  .data._ZL11maxAltitude:00000000 _ZL11maxAltitude
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14409  .rodata._ZL18ReceiverChannelMap:00000000 _ZL18ReceiverChannelMap
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:14419  .bss.runTimeAccelBias:00000000 $d
                     .debug_frame:00000010 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:11616  .text._Z18reportVehicleStatev:00000124 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccxmYZGk.s:12397  .text._Z19sendSerialTelemetryv:00000554 $t
                           .group:00000000 _ZN14HardwareSPIExtC5Ej

UNDEFINED SYMBOLS
systick_uptime_millis
_Z4initv
_ZN11HardwareSPIC2Ej
_ZN11HardwareSPI6nssPinEv
_Z12digitalWritehh
_Z7pinModeh13WiringPinMode
_ZN11HardwareSPI5beginE12SPIFrequencyjj
_ZN11HardwareSPI8transferEh
_ZN11HardwareSPI3endEv
_Z5delaym
_ZN5Print7printlnEPKc
SerialUSB
_Z13findMedianIntPii
_Z17delayMicrosecondsj
_ZN7TwoWire5beginEhh
Wire
__aeabi_f2d
__aeabi_d2f
sqrt
_Z10isSwitchedff
atan2
asin
rcc_dev_timer_clk_speed
gpio_set_mode
timer_attach_interrupt
PIN_MAP
_Z12filterSmoothfff
__aeabi_dsub
__aeabi_dadd
fmod
_Z12readShortI2Cv
_Z11sendByteI2Cih
_ZN7TwoWire11requestFromEii
_Z17updateRegisterI2Cihh
cos
sin
_Z10readWhoI2Ci
_Z11readWordI2Cv
_ZN7TwoWire9availableEv
_Z11readByteI2Cv
__aeabi_l2f
__aeabi_dmul
pow
_Z10analogReadh
_ZN14HardwareSerial4readEv
_ZN14HardwareSerial9availableEv
_ZN14HardwareSerial5beginEj
memset
snprintf
strlen
_ZN11EEPROMClass4readEt
EEPROM
_ZN11EEPROMClass5writeEtt
_ZN9USBSerial9availableEv
_ZN9USBSerial4readEv
atof
atol
_ZN5Print5printEc
_ZN5Print5printEli
_ZN5Print5printEhi
_ZN5Print5printEmi
_ZN5Print5printEii
_ZN5Print5printEdi
_ZN5Print5printEPKc
_ZN5Print7printlnEii
_ZN5Print7printlnEdi
_ZN5Print7printlnEv
_ZN5Print7printlnEmi
_ZN9USBSerial5beginEi
Serial3
