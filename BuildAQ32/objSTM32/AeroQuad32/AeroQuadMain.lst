   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 4
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"AeroQuadMain.cpp"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.timer_set_compare,"ax",%progbits
  20              		.align	1
  21              		.thumb
  22              		.thumb_func
  24              	timer_set_compare:
  25              	.LFB30:
  26              		.file 1 "../Libmaple/libmaple/libmaple/timer.h"
   1:../Libmaple/libmaple/libmaple/timer.h **** /******************************************************************************
   2:../Libmaple/libmaple/libmaple/timer.h ****  * The MIT License
   3:../Libmaple/libmaple/libmaple/timer.h ****  *
   4:../Libmaple/libmaple/libmaple/timer.h ****  * Copyright (c) 2011 LeafLabs, LLC.
   5:../Libmaple/libmaple/libmaple/timer.h ****  *
   6:../Libmaple/libmaple/libmaple/timer.h ****  * Permission is hereby granted, free of charge, to any person
   7:../Libmaple/libmaple/libmaple/timer.h ****  * obtaining a copy of this software and associated documentation
   8:../Libmaple/libmaple/libmaple/timer.h ****  * files (the "Software"), to deal in the Software without
   9:../Libmaple/libmaple/libmaple/timer.h ****  * restriction, including without limitation the rights to use, copy,
  10:../Libmaple/libmaple/libmaple/timer.h ****  * modify, merge, publish, distribute, sublicense, and/or sell copies
  11:../Libmaple/libmaple/libmaple/timer.h ****  * of the Software, and to permit persons to whom the Software is
  12:../Libmaple/libmaple/libmaple/timer.h ****  * furnished to do so, subject to the following conditions:
  13:../Libmaple/libmaple/libmaple/timer.h ****  *
  14:../Libmaple/libmaple/libmaple/timer.h ****  * The above copyright notice and this permission notice shall be
  15:../Libmaple/libmaple/libmaple/timer.h ****  * included in all copies or substantial portions of the Software.
  16:../Libmaple/libmaple/libmaple/timer.h ****  *
  17:../Libmaple/libmaple/libmaple/timer.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  18:../Libmaple/libmaple/libmaple/timer.h ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  19:../Libmaple/libmaple/libmaple/timer.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20:../Libmaple/libmaple/libmaple/timer.h ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  21:../Libmaple/libmaple/libmaple/timer.h ****  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  22:../Libmaple/libmaple/libmaple/timer.h ****  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  23:../Libmaple/libmaple/libmaple/timer.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  24:../Libmaple/libmaple/libmaple/timer.h ****  * SOFTWARE.
  25:../Libmaple/libmaple/libmaple/timer.h ****  *****************************************************************************/
  26:../Libmaple/libmaple/libmaple/timer.h **** 
  27:../Libmaple/libmaple/libmaple/timer.h **** /**
  28:../Libmaple/libmaple/libmaple/timer.h ****  * @file   timer.h
  29:../Libmaple/libmaple/libmaple/timer.h ****  * @author Marti Bolivar <mbolivar@leaflabs.com>
  30:../Libmaple/libmaple/libmaple/timer.h ****  * @brief  New-style timer interface.
  31:../Libmaple/libmaple/libmaple/timer.h ****  *
  32:../Libmaple/libmaple/libmaple/timer.h ****  * Replaces old timers.h implementation.
  33:../Libmaple/libmaple/libmaple/timer.h ****  */
  34:../Libmaple/libmaple/libmaple/timer.h **** 
  35:../Libmaple/libmaple/libmaple/timer.h **** #ifndef _TIMERS_H_
  36:../Libmaple/libmaple/libmaple/timer.h **** #define _TIMERS_H_
  37:../Libmaple/libmaple/libmaple/timer.h **** 
  38:../Libmaple/libmaple/libmaple/timer.h **** #include "libmaple.h"
  39:../Libmaple/libmaple/libmaple/timer.h **** #include "rcc.h"
  40:../Libmaple/libmaple/libmaple/timer.h **** #include "nvic.h"
  41:../Libmaple/libmaple/libmaple/timer.h **** #include "bitband.h"
  42:../Libmaple/libmaple/libmaple/timer.h **** 
  43:../Libmaple/libmaple/libmaple/timer.h **** #ifdef __cplusplus
  44:../Libmaple/libmaple/libmaple/timer.h **** extern "C"{
  45:../Libmaple/libmaple/libmaple/timer.h **** #endif
  46:../Libmaple/libmaple/libmaple/timer.h **** 
  47:../Libmaple/libmaple/libmaple/timer.h **** /*
  48:../Libmaple/libmaple/libmaple/timer.h ****  * Register maps and devices
  49:../Libmaple/libmaple/libmaple/timer.h ****  */
  50:../Libmaple/libmaple/libmaple/timer.h **** 
  51:../Libmaple/libmaple/libmaple/timer.h **** /** Advanced control timer register map type */
  52:../Libmaple/libmaple/libmaple/timer.h **** typedef struct timer_adv_reg_map {
  53:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR1;            /**< Control register 1 */
  54:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR2;            /**< Control register 2 */
  55:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 SMCR;           /**< Slave mode control register */
  56:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DIER;           /**< DMA/Interrupt enable register */
  57:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 SR;             /**< Status register */
  58:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 EGR;            /**< Event generation register  */
  59:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCMR1;          /**< Capture/compare mode register 1 */
  60:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCMR2;          /**< Capture/compare mode register 2 */
  61:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCER;           /**< Capture/compare enable register */
  62:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CNT;            /**< Counter */
  63:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 PSC;            /**< Prescaler */
  64:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 ARR;            /**< Auto-reload register */
  65:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 RCR;            /**< Repetition counter register */
  66:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR1;           /**< Capture/compare register 1 */
  67:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR2;           /**< Capture/compare register 2 */
  68:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR3;           /**< Capture/compare register 3 */
  69:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR4;           /**< Capture/compare register 4 */
  70:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 BDTR;           /**< Break and dead-time register */
  71:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DCR;            /**< DMA control register */
  72:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DMAR;           /**< DMA address for full transfer */
  73:../Libmaple/libmaple/libmaple/timer.h **** } timer_adv_reg_map;
  74:../Libmaple/libmaple/libmaple/timer.h **** 
  75:../Libmaple/libmaple/libmaple/timer.h **** /** General purpose timer register map type */
  76:../Libmaple/libmaple/libmaple/timer.h **** typedef struct timer_gen_reg_map {
  77:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR1;            /**< Control register 1 */
  78:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR2;            /**< Control register 2 */
  79:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 SMCR;           /**< Slave mode control register */
  80:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DIER;           /**< DMA/Interrupt enable register */
  81:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 SR;             /**< Status register */
  82:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 EGR;            /**< Event generation register  */
  83:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCMR1;          /**< Capture/compare mode register 1 */
  84:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCMR2;          /**< Capture/compare mode register 2 */
  85:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCER;           /**< Capture/compare enable register */
  86:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CNT;            /**< Counter */
  87:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 PSC;            /**< Prescaler */
  88:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 ARR;            /**< Auto-reload register */
  89:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED1;     /**< Reserved */
  90:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR1;           /**< Capture/compare register 1 */
  91:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR2;           /**< Capture/compare register 2 */
  92:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR3;           /**< Capture/compare register 3 */
  93:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR4;           /**< Capture/compare register 4 */
  94:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED2;     /**< Reserved */
  95:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DCR;            /**< DMA control register */
  96:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DMAR;           /**< DMA address for full transfer */
  97:../Libmaple/libmaple/libmaple/timer.h **** } timer_gen_reg_map;
  98:../Libmaple/libmaple/libmaple/timer.h **** 
  99:../Libmaple/libmaple/libmaple/timer.h **** /** Basic timer register map type */
 100:../Libmaple/libmaple/libmaple/timer.h **** typedef struct timer_bas_reg_map {
 101:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR1;            /**< Control register 1 */
 102:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR2;            /**< Control register 2 */
 103:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED1;     /**< Reserved */
 104:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DIER;           /**< DMA/Interrupt enable register */
 105:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 SR;             /**< Status register */
 106:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 EGR;            /**< Event generation register  */
 107:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED2;     /**< Reserved */
 108:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED3;     /**< Reserved */
 109:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED4;     /**< Reserved */
 110:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CNT;            /**< Counter */
 111:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 PSC;            /**< Prescaler */
 112:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 ARR;            /**< Auto-reload register */
 113:../Libmaple/libmaple/libmaple/timer.h **** } timer_bas_reg_map;
 114:../Libmaple/libmaple/libmaple/timer.h **** 
 115:../Libmaple/libmaple/libmaple/timer.h **** 
 116:../Libmaple/libmaple/libmaple/timer.h **** #ifdef STM32F2
 117:../Libmaple/libmaple/libmaple/timer.h ****   /** Timer 1 register map base pointer */
 118:../Libmaple/libmaple/libmaple/timer.h ****   #define TIMER1_BASE        ((struct timer_adv_reg_map*)0x40010000)
 119:../Libmaple/libmaple/libmaple/timer.h **** #else
 120:../Libmaple/libmaple/libmaple/timer.h ****   /** Timer 1 register map base pointer */
 121:../Libmaple/libmaple/libmaple/timer.h ****   #define TIMER1_BASE        ((struct timer_adv_reg_map*)0x40012C00)
 122:../Libmaple/libmaple/libmaple/timer.h **** #endif
 123:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 2 register map base pointer */
 124:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER2_BASE        ((struct timer_gen_reg_map*)0x40000000)
 125:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 3 register map base pointer */
 126:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER3_BASE        ((struct timer_gen_reg_map*)0x40000400)
 127:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 4 register map base pointer */
 128:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER4_BASE        ((struct timer_gen_reg_map*)0x40000800)
 129:../Libmaple/libmaple/libmaple/timer.h **** #ifdef STM32_HIGH_DENSITY
 130:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 5 register map base pointer */
 131:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER5_BASE        ((struct timer_gen_reg_map*)0x40000C00)
 132:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 6 register map base pointer */
 133:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER6_BASE        ((struct timer_bas_reg_map*)0x40001000)
 134:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 7 register map base pointer */
 135:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER7_BASE        ((struct timer_bas_reg_map*)0x40001400)
 136:../Libmaple/libmaple/libmaple/timer.h **** 
 137:../Libmaple/libmaple/libmaple/timer.h **** #ifdef STM32F2
 138:../Libmaple/libmaple/libmaple/timer.h ****   /** Timer 8 register map base pointer */
 139:../Libmaple/libmaple/libmaple/timer.h ****   #define TIMER8_BASE        ((struct timer_adv_reg_map*)0x40010400)
 140:../Libmaple/libmaple/libmaple/timer.h **** #else
 141:../Libmaple/libmaple/libmaple/timer.h ****   /** Timer 8 register map base pointer */
 142:../Libmaple/libmaple/libmaple/timer.h ****   #define TIMER8_BASE        ((struct timer_adv_reg_map*)0x40013400)
 143:../Libmaple/libmaple/libmaple/timer.h **** #endif
 144:../Libmaple/libmaple/libmaple/timer.h **** #endif
 145:../Libmaple/libmaple/libmaple/timer.h **** 
 146:../Libmaple/libmaple/libmaple/timer.h **** /*
 147:../Libmaple/libmaple/libmaple/timer.h ****  * Timer devices
 148:../Libmaple/libmaple/libmaple/timer.h ****  */
 149:../Libmaple/libmaple/libmaple/timer.h **** 
 150:../Libmaple/libmaple/libmaple/timer.h **** /**
 151:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Timer register map type.
 152:../Libmaple/libmaple/libmaple/timer.h ****  *
 153:../Libmaple/libmaple/libmaple/timer.h ****  * Just holds a pointer to the correct type of register map, based on
 154:../Libmaple/libmaple/libmaple/timer.h ****  * the timer's type.
 155:../Libmaple/libmaple/libmaple/timer.h ****  */
 156:../Libmaple/libmaple/libmaple/timer.h **** typedef union timer_reg_map {
 157:../Libmaple/libmaple/libmaple/timer.h ****     timer_adv_reg_map *adv;     /**< Advanced register map */
 158:../Libmaple/libmaple/libmaple/timer.h ****     timer_gen_reg_map *gen;     /**< General purpose register map */
 159:../Libmaple/libmaple/libmaple/timer.h ****     timer_bas_reg_map *bas;     /**< Basic register map */
 160:../Libmaple/libmaple/libmaple/timer.h **** } timer_reg_map;
 161:../Libmaple/libmaple/libmaple/timer.h **** 
 162:../Libmaple/libmaple/libmaple/timer.h **** /**
 163:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Timer type
 164:../Libmaple/libmaple/libmaple/timer.h ****  *
 165:../Libmaple/libmaple/libmaple/timer.h ****  * Type marker for timer_dev.
 166:../Libmaple/libmaple/libmaple/timer.h ****  *
 167:../Libmaple/libmaple/libmaple/timer.h ****  * @see timer_dev
 168:../Libmaple/libmaple/libmaple/timer.h ****  */
 169:../Libmaple/libmaple/libmaple/timer.h **** typedef enum timer_type {
 170:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_ADVANCED,             /**< Advanced type */
 171:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_GENERAL,              /**< General purpose type */
 172:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_BASIC                 /**< Basic type */
 173:../Libmaple/libmaple/libmaple/timer.h **** } timer_type;
 174:../Libmaple/libmaple/libmaple/timer.h **** 
 175:../Libmaple/libmaple/libmaple/timer.h **** /** Timer device type */
 176:../Libmaple/libmaple/libmaple/timer.h **** typedef struct timer_dev {
 177:../Libmaple/libmaple/libmaple/timer.h ****     timer_reg_map regs;         /**< Register map */
 178:../Libmaple/libmaple/libmaple/timer.h ****     rcc_clk_id clk_id;          /**< RCC clock information */
 179:../Libmaple/libmaple/libmaple/timer.h ****     timer_type type;            /**< Timer's type */
 180:../Libmaple/libmaple/libmaple/timer.h ****     voidFuncPtr handlers[];     /**< User IRQ handlers */
 181:../Libmaple/libmaple/libmaple/timer.h **** } timer_dev;
 182:../Libmaple/libmaple/libmaple/timer.h **** 
 183:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER1;
 184:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER2;
 185:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER3;
 186:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER4;
 187:../Libmaple/libmaple/libmaple/timer.h **** #ifdef STM32_HIGH_DENSITY
 188:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER5;
 189:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER6;
 190:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER7;
 191:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER8;
 192:../Libmaple/libmaple/libmaple/timer.h **** #endif
 193:../Libmaple/libmaple/libmaple/timer.h **** 
 194:../Libmaple/libmaple/libmaple/timer.h **** /*
 195:../Libmaple/libmaple/libmaple/timer.h ****  * Register bit definitions
 196:../Libmaple/libmaple/libmaple/timer.h ****  */
 197:../Libmaple/libmaple/libmaple/timer.h **** 
 198:../Libmaple/libmaple/libmaple/timer.h **** /* Control register 1 (CR1) */
 199:../Libmaple/libmaple/libmaple/timer.h **** 
 200:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_ARPE_BIT              7
 201:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_DIR_BIT               4
 202:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_OPM_BIT               3
 203:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_URS_BIT               2
 204:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_UDIS_BIT              1
 205:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CEN_BIT               0
 206:../Libmaple/libmaple/libmaple/timer.h **** 
 207:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD                   (0x3 << 8)
 208:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_1TCKINT           (0x0 << 8)
 209:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_2TCKINT           (0x1 << 8)
 210:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_4TICKINT          (0x2 << 8)
 211:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_ARPE                  BIT(TIMER_CR1_ARPE_BIT)
 212:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_CMS               (0x3 << 5)
 213:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_CMS_EDGE          (0x0 << 5)
 214:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_CMS_CENTER1       (0x1 << 5)
 215:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_CMS_CENTER2       (0x2 << 5)
 216:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_CMS_CENTER3       (0x3 << 5)
 217:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_DIR                   BIT(TIMER_CR1_DIR_BIT)
 218:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_OPM                   BIT(TIMER_CR1_OPM_BIT)
 219:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_URS                   BIT(TIMER_CR1_URS_BIT)
 220:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_UDIS                  BIT(TIMER_CR1_UDIS_BIT)
 221:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CEN                   BIT(TIMER_CR1_CEN_BIT)
 222:../Libmaple/libmaple/libmaple/timer.h **** 
 223:../Libmaple/libmaple/libmaple/timer.h **** /* Control register 2 (CR2) */
 224:../Libmaple/libmaple/libmaple/timer.h **** 
 225:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS4_BIT              14
 226:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS3N_BIT             13
 227:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS3_BIT              12
 228:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS2N_BIT             11
 229:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS2_BIT              10
 230:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS1N_BIT             9
 231:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS1_BIT              8
 232:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_TI1S_BIT              7 /* tills? yikes */
 233:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCDS_BIT              3
 234:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCUS_BIT              2
 235:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCPC_BIT              0
 236:../Libmaple/libmaple/libmaple/timer.h **** 
 237:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS4                  BIT(TIMER_CR2_OIS4_BIT)
 238:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS3N                 BIT(TIMER_CR2_OIS3N_BIT)
 239:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS3                  BIT(TIMER_CR2_OIS3_BIT)
 240:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS2N                 BIT(TIMER_CR2_OIS2N_BIT)
 241:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS2                  BIT(TIMER_CR2_OIS2_BIT)
 242:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS1N                 BIT(TIMER_CR2_OIS1N_BIT)
 243:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS1                  BIT(TIMER_CR2_OIS1_BIT)
 244:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_TI1S                  BIT(TIMER_CR2_TI1S_BIT)
 245:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS                   (0x7 << 4)
 246:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_RESET             (0x0 << 4)
 247:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_ENABLE            (0x1 << 4)
 248:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_UPDATE            (0x2 << 4)
 249:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_COMPARE_PULSE     (0x3 << 4)
 250:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_COMPARE_OC1REF    (0x4 << 4)
 251:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_COMPARE_OC2REF    (0x5 << 4)
 252:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_COMPARE_OC3REF    (0x6 << 4)
 253:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_COMPARE_OC4REF    (0x7 << 4)
 254:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCDS                  BIT(TIMER_CR2_CCDS_BIT)
 255:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCUS                  BIT(TIMER_CR2_CCUS_BIT)
 256:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCPC                  BIT(TIMER_CR2_CCPC_BIT)
 257:../Libmaple/libmaple/libmaple/timer.h **** 
 258:../Libmaple/libmaple/libmaple/timer.h **** /* Slave mode control register (SMCR) */
 259:../Libmaple/libmaple/libmaple/timer.h **** 
 260:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETP_BIT              15
 261:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ECE_BIT              14
 262:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_MSM_BIT              7
 263:../Libmaple/libmaple/libmaple/timer.h **** 
 264:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETP                  BIT(TIMER_SMCR_ETP_BIT)
 265:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ECE                  BIT(TIMER_SMCR_ECE_BIT)
 266:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETPS                 (0x3 << 12)
 267:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETPS_OFF             (0x0 << 12)
 268:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETPS_DIV2            (0x1 << 12)
 269:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETPS_DIV4            (0x2 << 12)
 270:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETPS_DIV8            (0x3 << 12)
 271:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETF                  (0xF << 12)
 272:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_MSM                  BIT(TIMER_SMCR_MSM_BIT)
 273:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS                   (0x3 << 4)
 274:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_ITR0              (0x0 << 4)
 275:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_ITR1              (0x1 << 4)
 276:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_ITR2              (0x2 << 4)
 277:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_ITR3              (0x3 << 4)
 278:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_TI1F_ED           (0x4 << 4)
 279:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_TI1FP1            (0x5 << 4)
 280:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_TI2FP2            (0x6 << 4)
 281:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_ETRF              (0x7 << 4)
 282:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS                  0x3
 283:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_DISABLED         0x0
 284:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_ENCODER1         0x1
 285:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_ENCODER2         0x2
 286:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_ENCODER3         0x3
 287:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_RESET            0x4
 288:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_GATED            0x5
 289:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_TRIGGER          0x6
 290:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_EXTERNAL         0x7
 291:../Libmaple/libmaple/libmaple/timer.h **** 
 292:../Libmaple/libmaple/libmaple/timer.h **** /* DMA/Interrupt enable register (DIER) */
 293:../Libmaple/libmaple/libmaple/timer.h **** 
 294:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_TDE_BIT              14
 295:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC4DE_BIT            12
 296:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC3DE_BIT            11
 297:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC2DE_BIT            10
 298:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC1DE_BIT            9
 299:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_UDE_BIT              8
 300:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_TIE_BIT              6
 301:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC4IE_BIT            4
 302:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC3IE_BIT            3
 303:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC2IE_BIT            2
 304:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC1IE_BIT            1
 305:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_UIE_BIT              0
 306:../Libmaple/libmaple/libmaple/timer.h **** 
 307:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_TDE                  BIT(TIMER_DIER_TDE_BIT)
 308:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC4DE                BIT(TIMER_DIER_CC4DE_BIT)
 309:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC3DE                BIT(TIMER_DIER_CC3DE_BIT)
 310:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC2DE                BIT(TIMER_DIER_CC2DE_BIT)
 311:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC1DE                BIT(TIMER_DIER_CC1DE_BIT)
 312:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_UDE                  BIT(TIMER_DIER_UDE_BIT)
 313:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_TIE                  BIT(TIMER_DIER_TIE_BIT)
 314:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC4IE                BIT(TIMER_DIER_CC4IE_BIT)
 315:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC3IE                BIT(TIMER_DIER_CC3IE_BIT)
 316:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC2IE                BIT(TIMER_DIER_CC2IE_BIT)
 317:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC1IE                BIT(TIMER_DIER_CC1IE_BIT)
 318:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_UIE                  BIT(TIMER_DIER_UIE_BIT)
 319:../Libmaple/libmaple/libmaple/timer.h **** 
 320:../Libmaple/libmaple/libmaple/timer.h **** /* Status register (SR) */
 321:../Libmaple/libmaple/libmaple/timer.h **** 
 322:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC4OF_BIT              12
 323:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC3OF_BIT              11
 324:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC2OF_BIT              10
 325:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC1OF_BIT              9
 326:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_BIF_BIT                7
 327:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_TIF_BIT                6
 328:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_COMIF_BIT              5
 329:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC4IF_BIT              4
 330:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC3IF_BIT              3
 331:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC2IF_BIT              2
 332:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC1IF_BIT              1
 333:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_UIF_BIT                0
 334:../Libmaple/libmaple/libmaple/timer.h **** 
 335:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC4OF                  BIT(TIMER_SR_CC4OF_BIT)
 336:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC3OF                  BIT(TIMER_SR_CC3OF_BIT)
 337:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC2OF                  BIT(TIMER_SR_CC2OF_BIT)
 338:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC1OF                  BIT(TIMER_SR_CC1OF_BIT)
 339:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_BIF                    BIT(TIMER_SR_BIF_BIT)
 340:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_TIF                    BIT(TIMER_SR_TIF_BIT)
 341:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_COMIF                  BIT(TIMER_SR_COMIF_BIT)
 342:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC4IF                  BIT(TIMER_SR_CC4IF_BIT)
 343:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC3IF                  BIT(TIMER_SR_CC3IF_BIT)
 344:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC2IF                  BIT(TIMER_SR_CC2IF_BIT)
 345:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC1IF                  BIT(TIMER_SR_CC1IF_BIT)
 346:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_UIF                    BIT(TIMER_SR_UIF_BIT)
 347:../Libmaple/libmaple/libmaple/timer.h **** 
 348:../Libmaple/libmaple/libmaple/timer.h **** /* Event generation register (EGR) */
 349:../Libmaple/libmaple/libmaple/timer.h **** 
 350:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_TG_BIT                6
 351:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC4G_BIT              4
 352:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC3G_BIT              3
 353:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC2G_BIT              2
 354:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC1G_BIT              1
 355:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_UG_BIT                0
 356:../Libmaple/libmaple/libmaple/timer.h **** 
 357:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_TG                    BIT(TIMER_EGR_TG_BIT)
 358:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC4G                  BIT(TIMER_EGR_CC4G_BIT)
 359:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC3G                  BIT(TIMER_EGR_CC3G_BIT)
 360:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC2G                  BIT(TIMER_EGR_CC2G_BIT)
 361:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC1G                  BIT(TIMER_EGR_CC1G_BIT)
 362:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_UG                    BIT(TIMER_EGR_UG_BIT)
 363:../Libmaple/libmaple/libmaple/timer.h **** 
 364:../Libmaple/libmaple/libmaple/timer.h **** /* Capture/compare mode registers, common values */
 365:../Libmaple/libmaple/libmaple/timer.h **** 
 366:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR_CCS_OUTPUT           0x0
 367:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR_CCS_INPUT_TI1        0x1
 368:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR_CCS_INPUT_TI2        0x2
 369:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR_CCS_INPUT_TRC        0x3
 370:../Libmaple/libmaple/libmaple/timer.h **** 
 371:../Libmaple/libmaple/libmaple/timer.h **** /* Capture/compare mode register 1 (CCMR1) */
 372:../Libmaple/libmaple/libmaple/timer.h **** 
 373:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2CE_BIT           15
 374:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2PE_BIT           11
 375:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2FE_BIT           10
 376:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1CE_BIT           7
 377:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1PE_BIT           3
 378:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1FE_BIT           2
 379:../Libmaple/libmaple/libmaple/timer.h **** 
 380:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2CE               BIT(TIMER_CCMR1_OC2CE_BIT)
 381:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2M                (0x3 << 12)
 382:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_IC2F                (0xF << 12)
 383:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2PE               BIT(TIMER_CCMR1_OC2PE_BIT)
 384:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2FE               BIT(TIMER_CCMR1_OC2FE_BIT)
 385:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_IC2PSC              (0x3 << 10)
 386:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC2S                (0x3 << 8)
 387:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC2S_OUTPUT         (TIMER_CCMR_CCS_OUTPUT << 8)
 388:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC2S_INPUT_TI1      (TIMER_CCMR_CCS_INPUT_TI1 << 8)
 389:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC2S_INPUT_TI2      (TIMER_CCMR_CCS_INPUT_TI2 << 8)
 390:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC2S_INPUT_TRC      (TIMER_CCMR_CCS_INPUT_TRC << 8)
 391:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1CE               BIT(TIMER_CCMR1_OC1CE_BIT)
 392:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1M                (0x3 << 4)
 393:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_IC1F                (0xF << 4)
 394:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1PE               BIT(TIMER_CCMR1_OC1PE_BIT)
 395:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1FE               BIT(TIMER_CCMR1_OC1FE_BIT)
 396:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_IC1PSC              (0x3 << 2)
 397:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC1S                0x3
 398:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC1S_OUTPUT         TIMER_CCMR_CCS_OUTPUT
 399:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC1S_INPUT_TI1      TIMER_CCMR_CCS_INPUT_TI1
 400:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC1S_INPUT_TI2      TIMER_CCMR_CCS_INPUT_TI2
 401:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC1S_INPUT_TRC      TIMER_CCMR_CCS_INPUT_TRC
 402:../Libmaple/libmaple/libmaple/timer.h **** 
 403:../Libmaple/libmaple/libmaple/timer.h **** /* Capture/compare mode register 2 (CCMR2) */
 404:../Libmaple/libmaple/libmaple/timer.h **** 
 405:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4CE_BIT           15
 406:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4PE_BIT           11
 407:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4FE_BIT           10
 408:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3CE_BIT           7
 409:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3PE_BIT           3
 410:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3FE_BIT           2
 411:../Libmaple/libmaple/libmaple/timer.h **** 
 412:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4CE               BIT(TIMER_CCMR2_OC4CE_BIT)
 413:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4M                (0x3 << 12)
 414:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_IC2F                (0xF << 12)
 415:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4PE               BIT(TIMER_CCMR2_OC4PE_BIT)
 416:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4FE               BIT(TIMER_CCMR2_OC4FE_BIT)
 417:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_IC2PSC              (0x3 << 10)
 418:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_CC4S                (0x3 << 8)
 419:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC4S_OUTPUT         (TIMER_CCMR_CCS_OUTPUT << 8)
 420:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC4S_INPUT_TI1      (TIMER_CCMR_CCS_INPUT_TI1 << 8)
 421:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC4S_INPUT_TI2      (TIMER_CCMR_CCS_INPUT_TI2 << 8)
 422:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC4S_INPUT_TRC      (TIMER_CCMR_CCS_INPUT_TRC << 8)
 423:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3CE               BIT(TIMER_CCMR2_OC3CE_BIT)
 424:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3M                (0x3 << 4)
 425:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_IC1F                (0xF << 4)
 426:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3PE               BIT(TIMER_CCMR2_OC3PE_BIT)
 427:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3FE               BIT(TIMER_CCMR2_OC3FE_BIT)
 428:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_IC1PSC              (0x3 << 2)
 429:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_CC3S                0x3
 430:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC3S_OUTPUT         TIMER_CCMR_CCS_OUTPUT
 431:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC3S_INPUT_TI1      TIMER_CCMR_CCS_INPUT_TI1
 432:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC3S_INPUT_TI2      TIMER_CCMR_CCS_INPUT_TI2
 433:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC3S_INPUT_TRC      TIMER_CCMR_CCS_INPUT_TRC
 434:../Libmaple/libmaple/libmaple/timer.h **** 
 435:../Libmaple/libmaple/libmaple/timer.h **** /* Capture/compare enable register (CCER) */
 436:../Libmaple/libmaple/libmaple/timer.h **** 
 437:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC4P_BIT             13
 438:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC4E_BIT             12
 439:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC3P_BIT             9
 440:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC3E_BIT             8
 441:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC2P_BIT             5
 442:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC2E_BIT             4
 443:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC1P_BIT             1
 444:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC1E_BIT             0
 445:../Libmaple/libmaple/libmaple/timer.h **** 
 446:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC4P                 BIT(TIMER_CCER_CC4P_BIT)
 447:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC4E                 BIT(TIMER_CCER_CC4E_BIT)
 448:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC3P                 BIT(TIMER_CCER_CC3P_BIT)
 449:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC3E                 BIT(TIMER_CCER_CC3E_BIT)
 450:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC2P                 BIT(TIMER_CCER_CC2P_BIT)
 451:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC2E                 BIT(TIMER_CCER_CC2E_BIT)
 452:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC1P                 BIT(TIMER_CCER_CC1P_BIT)
 453:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC1E                 BIT(TIMER_CCER_CC1E_BIT)
 454:../Libmaple/libmaple/libmaple/timer.h **** 
 455:../Libmaple/libmaple/libmaple/timer.h **** /* Break and dead-time register (BDTR) */
 456:../Libmaple/libmaple/libmaple/timer.h **** 
 457:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_MOE_BIT              15
 458:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_AOE_BIT              14
 459:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_BKP_BIT              13
 460:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_BKE_BIT              12
 461:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_OSSR_BIT             11
 462:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_OSSI_BIT             10
 463:../Libmaple/libmaple/libmaple/timer.h **** 
 464:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_MOE                  BIT(TIMER_BDTR_MOE_BIT)
 465:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_AOE                  BIT(TIMER_BDTR_AOE_BIT)
 466:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_BKP                  BIT(TIMER_BDTR_BKP_BIT)
 467:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_BKE                  BIT(TIMER_BDTR_BKE_BIT)
 468:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_OSSR                 BIT(TIMER_BDTR_OSSR_BIT)
 469:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_OSSI                 BIT(TIMER_BDTR_OSSI_BIT)
 470:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_LOCK                 (0x3 << 8)
 471:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_LOCK_OFF             (0x0 << 8)
 472:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_LOCK_LEVEL1          (0x1 << 8)
 473:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_LOCK_LEVEL2          (0x2 << 8)
 474:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_LOCK_LEVEL3          (0x3 << 8)
 475:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_DTG                  0xFF
 476:../Libmaple/libmaple/libmaple/timer.h **** 
 477:../Libmaple/libmaple/libmaple/timer.h **** /* DMA control register (DCR) */
 478:../Libmaple/libmaple/libmaple/timer.h **** 
 479:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL                   (0x1F << 8)
 480:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_1BYTE             (0x0 << 8)
 481:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_2BYTE             (0x1 << 8)
 482:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_3BYTE             (0x2 << 8)
 483:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_4BYTE             (0x3 << 8)
 484:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_5BYTE             (0x4 << 8)
 485:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_6BYTE             (0x5 << 8)
 486:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_7BYTE             (0x6 << 8)
 487:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_8BYTE             (0x7 << 8)
 488:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_9BYTE             (0x8 << 8)
 489:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_10BYTE            (0x9 << 8)
 490:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_11BYTE            (0xA << 8)
 491:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_12BYTE            (0xB << 8)
 492:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_13BYTE            (0xC << 8)
 493:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_14BYTE            (0xD << 8)
 494:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_15BYTE            (0xE << 8)
 495:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_16BYTE            (0xF << 8)
 496:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_17BYTE            (0x10 << 8)
 497:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_18BYTE            (0x11 << 8)
 498:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA                   0x1F
 499:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CR1               0x0
 500:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CR2               0x1
 501:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_SMCR              0x2
 502:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_DIER              0x3
 503:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_SR                0x4
 504:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_EGR               0x5
 505:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCMR1             0x6
 506:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCMR2             0x7
 507:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCER              0x8
 508:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CNT               0x9
 509:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_PSC               0xA
 510:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_ARR               0xB
 511:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_RCR               0xC
 512:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCR1              0xD
 513:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCR2              0xE
 514:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCR3              0xF
 515:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCR4              0x10
 516:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_BDTR              0x11
 517:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_DCR               0x12
 518:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_DMAR              0x13
 519:../Libmaple/libmaple/libmaple/timer.h **** 
 520:../Libmaple/libmaple/libmaple/timer.h **** /*
 521:../Libmaple/libmaple/libmaple/timer.h ****  * Convenience routines
 522:../Libmaple/libmaple/libmaple/timer.h ****  */
 523:../Libmaple/libmaple/libmaple/timer.h **** 
 524:../Libmaple/libmaple/libmaple/timer.h **** /**
 525:../Libmaple/libmaple/libmaple/timer.h ****  * Used to configure the behavior of a timer channel.  Note that not
 526:../Libmaple/libmaple/libmaple/timer.h ****  * all timers can be configured in every mode.
 527:../Libmaple/libmaple/libmaple/timer.h ****  */
 528:../Libmaple/libmaple/libmaple/timer.h **** /* TODO TIMER_PWM_CENTER_ALIGNED, TIMER_INPUT_CAPTURE, TIMER_ONE_PULSE */
 529:../Libmaple/libmaple/libmaple/timer.h **** typedef enum timer_mode {
 530:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_DISABLED, /**< In this mode, the timer stops counting,
 531:../Libmaple/libmaple/libmaple/timer.h ****                          channel interrupts are detached, and no state
 532:../Libmaple/libmaple/libmaple/timer.h ****                          changes are output. */
 533:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_PWM, /**< PWM output mode. This is the default mode for pins
 534:../Libmaple/libmaple/libmaple/timer.h ****                     after initialization. */
 535:../Libmaple/libmaple/libmaple/timer.h ****     /* TIMER_PWM_CENTER_ALIGNED, /\**< Center-aligned PWM output mode. *\/ */
 536:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_OUTPUT_COMPARE, /**< In this mode, the timer counts from 0
 537:../Libmaple/libmaple/libmaple/timer.h ****                                to its reload value repeatedly; every
 538:../Libmaple/libmaple/libmaple/timer.h ****                                time the counter value reaches one of
 539:../Libmaple/libmaple/libmaple/timer.h ****                                the channel compare values, the
 540:../Libmaple/libmaple/libmaple/timer.h ****                                corresponding interrupt is fired. */
 541:../Libmaple/libmaple/libmaple/timer.h ****     /* TIMER_INPUT_CAPTURE, /\**< In this mode, the timer can measure the */
 542:../Libmaple/libmaple/libmaple/timer.h ****     /*                           pulse lengths of input signals. *\/ */
 543:../Libmaple/libmaple/libmaple/timer.h ****     /* TIMER_ONE_PULSE /\**< In this mode, the timer can generate a single */
 544:../Libmaple/libmaple/libmaple/timer.h ****     /*                      pulse on a GPIO pin for a specified amount of */
 545:../Libmaple/libmaple/libmaple/timer.h ****     /*                      time. *\/ */
 546:../Libmaple/libmaple/libmaple/timer.h **** } timer_mode;
 547:../Libmaple/libmaple/libmaple/timer.h **** 
 548:../Libmaple/libmaple/libmaple/timer.h **** /** Timer channel numbers */
 549:../Libmaple/libmaple/libmaple/timer.h **** typedef enum timer_channel {
 550:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CH1 = 1, /**< Channel 1 */
 551:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CH2 = 2, /**< Channel 2 */
 552:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CH3 = 3, /**< Channel 3 */
 553:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CH4 = 4  /**< Channel 4 */
 554:../Libmaple/libmaple/libmaple/timer.h **** } timer_channel;
 555:../Libmaple/libmaple/libmaple/timer.h **** 
 556:../Libmaple/libmaple/libmaple/timer.h **** /*
 557:../Libmaple/libmaple/libmaple/timer.h ****  * Note: Don't require timer_channel arguments! We want to be able to say
 558:../Libmaple/libmaple/libmaple/timer.h ****  *
 559:../Libmaple/libmaple/libmaple/timer.h ****  * for (int channel = 1; channel <= 4; channel++) {
 560:../Libmaple/libmaple/libmaple/timer.h ****  *    ...
 561:../Libmaple/libmaple/libmaple/timer.h ****  * }
 562:../Libmaple/libmaple/libmaple/timer.h ****  *
 563:../Libmaple/libmaple/libmaple/timer.h ****  * without the compiler yelling at us.
 564:../Libmaple/libmaple/libmaple/timer.h ****  */
 565:../Libmaple/libmaple/libmaple/timer.h **** 
 566:../Libmaple/libmaple/libmaple/timer.h **** void timer_init(timer_dev *dev);
 567:../Libmaple/libmaple/libmaple/timer.h **** void timer_disable(timer_dev *dev);
 568:../Libmaple/libmaple/libmaple/timer.h **** void timer_set_mode(timer_dev *dev, uint8 channel, timer_mode mode);
 569:../Libmaple/libmaple/libmaple/timer.h **** void timer_foreach(void (*fn)(timer_dev*));
 570:../Libmaple/libmaple/libmaple/timer.h **** 
 571:../Libmaple/libmaple/libmaple/timer.h **** /**
 572:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Timer interrupt number.
 573:../Libmaple/libmaple/libmaple/timer.h ****  *
 574:../Libmaple/libmaple/libmaple/timer.h ****  * Not all timers support all of these values; see the descriptions
 575:../Libmaple/libmaple/libmaple/timer.h ****  * for each value.
 576:../Libmaple/libmaple/libmaple/timer.h ****  */
 577:../Libmaple/libmaple/libmaple/timer.h **** typedef enum timer_interrupt_id {
 578:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_UPDATE_INTERRUPT, /**< Update interrupt, available on all timers. */
 579:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CC1_INTERRUPT, /**< Capture/compare 1 interrupt, available
 580:../Libmaple/libmaple/libmaple/timer.h ****                               on general and advanced timers only. */
 581:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CC2_INTERRUPT, /**< Capture/compare 2 interrupt, general and
 582:../Libmaple/libmaple/libmaple/timer.h ****                               advanced timers only. */
 583:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CC3_INTERRUPT, /**< Capture/compare 3 interrupt, general and
 584:../Libmaple/libmaple/libmaple/timer.h ****                               advanced timers only. */
 585:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CC4_INTERRUPT, /**< Capture/compare 4 interrupt, general and
 586:../Libmaple/libmaple/libmaple/timer.h ****                               advanced timers only. */
 587:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_COM_INTERRUPT, /**< COM interrupt, advanced timers only */
 588:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_TRG_INTERRUPT, /**< Trigger interrupt, general and advanced
 589:../Libmaple/libmaple/libmaple/timer.h ****                               timers only */
 590:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_BREAK_INTERRUPT /**< Break interrupt, advanced timers only. */
 591:../Libmaple/libmaple/libmaple/timer.h **** } timer_interrupt_id;
 592:../Libmaple/libmaple/libmaple/timer.h **** 
 593:../Libmaple/libmaple/libmaple/timer.h **** void timer_attach_interrupt(timer_dev *dev,
 594:../Libmaple/libmaple/libmaple/timer.h ****                             uint8 interrupt,
 595:../Libmaple/libmaple/libmaple/timer.h ****                             voidFuncPtr handler);
 596:../Libmaple/libmaple/libmaple/timer.h **** void timer_detach_interrupt(timer_dev *dev, uint8 interrupt);
 597:../Libmaple/libmaple/libmaple/timer.h **** 
 598:../Libmaple/libmaple/libmaple/timer.h **** /**
 599:../Libmaple/libmaple/libmaple/timer.h ****  * Initialize all timer devices on the chip.
 600:../Libmaple/libmaple/libmaple/timer.h ****  */
 601:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_init_all(void) {
 602:../Libmaple/libmaple/libmaple/timer.h ****     timer_foreach(timer_init);
 603:../Libmaple/libmaple/libmaple/timer.h **** }
 604:../Libmaple/libmaple/libmaple/timer.h **** 
 605:../Libmaple/libmaple/libmaple/timer.h **** /**
 606:../Libmaple/libmaple/libmaple/timer.h ****  * Disables all timers on the device.
 607:../Libmaple/libmaple/libmaple/timer.h ****  */
 608:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_disable_all(void) {
 609:../Libmaple/libmaple/libmaple/timer.h ****     timer_foreach(timer_disable);
 610:../Libmaple/libmaple/libmaple/timer.h **** }
 611:../Libmaple/libmaple/libmaple/timer.h **** 
 612:../Libmaple/libmaple/libmaple/timer.h **** /**
 613:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Stop a timer's counter from changing.
 614:../Libmaple/libmaple/libmaple/timer.h ****  *
 615:../Libmaple/libmaple/libmaple/timer.h ****  * Does not affect the timer's mode or other settings.
 616:../Libmaple/libmaple/libmaple/timer.h ****  *
 617:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Device whose counter to pause.
 618:../Libmaple/libmaple/libmaple/timer.h ****  */
 619:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_pause(timer_dev *dev) {
 620:../Libmaple/libmaple/libmaple/timer.h ****     *bb_perip(&(dev->regs).bas->CR1, TIMER_CR1_CEN_BIT) = 0;
 621:../Libmaple/libmaple/libmaple/timer.h **** }
 622:../Libmaple/libmaple/libmaple/timer.h **** 
 623:../Libmaple/libmaple/libmaple/timer.h **** /**
 624:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Start a timer's counter.
 625:../Libmaple/libmaple/libmaple/timer.h ****  *
 626:../Libmaple/libmaple/libmaple/timer.h ****  * Does not affect the timer's mode or other settings.
 627:../Libmaple/libmaple/libmaple/timer.h ****  *
 628:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Device whose counter to resume
 629:../Libmaple/libmaple/libmaple/timer.h ****  */
 630:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_resume(timer_dev *dev) {
 631:../Libmaple/libmaple/libmaple/timer.h ****     *bb_perip(&(dev->regs).bas->CR1, TIMER_CR1_CEN_BIT) = 1;
 632:../Libmaple/libmaple/libmaple/timer.h **** }
 633:../Libmaple/libmaple/libmaple/timer.h **** 
 634:../Libmaple/libmaple/libmaple/timer.h **** /**
 635:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Returns the timer's counter value.
 636:../Libmaple/libmaple/libmaple/timer.h ****  *
 637:../Libmaple/libmaple/libmaple/timer.h ****  * This value is likely to be inaccurate if the counter is running
 638:../Libmaple/libmaple/libmaple/timer.h ****  * with a low prescaler.
 639:../Libmaple/libmaple/libmaple/timer.h ****  *
 640:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose counter to return
 641:../Libmaple/libmaple/libmaple/timer.h ****  */
 642:../Libmaple/libmaple/libmaple/timer.h **** static inline uint16 timer_get_count(timer_dev *dev) {
 643:../Libmaple/libmaple/libmaple/timer.h ****     return (uint16)(dev->regs).bas->CNT;
 644:../Libmaple/libmaple/libmaple/timer.h **** }
 645:../Libmaple/libmaple/libmaple/timer.h **** 
 646:../Libmaple/libmaple/libmaple/timer.h **** /**
 647:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Sets the counter value for the given timer.
 648:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose counter to set
 649:../Libmaple/libmaple/libmaple/timer.h ****  * @param value New counter value
 650:../Libmaple/libmaple/libmaple/timer.h ****  */
 651:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_set_count(timer_dev *dev, uint16 value) {
 652:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->CNT = value;
 653:../Libmaple/libmaple/libmaple/timer.h **** }
 654:../Libmaple/libmaple/libmaple/timer.h **** 
 655:../Libmaple/libmaple/libmaple/timer.h **** /**
 656:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Returns the given timer's prescaler.
 657:../Libmaple/libmaple/libmaple/timer.h ****  *
 658:../Libmaple/libmaple/libmaple/timer.h ****  * Note that if the timer's prescaler is set (e.g. via
 659:../Libmaple/libmaple/libmaple/timer.h ****  * timer_set_prescaler() or accessing a TIMx_PSC register), the value
 660:../Libmaple/libmaple/libmaple/timer.h ****  * returned by this function will reflect the new setting, but the
 661:../Libmaple/libmaple/libmaple/timer.h ****  * timer's counter will only reflect the new prescaler at the next
 662:../Libmaple/libmaple/libmaple/timer.h ****  * update event.
 663:../Libmaple/libmaple/libmaple/timer.h ****  *
 664:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose prescaler to return
 665:../Libmaple/libmaple/libmaple/timer.h ****  * @see timer_generate_update()
 666:../Libmaple/libmaple/libmaple/timer.h ****  */
 667:../Libmaple/libmaple/libmaple/timer.h **** static inline uint16 timer_get_prescaler(timer_dev *dev) {
 668:../Libmaple/libmaple/libmaple/timer.h ****     return (uint16)(dev->regs).bas->PSC;
 669:../Libmaple/libmaple/libmaple/timer.h **** }
 670:../Libmaple/libmaple/libmaple/timer.h **** 
 671:../Libmaple/libmaple/libmaple/timer.h **** /**
 672:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Set a timer's prescale value.
 673:../Libmaple/libmaple/libmaple/timer.h ****  *
 674:../Libmaple/libmaple/libmaple/timer.h ****  * Divides the input clock by (PSC+1).  The new value will not take
 675:../Libmaple/libmaple/libmaple/timer.h ****  * effect until the next update event.
 676:../Libmaple/libmaple/libmaple/timer.h ****  *
 677:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose prescaler to set
 678:../Libmaple/libmaple/libmaple/timer.h ****  * @param psc New prescaler value
 679:../Libmaple/libmaple/libmaple/timer.h ****  * @see timer_generate_update()
 680:../Libmaple/libmaple/libmaple/timer.h ****  */
 681:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_set_prescaler(timer_dev *dev, uint16 psc) {
 682:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->PSC = psc;
 683:../Libmaple/libmaple/libmaple/timer.h **** }
 684:../Libmaple/libmaple/libmaple/timer.h **** 
 685:../Libmaple/libmaple/libmaple/timer.h **** /**
 686:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Returns a timer's reload value.
 687:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose reload value to return
 688:../Libmaple/libmaple/libmaple/timer.h ****  */
 689:../Libmaple/libmaple/libmaple/timer.h **** static inline uint16 timer_get_reload(timer_dev *dev) {
 690:../Libmaple/libmaple/libmaple/timer.h ****     return (uint16)(dev->regs).bas->ARR;
 691:../Libmaple/libmaple/libmaple/timer.h **** }
 692:../Libmaple/libmaple/libmaple/timer.h **** 
 693:../Libmaple/libmaple/libmaple/timer.h **** /**
 694:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Set a timer's reload value.
 695:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose reload value to set
 696:../Libmaple/libmaple/libmaple/timer.h ****  * @param arr New reload value to use.  Takes effect at next update event.
 697:../Libmaple/libmaple/libmaple/timer.h ****  * @see timer_generate_update()
 698:../Libmaple/libmaple/libmaple/timer.h ****  */
 699:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_set_reload(timer_dev *dev, uint16 arr) {
 700:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->ARR = arr;
 701:../Libmaple/libmaple/libmaple/timer.h **** }
 702:../Libmaple/libmaple/libmaple/timer.h **** 
 703:../Libmaple/libmaple/libmaple/timer.h **** /**
 704:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Get the compare value for the given timer channel.
 705:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer device, must have type TIMER_ADVANCED or TIMER_GENERAL.
 706:../Libmaple/libmaple/libmaple/timer.h ****  * @param channel Channel whose compare value to get.
 707:../Libmaple/libmaple/libmaple/timer.h ****  */
 708:../Libmaple/libmaple/libmaple/timer.h **** static inline uint16 timer_get_compare(timer_dev *dev, uint8 channel) {
 709:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 *ccr = &(dev->regs).gen->CCR1 + (channel - 1);
 710:../Libmaple/libmaple/libmaple/timer.h ****     return *ccr;
 711:../Libmaple/libmaple/libmaple/timer.h **** }
 712:../Libmaple/libmaple/libmaple/timer.h **** 
 713:../Libmaple/libmaple/libmaple/timer.h **** /**
 714:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Set the compare value for the given timer channel.
 715:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer device, must have type TIMER_ADVANCED or TIMER_GENERAL.
 716:../Libmaple/libmaple/libmaple/timer.h ****  * @param channel Channel whose compare value to set.
 717:../Libmaple/libmaple/libmaple/timer.h ****  * @param value   New compare value.
 718:../Libmaple/libmaple/libmaple/timer.h ****  */
 719:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_set_compare(timer_dev *dev,
 720:../Libmaple/libmaple/libmaple/timer.h ****                                      uint8 channel,
 721:../Libmaple/libmaple/libmaple/timer.h ****                                      uint16 value) {
  27              		.loc 1 721 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32              	.LVL0:
  33              	.LBB2:
 722:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 *ccr = &(dev->regs).gen->CCR1 + (channel - 1);
  34              		.loc 1 722 0
  35 0000 0368     		ldr	r3, [r0, #0]
  36 0002 0139     		subs	r1, r1, #1
  37              	.LVL1:
  38 0004 3433     		adds	r3, r3, #52
  39              	.LVL2:
 723:../Libmaple/libmaple/libmaple/timer.h ****     *ccr = value;
  40              		.loc 1 723 0
  41 0006 43F82120 		str	r2, [r3, r1, lsl #2]
  42              	.LBE2:
 724:../Libmaple/libmaple/libmaple/timer.h **** }
  43              		.loc 1 724 0
  44 000a 7047     		bx	lr
  45              		.cfi_endproc
  46              	.LFE30:
  48              		.section	.text._ZL6millisv,"ax",%progbits
  49              		.align	1
  50              		.thumb
  51              		.thumb_func
  53              	_ZL6millisv:
  54              	.LFB55:
  55              		.file 2 "../Libmaple/libmaple/wirish/wirish_time.h"
   1:../Libmaple/libmaple/wirish/wirish_time.h **** /******************************************************************************
   2:../Libmaple/libmaple/wirish/wirish_time.h ****  * The MIT License
   3:../Libmaple/libmaple/wirish/wirish_time.h ****  *
   4:../Libmaple/libmaple/wirish/wirish_time.h ****  * Copyright (c) 2010 Perry Hung.
   5:../Libmaple/libmaple/wirish/wirish_time.h ****  *
   6:../Libmaple/libmaple/wirish/wirish_time.h ****  * Permission is hereby granted, free of charge, to any person
   7:../Libmaple/libmaple/wirish/wirish_time.h ****  * obtaining a copy of this software and associated documentation
   8:../Libmaple/libmaple/wirish/wirish_time.h ****  * files (the "Software"), to deal in the Software without
   9:../Libmaple/libmaple/wirish/wirish_time.h ****  * restriction, including without limitation the rights to use, copy,
  10:../Libmaple/libmaple/wirish/wirish_time.h ****  * modify, merge, publish, distribute, sublicense, and/or sell copies
  11:../Libmaple/libmaple/wirish/wirish_time.h ****  * of the Software, and to permit persons to whom the Software is
  12:../Libmaple/libmaple/wirish/wirish_time.h ****  * furnished to do so, subject to the following conditions:
  13:../Libmaple/libmaple/wirish/wirish_time.h ****  *
  14:../Libmaple/libmaple/wirish/wirish_time.h ****  * The above copyright notice and this permission notice shall be
  15:../Libmaple/libmaple/wirish/wirish_time.h ****  * included in all copies or substantial portions of the Software.
  16:../Libmaple/libmaple/wirish/wirish_time.h ****  *
  17:../Libmaple/libmaple/wirish/wirish_time.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  18:../Libmaple/libmaple/wirish/wirish_time.h ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  19:../Libmaple/libmaple/wirish/wirish_time.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20:../Libmaple/libmaple/wirish/wirish_time.h ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  21:../Libmaple/libmaple/wirish/wirish_time.h ****  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  22:../Libmaple/libmaple/wirish/wirish_time.h ****  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  23:../Libmaple/libmaple/wirish/wirish_time.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  24:../Libmaple/libmaple/wirish/wirish_time.h ****  * SOFTWARE.
  25:../Libmaple/libmaple/wirish/wirish_time.h ****  *****************************************************************************/
  26:../Libmaple/libmaple/wirish/wirish_time.h **** 
  27:../Libmaple/libmaple/wirish/wirish_time.h **** /**
  28:../Libmaple/libmaple/wirish/wirish_time.h ****  * @file wirish_time.h
  29:../Libmaple/libmaple/wirish/wirish_time.h ****  * @brief Timing and delay functions.
  30:../Libmaple/libmaple/wirish/wirish_time.h ****  */
  31:../Libmaple/libmaple/wirish/wirish_time.h **** 
  32:../Libmaple/libmaple/wirish/wirish_time.h **** #ifndef __WIRISH_TIME_H_
  33:../Libmaple/libmaple/wirish/wirish_time.h **** #define __WIRISH_TIME_H_
  34:../Libmaple/libmaple/wirish/wirish_time.h **** 
  35:../Libmaple/libmaple/wirish/wirish_time.h **** #include "libmaple.h"
  36:../Libmaple/libmaple/wirish/wirish_time.h **** #include "nvic.h"
  37:../Libmaple/libmaple/wirish/wirish_time.h **** #include "systick.h"
  38:../Libmaple/libmaple/wirish/wirish_time.h **** #include "boards.h"
  39:../Libmaple/libmaple/wirish/wirish_time.h **** 
  40:../Libmaple/libmaple/wirish/wirish_time.h **** #define US_PER_MS               1000
  41:../Libmaple/libmaple/wirish/wirish_time.h **** 
  42:../Libmaple/libmaple/wirish/wirish_time.h **** /**
  43:../Libmaple/libmaple/wirish/wirish_time.h ****  * Returns time (in milliseconds) since the beginning of program
  44:../Libmaple/libmaple/wirish/wirish_time.h ****  * execution. On overflow, restarts at 0.
  45:../Libmaple/libmaple/wirish/wirish_time.h ****  * @see micros()
  46:../Libmaple/libmaple/wirish/wirish_time.h ****  */
  47:../Libmaple/libmaple/wirish/wirish_time.h **** static inline uint32 millis(void) {
  56              		.loc 2 47 0
  57              		.cfi_startproc
  58              		@ args = 0, pretend = 0, frame = 0
  59              		@ frame_needed = 0, uses_anonymous_args = 0
  60              		@ link register save eliminated.
  61              	.LBB5:
  62              	.LBB6:
  63              		.file 3 "../Libmaple/libmaple/libmaple/systick.h"
   1:../Libmaple/libmaple/libmaple/systick.h **** /******************************************************************************
   2:../Libmaple/libmaple/libmaple/systick.h ****  * The MIT License
   3:../Libmaple/libmaple/libmaple/systick.h ****  *
   4:../Libmaple/libmaple/libmaple/systick.h ****  * Copyright (c) 2010 Perry Hung.
   5:../Libmaple/libmaple/libmaple/systick.h ****  *
   6:../Libmaple/libmaple/libmaple/systick.h ****  * Permission is hereby granted, free of charge, to any person
   7:../Libmaple/libmaple/libmaple/systick.h ****  * obtaining a copy of this software and associated documentation
   8:../Libmaple/libmaple/libmaple/systick.h ****  * files (the "Software"), to deal in the Software without
   9:../Libmaple/libmaple/libmaple/systick.h ****  * restriction, including without limitation the rights to use, copy,
  10:../Libmaple/libmaple/libmaple/systick.h ****  * modify, merge, publish, distribute, sublicense, and/or sell copies
  11:../Libmaple/libmaple/libmaple/systick.h ****  * of the Software, and to permit persons to whom the Software is
  12:../Libmaple/libmaple/libmaple/systick.h ****  * furnished to do so, subject to the following conditions:
  13:../Libmaple/libmaple/libmaple/systick.h ****  *
  14:../Libmaple/libmaple/libmaple/systick.h ****  * The above copyright notice and this permission notice shall be
  15:../Libmaple/libmaple/libmaple/systick.h ****  * included in all copies or substantial portions of the Software.
  16:../Libmaple/libmaple/libmaple/systick.h ****  *
  17:../Libmaple/libmaple/libmaple/systick.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  18:../Libmaple/libmaple/libmaple/systick.h ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  19:../Libmaple/libmaple/libmaple/systick.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20:../Libmaple/libmaple/libmaple/systick.h ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  21:../Libmaple/libmaple/libmaple/systick.h ****  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  22:../Libmaple/libmaple/libmaple/systick.h ****  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  23:../Libmaple/libmaple/libmaple/systick.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  24:../Libmaple/libmaple/libmaple/systick.h ****  * SOFTWARE.
  25:../Libmaple/libmaple/libmaple/systick.h ****  *****************************************************************************/
  26:../Libmaple/libmaple/libmaple/systick.h **** 
  27:../Libmaple/libmaple/libmaple/systick.h **** /**
  28:../Libmaple/libmaple/libmaple/systick.h ****  * @file systick.h
  29:../Libmaple/libmaple/libmaple/systick.h ****  *
  30:../Libmaple/libmaple/libmaple/systick.h ****  * @brief Various system timer definitions
  31:../Libmaple/libmaple/libmaple/systick.h ****  */
  32:../Libmaple/libmaple/libmaple/systick.h **** 
  33:../Libmaple/libmaple/libmaple/systick.h **** #ifndef _SYSTICK_H_
  34:../Libmaple/libmaple/libmaple/systick.h **** #define _SYSTICK_H_
  35:../Libmaple/libmaple/libmaple/systick.h **** 
  36:../Libmaple/libmaple/libmaple/systick.h **** #include "libmaple_types.h"
  37:../Libmaple/libmaple/libmaple/systick.h **** #include "util.h"
  38:../Libmaple/libmaple/libmaple/systick.h **** 
  39:../Libmaple/libmaple/libmaple/systick.h **** #ifdef __cplusplus
  40:../Libmaple/libmaple/libmaple/systick.h **** extern "C"{
  41:../Libmaple/libmaple/libmaple/systick.h **** #endif
  42:../Libmaple/libmaple/libmaple/systick.h **** 
  43:../Libmaple/libmaple/libmaple/systick.h **** /** SysTick register map type */
  44:../Libmaple/libmaple/libmaple/systick.h **** typedef struct systick_reg_map {
  45:../Libmaple/libmaple/libmaple/systick.h ****     __io uint32 CSR;            /**< Control and status register */
  46:../Libmaple/libmaple/libmaple/systick.h ****     __io uint32 RVR;            /**< Reload value register */
  47:../Libmaple/libmaple/libmaple/systick.h ****     __io uint32 CNT;            /**< Current value register ("count") */
  48:../Libmaple/libmaple/libmaple/systick.h ****     __io uint32 CVR;            /**< Calibration value register */
  49:../Libmaple/libmaple/libmaple/systick.h **** } systick_reg_map;
  50:../Libmaple/libmaple/libmaple/systick.h **** 
  51:../Libmaple/libmaple/libmaple/systick.h **** /** SysTick register map base pointer */
  52:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_BASE                    ((struct systick_reg_map*)0xE000E010)
  53:../Libmaple/libmaple/libmaple/systick.h **** 
  54:../Libmaple/libmaple/libmaple/systick.h **** /*
  55:../Libmaple/libmaple/libmaple/systick.h ****  * Register bit definitions.
  56:../Libmaple/libmaple/libmaple/systick.h ****  */
  57:../Libmaple/libmaple/libmaple/systick.h **** 
  58:../Libmaple/libmaple/libmaple/systick.h **** /* Control and status register */
  59:../Libmaple/libmaple/libmaple/systick.h **** 
  60:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_COUNTFLAG           BIT(16)
  61:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_CLKSOURCE           BIT(2)
  62:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_CLKSOURCE_EXTERNAL  0
  63:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_CLKSOURCE_CORE      BIT(2)
  64:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_TICKINT             BIT(1)
  65:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_TICKINT_PEND        BIT(1)
  66:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_TICKINT_NO_PEND     0
  67:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_ENABLE              BIT(0)
  68:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_ENABLE_MULTISHOT    BIT(0)
  69:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_ENABLE_DISABLED     0
  70:../Libmaple/libmaple/libmaple/systick.h **** 
  71:../Libmaple/libmaple/libmaple/systick.h **** /* Calibration value register */
  72:../Libmaple/libmaple/libmaple/systick.h **** 
  73:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CVR_NOREF               BIT(31)
  74:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CVR_SKEW                BIT(30)
  75:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CVR_TENMS               0xFFFFFF
  76:../Libmaple/libmaple/libmaple/systick.h **** 
  77:../Libmaple/libmaple/libmaple/systick.h **** /** System elapsed time, in milliseconds */
  78:../Libmaple/libmaple/libmaple/systick.h **** extern volatile uint32 systick_uptime_millis;
  79:../Libmaple/libmaple/libmaple/systick.h **** 
  80:../Libmaple/libmaple/libmaple/systick.h **** /**
  81:../Libmaple/libmaple/libmaple/systick.h ****  * @brief Returns the system uptime, in milliseconds.
  82:../Libmaple/libmaple/libmaple/systick.h ****  */
  83:../Libmaple/libmaple/libmaple/systick.h **** static inline uint32 systick_uptime(void) {
  84:../Libmaple/libmaple/libmaple/systick.h ****     return systick_uptime_millis;
  64              		.loc 3 84 0
  65 0000 014B     		ldr	r3, .L3
  66 0002 1868     		ldr	r0, [r3, #0]
  67              	.LBE6:
  68              	.LBE5:
  48:../Libmaple/libmaple/wirish/wirish_time.h ****     return systick_uptime();
  49:../Libmaple/libmaple/wirish/wirish_time.h **** }
  69              		.loc 2 49 0
  70 0004 7047     		bx	lr
  71              	.L4:
  72 0006 00BF     		.align	2
  73              	.L3:
  74 0008 00000000 		.word	systick_uptime_millis
  75              		.cfi_endproc
  76              	.LFE55:
  78              		.section	.text._ZL6microsv,"ax",%progbits
  79              		.align	1
  80              		.thumb
  81              		.thumb_func
  83              	_ZL6microsv:
  84              	.LFB56:
  50:../Libmaple/libmaple/wirish/wirish_time.h **** 
  51:../Libmaple/libmaple/wirish/wirish_time.h **** /**
  52:../Libmaple/libmaple/wirish/wirish_time.h ****  * Returns time (in microseconds) since the beginning of program
  53:../Libmaple/libmaple/wirish/wirish_time.h ****  * execution.  On overflow, restarts at 0.
  54:../Libmaple/libmaple/wirish/wirish_time.h ****  * @see millis()
  55:../Libmaple/libmaple/wirish/wirish_time.h ****  */
  56:../Libmaple/libmaple/wirish/wirish_time.h **** static inline uint32 micros(void) {
  85              		.loc 2 56 0
  86              		.cfi_startproc
  87              		@ args = 0, pretend = 0, frame = 0
  88              		@ frame_needed = 0, uses_anonymous_args = 0
  89 0000 38B5     		push	{r3, r4, r5, lr}
  90              	.LCFI0:
  91              		.cfi_def_cfa_offset 16
  92              		.cfi_offset 14, -4
  93              		.cfi_offset 5, -8
  94              		.cfi_offset 4, -12
  95              		.cfi_offset 3, -16
  96              	.L6:
  97              	.LBB10:
  57:../Libmaple/libmaple/wirish/wirish_time.h ****     uint32 ms;
  58:../Libmaple/libmaple/wirish/wirish_time.h ****     uint32 cycle_cnt;
  59:../Libmaple/libmaple/wirish/wirish_time.h ****     uint32 res;
  60:../Libmaple/libmaple/wirish/wirish_time.h **** 
  61:../Libmaple/libmaple/wirish/wirish_time.h ****     do {
  62:../Libmaple/libmaple/wirish/wirish_time.h ****         ms = millis();
  98              		.loc 2 62 0 discriminator 1
  99 0002 FFF7FEFF 		bl	_ZL6millisv
 100              	.LBB11:
 101              	.LBB12:
  85:../Libmaple/libmaple/libmaple/systick.h **** }
  86:../Libmaple/libmaple/libmaple/systick.h **** 
  87:../Libmaple/libmaple/libmaple/systick.h **** 
  88:../Libmaple/libmaple/libmaple/systick.h **** void systick_init(uint32 reload_val);
  89:../Libmaple/libmaple/libmaple/systick.h **** void systick_disable();
  90:../Libmaple/libmaple/libmaple/systick.h **** void systick_enable();
  91:../Libmaple/libmaple/libmaple/systick.h **** 
  92:../Libmaple/libmaple/libmaple/systick.h **** /**
  93:../Libmaple/libmaple/libmaple/systick.h ****  * @brief Returns the current value of the SysTick counter.
  94:../Libmaple/libmaple/libmaple/systick.h ****  */
  95:../Libmaple/libmaple/libmaple/systick.h **** static inline uint32 systick_get_count(void) {
  96:../Libmaple/libmaple/libmaple/systick.h ****     return SYSTICK_BASE->CNT;
 102              		.loc 3 96 0 discriminator 1
 103 0006 094B     		ldr	r3, .L8
 104              	.LBE12:
 105              	.LBE11:
 106              		.loc 2 62 0 discriminator 1
 107 0008 0446     		mov	r4, r0
 108              	.LVL3:
 109              	.LBB14:
 110              	.LBB13:
 111              		.loc 3 96 0 discriminator 1
 112 000a 9D68     		ldr	r5, [r3, #8]
 113              	.LBE13:
 114              	.LBE14:
  63:../Libmaple/libmaple/wirish/wirish_time.h ****         cycle_cnt = systick_get_count();
  64:../Libmaple/libmaple/wirish/wirish_time.h ****     } while (ms != millis());
 115              		.loc 2 64 0 discriminator 1
 116 000c FFF7FEFF 		bl	_ZL6millisv
 117              	.LVL4:
  61:../Libmaple/libmaple/wirish/wirish_time.h ****     do {
 118              		.loc 2 61 0 discriminator 1
 119 0010 8442     		cmp	r4, r0
 120 0012 F6D1     		bne	.L6
 121              	.LVL5:
  65:../Libmaple/libmaple/wirish/wirish_time.h **** 
  66:../Libmaple/libmaple/wirish/wirish_time.h ****     /* SYSTICK_RELOAD_VAL is 1 less than the number of cycles it
  67:../Libmaple/libmaple/wirish/wirish_time.h ****        actually takes to complete a SysTick reload */
  68:../Libmaple/libmaple/wirish/wirish_time.h ****     res = (ms * US_PER_MS) +
  69:../Libmaple/libmaple/wirish/wirish_time.h ****         (SYSTICK_RELOAD_VAL + 1 - cycle_cnt) / CYCLES_PER_MICROSECOND;
 122              		.loc 2 69 0
 123 0014 C5F52435 		rsb	r5, r5, #167936
 124              	.LVL6:
 125 0018 4035     		adds	r5, r5, #64
 126 001a A821     		movs	r1, #168
 127 001c B5FBF1F5 		udiv	r5, r5, r1
 128              	.LBE10:
  70:../Libmaple/libmaple/wirish/wirish_time.h **** 
  71:../Libmaple/libmaple/wirish/wirish_time.h ****     return res;
  72:../Libmaple/libmaple/wirish/wirish_time.h **** }
 129              		.loc 2 72 0
 130 0020 4FF47A70 		mov	r0, #1000
 131 0024 00FB0450 		mla	r0, r0, r4, r5
 132 0028 38BD     		pop	{r3, r4, r5, pc}
 133              	.L9:
 134 002a 00BF     		.align	2
 135              	.L8:
 136 002c 10E000E0 		.word	-536813552
 137              		.cfi_endproc
 138              	.LFE56:
 140              		.section	.text._Z9FrqChangev,"ax",%progbits
 141              		.align	1
 142              		.global	_Z9FrqChangev
 143              		.thumb
 144              		.thumb_func
 146              	_Z9FrqChangev:
 147              	.LFB171:
 148              		.file 4 "../Libraries/AQ_Receiver/Receiver_STM32PPM.h"
   1:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** /*
   2:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Copyright (c) 2012 kha.  All rights reserved.
   3:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
   4:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   STM32 PPM receiver by kha based on 
   5:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   STM32 receiver class by ala42 using time input capture
   6:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   for use with AeroQuad software and Maple library
   7:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   V 1.0 Jun 14 2012
   8:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
   9:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Define the pin numbers used for the receiver in receiverPin[]
  10:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  11:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Timer and timer channels are accessed using the Maple PIN_MAP array.
  12:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Make sure libmaple and this receiver class are compiled using the
  13:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   same structure alignment mode. When in doubt, change the stm32_pin_info
  14:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   declaration in wirish_types.h to align the size to a multiple of 4 byte
  15:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   by adding a filler byte at the end of the structure declaration.
  16:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** */
  17:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  18:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #ifndef _AEROQUAD_RECEIVER_STM32PPM_H_
  19:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #define _AEROQUAD_RECEIVER_STM32PPM_H_
  20:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  21:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #if defined(AeroQuadSTM32)
  22:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  23:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #include "Receiver.h"
  24:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #include "wirish.h"
  25:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  26:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** //#define STM32_TIMER_DEBUG // enable debug messages
  27:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  28:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** ///////////////////////////////////////////////////////////////////////////////
  29:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** // configuration part starts here
  30:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** // definition of pins used for PWM receiver input
  31:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  32:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #ifdef BOARD_aeroquad32
  33:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** static byte receiverPin = Port2Pin('D', 15);
  34:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #endif
  35:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  36:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #ifdef BOARD_aeroquad32mini
  37:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** static byte receiverPin = 2; // PB7
  38:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #endif
  39:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  40:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #ifdef BOARD_freeflight
  41:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** static byte receiverPin = Port2Pin('A',  0);
  42:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #endif
  43:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  44:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #ifdef BOARD_discovery_f4
  45:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** static byte receiverPin = Port2Pin('E',  9);
  46:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #endif
  47:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  48:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  49:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #define SERIAL_SUM_PPM_1         1,2,3,0,4,5,6,7 // PITCH,YAW,THR,ROLL... For Graupner/Spektrum
  50:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #define SERIAL_SUM_PPM_2         0,1,3,2,4,5,6,7 // ROLL,PITCH,THR,YAW... For Robe/Hitec/Futaba
  51:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #define SERIAL_SUM_PPM_3         1,0,3,2,4,5,6,7 // PITCH,ROLL,THR,YAW... For some Hitec/Sanwa/Othe
  52:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  53:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #if defined (SKETCH_SERIAL_SUM_PPM)
  54:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   #define SERIAL_SUM_PPM SKETCH_SERIAL_SUM_PPM
  55:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #else
  56:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   #define SERIAL_SUM_PPM SERIAL_SUM_PPM_1
  57:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #endif
  58:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  59:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** static byte ReceiverChannelMap[] = {SERIAL_SUM_PPM};
  60:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  61:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** uint16 rawChannelValue[8] =  {1500,1500,1500,1500,1500,1500,1500,1500};
  62:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** byte   currentChannel;
  63:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  64:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  65:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** ///////////////////////////////////////////////////////////////////////////////
  66:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** // implementation part starts here.
  67:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  68:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** typedef struct {
  69:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer_dev   *TimerDev;
  70:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer_gen_reg_map *TimerRegs;
  71:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   __io uint32	*Timer_ccr;
  72:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   uint16		RiseTime;
  73:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   int			TimerChannel;
  74:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   int			PolarityMask;
  75:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** } tFrqData;
  76:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  77:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** volatile tFrqData FrqData;
  78:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  79:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** void FrqInit(int aDefault, timer_dev *aTimer, int aTimerChannel)
  80:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** {
  81:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   aTimerChannel--;  // transform timer channel numbering from 1-4 to 0-3
  82:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  83:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.TimerDev     = aTimer;
  84:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer_gen_reg_map *timer = aTimer->regs.gen;
  85:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.TimerRegs    = timer;
  86:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   
  87:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.Timer_ccr    = &timer->CCR1 + aTimerChannel;
  88:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.TimerChannel = aTimerChannel;
  89:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   
  90:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   int TimerEnable = (1 << (4*aTimerChannel));
  91:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.PolarityMask = TimerEnable << 1;
  92:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   
  93:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   uint32 clock_speed = rcc_dev_timer_clk_speed(FrqData.TimerDev->clk_id);
  94:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->PSC	= (clock_speed/1000000)-1;
  95:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->ARR	= 0xffff;
  96:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CR1	= 0;
  97:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->DIER &= ~(1);
  98:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   
  99:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CCER &= ~TimerEnable; // Disable timer
 100:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CCER &= ~(FrqData.PolarityMask);
 101:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   
 102:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #ifdef STM32_TIMER_DEBUG
 103:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Serial.print("  clk ");
 104:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Serial.print(clock_speed/1000000, 10);
 105:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Serial.print("MHz ");
 106:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   
 107:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Serial.print(" CCMR0 ");
 108:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Serial.print(timer->CCMR1, 16);
 109:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #endif
 110:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   
 111:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   volatile uint32 *mr;
 112:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   if(aTimerChannel < 2) {
 113:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     mr = &(timer->CCMR1);
 114:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   } else {
 115:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     mr = &(timer->CCMR2);
 116:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   }
 117:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   *mr &= ~(0xFF << (8*(aTimerChannel&1)));	// prescaler 1
 118:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   *mr |= 0x61 << (8*(aTimerChannel&1));		// 0x61 -> 6=filter, 1=inputs 1,2,3,4
 119:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   
 120:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CCER |= TimerEnable; // Enable
 121:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CR1 = 1;
 122:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   
 123:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #ifdef STM32_TIMER_DEBUG
 124:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Serial.print(" CCER ");
 125:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Serial.print(timer->CCER, 16);
 126:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Serial.print(" CCMR1 ");
 127:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Serial.print(timer->CCMR1, 16);
 128:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Serial.println();
 129:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #endif
 130:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** }
 131:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 132:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** void FrqChange()
 133:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** {
 149              		.loc 4 133 0
 150              		.cfi_startproc
 151              		@ args = 0, pretend = 0, frame = 0
 152              		@ frame_needed = 0, uses_anonymous_args = 0
 153              	.LBB15:
 134:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer_gen_reg_map *timer = FrqData.TimerRegs;
 154              		.loc 4 134 0
 155 0000 174B     		ldr	r3, .L16
 156              	.LBE15:
 133:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** {
 157              		.loc 4 133 0
 158 0002 30B5     		push	{r4, r5, lr}
 159              	.LCFI1:
 160              		.cfi_def_cfa_offset 12
 161              		.cfi_offset 14, -4
 162              		.cfi_offset 5, -8
 163              		.cfi_offset 4, -12
 164              	.LBB18:
 165              		.loc 4 134 0
 166 0004 5868     		ldr	r0, [r3, #4]
 167              	.LVL7:
 135:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   uint16_t c = *(FrqData.Timer_ccr);
 168              		.loc 4 135 0
 169 0006 9C68     		ldr	r4, [r3, #8]
 170 0008 2468     		ldr	r4, [r4, #0]
 171              	.LVL8:
 136:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   bool rising = (timer->CCER & FrqData.PolarityMask) == 0;
 172              		.loc 4 136 0
 173 000a 026A     		ldr	r2, [r0, #32]
 174 000c 5969     		ldr	r1, [r3, #20]
 175              	.LVL9:
 176              	.LBB16:
 137:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 138:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   if(rising) {
 177              		.loc 4 138 0
 178 000e 11EA0200 		ands	r0, r1, r2
 179              	.LVL10:
 180 0012 1DD1     		bne	.L11
 181              	.LBB17:
 139:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     uint16_t diffTime = c - FrqData.RiseTime;
 182              		.loc 4 139 0
 183 0014 9D89     		ldrh	r5, [r3, #12]
 184 0016 611B     		subs	r1, r4, r5
 185              	.LVL11:
 186 0018 89B2     		uxth	r1, r1
 187              	.LVL12:
 140:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     if ((diffTime>900) && (diffTime<2100)) {
 188              		.loc 4 140 0
 189 001a A1F56072 		sub	r2, r1, #896
 190 001e 551F     		subs	r5, r2, #5
 191 0020 1FFA85FC 		uxth	ip, r5
 192 0024 40F2AE45 		movw	r5, #1198
 193 0028 AC45     		cmp	ip, r5
 194 002a 0E4A     		ldr	r2, .L16+4
 195 002c 07D8     		bhi	.L12
 141:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****       if (currentChannel<8) {
 196              		.loc 4 141 0
 197 002e 1078     		ldrb	r0, [r2, #0]	@ zero_extendqisi2
 198 0030 0728     		cmp	r0, #7
 199 0032 0CD8     		bhi	.L13
 142:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 	rawChannelValue[currentChannel]=diffTime;
 200              		.loc 4 142 0
 201 0034 0C4D     		ldr	r5, .L16+8
 202 0036 25F81010 		strh	r1, [r5, r0, lsl #1]	@ movhi
 143:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 	currentChannel++;
 203              		.loc 4 143 0
 204 003a 0130     		adds	r0, r0, #1
 205 003c 03E0     		b	.L15
 206              	.L12:
 144:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****       }
 145:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     } else if (diffTime>2500) {
 207              		.loc 4 145 0
 208 003e 40F6C415 		movw	r5, #2500
 209 0042 A942     		cmp	r1, r5
 210 0044 01D9     		bls	.L14
 211              	.L15:
 146:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****       currentChannel=0;
 212              		.loc 4 146 0
 213 0046 1070     		strb	r0, [r2, #0]
 214 0048 01E0     		b	.L13
 215              	.L14:
 147:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     } else {
 148:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****       // glitch stop and wait next round
 149:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****       currentChannel=9;
 216              		.loc 4 149 0
 217 004a 0920     		movs	r0, #9
 218 004c 1070     		strb	r0, [r2, #0]
 219              	.L13:
 150:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     }
 151:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     //    Serial.print(highTime);
 152:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     //    Serial.println();
 153:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     FrqData.RiseTime = c;
 220              		.loc 4 153 0
 221 004e 9C81     		strh	r4, [r3, #12]	@ movhi
 222              	.LVL13:
 223              	.L11:
 224              	.LBE17:
 225              	.LBE16:
 154:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   }
 155:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.TimerRegs->CCER ^= FrqData.PolarityMask; // invert polarity
 226              		.loc 4 155 0
 227 0050 5A68     		ldr	r2, [r3, #4]
 228 0052 116A     		ldr	r1, [r2, #32]
 229 0054 5869     		ldr	r0, [r3, #20]
 230 0056 80EA0103 		eor	r3, r0, r1
 231 005a 1362     		str	r3, [r2, #32]
 232              	.LBE18:
 156:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** }
 233              		.loc 4 156 0
 234 005c 30BD     		pop	{r4, r5, pc}
 235              	.L17:
 236 005e 00BF     		.align	2
 237              	.L16:
 238 0060 00000000 		.word	.LANCHOR0
 239 0064 00000000 		.word	.LANCHOR1
 240 0068 00000000 		.word	.LANCHOR2
 241              		.cfi_endproc
 242              	.LFE171:
 244              		.section	.text._ZL16hottV4SendBinaryPh,"ax",%progbits
 245              		.align	1
 246              		.thumb
 247              		.thumb_func
 249              	_ZL16hottV4SendBinaryPh:
 250              	.LFB257:
 251              		.file 5 "../Libraries/AQ_HoTT/HoTT_Telemetry.h"
   1:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /*
   2:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   www.AeroQuad.com
   4:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  
   7:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   (at your option) any later version. 
  11:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  12:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  17:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** */
  20:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  21:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #ifndef _AEROQUAD_HOTT_TELEMETRY_H_
  22:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #define _AEROQUAD_HOTT_TELEMETRY_H_
  23:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  24:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #include "HoTT.h"
  25:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #include <stdio.h>
  26:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  27:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** HardwareSerial *hottV4Serial;
  28:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  29:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static uint8_t minutes = 0;
  30:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static uint16_t milliseconds = 0;
  31:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static signed int maxAltitude = 500;
  32:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static signed int minAltitude = 500;
  33:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** volatile unsigned int CountMilliseconds = 0;
  34:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** bool isAHOff, isAHOn, isNavOn, isHoldOn, isGPSOff;
  35:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  36:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /* ##################################################################### *
  37:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  *                HoTTv4 Common Serial                                   *
  38:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * ##################################################################### */
  39:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  40:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  41:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
  42:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Writes out given data to data register.
  43:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
  44:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static void hottV4SerialWrite(uint8_t data) {
  45:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4Serial->write(data);
  46:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
  47:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  48:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
  49:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Clears input buffer
  50:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
  51:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** void hottV4SerialClearInput() {
  52:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	while(hottV4Serial->available() > 0) {
  53:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		hottV4Serial->read();
  54:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	}
  55:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
  56:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  57:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
  58:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Reads last byte from input buffer
  59:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
  60:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** int hottV4SerialRead() {
  61:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	while(hottV4Serial->available() > 1) {
  62:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		hottV4Serial->read();
  63:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	}
  64:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     if(hottV4Serial->available()) {
  65:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     	return hottV4Serial->read();
  66:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     } else {
  67:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     	return 0xff;
  68:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     }
  69:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
  70:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  71:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  72:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  73:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #define hottV4TelemetryBufferSize 45
  74:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static uint8_t  hottV4TelemetryBuffer[hottV4TelemetryBufferSize];
  75:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static byte  hottV4TelemetryBufferIndex;
  76:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  77:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
  78:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Buffer telemetry data
  79:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
  80:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static void hottV4SendBinary(uint8_t *data) {
 252              		.loc 5 80 0
 253              		.cfi_startproc
 254              		@ args = 0, pretend = 0, frame = 0
 255              		@ frame_needed = 0, uses_anonymous_args = 0
 256              	.LVL14:
 257 0000 10B5     		push	{r4, lr}
 258              	.LCFI2:
 259              		.cfi_def_cfa_offset 8
 260              		.cfi_offset 14, -4
 261              		.cfi_offset 4, -8
 262              		.loc 5 80 0
 263 0002 0023     		movs	r3, #0
  81:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint16_t crc = 0;
 264              		.loc 5 81 0
 265 0004 1A46     		mov	r2, r3
 266              	.LVL15:
 267              	.L19:
 268              	.LBB19:
 269              	.LBB20:
  82:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  83:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   for (uint8_t index = 0; index < hottV4TelemetryBufferSize-1; index++) {
  84:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     crc = crc + data[index];
 270              		.loc 5 84 0 discriminator 2
 271 0006 C45C     		ldrb	r4, [r0, r3]	@ zero_extendqisi2
  85:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     hottV4TelemetryBuffer[index] = data[index];
 272              		.loc 5 85 0 discriminator 2
 273 0008 0649     		ldr	r1, .L21
 274 000a 5C54     		strb	r4, [r3, r1]
 275 000c 0133     		adds	r3, r3, #1
  84:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     crc = crc + data[index];
 276              		.loc 5 84 0 discriminator 2
 277 000e A218     		adds	r2, r4, r2
  83:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   for (uint8_t index = 0; index < hottV4TelemetryBufferSize-1; index++) {
 278              		.loc 5 83 0 discriminator 2
 279 0010 2C2B     		cmp	r3, #44
  84:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     crc = crc + data[index];
 280              		.loc 5 84 0 discriminator 2
 281 0012 92B2     		uxth	r2, r2
 282              	.LVL16:
  83:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   for (uint8_t index = 0; index < hottV4TelemetryBufferSize-1; index++) {
 283              		.loc 5 83 0 discriminator 2
 284 0014 F7D1     		bne	.L19
 285              	.LVL17:
 286              	.LBE20:
  86:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****    }
  87:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  88:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint8_t crcVal = crc & 0xFF;
  89:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4TelemetryBuffer[hottV4TelemetryBufferSize-1] = crcVal;
  90:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  91:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4TelemetryBufferIndex = 0;
 287              		.loc 5 91 0
 288 0016 044B     		ldr	r3, .L21+4
  88:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint8_t crcVal = crc & 0xFF;
 289              		.loc 5 88 0
 290 0018 81F82C20 		strb	r2, [r1, #44]
 291              		.loc 5 91 0
 292 001c 0020     		movs	r0, #0
 293              	.LVL18:
 294 001e 1870     		strb	r0, [r3, #0]
 295              	.LBE19:
  92:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 296              		.loc 5 92 0
 297 0020 10BD     		pop	{r4, pc}
 298              	.L22:
 299 0022 00BF     		.align	2
 300              	.L21:
 301 0024 00000000 		.word	.LANCHOR3
 302 0028 00000000 		.word	.LANCHOR4
 303              		.cfi_endproc
 304              	.LFE257:
 306              		.section	.text._ZL20hottv4UpdateAltVariov,"ax",%progbits
 307              		.align	1
 308              		.thumb
 309              		.thumb_func
 311              	_ZL20hottv4UpdateAltVariov:
 312              	.LFB264:
  93:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  94:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  95:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /* ##################################################################### *
  96:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  *                HoTTv4 Module specific Update functions                *
  97:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * ##################################################################### */
  98:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
  99:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #if defined(HOTTV4DIR)
 100:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
 101:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Updates current direction related on compass information.
 102:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
 103:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static int hottV4UpdateDirection() {
 104:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	return ((int)(trueNorthHeading / M_PI * 180.0) + 360) % 360;
 105:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	}
 106:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #endif
 107:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 108:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static void HoTTInvertDisplay(uint8_t *data) {
 109:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     data[4] = 0x80; // Inverts MikroKopter Telemetry Display for Voltage
 110:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 111:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 112:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #if defined(HOTTV4BATT)
 113:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
 114:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Updates battery voltage telemetry data with given value.
 115:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Resolution is in 0,1V, e.g. 0x7E == 12,6V.
 116:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * If value is below batteryWarning, telemetry alarm is triggered
 117:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
 118:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static short hottv4UpdateBattery(uint8_t *data) {
 119:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	short voltage = batteryData[0].voltage/10;
 120:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 121:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryWarning || batteryAlarm) {
 122:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		HoTTInvertDisplay(data);
 123:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	}
 124:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 125:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	return voltage;
 126:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 127:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 128:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static short hottv4UpdateCurrent() {
 129:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryData[0].cPin != BM_NOPIN) return batteryData[0].current/100;
 130:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	return 0;
 131:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 132:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 133:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static long hottv4UpdateCapacity() {
 134:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryData[0].cPin != BM_NOPIN) return batteryData[0].usedCapacity/1000;
 135:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	return 0;
 136:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 137:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #endif
 138:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 139:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 140:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #if defined(AltitudeHoldBaro) || defined(AltitudeHoldRangeFinder)
 141:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
 142:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Current relative altitude based on baro or ultrasonic values. 
 143:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Result is displayed in meter.
 144:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  *
 145:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * @param data Pointer to telemetry data frame
 146:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * @param lowByteIndex Index for the low byte that represents the altitude in telemetry data frame
 147:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
 148:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static int32_t hottv4UpdateAlt() {
 149:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   int32_t alt = 0;
 150:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   
 151:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #if defined(AltitudeHoldBaro)
 152:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   alt = (int)getBaroAltitude() + 500;  // 500 == 0m
 153:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #endif 
 154:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 155:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #if defined(AltitudeHoldRangeFinder)
 156:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if (isOnRangerRange(rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX])) {
 157:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	alt = (int)rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX] + 500;
 158:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   }
 159:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #endif
 160:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   
 161:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(alt > maxAltitude) maxAltitude = alt;
 162:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   else if(alt < minAltitude) minAltitude = alt;
 163:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 164:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   return alt;
 165:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 166:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 167:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 168:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static unsigned int hottv4UpdateAltVario() {
 313              		.loc 5 168 0
 314              		.cfi_startproc
 315              		@ args = 0, pretend = 0, frame = 0
 316              		@ frame_needed = 0, uses_anonymous_args = 0
 317              	.LVL19:
 318 0000 10B5     		push	{r4, lr}
 319              	.LCFI3:
 320              		.cfi_def_cfa_offset 8
 321              		.cfi_offset 14, -4
 322              		.cfi_offset 4, -8
 323              	.LBB21:
 169:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	unsigned int varioSound = 30000;
 170:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 171:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if(altitudeHoldState == ON)
 324              		.loc 5 171 0
 325 0002 0E48     		ldr	r0, .L28
 326 0004 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 327 0006 012B     		cmp	r3, #1
 328 0008 12D1     		bne	.L25
 172:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	{
 173:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		if((receiverCommand[THROTTLE] > (altitudeHoldThrottle + altitudeHoldBump))) varioSound = 30100;
 329              		.loc 5 173 0
 330 000a 0D48     		ldr	r0, .L28+4
 331 000c 0D4A     		ldr	r2, .L28+8
 332 000e 0E4B     		ldr	r3, .L28+12
 333 0010 0068     		ldr	r0, [r0, #0]
 334 0012 1268     		ldr	r2, [r2, #0]
 335 0014 DB68     		ldr	r3, [r3, #12]
 336 0016 8118     		adds	r1, r0, r2
 337 0018 8B42     		cmp	r3, r1
 338 001a 0CDC     		bgt	.L26
 174:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		else if((receiverCommand[THROTTLE] < (altitudeHoldThrottle - altitudeHoldBump))) varioSound = 299
 339              		.loc 5 174 0
 340 001c 821A     		subs	r2, r0, r2
 169:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	unsigned int varioSound = 30000;
 341              		.loc 5 169 0
 342 001e 47F2305C 		movw	ip, #30000
 343 0022 47F2CC44 		movw	r4, #29900
 344 0026 9342     		cmp	r3, r2
 345 0028 B4BF     		ite	lt
 346 002a 2046     		movlt	r0, r4
 347 002c 6046     		movge	r0, ip
 348 002e 10BD     		pop	{r4, pc}
 349              	.L25:
 350 0030 47F23050 		movw	r0, #30000
 351 0034 10BD     		pop	{r4, pc}
 352              	.L26:
 173:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		if((receiverCommand[THROTTLE] > (altitudeHoldThrottle + altitudeHoldBump))) varioSound = 30100;
 353              		.loc 5 173 0
 354 0036 47F29450 		movw	r0, #30100
 355              	.LVL20:
 356              	.LBE21:
 175:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	}
 176:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 177:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	return varioSound;
 178:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 357              		.loc 5 178 0
 358 003a 10BD     		pop	{r4, pc}
 359              	.L29:
 360              		.align	2
 361              	.L28:
 362 003c 00000000 		.word	.LANCHOR5
 363 0040 00000000 		.word	.LANCHOR7
 364 0044 00000000 		.word	.LANCHOR8
 365 0048 00000000 		.word	.LANCHOR6
 366              		.cfi_endproc
 367              	.LFE264:
 369              		.section	.text.startup._Z7premainv,"ax",%progbits
 370              		.align	1
 371              		.global	_Z7premainv
 372              		.thumb
 373              		.thumb_func
 375              	_Z7premainv:
 376              	.LFB113:
 377              		.file 6 "C:/MinGW/msys/1.0/home/ang/AeroQuad32/AeroQuadMain.cpp"
   1:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp **** #include <SerialMapping.h>
   2:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp **** #include <WProgram.h>
   3:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp **** 
   4:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp **** __attribute__(( constructor )) void premain() {
 378              		.loc 6 4 0
 379              		.cfi_startproc
 380              		@ args = 0, pretend = 0, frame = 0
 381              		@ frame_needed = 0, uses_anonymous_args = 0
 382              		@ link register save eliminated.
   5:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp ****     init();
   6:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp **** }
 383              		.loc 6 6 0
   5:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp ****     init();
 384              		.loc 6 5 0
 385 0000 FFF7FEBF 		b	_Z4initv
 386              		.cfi_endproc
 387              	.LFE113:
 389              		.section	.init_array,"aw",%init_array
 390              		.align	2
 391 0000 00000000 		.word	_Z7premainv(target1)
 392              		.section	.text._Z23initializeReceiverParami,"ax",%progbits
 393              		.align	1
 394              		.global	_Z23initializeReceiverParami
 395              		.thumb
 396              		.thumb_func
 398              	_Z23initializeReceiverParami:
 399              	.LFB121:
 400              		.file 7 "../Libraries/AQ_Receiver/Receiver.h"
   1:../Libraries/AQ_Receiver/Receiver.h **** /*
   2:../Libraries/AQ_Receiver/Receiver.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Receiver/Receiver.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Receiver/Receiver.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Receiver/Receiver.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Receiver/Receiver.h ****  
   7:../Libraries/AQ_Receiver/Receiver.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Receiver/Receiver.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Receiver/Receiver.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Receiver/Receiver.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Receiver/Receiver.h **** 
  12:../Libraries/AQ_Receiver/Receiver.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Receiver/Receiver.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Receiver/Receiver.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Receiver/Receiver.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Receiver/Receiver.h **** 
  17:../Libraries/AQ_Receiver/Receiver.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Receiver/Receiver.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Receiver/Receiver.h **** */
  20:../Libraries/AQ_Receiver/Receiver.h **** 
  21:../Libraries/AQ_Receiver/Receiver.h **** #ifndef _AEROQUAD_RECEIVER_H_
  22:../Libraries/AQ_Receiver/Receiver.h **** #define _AEROQUAD_RECEIVER_H_
  23:../Libraries/AQ_Receiver/Receiver.h **** 
  24:../Libraries/AQ_Receiver/Receiver.h **** #include "Arduino.h"
  25:../Libraries/AQ_Receiver/Receiver.h **** 
  26:../Libraries/AQ_Receiver/Receiver.h **** #define PWM2RAD 0.002 //  Based upon 5RAD for full stick movement, you take this times the RAD to g
  27:../Libraries/AQ_Receiver/Receiver.h **** 
  28:../Libraries/AQ_Receiver/Receiver.h **** // Receiver variables
  29:../Libraries/AQ_Receiver/Receiver.h **** #define TIMEOUT 25000
  30:../Libraries/AQ_Receiver/Receiver.h **** #define MINCOMMAND 1000
  31:../Libraries/AQ_Receiver/Receiver.h **** #define MIDCOMMAND 1500
  32:../Libraries/AQ_Receiver/Receiver.h **** #define MAXCOMMAND 2000
  33:../Libraries/AQ_Receiver/Receiver.h **** #define MINDELTA 200
  34:../Libraries/AQ_Receiver/Receiver.h **** #define MINCHECK MINCOMMAND + 100
  35:../Libraries/AQ_Receiver/Receiver.h **** #define MAXCHECK MAXCOMMAND - 100
  36:../Libraries/AQ_Receiver/Receiver.h **** #define MINTHROTTLE MINCOMMAND + 100
  37:../Libraries/AQ_Receiver/Receiver.h **** #define LEVELOFF 100
  38:../Libraries/AQ_Receiver/Receiver.h **** #define MAX_NB_CHANNEL 8
  39:../Libraries/AQ_Receiver/Receiver.h **** 
  40:../Libraries/AQ_Receiver/Receiver.h **** int lastReceiverChannel = 0;
  41:../Libraries/AQ_Receiver/Receiver.h **** 
  42:../Libraries/AQ_Receiver/Receiver.h **** float receiverXmitFactor = 0.0;
  43:../Libraries/AQ_Receiver/Receiver.h **** int receiverData[MAX_NB_CHANNEL] = {0,0,0,0,0,0,0,0};
  44:../Libraries/AQ_Receiver/Receiver.h **** int receiverZero[3] = {0,0,0};
  45:../Libraries/AQ_Receiver/Receiver.h **** int receiverCommand[MAX_NB_CHANNEL] = {0,0,0,0,0,0,0,0};
  46:../Libraries/AQ_Receiver/Receiver.h **** int receiverCommandSmooth[MAX_NB_CHANNEL] = {0,0,0,0,0,0,0,0};
  47:../Libraries/AQ_Receiver/Receiver.h **** float receiverSlope[MAX_NB_CHANNEL] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
  48:../Libraries/AQ_Receiver/Receiver.h **** float receiverOffset[MAX_NB_CHANNEL] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
  49:../Libraries/AQ_Receiver/Receiver.h **** float receiverSmoothFactor[MAX_NB_CHANNEL] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
  50:../Libraries/AQ_Receiver/Receiver.h **** int channelCal;
  51:../Libraries/AQ_Receiver/Receiver.h **** 
  52:../Libraries/AQ_Receiver/Receiver.h **** void initializeReceiverParam(int nbChannel = 6) {
 401              		.loc 7 52 0
 402              		.cfi_startproc
 403              		@ args = 0, pretend = 0, frame = 0
 404              		@ frame_needed = 0, uses_anonymous_args = 0
 405              		@ link register save eliminated.
 406              	.LVL21:
 407              	.LBB22:
  53:../Libraries/AQ_Receiver/Receiver.h ****   
  54:../Libraries/AQ_Receiver/Receiver.h ****   lastReceiverChannel = nbChannel;
 408              		.loc 7 54 0
 409 0000 244A     		ldr	r2, .L40
  55:../Libraries/AQ_Receiver/Receiver.h **** 
  56:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[XAXIS] = 1500;
 410              		.loc 7 56 0
 411 0002 254B     		ldr	r3, .L40+4
  54:../Libraries/AQ_Receiver/Receiver.h ****   lastReceiverChannel = nbChannel;
 412              		.loc 7 54 0
 413 0004 1060     		str	r0, [r2, #0]
 414              		.loc 7 56 0
 415 0006 40F2DC51 		movw	r1, #1500
  57:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[YAXIS] = 1500;
  58:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[ZAXIS] = 1500;
  59:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[THROTTLE] = 1000;
 416              		.loc 7 59 0
 417 000a 4FF47A72 		mov	r2, #1000
  56:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[XAXIS] = 1500;
 418              		.loc 7 56 0
 419 000e 1960     		str	r1, [r3, #0]
  57:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[YAXIS] = 1500;
 420              		.loc 7 57 0
 421 0010 5960     		str	r1, [r3, #4]
  58:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[ZAXIS] = 1500;
 422              		.loc 7 58 0
 423 0012 9960     		str	r1, [r3, #8]
 424              		.loc 7 59 0
 425 0014 DA60     		str	r2, [r3, #12]
  60:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[MODE] = 1000;
 426              		.loc 7 60 0
 427 0016 1A61     		str	r2, [r3, #16]
  61:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[AUX1] = 1000;
 428              		.loc 7 61 0
 429 0018 5A61     		str	r2, [r3, #20]
  62:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[AUX2] = 1000;
 430              		.loc 7 62 0
 431 001a 9A61     		str	r2, [r3, #24]
  63:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[AUX3] = 1000;
 432              		.loc 7 63 0
 433 001c DA61     		str	r2, [r3, #28]
 434              	.LVL22:
 435              	.LBB23:
  64:../Libraries/AQ_Receiver/Receiver.h ****   
  65:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 436              		.loc 7 65 0
 437 001e 0023     		movs	r3, #0
 438 0020 07E0     		b	.L32
 439              	.LVL23:
 440              	.L33:
  66:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = 1.0;
 441              		.loc 7 66 0 discriminator 2
 442 0022 0121     		movs	r1, #1
 443 0024 1D4A     		ldr	r2, .L40+8
  65:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 444              		.loc 7 65 0 discriminator 2
 445 0026 03EB010C 		add	ip, r3, r1
 446              		.loc 7 66 0 discriminator 2
 447 002a 42F82310 		str	r1, [r2, r3, lsl #2]
  65:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 448              		.loc 7 65 0 discriminator 2
 449 002e 5FFA8CF3 		uxtb	r3, ip
 450              	.LVL24:
 451              	.L32:
  65:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 452              		.loc 7 65 0 is_stmt 0 discriminator 1
 453 0032 8342     		cmp	r3, r0
 454 0034 F5DB     		blt	.L33
 455              	.LVL25:
 456              	.LBE23:
 457              	.LBB24:
  67:../Libraries/AQ_Receiver/Receiver.h ****   }
  68:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < THROTTLE; channel++) {
  69:../Libraries/AQ_Receiver/Receiver.h ****     receiverZero[channel] = 1500;
 458              		.loc 7 69 0 is_stmt 1 discriminator 1
 459 0036 1A4B     		ldr	r3, .L40+12
 460              	.LVL26:
 461 0038 40F2DC51 		movw	r1, #1500
 462 003c 1960     		str	r1, [r3, #0]
 463              	.LVL27:
 464 003e 5960     		str	r1, [r3, #4]
 465              	.LVL28:
 466 0040 9960     		str	r1, [r3, #8]
 467              	.LVL29:
 468 0042 0023     		movs	r3, #0
 469 0044 08E0     		b	.L34
 470              	.LVL30:
 471              	.L35:
 472              	.LBE24:
 473              	.LBB25:
  70:../Libraries/AQ_Receiver/Receiver.h ****   }
  71:../Libraries/AQ_Receiver/Receiver.h **** 	
  72:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
  73:../Libraries/AQ_Receiver/Receiver.h ****     receiverSlope[channel] = 1;
 474              		.loc 7 73 0 discriminator 2
 475 0046 174A     		ldr	r2, .L40+16
 476 0048 02EB8301 		add	r1, r2, r3, lsl #2
 477 004c 4FF07E5C 		mov	ip, #1065353216
  72:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 478              		.loc 7 72 0 discriminator 2
 479 0050 5A1C     		adds	r2, r3, #1
 480              		.loc 7 73 0 discriminator 2
 481 0052 C1F800C0 		str	ip, [r1, #0]	@ float
  72:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 482              		.loc 7 72 0 discriminator 2
 483 0056 D3B2     		uxtb	r3, r2
 484              	.LVL31:
 485              	.L34:
  72:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 486              		.loc 7 72 0 is_stmt 0 discriminator 1
 487 0058 8342     		cmp	r3, r0
 488 005a F4DB     		blt	.L35
  72:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 489              		.loc 7 72 0
 490 005c 0023     		movs	r3, #0
 491              	.LVL32:
 492 005e 08E0     		b	.L36
 493              	.LVL33:
 494              	.L37:
 495              	.LBE25:
 496              	.LBB26:
  74:../Libraries/AQ_Receiver/Receiver.h ****   }	
  75:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
  76:../Libraries/AQ_Receiver/Receiver.h ****     receiverOffset[channel] = 1;
 497              		.loc 7 76 0 is_stmt 1 discriminator 2
 498 0060 114A     		ldr	r2, .L40+20
 499 0062 02EB8301 		add	r1, r2, r3, lsl #2
 500 0066 4FF07E5C 		mov	ip, #1065353216
  75:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 501              		.loc 7 75 0 discriminator 2
 502 006a 0133     		adds	r3, r3, #1
 503              	.LVL34:
 504              		.loc 7 76 0 discriminator 2
 505 006c C1F800C0 		str	ip, [r1, #0]	@ float
  75:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 506              		.loc 7 75 0 discriminator 2
 507 0070 DBB2     		uxtb	r3, r3
 508              	.LVL35:
 509              	.L36:
  75:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 510              		.loc 7 75 0 is_stmt 0 discriminator 1
 511 0072 8342     		cmp	r3, r0
 512 0074 F4DB     		blt	.L37
  75:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 513              		.loc 7 75 0
 514 0076 0023     		movs	r3, #0
 515              	.LVL36:
 516 0078 08E0     		b	.L38
 517              	.LVL37:
 518              	.L39:
 519              	.LBE26:
 520              	.LBB27:
  77:../Libraries/AQ_Receiver/Receiver.h ****   }
  78:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
  79:../Libraries/AQ_Receiver/Receiver.h ****     receiverSmoothFactor[channel] = 1; 
 521              		.loc 7 79 0 is_stmt 1 discriminator 2
 522 007a 0C4A     		ldr	r2, .L40+24
 523 007c 02EB8301 		add	r1, r2, r3, lsl #2
 524 0080 4FF07E5C 		mov	ip, #1065353216
  78:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 525              		.loc 7 78 0 discriminator 2
 526 0084 0133     		adds	r3, r3, #1
 527              	.LVL38:
 528              		.loc 7 79 0 discriminator 2
 529 0086 C1F800C0 		str	ip, [r1, #0]	@ float
  78:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 530              		.loc 7 78 0 discriminator 2
 531 008a DBB2     		uxtb	r3, r3
 532              	.LVL39:
 533              	.L38:
  78:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 534              		.loc 7 78 0 is_stmt 0 discriminator 1
 535 008c 8342     		cmp	r3, r0
 536 008e F4DB     		blt	.L39
 537              	.LBE27:
 538              	.LBE22:
  80:../Libraries/AQ_Receiver/Receiver.h ****   }
  81:../Libraries/AQ_Receiver/Receiver.h **** }
 539              		.loc 7 81 0 is_stmt 1
 540 0090 7047     		bx	lr
 541              	.L41:
 542 0092 00BF     		.align	2
 543              	.L40:
 544 0094 00000000 		.word	.LANCHOR9
 545 0098 00000000 		.word	.LANCHOR6
 546 009c 00000000 		.word	.LANCHOR10
 547 00a0 00000000 		.word	.LANCHOR11
 548 00a4 00000000 		.word	.LANCHOR12
 549 00a8 00000000 		.word	.LANCHOR13
 550 00ac 00000000 		.word	.LANCHOR14
 551              		.cfi_endproc
 552              	.LFE121:
 554              		.section	.text._Z17getReceiverSIDatah,"ax",%progbits
 555              		.align	1
 556              		.global	_Z17getReceiverSIDatah
 557              		.thumb
 558              		.thumb_func
 560              	_Z17getReceiverSIDatah:
 561              	.LFB123:
  82:../Libraries/AQ_Receiver/Receiver.h ****   
  83:../Libraries/AQ_Receiver/Receiver.h **** int getRawChannelValue(byte channel);  
  84:../Libraries/AQ_Receiver/Receiver.h **** void readReceiver();
  85:../Libraries/AQ_Receiver/Receiver.h ****   
  86:../Libraries/AQ_Receiver/Receiver.h **** void readReceiver()
  87:../Libraries/AQ_Receiver/Receiver.h **** {
  88:../Libraries/AQ_Receiver/Receiver.h ****   for(byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
  89:../Libraries/AQ_Receiver/Receiver.h **** 
  90:../Libraries/AQ_Receiver/Receiver.h ****     // Apply receiver calibration adjustment
  91:../Libraries/AQ_Receiver/Receiver.h ****     receiverData[channel] = (receiverSlope[channel] * getRawChannelValue(channel)) + receiverOffset
  92:../Libraries/AQ_Receiver/Receiver.h ****     // Smooth the flight control receiver inputs
  93:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = filterSmooth(receiverData[channel], receiverCommandSmooth[chan
  94:../Libraries/AQ_Receiver/Receiver.h ****   }
  95:../Libraries/AQ_Receiver/Receiver.h ****   
  96:../Libraries/AQ_Receiver/Receiver.h ****   // Reduce receiver commands using receiverXmitFactor and center around 1500
  97:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < THROTTLE; channel++) {
  98:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommand[channel] = ((receiverCommandSmooth[channel] - receiverZero[channel]) * receiver
  99:../Libraries/AQ_Receiver/Receiver.h ****   }	
 100:../Libraries/AQ_Receiver/Receiver.h ****   // No xmitFactor reduction applied for throttle, mode and AUX
 101:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = THROTTLE; channel < lastReceiverChannel; channel++) {
 102:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommand[channel] = receiverCommandSmooth[channel];
 103:../Libraries/AQ_Receiver/Receiver.h ****   }
 104:../Libraries/AQ_Receiver/Receiver.h **** }
 105:../Libraries/AQ_Receiver/Receiver.h **** 
 106:../Libraries/AQ_Receiver/Receiver.h **** 
 107:../Libraries/AQ_Receiver/Receiver.h **** void setChannelValue(byte channel,int value);
 108:../Libraries/AQ_Receiver/Receiver.h ****   
 109:../Libraries/AQ_Receiver/Receiver.h **** // return the smoothed & scaled number of radians/sec in stick movement - zero centered
 110:../Libraries/AQ_Receiver/Receiver.h **** const float getReceiverSIData(byte channel) {
 562              		.loc 7 110 0
 563              		.cfi_startproc
 564              		@ args = 0, pretend = 0, frame = 0
 565              		@ frame_needed = 0, uses_anonymous_args = 0
 566              		@ link register save eliminated.
 567              	.LVL40:
 111:../Libraries/AQ_Receiver/Receiver.h ****   return ((receiverCommand[channel] - receiverZero[channel]) * (2.5 * PWM2RAD));  // +/- 2.5RPS 50%
 568              		.loc 7 111 0
 569 0000 0849     		ldr	r1, .L43
 570 0002 094B     		ldr	r3, .L43+4
 571 0004 51F82020 		ldr	r2, [r1, r0, lsl #2]
 572 0008 53F82010 		ldr	r1, [r3, r0, lsl #2]
 573 000c 531A     		subs	r3, r2, r1
 574 000e 00EE103A 		fmsr	s0, r3	@ int
 112:../Libraries/AQ_Receiver/Receiver.h **** }
 575              		.loc 7 112 0
 576 0012 DFED067A 		flds	s15, .L43+8
 111:../Libraries/AQ_Receiver/Receiver.h ****   return ((receiverCommand[channel] - receiverZero[channel]) * (2.5 * PWM2RAD));  // +/- 2.5RPS 50%
 577              		.loc 7 111 0
 578 0016 B8EEC07A 		fsitos	s14, s0
 579              		.loc 7 112 0
 580 001a 67EE276A 		fmuls	s13, s14, s15
 581 001e 16EE900A 		fmrs	r0, s13
 582              	.LVL41:
 583 0022 7047     		bx	lr
 584              	.L44:
 585              		.align	2
 586              	.L43:
 587 0024 00000000 		.word	.LANCHOR6
 588 0028 00000000 		.word	.LANCHOR11
 589 002c 0BD7A33B 		.word	1000593163
 590              		.cfi_endproc
 591              	.LFE123:
 593              		.section	.text._Z9updatePIDffP7PIDdata,"ax",%progbits
 594              		.align	1
 595              		.global	_Z9updatePIDffP7PIDdata
 596              		.thumb
 597              		.thumb_func
 599              	_Z9updatePIDffP7PIDdata:
 600              	.LFB124:
 601              		.file 8 "C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad/PID.h"
   1:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** /*
   2:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   AeroQuad v3.0.1 - February 2012
   3:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   www.AeroQuad.com
   4:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   An Open Source Arduino based multicopter.
   6:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****  
   7:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   This program is free software: you can redistribute it and/or modify 
   8:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   it under the terms of the GNU General Public License as published by 
   9:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   (at your option) any later version. 
  11:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** 
  12:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   This program is distributed in the hope that it will be useful, 
  13:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   GNU General Public License for more details. 
  16:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** 
  17:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   You should have received a copy of the GNU General Public License 
  18:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** */
  20:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** 
  21:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** #ifndef _AQ_PID_H_
  22:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** #define _AQ_PID_H_
  23:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** 
  24:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** enum {
  25:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   RATE_XAXIS_PID_IDX = 0,
  26:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   RATE_YAXIS_PID_IDX,
  27:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   ZAXIS_PID_IDX,
  28:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   ATTITUDE_XAXIS_PID_IDX,
  29:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   ATTITUDE_YAXIS_PID_IDX,
  30:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   HEADING_HOLD_PID_IDX,
  31:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   ATTITUDE_GYRO_XAXIS_PID_IDX,
  32:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   ATTITUDE_GYRO_YAXIS_PID_IDX,
  33:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
  34:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     BARO_ALTITUDE_HOLD_PID_IDX,
  35:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     ZDAMPENING_PID_IDX,
  36:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   #endif
  37:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   #if defined AltitudeHoldRangeFinder
  38:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     SONAR_ALTITUDE_HOLD_PID_IDX,
  39:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   #endif
  40:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   #if defined UseGPSNavigator
  41:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     GPSPITCH_PID_IDX,
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     GPSROLL_PID_IDX,
  43:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     GPSYAW_PID_IDX,
  44:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   #endif    
  45:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** 
  46:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   LAST_PID_IDX  // keep this definition at the end of this enum
  47:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** };
  48:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** 
  49:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** //// PID Variables
  50:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** struct PIDdata {
  51:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   float P, I, D;
  52:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   float lastError;
  53:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   // AKA experiments with PID
  54:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   float previousPIDTime;
  55:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   float integratedError;
  56:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   float windupGuard; // Thinking about having individual wind up guards for each PID
  57:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** } PID[LAST_PID_IDX];
  58:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** 
  59:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** // This struct above declares the variable PID[] to hold each of the PID values for various functio
  60:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** // The following constants are declared in AeroQuad.h
  61:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** // ROLL = 0, PITCH = 1, YAW = 2 (used for Arcobatic Mode, gyros only)
  62:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** // ROLLLEVEL = 3, PITCHLEVEL = 4, LEVELGYROROLL = 6, LEVELGYROPITCH = 7 (used for Stable Mode, acce
  63:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** // HEADING = 5 (used for heading hold)
  64:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** // ALTITUDE = 8 (used for altitude hold)
  65:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** // ZDAMPENING = 9 (used in altitude hold to dampen vertical accelerations)
  66:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** float windupGuard; // Read in from EEPROM
  67:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** //// Modified from http://www.arduino.cc/playground/Main/BarebonesPIDForEspresso
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** float updatePID(float targetPosition, float currentPosition, struct PIDdata *PIDparameters) {
 602              		.loc 8 68 0
 603              		.cfi_startproc
 604              		@ args = 0, pretend = 0, frame = 0
 605              		@ frame_needed = 0, uses_anonymous_args = 0
 606              		@ link register save eliminated.
 607              	.LVL42:
 608              	.LBB28:
  69:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** 
  70:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   // AKA PID experiments
  71:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   const float deltaPIDTime = (currentTime - PIDparameters->previousPIDTime) / 1000000.0;
 609              		.loc 8 71 0
 610 0000 2A4B     		ldr	r3, .L52
 611              	.LBE28:
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** float updatePID(float targetPosition, float currentPosition, struct PIDdata *PIDparameters) {
 612              		.loc 8 68 0
 613 0002 07EE101A 		fmsr	s14, r1
 614              	.LBB29:
 615              		.loc 8 71 0
 616 0006 1968     		ldr	r1, [r3, #0]
 617              	.LVL43:
 618 0008 01EE101A 		fmsr	s2, r1	@ int
 619 000c D2ED040A 		flds	s1, [r2, #16]
 620 0010 B8EE410A 		fuitos	s0, s2
  72:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** 
  73:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   PIDparameters->previousPIDTime = currentTime;  // AKA PID experiments
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   float error = targetPosition - currentPosition;
 621              		.loc 8 74 0
 622 0014 07EE900A 		fmsr	s15, r0
  75:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** 
  76:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   if (inFlight) {
 623              		.loc 8 76 0
 624 0018 2548     		ldr	r0, .L52+4
 625              	.LVL44:
  71:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   const float deltaPIDTime = (currentTime - PIDparameters->previousPIDTime) / 1000000.0;
 626              		.loc 8 71 0
 627 001a 30EE606A 		fsubs	s12, s0, s1
 628 001e DFED256A 		flds	s13, .L52+8
 629              		.loc 8 76 0
 630 0022 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
  71:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   const float deltaPIDTime = (currentTime - PIDparameters->previousPIDTime) / 1000000.0;
 631              		.loc 8 71 0
 632 0024 86EE265A 		fdivs	s10, s12, s13
 633              	.LVL45:
  73:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   PIDparameters->previousPIDTime = currentTime;  // AKA PID experiments
 634              		.loc 8 73 0
 635 0028 82ED040A 		fsts	s0, [r2, #16]
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   float error = targetPosition - currentPosition;
 636              		.loc 8 74 0
 637 002c 77EEC75A 		fsubs	s11, s15, s14
 638              	.LVL46:
 639              		.loc 8 76 0
 640 0030 33B1     		cbz	r3, .L46
  77:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     PIDparameters->integratedError += error * deltaPIDTime;
 641              		.loc 8 77 0
 642 0032 D2ED051A 		flds	s3, [r2, #20]
 643 0036 45EE851A 		fmacs	s3, s11, s10
 644 003a C2ED051A 		fsts	s3, [r2, #20]
 645 003e 01E0     		b	.L47
 646              	.L46:
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   }
  79:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   else {
  80:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     PIDparameters->integratedError = 0.0;
 647              		.loc 8 80 0
 648 0040 0020     		movs	r0, #0
 649 0042 5061     		str	r0, [r2, #20]	@ float
 650              	.L47:
  81:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   }
  82:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   PIDparameters->integratedError = constrain(PIDparameters->integratedError, -PIDparameters->windup
 651              		.loc 8 82 0
 652 0044 D2ED066A 		flds	s13, [r2, #24]
 653 0048 92ED056A 		flds	s12, [r2, #20]
 654 004c F1EE667A 		fnegs	s15, s13
 655              	.LVL47:
 656 0050 B4EEE76A 		fcmpes	s12, s15
 657 0054 F1EE10FA 		fmstat
 658 0058 08D4     		bmi	.L48
 659              		.loc 8 82 0 is_stmt 0 discriminator 2
 660 005a B4EE666A 		fcmps	s12, s13
 661 005e F1EE10FA 		fmstat
 662 0062 CCBF     		ite	gt
 663 0064 F0EE667A 		fcpysgt	s15, s13
 664 0068 F0EE467A 		fcpysle	s15, s12
 665              	.L48:
  83:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   float dTerm = PIDparameters->D * (currentPosition - PIDparameters->lastError) / (deltaPIDTime * 1
 666              		.loc 8 83 0 is_stmt 1 discriminator 6
 667 006c D2ED034A 		flds	s9, [r2, #12]
 668 0070 92ED024A 		flds	s8, [r2, #8]
 669 0074 77EE643A 		fsubs	s7, s14, s9
 670 0078 DFED0F2A 		flds	s5, .L52+12
 671 007c 63EE843A 		fmuls	s7, s7, s8
 672 0080 65EE222A 		fmuls	s5, s10, s5
  84:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   PIDparameters->lastError = currentPosition;
  85:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** 
  86:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   return (PIDparameters->P * error) + (PIDparameters->I * PIDparameters->integratedError) + dTerm;
 673              		.loc 8 86 0 discriminator 6
 674 0084 92ED013A 		flds	s6, [r2, #4]
  83:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   float dTerm = PIDparameters->D * (currentPosition - PIDparameters->lastError) / (deltaPIDTime * 1
 675              		.loc 8 83 0 discriminator 6
 676 0088 C3EEA22A 		fdivs	s5, s7, s5
 677              	.LVL48:
  84:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   PIDparameters->lastError = currentPosition;
 678              		.loc 8 84 0 discriminator 6
 679 008c 82ED037A 		fsts	s14, [r2, #12]
 680              		.loc 8 86 0 discriminator 6
 681 0090 92ED007A 		flds	s14, [r2, #0]
 682              	.LVL49:
  82:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   PIDparameters->integratedError = constrain(PIDparameters->integratedError, -PIDparameters->windup
 683              		.loc 8 82 0 discriminator 6
 684 0094 C2ED057A 		fsts	s15, [r2, #20]
 685              		.loc 8 86 0 discriminator 6
 686 0098 67EE837A 		fmuls	s15, s15, s6
 687 009c 45EE877A 		fmacs	s15, s11, s14
 688              	.LBE29:
  87:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** }
 689              		.loc 8 87 0 discriminator 6
 690 00a0 37EEA22A 		fadds	s4, s15, s5
 691 00a4 12EE100A 		fmrs	r0, s4
 692 00a8 7047     		bx	lr
 693              	.L53:
 694 00aa 00BF     		.align	2
 695              	.L52:
 696 00ac 00000000 		.word	.LANCHOR15
 697 00b0 00000000 		.word	.LANCHOR16
 698 00b4 00247449 		.word	1232348160
 699 00b8 0000C842 		.word	1120403456
 700              		.cfi_endproc
 701              	.LFE124:
 703              		.section	.text._Z17zeroIntegralErrorv,"ax",%progbits
 704              		.align	1
 705              		.global	_Z17zeroIntegralErrorv
 706              		.thumb
 707              		.thumb_func
 709              	_Z17zeroIntegralErrorv:
 710              	.LFB125:
  88:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** 
  89:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** void zeroIntegralError() __attribute__ ((noinline));
  90:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** void zeroIntegralError() {
 711              		.loc 8 90 0
 712              		.cfi_startproc
 713              		@ args = 0, pretend = 0, frame = 0
 714              		@ frame_needed = 0, uses_anonymous_args = 0
 715              		@ link register save eliminated.
 716              	.LVL50:
 717              	.LBB30:
  91:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   for (byte axis = 0; axis <= ATTITUDE_YAXIS_PID_IDX; axis++) {
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     PID[axis].integratedError = 0;
  93:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     PID[axis].previousPIDTime = currentTime;
 718              		.loc 8 93 0
 719 0000 0C49     		ldr	r1, .L55
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     PID[axis].integratedError = 0;
 720              		.loc 8 92 0
 721 0002 0D4B     		ldr	r3, .L55+4
 722              		.loc 8 93 0
 723 0004 0868     		ldr	r0, [r1, #0]
 724 0006 07EE100A 		fmsr	s14, r0	@ int
 725 000a F8EE477A 		fuitos	s15, s14
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     PID[axis].integratedError = 0;
 726              		.loc 8 92 0
 727 000e 0022     		movs	r2, #0
 728 0010 5A61     		str	r2, [r3, #20]	@ float
 729              		.loc 8 93 0
 730 0012 C3ED047A 		fsts	s15, [r3, #16]
 731              	.LVL51:
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     PID[axis].integratedError = 0;
 732              		.loc 8 92 0
 733 0016 1A63     		str	r2, [r3, #48]	@ float
 734              		.loc 8 93 0
 735 0018 C3ED0B7A 		fsts	s15, [r3, #44]
 736              	.LVL52:
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     PID[axis].integratedError = 0;
 737              		.loc 8 92 0
 738 001c DA64     		str	r2, [r3, #76]	@ float
 739              		.loc 8 93 0
 740 001e C3ED127A 		fsts	s15, [r3, #72]
 741              	.LVL53:
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     PID[axis].integratedError = 0;
 742              		.loc 8 92 0
 743 0022 9A66     		str	r2, [r3, #104]	@ float
 744              		.loc 8 93 0
 745 0024 C3ED197A 		fsts	s15, [r3, #100]
 746              	.LVL54:
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****     PID[axis].integratedError = 0;
 747              		.loc 8 92 0
 748 0028 C3F88420 		str	r2, [r3, #132]	@ float
 749              		.loc 8 93 0
 750 002c C3ED207A 		fsts	s15, [r3, #128]
 751              	.LVL55:
 752              	.LBE30:
  94:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h ****   }
  95:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\PID.h **** }
 753              		.loc 8 95 0
 754 0030 7047     		bx	lr
 755              	.L56:
 756 0032 00BF     		.align	2
 757              	.L55:
 758 0034 00000000 		.word	.LANCHOR15
 759 0038 00000000 		.word	.LANCHOR17
 760              		.cfi_endproc
 761              	.LFE125:
 763              		.section	.text._Z18computeFourthOrderfP15fourthOrderData,"ax",%progbits
 764              		.align	1
 765              		.global	_Z18computeFourthOrderfP15fourthOrderData
 766              		.thumb
 767              		.thumb_func
 769              	_Z18computeFourthOrderfP15fourthOrderData:
 770              	.LFB126:
 771              		.file 9 "../Libraries/AQ_Math/FourtOrderFilter.h"
   1:../Libraries/AQ_Math/FourtOrderFilter.h **** /*
   2:../Libraries/AQ_Math/FourtOrderFilter.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Math/FourtOrderFilter.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Math/FourtOrderFilter.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Math/FourtOrderFilter.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Math/FourtOrderFilter.h ****  
   7:../Libraries/AQ_Math/FourtOrderFilter.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Math/FourtOrderFilter.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Math/FourtOrderFilter.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Math/FourtOrderFilter.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  12:../Libraries/AQ_Math/FourtOrderFilter.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Math/FourtOrderFilter.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Math/FourtOrderFilter.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Math/FourtOrderFilter.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  17:../Libraries/AQ_Math/FourtOrderFilter.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Math/FourtOrderFilter.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Math/FourtOrderFilter.h **** */
  20:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  21:../Libraries/AQ_Math/FourtOrderFilter.h **** #ifndef _AQ_FOURTH_ORDER_FILTER_H_
  22:../Libraries/AQ_Math/FourtOrderFilter.h **** #define _AQ_FOURTH_ORDER_FILTER_H_
  23:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  24:../Libraries/AQ_Math/FourtOrderFilter.h **** ////////////////////////////////////////////////////////////////////////////////
  25:../Libraries/AQ_Math/FourtOrderFilter.h **** //
  26:../Libraries/AQ_Math/FourtOrderFilter.h **** //
  27:../Libraries/AQ_Math/FourtOrderFilter.h **** ////////////////////////////////////////////////////////////////////////////////
  28:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  29:../Libraries/AQ_Math/FourtOrderFilter.h **** #include <GlobalDefined.h>
  30:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  31:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  32:../Libraries/AQ_Math/FourtOrderFilter.h **** struct fourthOrderData
  33:../Libraries/AQ_Math/FourtOrderFilter.h **** {
  34:../Libraries/AQ_Math/FourtOrderFilter.h ****   float  inputTm1,  inputTm2,  inputTm3,  inputTm4;
  35:../Libraries/AQ_Math/FourtOrderFilter.h ****   float outputTm1, outputTm2, outputTm3, outputTm4;
  36:../Libraries/AQ_Math/FourtOrderFilter.h **** } fourthOrder[4];
  37:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  38:../Libraries/AQ_Math/FourtOrderFilter.h **** float computeFourthOrder(float currentInput, struct fourthOrderData *filterParameters)
  39:../Libraries/AQ_Math/FourtOrderFilter.h **** {
 772              		.loc 9 39 0
 773              		.cfi_startproc
 774              		@ args = 0, pretend = 0, frame = 0
 775              		@ frame_needed = 0, uses_anonymous_args = 0
 776              		@ link register save eliminated.
 777              	.LVL56:
 778              	.LBB31:
  40:../Libraries/AQ_Math/FourtOrderFilter.h ****   // cheby2(4,60,12.5/50)
  41:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _b0  0.001893594048567
  42:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _b1 -0.002220262954039
  43:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _b2  0.003389066536478
  44:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _b3 -0.002220262954039
  45:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _b4  0.001893594048567
  46:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  47:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _a1 -3.362256889209355
  48:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _a2  4.282608240117919
  49:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _a3 -2.444765517272841
  50:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _a4  0.527149895089809
  51:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  52:../Libraries/AQ_Math/FourtOrderFilter.h ****   float output;
  53:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  54:../Libraries/AQ_Math/FourtOrderFilter.h ****   output = _b0 * currentInput                + 
  55:../Libraries/AQ_Math/FourtOrderFilter.h ****            _b1 * filterParameters->inputTm1  + 
  56:../Libraries/AQ_Math/FourtOrderFilter.h ****            _b2 * filterParameters->inputTm2  +
  57:../Libraries/AQ_Math/FourtOrderFilter.h ****            _b3 * filterParameters->inputTm3  +
  58:../Libraries/AQ_Math/FourtOrderFilter.h ****            _b4 * filterParameters->inputTm4  -
  59:../Libraries/AQ_Math/FourtOrderFilter.h ****            _a1 * filterParameters->outputTm1 -
  60:../Libraries/AQ_Math/FourtOrderFilter.h ****            _a2 * filterParameters->outputTm2 -
  61:../Libraries/AQ_Math/FourtOrderFilter.h ****            _a3 * filterParameters->outputTm3 -
  62:../Libraries/AQ_Math/FourtOrderFilter.h ****            _a4 * filterParameters->outputTm4;
 779              		.loc 9 62 0
 780 0000 91ED005A 		flds	s10, [r1, #0]
 781 0004 9FED203A 		flds	s6, .L58
 782              	.LBE31:
  39:../Libraries/AQ_Math/FourtOrderFilter.h **** {
 783              		.loc 9 39 0
 784 0008 05EE900A 		fmsr	s11, r0
 785              	.LBB32:
 786              		.loc 9 62 0
 787 000c 9FED1F2A 		flds	s4, .L58+4
 788 0010 65EE037A 		fmuls	s15, s10, s6
 789 0014 45EE827A 		fmacs	s15, s11, s4
 790 0018 D1ED014A 		flds	s9, [r1, #4]
 791 001c DFED1C2A 		flds	s5, .L58+8
 792 0020 44EEA27A 		fmacs	s15, s9, s5
 793 0024 91ED024A 		flds	s8, [r1, #8]
 794 0028 44EE037A 		fmacs	s15, s8, s6
 795 002c D1ED031A 		flds	s3, [r1, #12]
 796 0030 41EE827A 		fmacs	s15, s3, s4
 797 0034 91ED047A 		flds	s14, [r1, #16]
 798 0038 9FED161A 		flds	s2, .L58+12
 799 003c 47EE017A 		fmacs	s15, s14, s2
 800 0040 D1ED056A 		flds	s13, [r1, #20]
 801 0044 DFED140A 		flds	s1, .L58+16
 802 0048 46EEE07A 		fnmacs	s15, s13, s1
 803 004c 91ED066A 		flds	s12, [r1, #24]
 804 0050 9FED120A 		flds	s0, .L58+20
 805 0054 46EE007A 		fmacs	s15, s12, s0
 806 0058 91ED073A 		flds	s6, [r1, #28]
 807 005c DFED103A 		flds	s7, .L58+24
 808 0060 43EE637A 		fnmacs	s15, s6, s7
 809              	.LVL57:
  63:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  64:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm4 = filterParameters->inputTm3;
  65:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm3 = filterParameters->inputTm2;
  66:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm2 = filterParameters->inputTm1;
  67:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm1 = currentInput;
 810              		.loc 9 67 0
 811 0064 0860     		str	r0, [r1, #0]	@ float
  64:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm4 = filterParameters->inputTm3;
 812              		.loc 9 64 0
 813 0066 81ED034A 		fsts	s8, [r1, #12]
  65:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm3 = filterParameters->inputTm2;
 814              		.loc 9 65 0
 815 006a C1ED024A 		fsts	s9, [r1, #8]
  66:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm2 = filterParameters->inputTm1;
 816              		.loc 9 66 0
 817 006e 81ED015A 		fsts	s10, [r1, #4]
  68:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  69:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->outputTm4 = filterParameters->outputTm3;
 818              		.loc 9 69 0
 819 0072 81ED076A 		fsts	s12, [r1, #28]
  70:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->outputTm3 = filterParameters->outputTm2;
 820              		.loc 9 70 0
 821 0076 C1ED066A 		fsts	s13, [r1, #24]
  71:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->outputTm2 = filterParameters->outputTm1;
 822              		.loc 9 71 0
 823 007a 81ED057A 		fsts	s14, [r1, #20]
  72:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->outputTm1 = output;
 824              		.loc 9 72 0
 825 007e C1ED047A 		fsts	s15, [r1, #16]
 826              	.LBE32:
  73:../Libraries/AQ_Math/FourtOrderFilter.h ****     
  74:../Libraries/AQ_Math/FourtOrderFilter.h ****   return output;
  75:../Libraries/AQ_Math/FourtOrderFilter.h **** }
 827              		.loc 9 75 0
 828 0082 17EE900A 		fmrs	r0, s15
 829              	.LVL58:
 830 0086 7047     		bx	lr
 831              	.L59:
 832              		.align	2
 833              	.L58:
 834 0088 D58111BB 		.word	-1156480555
 835 008c 7932F83A 		.word	989344377
 836 0090 1A1B5E3B 		.word	996023066
 837 0094 382F5740 		.word	1079455544
 838 0098 200B8940 		.word	1082723104
 839 009c 0A771C40 		.word	1075607306
 840 00a0 4CF3063F 		.word	1057420108
 841              		.cfi_endproc
 842              	.LFE126:
 844              		.section	.text._Z16setupFourthOrderv,"ax",%progbits
 845              		.align	1
 846              		.global	_Z16setupFourthOrderv
 847              		.thumb
 848              		.thumb_func
 850              	_Z16setupFourthOrderv:
 851              	.LFB127:
  76:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  77:../Libraries/AQ_Math/FourtOrderFilter.h **** void setupFourthOrder(void)
  78:../Libraries/AQ_Math/FourtOrderFilter.h **** {
 852              		.loc 9 78 0
 853              		.cfi_startproc
 854              		@ args = 0, pretend = 0, frame = 0
 855              		@ frame_needed = 0, uses_anonymous_args = 0
 856              		@ link register save eliminated.
  79:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm1 = 0.0;
 857              		.loc 9 79 0
 858 0000 0D4B     		ldr	r3, .L61
  80:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm2 = 0.0;
  81:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm3 = 0.0;
  82:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm4 = 0.0;
  83:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  84:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm1 = 0.0;
  85:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm2 = 0.0;
  86:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm3 = 0.0;
  87:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm4 = 0.0;
  88:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  89:../Libraries/AQ_Math/FourtOrderFilter.h ****   //////////
  90:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm1 = 0.0;
  91:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm2 = 0.0;
  92:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm3 = 0.0;
  93:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm4 = 0.0;
  94:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  95:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm1 = 0.0;
  96:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm2 = 0.0;
  97:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm3 = 0.0;
  98:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm4 = 0.0;
  99:../Libraries/AQ_Math/FourtOrderFilter.h ****   
 100:../Libraries/AQ_Math/FourtOrderFilter.h ****   //////////
 101:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].inputTm1 = -9.8065;
 859              		.loc 9 101 0
 860 0002 0E4A     		ldr	r2, .L61+4
  79:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm1 = 0.0;
 861              		.loc 9 79 0
 862 0004 0020     		movs	r0, #0
 863 0006 1860     		str	r0, [r3, #0]	@ float
  80:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm2 = 0.0;
 864              		.loc 9 80 0
 865 0008 5860     		str	r0, [r3, #4]	@ float
  81:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm3 = 0.0;
 866              		.loc 9 81 0
 867 000a 9860     		str	r0, [r3, #8]	@ float
  82:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm4 = 0.0;
 868              		.loc 9 82 0
 869 000c D860     		str	r0, [r3, #12]	@ float
  84:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm1 = 0.0;
 870              		.loc 9 84 0
 871 000e 1861     		str	r0, [r3, #16]	@ float
  85:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm2 = 0.0;
 872              		.loc 9 85 0
 873 0010 5861     		str	r0, [r3, #20]	@ float
  86:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm3 = 0.0;
 874              		.loc 9 86 0
 875 0012 9861     		str	r0, [r3, #24]	@ float
  87:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm4 = 0.0;
 876              		.loc 9 87 0
 877 0014 D861     		str	r0, [r3, #28]	@ float
  90:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm1 = 0.0;
 878              		.loc 9 90 0
 879 0016 1862     		str	r0, [r3, #32]	@ float
  91:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm2 = 0.0;
 880              		.loc 9 91 0
 881 0018 5862     		str	r0, [r3, #36]	@ float
  92:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm3 = 0.0;
 882              		.loc 9 92 0
 883 001a 9862     		str	r0, [r3, #40]	@ float
  93:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm4 = 0.0;
 884              		.loc 9 93 0
 885 001c D862     		str	r0, [r3, #44]	@ float
  95:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm1 = 0.0;
 886              		.loc 9 95 0
 887 001e 1863     		str	r0, [r3, #48]	@ float
  96:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm2 = 0.0;
 888              		.loc 9 96 0
 889 0020 5863     		str	r0, [r3, #52]	@ float
  97:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm3 = 0.0;
 890              		.loc 9 97 0
 891 0022 9863     		str	r0, [r3, #56]	@ float
  98:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm4 = 0.0;
 892              		.loc 9 98 0
 893 0024 D863     		str	r0, [r3, #60]	@ float
 894              		.loc 9 101 0
 895 0026 1A64     		str	r2, [r3, #64]	@ float
 102:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].inputTm2 = -9.8065;
 896              		.loc 9 102 0
 897 0028 5A64     		str	r2, [r3, #68]	@ float
 103:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].inputTm3 = -9.8065;
 898              		.loc 9 103 0
 899 002a 9A64     		str	r2, [r3, #72]	@ float
 104:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].inputTm4 = -9.8065;
 900              		.loc 9 104 0
 901 002c DA64     		str	r2, [r3, #76]	@ float
 105:../Libraries/AQ_Math/FourtOrderFilter.h ****   
 106:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].outputTm1 = -9.8065;
 902              		.loc 9 106 0
 903 002e 1A65     		str	r2, [r3, #80]	@ float
 107:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].outputTm2 = -9.8065;
 904              		.loc 9 107 0
 905 0030 5A65     		str	r2, [r3, #84]	@ float
 108:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].outputTm3 = -9.8065;
 906              		.loc 9 108 0
 907 0032 9A65     		str	r2, [r3, #88]	@ float
 109:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].outputTm4 = -9.8065;
 908              		.loc 9 109 0
 909 0034 DA65     		str	r2, [r3, #92]	@ float
 110:../Libraries/AQ_Math/FourtOrderFilter.h **** }
 910              		.loc 9 110 0
 911 0036 7047     		bx	lr
 912              	.L62:
 913              		.align	2
 914              	.L61:
 915 0038 00000000 		.word	.LANCHOR18
 916 003c 6DE71CC1 		.word	-1055070355
 917              		.cfi_endproc
 918              	.LFE127:
 920              		.section	.text._ZN14HardwareSPIExt5SetCSEi,"axG",%progbits,_ZN14HardwareSPIExt5SetCSEi,comdat
 921              		.align	1
 922              		.weak	_ZN14HardwareSPIExt5SetCSEi
 923              		.thumb
 924              		.thumb_func
 926              	_ZN14HardwareSPIExt5SetCSEi:
 927              	.LFB131:
 928              		.file 10 "../Libraries/AQ_SPI/HardwareSPIExt.h"
   1:../Libraries/AQ_SPI/HardwareSPIExt.h **** #ifndef _AEROQUAD_SPI_HARDWARESPIEXT_H_
   2:../Libraries/AQ_SPI/HardwareSPIExt.h **** #define _AEROQUAD_SPI_HARDWARESPIEXT_H_
   3:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
   4:../Libraries/AQ_SPI/HardwareSPIExt.h **** #if defined(AeroQuadSTM32)
   5:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
   6:../Libraries/AQ_SPI/HardwareSPIExt.h **** // helper class to extend the maple HardwareSPI class
   7:../Libraries/AQ_SPI/HardwareSPIExt.h **** // used by the MPU6000 library
   8:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
   9:../Libraries/AQ_SPI/HardwareSPIExt.h **** #include <HardwareSPI.h>
  10:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  11:../Libraries/AQ_SPI/HardwareSPIExt.h **** #define SPI_READ_FLAG  0x80
  12:../Libraries/AQ_SPI/HardwareSPIExt.h **** #define SPI_MULTI_FLAG 0x40
  13:../Libraries/AQ_SPI/HardwareSPIExt.h **** #define SetPin digitalWrite
  14:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  15:../Libraries/AQ_SPI/HardwareSPIExt.h **** class HardwareSPIExt : public HardwareSPI {
  16:../Libraries/AQ_SPI/HardwareSPIExt.h **** public:
  17:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	HardwareSPIExt(uint32 spiPortNumber) : HardwareSPI(spiPortNumber) {
  18:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetCS(nssPin());
  19:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		fSpiMultiFlag = 0;
  20:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
  21:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  22:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void SetCS(int aCS)
 929              		.loc 10 22 0
 930              		.cfi_startproc
 931              		@ args = 0, pretend = 0, frame = 0
 932              		@ frame_needed = 0, uses_anonymous_args = 0
 933              		@ link register save eliminated.
 934              	.LVL59:
  23:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  24:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		fCS = aCS;
 935              		.loc 10 24 0
 936 0000 4160     		str	r1, [r0, #4]
  25:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 937              		.loc 10 25 0
 938 0002 7047     		bx	lr
 939              		.cfi_endproc
 940              	.LFE131:
 942              		.section	.text._ZN14HardwareSPIExtC2Ej,"axG",%progbits,_ZN14HardwareSPIExtC5Ej,comdat
 943              		.align	1
 944              		.weak	_ZN14HardwareSPIExtC2Ej
 945              		.thumb
 946              		.thumb_func
 948              	_ZN14HardwareSPIExtC2Ej:
 949              	.LFB129:
  17:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	HardwareSPIExt(uint32 spiPortNumber) : HardwareSPI(spiPortNumber) {
 950              		.loc 10 17 0
 951              		.cfi_startproc
 952              		@ args = 0, pretend = 0, frame = 0
 953              		@ frame_needed = 0, uses_anonymous_args = 0
 954              	.LVL60:
 955 0000 10B5     		push	{r4, lr}
 956              	.LCFI4:
 957              		.cfi_def_cfa_offset 8
 958              		.cfi_offset 14, -4
 959              		.cfi_offset 4, -8
  17:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	HardwareSPIExt(uint32 spiPortNumber) : HardwareSPI(spiPortNumber) {
 960              		.loc 10 17 0
 961 0002 0446     		mov	r4, r0
 962              	.LBB33:
 963 0004 FFF7FEFF 		bl	_ZN11HardwareSPIC2Ej
 964              	.LVL61:
  18:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetCS(nssPin());
 965              		.loc 10 18 0
 966 0008 2046     		mov	r0, r4
 967 000a FFF7FEFF 		bl	_ZN11HardwareSPI6nssPinEv
 968 000e 0146     		mov	r1, r0
 969 0010 2046     		mov	r0, r4
 970 0012 FFF7FEFF 		bl	_ZN14HardwareSPIExt5SetCSEi
  19:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		fSpiMultiFlag = 0;
 971              		.loc 10 19 0
 972 0016 0023     		movs	r3, #0
 973 0018 2372     		strb	r3, [r4, #8]
 974              	.LBE33:
  20:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 975              		.loc 10 20 0
 976 001a 2046     		mov	r0, r4
 977 001c 10BD     		pop	{r4, pc}
 978              		.cfi_endproc
 979              	.LFE129:
 981              		.section	.text._ZN14HardwareSPIExt5beginE12SPIFrequencyjj,"axG",%progbits,_ZN14HardwareSPIExt5begi
 982              		.align	1
 983              		.weak	_ZN14HardwareSPIExt5beginE12SPIFrequencyjj
 984              		.thumb
 985              		.thumb_func
 987              	_ZN14HardwareSPIExt5beginE12SPIFrequencyjj:
 988              	.LFB133:
  26:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  27:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void SetMultiFlag() {
  28:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		fSpiMultiFlag = SPI_MULTI_FLAG;
  29:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
  30:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  31:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void begin(SPIFrequency frequency, uint32 bitOrder, uint32 mode)
 989              		.loc 10 31 0
 990              		.cfi_startproc
 991              		@ args = 0, pretend = 0, frame = 0
 992              		@ frame_needed = 0, uses_anonymous_args = 0
 993              	.LVL62:
 994 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 995              	.LCFI5:
 996              		.cfi_def_cfa_offset 24
 997              		.cfi_offset 14, -4
 998              		.cfi_offset 8, -8
 999              		.cfi_offset 7, -12
 1000              		.cfi_offset 6, -16
 1001              		.cfi_offset 5, -20
 1002              		.cfi_offset 4, -24
 1003              		.loc 10 31 0
 1004 0004 0446     		mov	r4, r0
 1005 0006 0D46     		mov	r5, r1
  32:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  33:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
 1006              		.loc 10 33 0
 1007 0008 0079     		ldrb	r0, [r0, #4]	@ zero_extendqisi2
 1008              	.LVL63:
 1009 000a 0121     		movs	r1, #1
 1010              	.LVL64:
  31:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void begin(SPIFrequency frequency, uint32 bitOrder, uint32 mode)
 1011              		.loc 10 31 0
 1012 000c 1746     		mov	r7, r2
 1013 000e 1E46     		mov	r6, r3
 1014              		.loc 10 33 0
 1015 0010 FFF7FEFF 		bl	_Z12digitalWritehh
 1016              	.LVL65:
  34:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		pinMode(fCS, OUTPUT);
 1017              		.loc 10 34 0
 1018 0014 2079     		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 1019 0016 0021     		movs	r1, #0
 1020 0018 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
  35:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  36:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		HardwareSPI::begin(frequency, bitOrder, mode);
 1021              		.loc 10 36 0
 1022 001c 2046     		mov	r0, r4
 1023 001e 2946     		mov	r1, r5
 1024 0020 3A46     		mov	r2, r7
 1025 0022 3346     		mov	r3, r6
  37:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 1026              		.loc 10 37 0
 1027 0024 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
  36:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		HardwareSPI::begin(frequency, bitOrder, mode);
 1028              		.loc 10 36 0
 1029 0028 FFF7FEBF 		b	_ZN11HardwareSPI5beginE12SPIFrequencyjj
 1030              		.cfi_endproc
 1031              	.LFE133:
 1033              		.section	.text._ZN14HardwareSPIExt4ReadEiPhi,"axG",%progbits,_ZN14HardwareSPIExt4ReadEiPhi,comdat
 1034              		.align	1
 1035              		.weak	_ZN14HardwareSPIExt4ReadEiPhi
 1036              		.thumb
 1037              		.thumb_func
 1039              	_ZN14HardwareSPIExt4ReadEiPhi:
 1040              	.LFB134:
  38:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  39:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void Read(int addr, unsigned char *data, int dataLen)
 1041              		.loc 10 39 0
 1042              		.cfi_startproc
 1043              		@ args = 0, pretend = 0, frame = 0
 1044              		@ frame_needed = 0, uses_anonymous_args = 0
 1045              	.LVL66:
 1046 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1047              	.LCFI6:
 1048              		.cfi_def_cfa_offset 24
 1049              		.cfi_offset 14, -4
 1050              		.cfi_offset 7, -8
 1051              		.cfi_offset 6, -12
 1052              		.cfi_offset 5, -16
 1053              		.cfi_offset 4, -20
 1054              		.cfi_offset 3, -24
 1055              		.loc 10 39 0
 1056 0002 0446     		mov	r4, r0
 1057 0004 0D46     		mov	r5, r1
  40:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  41:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 0);
 1058              		.loc 10 41 0
 1059 0006 0079     		ldrb	r0, [r0, #4]	@ zero_extendqisi2
 1060              	.LVL67:
 1061 0008 0021     		movs	r1, #0
 1062              	.LVL68:
  39:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void Read(int addr, unsigned char *data, int dataLen)
 1063              		.loc 10 39 0
 1064 000a 1F46     		mov	r7, r3
 1065 000c 1646     		mov	r6, r2
 1066              		.loc 10 41 0
 1067 000e FFF7FEFF 		bl	_Z12digitalWritehh
 1068              	.LVL69:
  42:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		transfer(addr | SPI_READ_FLAG | fSpiMultiFlag);
 1069              		.loc 10 42 0
 1070 0012 207A     		ldrb	r0, [r4, #8]	@ zero_extendqisi2
 1071 0014 60F07F03 		orn	r3, r0, #127
 1072 0018 1D43     		orrs	r5, r5, r3
 1073              	.LVL70:
 1074 001a E9B2     		uxtb	r1, r5
 1075 001c 2046     		mov	r0, r4
 1076 001e FFF7FEFF 		bl	_ZN11HardwareSPI8transferEh
 1077 0022 3D46     		mov	r5, r7
  43:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		while(dataLen-- > 0) {
 1078              		.loc 10 43 0
 1079 0024 06E0     		b	.L68
 1080              	.LVL71:
 1081              	.L69:
  44:../Libraries/AQ_SPI/HardwareSPIExt.h **** 			*data++ = transfer(0);
 1082              		.loc 10 44 0
 1083 0026 2046     		mov	r0, r4
 1084 0028 0021     		movs	r1, #0
 1085 002a FFF7FEFF 		bl	_ZN11HardwareSPI8transferEh
 1086 002e 06F8010B 		strb	r0, [r6], #1
 1087              	.LVL72:
 1088 0032 013D     		subs	r5, r5, #1
 1089              	.L68:
  43:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		while(dataLen-- > 0) {
 1090              		.loc 10 43 0 discriminator 1
 1091 0034 002D     		cmp	r5, #0
 1092 0036 F6DC     		bgt	.L69
  45:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		}
  46:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
 1093              		.loc 10 46 0
 1094 0038 2079     		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 1095 003a 0121     		movs	r1, #1
  47:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 1096              		.loc 10 47 0
 1097 003c BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
  46:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
 1098              		.loc 10 46 0
 1099 0040 FFF7FEBF 		b	_Z12digitalWritehh
 1100              		.cfi_endproc
 1101              	.LFE134:
 1103              		.section	.text._ZN14HardwareSPIExt4ReadEi,"axG",%progbits,_ZN14HardwareSPIExt4ReadEi,comdat
 1104              		.align	1
 1105              		.weak	_ZN14HardwareSPIExt4ReadEi
 1106              		.thumb
 1107              		.thumb_func
 1109              	_ZN14HardwareSPIExt4ReadEi:
 1110              	.LFB135:
  48:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  49:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	unsigned char Read(int addr)
 1111              		.loc 10 49 0
 1112              		.cfi_startproc
 1113              		@ args = 0, pretend = 0, frame = 8
 1114              		@ frame_needed = 0, uses_anonymous_args = 0
 1115              	.LVL73:
 1116 0000 07B5     		push	{r0, r1, r2, lr}
 1117              	.LCFI7:
 1118              		.cfi_def_cfa_offset 16
 1119              		.cfi_offset 14, -4
 1120              		.cfi_offset 2, -8
 1121              		.cfi_offset 1, -12
 1122              		.cfi_offset 0, -16
 1123              	.LBB34:
  50:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  51:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		unsigned char data;
  52:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		Read(addr, &data, 1);
 1124              		.loc 10 52 0
 1125 0002 0123     		movs	r3, #1
 1126 0004 0DF10702 		add	r2, sp, #7
 1127 0008 FFF7FEFF 		bl	_ZN14HardwareSPIExt4ReadEiPhi
 1128              	.LVL74:
 1129              	.LBE34:
  53:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  54:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		return data;
  55:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 1130              		.loc 10 55 0
 1131 000c 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 1132 0010 0EBD     		pop	{r1, r2, r3, pc}
 1133              		.cfi_endproc
 1134              	.LFE135:
 1136              		.section	.text._ZN14HardwareSPIExt5WriteEiPhi,"axG",%progbits,_ZN14HardwareSPIExt5WriteEiPhi,comda
 1137              		.align	1
 1138              		.weak	_ZN14HardwareSPIExt5WriteEiPhi
 1139              		.thumb
 1140              		.thumb_func
 1142              	_ZN14HardwareSPIExt5WriteEiPhi:
 1143              	.LFB136:
  56:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  57:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void Write(int addr, unsigned char *data, int dataLen)
 1144              		.loc 10 57 0
 1145              		.cfi_startproc
 1146              		@ args = 0, pretend = 0, frame = 0
 1147              		@ frame_needed = 0, uses_anonymous_args = 0
 1148              	.LVL75:
 1149 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1150              	.LCFI8:
 1151              		.cfi_def_cfa_offset 24
 1152              		.cfi_offset 14, -4
 1153              		.cfi_offset 7, -8
 1154              		.cfi_offset 6, -12
 1155              		.cfi_offset 5, -16
 1156              		.cfi_offset 4, -20
 1157              		.cfi_offset 3, -24
 1158              		.loc 10 57 0
 1159 0002 0446     		mov	r4, r0
 1160 0004 0D46     		mov	r5, r1
  58:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  59:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 0);
 1161              		.loc 10 59 0
 1162 0006 0079     		ldrb	r0, [r0, #4]	@ zero_extendqisi2
 1163              	.LVL76:
 1164 0008 0021     		movs	r1, #0
 1165              	.LVL77:
  57:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void Write(int addr, unsigned char *data, int dataLen)
 1166              		.loc 10 57 0
 1167 000a 1F46     		mov	r7, r3
 1168 000c 1646     		mov	r6, r2
 1169              		.loc 10 59 0
 1170 000e FFF7FEFF 		bl	_Z12digitalWritehh
 1171              	.LVL78:
  60:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		transfer(addr | fSpiMultiFlag);
 1172              		.loc 10 60 0
 1173 0012 237A     		ldrb	r3, [r4, #8]	@ zero_extendqisi2
 1174 0014 1D43     		orrs	r5, r5, r3
 1175              	.LVL79:
 1176 0016 E9B2     		uxtb	r1, r5
 1177 0018 2046     		mov	r0, r4
 1178 001a FFF7FEFF 		bl	_ZN11HardwareSPI8transferEh
 1179 001e 3D46     		mov	r5, r7
  61:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		while(dataLen-- > 0) {
 1180              		.loc 10 61 0
 1181 0020 05E0     		b	.L72
 1182              	.LVL80:
 1183              	.L73:
  62:../Libraries/AQ_SPI/HardwareSPIExt.h **** 			transfer(*data++);
 1184              		.loc 10 62 0
 1185 0022 2046     		mov	r0, r4
 1186 0024 16F8011B 		ldrb	r1, [r6], #1	@ zero_extendqisi2
 1187              	.LVL81:
 1188 0028 FFF7FEFF 		bl	_ZN11HardwareSPI8transferEh
 1189 002c 013D     		subs	r5, r5, #1
 1190              	.LVL82:
 1191              	.L72:
  61:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		while(dataLen-- > 0) {
 1192              		.loc 10 61 0 discriminator 1
 1193 002e 002D     		cmp	r5, #0
 1194 0030 F7DC     		bgt	.L73
  63:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		}
  64:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
 1195              		.loc 10 64 0
 1196 0032 2079     		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 1197 0034 0121     		movs	r1, #1
  65:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 1198              		.loc 10 65 0
 1199 0036 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
  64:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
 1200              		.loc 10 64 0
 1201 003a FFF7FEBF 		b	_Z12digitalWritehh
 1202              		.cfi_endproc
 1203              	.LFE136:
 1205              		.section	.text._ZN14HardwareSPIExt5WriteEih,"axG",%progbits,_ZN14HardwareSPIExt5WriteEih,comdat
 1206              		.align	1
 1207              		.weak	_ZN14HardwareSPIExt5WriteEih
 1208              		.thumb
 1209              		.thumb_func
 1211              	_ZN14HardwareSPIExt5WriteEih:
 1212              	.LFB137:
  66:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  67:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void Write(int addr, unsigned char data)
 1213              		.loc 10 67 0
 1214              		.cfi_startproc
 1215              		@ args = 0, pretend = 0, frame = 8
 1216              		@ frame_needed = 0, uses_anonymous_args = 0
 1217              	.LVL83:
 1218 0000 07B5     		push	{r0, r1, r2, lr}
 1219              	.LCFI9:
 1220              		.cfi_def_cfa_offset 16
 1221              		.cfi_offset 14, -4
 1222              		.cfi_offset 2, -8
 1223              		.cfi_offset 1, -12
 1224              		.cfi_offset 0, -16
 1225              	.LVL84:
 1226              		.loc 10 67 0
 1227 0002 02AB     		add	r3, sp, #8
 1228              	.LVL85:
 1229 0004 03F8012D 		strb	r2, [r3, #-1]!
  68:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  69:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		Write(addr, &data, 1);
 1230              		.loc 10 69 0
 1231 0008 1A46     		mov	r2, r3
 1232              	.LVL86:
 1233 000a 0123     		movs	r3, #1
 1234 000c FFF7FEFF 		bl	_ZN14HardwareSPIExt5WriteEiPhi
 1235              	.LVL87:
  70:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 1236              		.loc 10 70 0
 1237 0010 0EBD     		pop	{r1, r2, r3, pc}
 1238              		.cfi_endproc
 1239              	.LFE137:
 1241              		.section	.text._Z19MPU6000_SpiLowSpeedv,"ax",%progbits
 1242              		.align	1
 1243              		.global	_Z19MPU6000_SpiLowSpeedv
 1244              		.thumb
 1245              		.thumb_func
 1247              	_Z19MPU6000_SpiLowSpeedv:
 1248              	.LFB138:
 1249              		.file 11 "../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h"
   1:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** /*
   2:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   AeroQuad v3.0 - May 2011
   3:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   Copyright (c) 2011 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
   7:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   This program is free software: you can redistribute it and/or modify
   8:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   it under the terms of the GNU General Public License as published by
   9:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   the Free Software Foundation, either version 3 of the License, or
  10:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   (at your option) any later version.
  11:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  12:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   This program is distributed in the hope that it will be useful,
  13:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   GNU General Public License for more details.
  16:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  17:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   You should have received a copy of the GNU General Public License
  18:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** */
  20:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  21:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** // parts of the init sequence were taken from AP_InertialSensor_MPU6000.h
  22:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  23:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifndef _AEROQUAD_PLATFORM_MPU6000_H_
  24:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define _AEROQUAD_PLATFORM_MPU6000_H_
  25:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  26:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** // I2C support for MPU6000/6050 is not tested yet
  27:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** //#define MPU6000_I2C
  28:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  29:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #include "Arduino.h"
  30:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #include <SensorsStatus.h>
  31:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  32:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** //#define MPU6000_I2C	// insert this define before #include <Platform_MPU6000.h> when you use a I2C
  33:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  34:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** // MPU 6000 registers
  35:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_WHOAMI			0x75
  36:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_SMPLRT_DIV		0x19
  37:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_CONFIG			0x1A
  38:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_CONFIG		0x1B
  39:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_CONFIG		0x1C
  40:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_FIFO_EN			0x23
  41:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_INT_PIN_CFG		0x37
  42:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_INT_ENABLE		0x38
  43:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_INT_STATUS		0x3A
  44:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_XOUT_H		0x3B
  45:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_XOUT_L		0x3C
  46:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_YOUT_H		0x3D
  47:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_YOUT_L		0x3E
  48:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_ZOUT_H		0x3F
  49:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_ZOUT_L		0x40
  50:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_TEMP_OUT_H		0x41
  51:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_TEMP_OUT_L		0x42
  52:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_XOUT_H		0x43
  53:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_XOUT_L		0x44
  54:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_YOUT_H		0x45
  55:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_YOUT_L		0x46
  56:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_ZOUT_H		0x47
  57:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_ZOUT_L		0x48
  58:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_USER_CTRL		0x6A
  59:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_PWR_MGMT_1		0x6B
  60:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_PWR_MGMT_2		0x6C
  61:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_FIFO_COUNTH		0x72
  62:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_FIFO_COUNTL		0x73
  63:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_FIFO_R_W			0x74
  64:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  65:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  66:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** // Configuration bits
  67:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_SLEEP				0x40
  68:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_H_RESET				0x80
  69:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_CLKSEL				0x07
  70:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPU_CLK_SEL_PLLGYROX	0x01
  71:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPU_CLK_SEL_PLLGYROZ	0x03
  72:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPU_EXT_SYNC_GYROX		0x02
  73:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_FS_250DPS          0x00
  74:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_FS_500DPS          0x08
  75:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_FS_1000DPS         0x10
  76:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_FS_2000DPS         0x18
  77:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_FS_MASK            0x18
  78:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_256HZ_NOLPF2  0x00
  79:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_188HZ         0x01
  80:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_98HZ          0x02
  81:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_42HZ          0x03
  82:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_20HZ          0x04
  83:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_10HZ          0x05
  84:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_5HZ           0x06
  85:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_2100HZ_NOLPF  0x07
  86:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_MASK          0x07
  87:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_INT_ANYRD_2CLEAR    0x10
  88:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_RAW_RDY_EN			0x01
  89:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_I2C_IF_DIS          0x10
  90:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_INT_STATUS_DATA		0x01
  91:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  92:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  93:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** typedef struct {
  94:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	short x;
  95:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	short y;
  96:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	short z;
  97:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** } tAxis;
  98:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  99:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** union uMPU6000 {
 100:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	unsigned char rawByte[];
 101:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	unsigned short rawWord[];
 102:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	struct {
 103:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		tAxis accel;
 104:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		short temperature;
 105:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		tAxis gyro;
 106:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	} data;
 107:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** } MPU6000;
 108:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 109:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 110:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifdef MPU6000_I2C
 111:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	#ifndef MPU6000_I2C_ADDRESS
 112:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		#define MPU6000_I2C_ADDRESS 0x68
 113:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	#endif
 114:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #else
 115:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	#include <HardwareSPIExt.h>
 116:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	HardwareSPIExt spiMPU6000(4);
 117:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #endif
 118:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 119:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void MPU6000_SpiLowSpeed()
 120:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1250              		.loc 11 120 0
 1251              		.cfi_startproc
 1252              		@ args = 0, pretend = 0, frame = 0
 1253              		@ frame_needed = 0, uses_anonymous_args = 0
 1254 0000 08B5     		push	{r3, lr}
 1255              	.LCFI10:
 1256              		.cfi_def_cfa_offset 8
 1257              		.cfi_offset 14, -4
 1258              		.cfi_offset 3, -8
 121:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifndef MPU6000_I2C
 122:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	spiMPU6000.begin(SPI_562_500KHZ, MSBFIRST, 3);
 1259              		.loc 11 122 0
 1260 0002 0348     		ldr	r0, .L76
 1261 0004 0521     		movs	r1, #5
 1262 0006 0122     		movs	r2, #1
 1263 0008 0323     		movs	r3, #3
 1264 000a FFF7FEFF 		bl	_ZN14HardwareSPIExt5beginE12SPIFrequencyjj
 123:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #endif
 124:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1265              		.loc 11 124 0
 1266 000e 08BD     		pop	{r3, pc}
 1267              	.L77:
 1268              		.align	2
 1269              	.L76:
 1270 0010 00000000 		.word	.LANCHOR19
 1271              		.cfi_endproc
 1272              	.LFE138:
 1274              		.section	.text._Z20MPU6000_SpiHighSpeedv,"ax",%progbits
 1275              		.align	1
 1276              		.global	_Z20MPU6000_SpiHighSpeedv
 1277              		.thumb
 1278              		.thumb_func
 1280              	_Z20MPU6000_SpiHighSpeedv:
 1281              	.LFB139:
 125:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 126:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void MPU6000_SpiHighSpeed()
 127:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1282              		.loc 11 127 0
 1283              		.cfi_startproc
 1284              		@ args = 0, pretend = 0, frame = 0
 1285              		@ frame_needed = 0, uses_anonymous_args = 0
 1286 0000 10B5     		push	{r4, lr}
 1287              	.LCFI11:
 1288              		.cfi_def_cfa_offset 8
 1289              		.cfi_offset 14, -4
 1290              		.cfi_offset 4, -8
 128:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifndef MPU6000_I2C
 129:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	spiMPU6000.end();
 1291              		.loc 11 129 0
 1292 0002 054C     		ldr	r4, .L79
 1293 0004 2046     		mov	r0, r4
 1294 0006 FFF7FEFF 		bl	_ZN11HardwareSPI3endEv
 130:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     spiMPU6000.begin(SPI_9MHZ, MSBFIRST, 3);
 1295              		.loc 11 130 0
 1296 000a 0121     		movs	r1, #1
 1297 000c 2046     		mov	r0, r4
 1298 000e 0A46     		mov	r2, r1
 1299 0010 0323     		movs	r3, #3
 1300 0012 FFF7FEFF 		bl	_ZN14HardwareSPIExt5beginE12SPIFrequencyjj
 131:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #endif
 132:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1301              		.loc 11 132 0
 1302 0016 10BD     		pop	{r4, pc}
 1303              	.L80:
 1304              		.align	2
 1305              	.L79:
 1306 0018 00000000 		.word	.LANCHOR19
 1307              		.cfi_endproc
 1308              	.LFE139:
 1310              		.section	.text._Z16MPU6000_WriteRegih,"ax",%progbits
 1311              		.align	1
 1312              		.global	_Z16MPU6000_WriteRegih
 1313              		.thumb
 1314              		.thumb_func
 1316              	_Z16MPU6000_WriteRegih:
 1317              	.LFB140:
 133:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 134:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void MPU6000_WriteReg(int addr, byte data)
 135:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1318              		.loc 11 135 0
 1319              		.cfi_startproc
 1320              		@ args = 0, pretend = 0, frame = 0
 1321              		@ frame_needed = 0, uses_anonymous_args = 0
 1322              	.LVL88:
 1323 0000 08B5     		push	{r3, lr}
 1324              	.LCFI12:
 1325              		.cfi_def_cfa_offset 8
 1326              		.cfi_offset 14, -4
 1327              		.cfi_offset 3, -8
 1328              		.loc 11 135 0
 1329 0002 0346     		mov	r3, r0
 1330 0004 0A46     		mov	r2, r1
 136:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifdef MPU6000_I2C
 137:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	updateRegisterI2C(MPU6000_I2C_ADDRESS, addr, data);
 138:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #else
 139:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	spiMPU6000.Write(addr, data);
 1331              		.loc 11 139 0
 1332 0006 0448     		ldr	r0, .L82
 1333              	.LVL89:
 1334 0008 1946     		mov	r1, r3
 1335              	.LVL90:
 1336 000a FFF7FEFF 		bl	_ZN14HardwareSPIExt5WriteEih
 1337              	.LVL91:
 140:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #endif
 141:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     delay(1);
 1338              		.loc 11 141 0
 1339 000e 0120     		movs	r0, #1
 142:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1340              		.loc 11 142 0
 1341 0010 BDE80840 		pop	{r3, lr}
 141:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     delay(1);
 1342              		.loc 11 141 0
 1343 0014 FFF7FEBF 		b	_Z5delaym
 1344              	.L83:
 1345              		.align	2
 1346              	.L82:
 1347 0018 00000000 		.word	.LANCHOR19
 1348              		.cfi_endproc
 1349              	.LFE140:
 1351              		.section	.text._Z15MPU6000_ReadRegi,"ax",%progbits
 1352              		.align	1
 1353              		.global	_Z15MPU6000_ReadRegi
 1354              		.thumb
 1355              		.thumb_func
 1357              	_Z15MPU6000_ReadRegi:
 1358              	.LFB141:
 143:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 144:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** byte MPU6000_ReadReg(int addr)
 145:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1359              		.loc 11 145 0
 1360              		.cfi_startproc
 1361              		@ args = 0, pretend = 0, frame = 0
 1362              		@ frame_needed = 0, uses_anonymous_args = 0
 1363              	.LVL92:
 1364 0000 10B5     		push	{r4, lr}
 1365              	.LCFI13:
 1366              		.cfi_def_cfa_offset 8
 1367              		.cfi_offset 14, -4
 1368              		.cfi_offset 4, -8
 1369              		.loc 11 145 0
 1370 0002 0146     		mov	r1, r0
 1371              	.LBB35:
 146:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifdef MPU6000_I2C
 147:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	sendByteI2C(MPU6000_I2C_ADDRESS, addr);
 148:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	byte data = readByteI2C(MPU6000_I2C_ADDRESS);
 149:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #else
 150:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	byte data = spiMPU6000.Read(addr);
 1372              		.loc 11 150 0
 1373 0004 0448     		ldr	r0, .L85
 1374              	.LVL93:
 1375 0006 FFF7FEFF 		bl	_ZN14HardwareSPIExt4ReadEi
 1376              	.LVL94:
 1377 000a 0446     		mov	r4, r0
 1378              	.LVL95:
 151:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #endif
 152:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     delay(1);
 1379              		.loc 11 152 0
 1380 000c 0120     		movs	r0, #1
 1381              	.LVL96:
 1382 000e FFF7FEFF 		bl	_Z5delaym
 1383              	.LBE35:
 153:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     return data;
 154:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1384              		.loc 11 154 0
 1385 0012 2046     		mov	r0, r4
 1386 0014 10BD     		pop	{r4, pc}
 1387              	.L86:
 1388 0016 00BF     		.align	2
 1389              	.L85:
 1390 0018 00000000 		.word	.LANCHOR19
 1391              		.cfi_endproc
 1392              	.LFE141:
 1394              		.section	.text._Z24initializeMPU6000Sensorsv,"ax",%progbits
 1395              		.align	1
 1396              		.global	_Z24initializeMPU6000Sensorsv
 1397              		.thumb
 1398              		.thumb_func
 1400              	_Z24initializeMPU6000Sensorsv:
 1401              	.LFB142:
 155:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 156:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** bool initializeMPU6000SensorsDone = false;
 157:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void initializeMPU6000Sensors()
 158:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1402              		.loc 11 158 0
 1403              		.cfi_startproc
 1404              		@ args = 0, pretend = 0, frame = 0
 1405              		@ frame_needed = 0, uses_anonymous_args = 0
 1406              	.LBB36:
 159:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	if(initializeMPU6000SensorsDone) {
 1407              		.loc 11 159 0
 1408 0000 254B     		ldr	r3, .L90
 1409              	.LBE36:
 158:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1410              		.loc 11 158 0
 1411 0002 10B5     		push	{r4, lr}
 1412              	.LCFI14:
 1413              		.cfi_def_cfa_offset 8
 1414              		.cfi_offset 14, -4
 1415              		.cfi_offset 4, -8
 1416              	.LBB37:
 1417              		.loc 11 159 0
 1418 0004 1C78     		ldrb	r4, [r3, #0]	@ zero_extendqisi2
 1419 0006 002C     		cmp	r4, #0
 1420 0008 44D1     		bne	.L87
 160:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		return;
 161:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	}
 162:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	initializeMPU6000SensorsDone = true;
 1421              		.loc 11 162 0
 1422 000a 0122     		movs	r2, #1
 1423 000c 1A70     		strb	r2, [r3, #0]
 163:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 164:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifdef DEBUG_INIT
 165:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	Serial.println("initializeMPU6000Sensors");
 1424              		.loc 11 165 0
 1425 000e 2348     		ldr	r0, .L90+4
 1426 0010 2349     		ldr	r1, .L90+8
 1427 0012 FFF7FEFF 		bl	_ZN5Print7printlnEPKc
 166:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #endif
 167:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	MPU6000_SpiLowSpeed();
 1428              		.loc 11 167 0
 1429 0016 FFF7FEFF 		bl	_Z19MPU6000_SpiLowSpeedv
 168:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 169:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	unsigned char val;
 170:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 171:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	val = MPU6000_ReadReg(MPUREG_WHOAMI);
 1430              		.loc 11 171 0
 1431 001a 7520     		movs	r0, #117
 1432 001c FFF7FEFF 		bl	_Z15MPU6000_ReadRegi
 1433              	.LVL97:
 172:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	if((val&0x7E) == 0x68) {
 1434              		.loc 11 172 0
 1435 0020 00F07E00 		and	r0, r0, #126
 1436              	.LVL98:
 1437 0024 6828     		cmp	r0, #104
 1438 0026 2FD1     		bne	.L89
 173:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		vehicleState |= GYRO_DETECTED;
 174:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		vehicleState |= ACCEL_DETECTED;
 1439              		.loc 11 174 0
 1440 0028 1E4B     		ldr	r3, .L90+12
 1441 002a 1868     		ldr	r0, [r3, #0]
 1442 002c 40F00301 		orr	r1, r0, #3
 1443 0030 1960     		str	r1, [r3, #0]
 175:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifdef DEBUG_INIT
 176:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		Serial.println("MPU6000 found");
 1444              		.loc 11 176 0
 1445 0032 1A48     		ldr	r0, .L90+4
 1446 0034 1C49     		ldr	r1, .L90+16
 1447 0036 FFF7FEFF 		bl	_ZN5Print7printlnEPKc
 177:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #endif
 178:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	} else {
 179:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifdef DEBUG_INIT
 180:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		Serial.println("MPU6000 not found");
 181:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #endif
 182:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		return;
 183:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	}
 184:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 185:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     // Chip reset
 186:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000_WriteReg(MPUREG_PWR_MGMT_1, BIT_H_RESET);
 1448              		.loc 11 186 0
 1449 003a 8021     		movs	r1, #128
 1450 003c 6B20     		movs	r0, #107
 1451 003e FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 187:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     delay(100);  // Startup time delay
 1452              		.loc 11 187 0
 1453 0042 6420     		movs	r0, #100
 1454 0044 FFF7FEFF 		bl	_Z5delaym
 188:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 189:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifndef MPU6000_I2C
 190:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     // Disable I2C bus
 191:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000_WriteReg(MPUREG_USER_CTRL, BIT_I2C_IF_DIS);
 1455              		.loc 11 191 0
 1456 0048 6A20     		movs	r0, #106
 1457 004a 1021     		movs	r1, #16
 1458 004c FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 192:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #endif
 193:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 194:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     // Wake Up device and select GyroZ clock (better performance)
 195:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000_WriteReg(MPUREG_PWR_MGMT_1, MPU_CLK_SEL_PLLGYROZ);
 1459              		.loc 11 195 0
 1460 0050 6B20     		movs	r0, #107
 1461 0052 0321     		movs	r1, #3
 1462 0054 FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 196:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000_WriteReg(MPUREG_PWR_MGMT_2, 0);
 1463              		.loc 11 196 0
 1464 0058 6C20     		movs	r0, #108
 1465 005a 2146     		mov	r1, r4
 1466 005c FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 197:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 198:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 199:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	// SAMPLE RATE
 200:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000_WriteReg(MPUREG_SMPLRT_DIV,0x00);     // Sample rate = 1kHz
 1467              		.loc 11 200 0
 1468 0060 1920     		movs	r0, #25
 1469 0062 2146     		mov	r1, r4
 1470 0064 FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 201:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 202:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	// FS & DLPF   FS=1000/s, DLPF = 42Hz (low pass filter)
 203:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000_WriteReg(MPUREG_CONFIG, BITS_DLPF_CFG_42HZ);
 1471              		.loc 11 203 0
 1472 0068 1A20     		movs	r0, #26
 1473 006a 0321     		movs	r1, #3
 1474 006c FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 204:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000_WriteReg(MPUREG_GYRO_CONFIG,BITS_FS_1000DPS);  // Gyro scale 1000/s
 1475              		.loc 11 204 0
 1476 0070 1B20     		movs	r0, #27
 1477 0072 1021     		movs	r1, #16
 1478 0074 FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 205:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     //Serial.print("MPUREG_GYRO_CONFIG read 0x");
 206:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     //Serial.println(MPU6000_ReadReg(MPUREG_GYRO_CONFIG), 16);
 207:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 208:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000_WriteReg(MPUREG_ACCEL_CONFIG,0x08);   // Accel scale +-4g (4096LSB/g)
 1479              		.loc 11 208 0
 1480 0078 1C20     		movs	r0, #28
 1481 007a 0821     		movs	r1, #8
 1482 007c FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 1483              	.LBE37:
 209:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 210:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     // INT CFG => Interrupt on Data Ready
 211:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     //MPU6000_WriteReg(MPUREG_INT_ENABLE,BIT_RAW_RDY_EN);        // INT: Raw data ready
 212:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     //MPU6000_WriteReg(MPUREG_INT_PIN_CFG,BIT_INT_ANYRD_2CLEAR); // INT: Clear on any read
 213:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 214:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     // switch to high clock rate
 215:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000_SpiHighSpeed();
 216:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** };
 1484              		.loc 11 216 0
 1485 0080 BDE81040 		pop	{r4, lr}
 1486              	.LBB38:
 215:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000_SpiHighSpeed();
 1487              		.loc 11 215 0
 1488 0084 FFF7FEBF 		b	_Z20MPU6000_SpiHighSpeedv
 1489              	.L89:
 180:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		Serial.println("MPU6000 not found");
 1490              		.loc 11 180 0
 1491 0088 0448     		ldr	r0, .L90+4
 1492 008a 0849     		ldr	r1, .L90+20
 1493              	.LBE38:
 1494              		.loc 11 216 0
 1495 008c BDE81040 		pop	{r4, lr}
 1496              	.LBB39:
 180:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		Serial.println("MPU6000 not found");
 1497              		.loc 11 180 0
 1498 0090 FFF7FEBF 		b	_ZN5Print7printlnEPKc
 1499              	.L87:
 1500 0094 10BD     		pop	{r4, pc}
 1501              	.L91:
 1502 0096 00BF     		.align	2
 1503              	.L90:
 1504 0098 00000000 		.word	.LANCHOR20
 1505 009c 00000000 		.word	SerialUSB
 1506 00a0 00000000 		.word	.LC1
 1507 00a4 00000000 		.word	.LANCHOR21
 1508 00a8 19000000 		.word	.LC2
 1509 00ac 27000000 		.word	.LC3
 1510              	.LBE39:
 1511              		.cfi_endproc
 1512              	.LFE142:
 1514              		.section	.text._Z15MPU6000SwapDataPhi,"ax",%progbits
 1515              		.align	1
 1516              		.global	_Z15MPU6000SwapDataPhi
 1517              		.thumb
 1518              		.thumb_func
 1520              	_Z15MPU6000SwapDataPhi:
 1521              	.LFB143:
 217:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 218:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 219:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void MPU6000SwapData(unsigned char *data, int datalen)
 220:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1522              		.loc 11 220 0
 1523              		.cfi_startproc
 1524              		@ args = 0, pretend = 0, frame = 0
 1525              		@ frame_needed = 0, uses_anonymous_args = 0
 1526              		@ link register save eliminated.
 1527              	.LVL99:
 1528              	.LBB40:
 221:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	datalen /= 2;
 1529              		.loc 11 221 0
 1530 0000 01EBD171 		add	r1, r1, r1, lsr #31
 1531              	.LVL100:
 1532 0004 4910     		asrs	r1, r1, #1
 1533              	.LVL101:
 222:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	while(datalen--) {
 1534              		.loc 11 222 0
 1535 0006 04E0     		b	.L93
 1536              	.LVL102:
 1537              	.L94:
 1538              	.LBB41:
 223:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		unsigned char t = data[0];
 1539              		.loc 11 223 0
 1540 0008 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 1541              	.LVL103:
 224:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		data[0] = data[1];
 1542              		.loc 11 224 0
 1543 000a 4278     		ldrb	r2, [r0, #1]	@ zero_extendqisi2
 225:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		data[1] = t;
 1544              		.loc 11 225 0
 1545 000c 4370     		strb	r3, [r0, #1]
 224:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		data[0] = data[1];
 1546              		.loc 11 224 0
 1547 000e 0270     		strb	r2, [r0, #0]
 226:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		data += 2;
 1548              		.loc 11 226 0
 1549 0010 0230     		adds	r0, r0, #2
 1550              	.LVL104:
 1551              	.L93:
 1552              	.LBE41:
 222:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	while(datalen--) {
 1553              		.loc 11 222 0 discriminator 1
 1554 0012 11F1FF31 		adds	r1, r1, #-1
 1555              	.LVL105:
 1556 0016 F7D2     		bcs	.L94
 1557              	.LBE40:
 227:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	}
 228:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1558              		.loc 11 228 0
 1559 0018 7047     		bx	lr
 1560              		.cfi_endproc
 1561              	.LFE143:
 1563              		.section	.text._Z18readMPU6000Sensorsv,"ax",%progbits
 1564              		.align	1
 1565              		.global	_Z18readMPU6000Sensorsv
 1566              		.thumb
 1567              		.thumb_func
 1569              	_Z18readMPU6000Sensorsv:
 1570              	.LFB144:
 229:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 230:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void readMPU6000Sensors()
 231:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1571              		.loc 11 231 0
 1572              		.cfi_startproc
 1573              		@ args = 0, pretend = 0, frame = 0
 1574              		@ frame_needed = 0, uses_anonymous_args = 0
 1575 0000 10B5     		push	{r4, lr}
 1576              	.LCFI15:
 1577              		.cfi_def_cfa_offset 8
 1578              		.cfi_offset 14, -4
 1579              		.cfi_offset 4, -8
 232:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifdef MPU6000_I2C
 233:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	sendByteI2C(MPU6000_I2C_ADDRESS, MPUREG_ACCEL_XOUT_H);
 234:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     Wire.requestFrom(MPU6000_I2C_ADDRESS, sizeof(MPU6000));
 235:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     for(byte i=0; i<sizeof(MPU6000)/sizeof(short); i++) {
 236:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     	MPU6000.rawWord[i] = readWordI2C();
 237:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     }
 238:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #else
 239:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	spiMPU6000.Read(MPUREG_ACCEL_XOUT_H, MPU6000.rawByte, sizeof(MPU6000));
 1580              		.loc 11 239 0
 1581 0002 064C     		ldr	r4, .L96
 1582 0004 0648     		ldr	r0, .L96+4
 1583 0006 3B21     		movs	r1, #59
 1584 0008 2246     		mov	r2, r4
 1585 000a 0E23     		movs	r3, #14
 1586 000c FFF7FEFF 		bl	_ZN14HardwareSPIExt4ReadEiPhi
 240:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	MPU6000SwapData(MPU6000.rawByte, sizeof(MPU6000));
 1587              		.loc 11 240 0
 1588 0010 2046     		mov	r0, r4
 1589 0012 0E21     		movs	r1, #14
 241:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #endif
 242:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1590              		.loc 11 242 0
 1591 0014 BDE81040 		pop	{r4, lr}
 240:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	MPU6000SwapData(MPU6000.rawByte, sizeof(MPU6000));
 1592              		.loc 11 240 0
 1593 0018 FFF7FEBF 		b	_Z15MPU6000SwapDataPhi
 1594              	.L97:
 1595              		.align	2
 1596              	.L96:
 1597 001c 00000000 		.word	.LANCHOR22
 1598 0020 00000000 		.word	.LANCHOR19
 1599              		.cfi_endproc
 1600              	.LFE144:
 1602              		.section	.text._Z16readMPU6000Accelv,"ax",%progbits
 1603              		.align	1
 1604              		.global	_Z16readMPU6000Accelv
 1605              		.thumb
 1606              		.thumb_func
 1608              	_Z16readMPU6000Accelv:
 1609              	.LFB145:
 243:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 244:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** int readMPU6000Count=0;
 245:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** int readMPU6000AccelCount=0;
 246:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** int readMPU6000GyroCount=0;
 247:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 248:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void readMPU6000Accel()
 249:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1610              		.loc 11 249 0
 1611              		.cfi_startproc
 1612              		@ args = 0, pretend = 0, frame = 0
 1613              		@ frame_needed = 0, uses_anonymous_args = 0
 250:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	readMPU6000AccelCount++;
 1614              		.loc 11 250 0
 1615 0000 0748     		ldr	r0, .L100
 249:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1616              		.loc 11 249 0
 1617 0002 10B5     		push	{r4, lr}
 1618              	.LCFI16:
 1619              		.cfi_def_cfa_offset 8
 1620              		.cfi_offset 14, -4
 1621              		.cfi_offset 4, -8
 251:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	if(readMPU6000AccelCount != readMPU6000Count) {
 1622              		.loc 11 251 0
 1623 0004 074C     		ldr	r4, .L100+4
 250:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	readMPU6000AccelCount++;
 1624              		.loc 11 250 0
 1625 0006 0168     		ldr	r1, [r0, #0]
 1626              		.loc 11 251 0
 1627 0008 2268     		ldr	r2, [r4, #0]
 250:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	readMPU6000AccelCount++;
 1628              		.loc 11 250 0
 1629 000a 4B1C     		adds	r3, r1, #1
 1630              		.loc 11 251 0
 1631 000c 9342     		cmp	r3, r2
 250:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	readMPU6000AccelCount++;
 1632              		.loc 11 250 0
 1633 000e 0360     		str	r3, [r0, #0]
 1634              		.loc 11 251 0
 1635 0010 04D0     		beq	.L98
 252:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		readMPU6000Sensors();
 1636              		.loc 11 252 0
 1637 0012 FFF7FEFF 		bl	_Z18readMPU6000Sensorsv
 253:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		readMPU6000Count++;
 1638              		.loc 11 253 0
 1639 0016 2368     		ldr	r3, [r4, #0]
 1640 0018 5A1C     		adds	r2, r3, #1
 1641 001a 2260     		str	r2, [r4, #0]
 1642              	.L98:
 1643 001c 10BD     		pop	{r4, pc}
 1644              	.L101:
 1645 001e 00BF     		.align	2
 1646              	.L100:
 1647 0020 00000000 		.word	.LANCHOR23
 1648 0024 00000000 		.word	.LANCHOR24
 1649              		.cfi_endproc
 1650              	.LFE145:
 1652              		.section	.text._Z15readMPU6000Gyrov,"ax",%progbits
 1653              		.align	1
 1654              		.global	_Z15readMPU6000Gyrov
 1655              		.thumb
 1656              		.thumb_func
 1658              	_Z15readMPU6000Gyrov:
 1659              	.LFB146:
 254:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	}
 255:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 256:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 257:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void readMPU6000Gyro()
 258:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1660              		.loc 11 258 0
 1661              		.cfi_startproc
 1662              		@ args = 0, pretend = 0, frame = 0
 1663              		@ frame_needed = 0, uses_anonymous_args = 0
 1664 0000 10B5     		push	{r4, lr}
 1665              	.LCFI17:
 1666              		.cfi_def_cfa_offset 8
 1667              		.cfi_offset 14, -4
 1668              		.cfi_offset 4, -8
 259:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	readMPU6000GyroCount++;
 1669              		.loc 11 259 0
 1670 0002 074C     		ldr	r4, .L104
 260:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	if(readMPU6000GyroCount != readMPU6000Count) {
 1671              		.loc 11 260 0
 1672 0004 0748     		ldr	r0, .L104+4
 259:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	readMPU6000GyroCount++;
 1673              		.loc 11 259 0
 1674 0006 2168     		ldr	r1, [r4, #0]
 1675              		.loc 11 260 0
 1676 0008 0268     		ldr	r2, [r0, #0]
 259:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	readMPU6000GyroCount++;
 1677              		.loc 11 259 0
 1678 000a 4B1C     		adds	r3, r1, #1
 1679              		.loc 11 260 0
 1680 000c 9342     		cmp	r3, r2
 259:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	readMPU6000GyroCount++;
 1681              		.loc 11 259 0
 1682 000e 2360     		str	r3, [r4, #0]
 1683              		.loc 11 260 0
 1684 0010 04D0     		beq	.L102
 261:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		readMPU6000Sensors();
 1685              		.loc 11 261 0
 1686 0012 FFF7FEFF 		bl	_Z18readMPU6000Sensorsv
 262:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 		readMPU6000GyroCount++;
 1687              		.loc 11 262 0
 1688 0016 2368     		ldr	r3, [r4, #0]
 1689 0018 5A1C     		adds	r2, r3, #1
 1690 001a 2260     		str	r2, [r4, #0]
 1691              	.L102:
 1692 001c 10BD     		pop	{r4, pc}
 1693              	.L105:
 1694 001e 00BF     		.align	2
 1695              	.L104:
 1696 0020 00000000 		.word	.LANCHOR25
 1697 0024 00000000 		.word	.LANCHOR24
 1698              		.cfi_endproc
 1699              	.LFE146:
 1701              		.section	.text._Z14initializeGyrov,"ax",%progbits
 1702              		.align	1
 1703              		.global	_Z14initializeGyrov
 1704              		.thumb
 1705              		.thumb_func
 1707              	_Z14initializeGyrov:
 1708              	.LFB147:
 1709              		.file 12 "../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h"
   1:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** /*
   2:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   AeroQuad v3.0 - May 2011
   3:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   Copyright (c) 2011 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
   7:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   This program is free software: you can redistribute it and/or modify
   8:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   it under the terms of the GNU General Public License as published by
   9:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   the Free Software Foundation, either version 3 of the License, or
  10:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   (at your option) any later version.
  11:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  12:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   This program is distributed in the hope that it will be useful,
  13:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   GNU General Public License for more details.
  16:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  17:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   You should have received a copy of the GNU General Public License
  18:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** */
  20:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  21:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** #ifndef _AEROQUAD_GYROSCOPE_MPU6000_COMMON_H_
  22:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** #define _AEROQUAD_GYROSCOPE_MPU6000_COMMON_H_
  23:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  24:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** int gyroRaw[3] = {0,0,0};
  25:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  26:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** #include <Platform_MPU6000.h>
  27:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** #include <Gyroscope.h>
  28:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  29:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void initializeGyro() {
 1710              		.loc 12 29 0
 1711              		.cfi_startproc
 1712              		@ args = 0, pretend = 0, frame = 0
 1713              		@ frame_needed = 0, uses_anonymous_args = 0
 1714              		@ link register save eliminated.
 1715              	.LVL106:
 1716              	.LBB42:
  30:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   float range = 2*1000.0;
  31:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroScaleFactor = radians(range/65536.0);
 1717              		.loc 12 31 0
 1718 0000 024A     		ldr	r2, .L107
 1719 0002 034B     		ldr	r3, .L107+4
 1720 0004 1A60     		str	r2, [r3, #0]	@ float
 1721              	.LBE42:
  32:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  33:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   initializeMPU6000Sensors();
  34:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 1722              		.loc 12 34 0
 1723              	.LBB43:
  33:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   initializeMPU6000Sensors();
 1724              		.loc 12 33 0
 1725 0006 FFF7FEBF 		b	_Z24initializeMPU6000Sensorsv
 1726              	.L108:
 1727 000a 00BF     		.align	2
 1728              	.L107:
 1729 000c 58A00B3A 		.word	973840472
 1730 0010 00000000 		.word	.LANCHOR26
 1731              	.LBE43:
 1732              		.cfi_endproc
 1733              	.LFE147:
 1735              		.section	.text._Z17gyroUpdateHeadingv,"ax",%progbits
 1736              		.align	1
 1737              		.global	_Z17gyroUpdateHeadingv
 1738              		.thumb
 1739              		.thumb_func
 1741              	_Z17gyroUpdateHeadingv:
 1742              	.LFB148:
  35:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  36:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void gyroUpdateHeading()
  37:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** {
 1743              		.loc 12 37 0
 1744              		.cfi_startproc
 1745              		@ args = 0, pretend = 0, frame = 0
 1746              		@ frame_needed = 0, uses_anonymous_args = 0
 1747 0000 08B5     		push	{r3, lr}
 1748              	.LCFI18:
 1749              		.cfi_def_cfa_offset 8
 1750              		.cfi_offset 14, -4
 1751              		.cfi_offset 3, -8
 1752              	.LBB44:
  38:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   long int currentTime = micros();
 1753              		.loc 12 38 0
 1754 0002 FFF7FEFF 		bl	_ZL6microsv
 1755              	.LVL107:
  39:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   if (gyroRate[ZAXIS] > (float)radians(1.0) || gyroRate[ZAXIS] < (float)radians(-1.0)) {
 1756              		.loc 12 39 0
 1757 0006 124B     		ldr	r3, .L113
 1758 0008 DFED127A 		flds	s15, .L113+4
 1759 000c 93ED027A 		flds	s14, [r3, #8]
 1760 0010 B4EEE77A 		fcmpes	s14, s15
 1761 0014 F1EE10FA 		fmstat
 1762 0018 0F4B     		ldr	r3, .L113+8
 1763 001a 06DC     		bgt	.L110
 1764              		.loc 12 39 0 is_stmt 0 discriminator 1
 1765 001c 9FED0F0A 		flds	s0, .L113+12
 1766 0020 B4EEC07A 		fcmpes	s14, s0
 1767 0024 F1EE10FA 		fmstat
 1768 0028 10D5     		bpl	.L111
 1769              	.L110:
  40:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     gyroHeading += gyroRate[ZAXIS] * ((currentTime - gyroLastMesuredTime) / 1000000.0);
 1770              		.loc 12 40 0 is_stmt 1
 1771 002a 1968     		ldr	r1, [r3, #0]
 1772 002c 0C4A     		ldr	r2, .L113+16
 1773 002e 411A     		subs	r1, r0, r1
 1774 0030 01EE901A 		fmsr	s3, r1	@ int
 1775 0034 9FED0B1A 		flds	s2, .L113+20
 1776 0038 F8EE616A 		fuitos	s13, s3
 1777 003c D2ED000A 		flds	s1, [r2, #0]
 1778 0040 C6EE816A 		fdivs	s13, s13, s2
 1779 0044 47EE260A 		fmacs	s1, s14, s13
 1780 0048 C2ED000A 		fsts	s1, [r2, #0]
 1781              	.L111:
  41:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   }
  42:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroLastMesuredTime = currentTime;
 1782              		.loc 12 42 0
 1783 004c 1860     		str	r0, [r3, #0]
 1784              	.LBE44:
  43:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 1785              		.loc 12 43 0
 1786 004e 08BD     		pop	{r3, pc}
 1787              	.L114:
 1788              		.align	2
 1789              	.L113:
 1790 0050 00000000 		.word	.LANCHOR27
 1791 0054 35FA8E3C 		.word	1016003125
 1792 0058 00000000 		.word	.LANCHOR29
 1793 005c 35FA8EBC 		.word	-1131480523
 1794 0060 00000000 		.word	.LANCHOR28
 1795 0064 00247449 		.word	1232348160
 1796              		.cfi_endproc
 1797              	.LFE148:
 1799              		.section	.text._Z11measureGyrov,"ax",%progbits
 1800              		.align	1
 1801              		.global	_Z11measureGyrov
 1802              		.thumb
 1803              		.thumb_func
 1805              	_Z11measureGyrov:
 1806              	.LFB149:
  44:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  45:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void measureGyro() {
 1807              		.loc 12 45 0
 1808              		.cfi_startproc
 1809              		@ args = 0, pretend = 0, frame = 16
 1810              		@ frame_needed = 0, uses_anonymous_args = 0
 1811 0000 30B5     		push	{r4, r5, lr}
 1812              	.LCFI19:
 1813              		.cfi_def_cfa_offset 12
 1814              		.cfi_offset 14, -4
 1815              		.cfi_offset 5, -8
 1816              		.cfi_offset 4, -12
 1817 0002 85B0     		sub	sp, sp, #20
 1818              	.LCFI20:
 1819              		.cfi_def_cfa_offset 32
 1820              	.LBB45:
  46:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   readMPU6000Gyro();
 1821              		.loc 12 46 0
 1822 0004 FFF7FEFF 		bl	_Z15readMPU6000Gyrov
  47:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  48:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   int gyroADC[3];
  49:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroRaw[XAXIS]=MPU6000.data.gyro.x)  - gyroZero[XAXIS];
 1823              		.loc 12 49 0
 1824 0008 1A4A     		ldr	r2, .L116
 1825 000a 1B49     		ldr	r1, .L116+4
 1826 000c B2F90850 		ldrsh	r5, [r2, #8]
 1827 0010 1A4B     		ldr	r3, .L116+8
 1828 0012 0C68     		ldr	r4, [r1, #0]
 1829 0014 1D60     		str	r5, [r3, #0]
 1830 0016 2C1B     		subs	r4, r5, r4
  50:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1831              		.loc 12 50 0
 1832 0018 B2F90A00 		ldrsh	r0, [r2, #10]
 1833 001c 4D68     		ldr	r5, [r1, #4]
  51:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[ZAXIS] = gyroZero[ZAXIS] - (gyroRaw[ZAXIS]=MPU6000.data.gyro.z);
 1834              		.loc 12 51 0
 1835 001e B2F90C20 		ldrsh	r2, [r2, #12]
 1836 0022 8968     		ldr	r1, [r1, #8]
  50:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1837              		.loc 12 50 0
 1838 0024 5860     		str	r0, [r3, #4]
 1839              		.loc 12 51 0
 1840 0026 9A60     		str	r2, [r3, #8]
  50:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1841              		.loc 12 50 0
 1842 0028 281A     		subs	r0, r5, r0
 1843              		.loc 12 51 0
 1844 002a 8A1A     		subs	r2, r1, r2
 1845              	.LBB46:
  52:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  53:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   for (byte axis = 0; axis <= ZAXIS; axis++) {
  54:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     gyroRate[axis] = gyroADC[axis] * gyroScaleFactor;
 1846              		.loc 12 54 0
 1847 002c 01EE904A 		fmsr	s3, r4	@ int
 1848 0030 1349     		ldr	r1, .L116+12
 1849 0032 144B     		ldr	r3, .L116+16
 1850              	.LBE46:
  49:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroRaw[XAXIS]=MPU6000.data.gyro.x)  - gyroZero[XAXIS];
 1851              		.loc 12 49 0
 1852 0034 0194     		str	r4, [sp, #4]
 1853              	.LBB47:
 1854              		.loc 12 54 0
 1855 0036 00EE900A 		fmsr	s1, r0	@ int
 1856 003a 06EE902A 		fmsr	s13, r2	@ int
 1857 003e D1ED007A 		flds	s15, [r1, #0]
 1858 0042 B8EEE11A 		fsitos	s2, s3
 1859 0046 B8EEE00A 		fsitos	s0, s1
 1860 004a B8EEE67A 		fsitos	s14, s13
 1861 004e 21EE271A 		fmuls	s2, s2, s15
 1862 0052 20EE270A 		fmuls	s0, s0, s15
 1863 0056 67EE277A 		fmuls	s15, s14, s15
 1864              	.LBE47:
  50:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1865              		.loc 12 50 0
 1866 005a 0290     		str	r0, [sp, #8]
  51:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[ZAXIS] = gyroZero[ZAXIS] - (gyroRaw[ZAXIS]=MPU6000.data.gyro.z);
 1867              		.loc 12 51 0
 1868 005c 0392     		str	r2, [sp, #12]
 1869              	.LVL108:
 1870              	.LBB48:
 1871              		.loc 12 54 0
 1872 005e 83ED001A 		fsts	s2, [r3, #0]
 1873              	.LVL109:
 1874 0062 83ED010A 		fsts	s0, [r3, #4]
 1875              	.LVL110:
 1876 0066 C3ED027A 		fsts	s15, [r3, #8]
 1877              	.LVL111:
 1878              	.LBE48:
 1879              	.LBE45:
  55:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   }
  56:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  57:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroUpdateHeading();
  58:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 1880              		.loc 12 58 0
 1881 006a 05B0     		add	sp, sp, #20
 1882 006c BDE83040 		pop	{r4, r5, lr}
 1883              	.LBB49:
  57:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroUpdateHeading();
 1884              		.loc 12 57 0
 1885 0070 FFF7FEBF 		b	_Z17gyroUpdateHeadingv
 1886              	.L117:
 1887              		.align	2
 1888              	.L116:
 1889 0074 00000000 		.word	.LANCHOR22
 1890 0078 00000000 		.word	.LANCHOR31
 1891 007c 00000000 		.word	.LANCHOR30
 1892 0080 00000000 		.word	.LANCHOR26
 1893 0084 00000000 		.word	.LANCHOR27
 1894              	.LBE49:
 1895              		.cfi_endproc
 1896              	.LFE149:
 1898              		.section	.text._Z14measureGyroSumv,"ax",%progbits
 1899              		.align	1
 1900              		.global	_Z14measureGyroSumv
 1901              		.thumb
 1902              		.thumb_func
 1904              	_Z14measureGyroSumv:
 1905              	.LFB150:
  59:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  60:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void measureGyroSum() {
 1906              		.loc 12 60 0
 1907              		.cfi_startproc
 1908              		@ args = 0, pretend = 0, frame = 0
 1909              		@ frame_needed = 0, uses_anonymous_args = 0
 1910 0000 10B5     		push	{r4, lr}
 1911              	.LCFI21:
 1912              		.cfi_def_cfa_offset 8
 1913              		.cfi_offset 14, -4
 1914              		.cfi_offset 4, -8
  61:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   readMPU6000Gyro();
 1915              		.loc 12 61 0
 1916 0002 FFF7FEFF 		bl	_Z15readMPU6000Gyrov
  62:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[XAXIS] += (gyroRaw[XAXIS]=MPU6000.data.gyro.x);
 1917              		.loc 12 62 0
 1918 0006 0D4B     		ldr	r3, .L119
 1919 0008 0D49     		ldr	r1, .L119+4
 1920 000a 1C68     		ldr	r4, [r3, #0]
 1921 000c B1F90800 		ldrsh	r0, [r1, #8]
 1922 0010 0C4A     		ldr	r2, .L119+8
 1923 0012 2418     		adds	r4, r4, r0
 1924 0014 1C60     		str	r4, [r3, #0]
 1925 0016 1060     		str	r0, [r2, #0]
  63:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[YAXIS] += (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1926              		.loc 12 63 0
 1927 0018 5C68     		ldr	r4, [r3, #4]
 1928 001a B1F90A00 		ldrsh	r0, [r1, #10]
  64:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[ZAXIS] += (gyroRaw[ZAXIS]=MPU6000.data.gyro.z);
 1929              		.loc 12 64 0
 1930 001e B1F90C10 		ldrsh	r1, [r1, #12]
  63:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[YAXIS] += (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1931              		.loc 12 63 0
 1932 0022 5060     		str	r0, [r2, #4]
 1933 0024 2018     		adds	r0, r4, r0
 1934 0026 5860     		str	r0, [r3, #4]
 1935              		.loc 12 64 0
 1936 0028 9868     		ldr	r0, [r3, #8]
 1937 002a 9160     		str	r1, [r2, #8]
 1938 002c 4118     		adds	r1, r0, r1
 1939 002e 9960     		str	r1, [r3, #8]
  65:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  66:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSampleCount++;
 1940              		.loc 12 66 0
 1941 0030 054B     		ldr	r3, .L119+12
 1942 0032 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 1943 0034 421C     		adds	r2, r0, #1
 1944 0036 1A70     		strb	r2, [r3, #0]
  67:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 1945              		.loc 12 67 0
 1946 0038 10BD     		pop	{r4, pc}
 1947              	.L120:
 1948 003a 00BF     		.align	2
 1949              	.L119:
 1950 003c 00000000 		.word	.LANCHOR32
 1951 0040 00000000 		.word	.LANCHOR22
 1952 0044 00000000 		.word	.LANCHOR30
 1953 0048 00000000 		.word	.LANCHOR33
 1954              		.cfi_endproc
 1955              	.LFE150:
 1957              		.section	.text._Z16evaluateGyroRatev,"ax",%progbits
 1958              		.align	1
 1959              		.global	_Z16evaluateGyroRatev
 1960              		.thumb
 1961              		.thumb_func
 1963              	_Z16evaluateGyroRatev:
 1964              	.LFB151:
  68:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  69:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void evaluateGyroRate() {
 1965              		.loc 12 69 0
 1966              		.cfi_startproc
 1967              		@ args = 0, pretend = 0, frame = 16
 1968              		@ frame_needed = 0, uses_anonymous_args = 0
 1969 0000 7FB5     		push	{r0, r1, r2, r3, r4, r5, r6, lr}
 1970              	.LCFI22:
 1971              		.cfi_def_cfa_offset 32
 1972              		.cfi_offset 14, -4
 1973              		.cfi_offset 6, -8
 1974              		.cfi_offset 5, -12
 1975              		.cfi_offset 4, -16
 1976              		.cfi_offset 3, -20
 1977              		.cfi_offset 2, -24
 1978              		.cfi_offset 1, -28
 1979              		.cfi_offset 0, -32
 1980              	.LBB50:
  70:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   int gyroADC[3];
  71:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroSample[XAXIS] / gyroSampleCount) - gyroZero[XAXIS];
 1981              		.loc 12 71 0
 1982 0002 1F4B     		ldr	r3, .L122
 1983 0004 1F4D     		ldr	r5, .L122+4
 1984 0006 1A68     		ldr	r2, [r3, #0]
 1985 0008 95F800C0 		ldrb	ip, [r5, #0]	@ zero_extendqisi2
  72:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroSample[YAXIS] / gyroSampleCount);
 1986              		.loc 12 72 0
 1987 000c 5968     		ldr	r1, [r3, #4]
  71:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroSample[XAXIS] / gyroSampleCount) - gyroZero[XAXIS];
 1988              		.loc 12 71 0
 1989 000e 92FBFCF4 		sdiv	r4, r2, ip
 1990 0012 1D4A     		ldr	r2, .L122+8
 1991              		.loc 12 72 0
 1992 0014 92E84100 		ldmia	r2, {r0, r6}
  71:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroSample[XAXIS] / gyroSampleCount) - gyroZero[XAXIS];
 1993              		.loc 12 71 0
 1994 0018 241A     		subs	r4, r4, r0
 1995              		.loc 12 72 0
 1996 001a 91FBFCF0 		sdiv	r0, r1, ip
 1997 001e 301A     		subs	r0, r6, r0
  73:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[ZAXIS] = gyroZero[ZAXIS] - (gyroSample[ZAXIS] / gyroSampleCount);
 1998              		.loc 12 73 0
 1999 0020 9E68     		ldr	r6, [r3, #8]
 2000 0022 9168     		ldr	r1, [r2, #8]
  71:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroSample[XAXIS] / gyroSampleCount) - gyroZero[XAXIS];
 2001              		.loc 12 71 0
 2002 0024 0194     		str	r4, [sp, #4]
 2003              		.loc 12 73 0
 2004 0026 96FBFCFC 		sdiv	ip, r6, ip
  74:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  75:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[XAXIS] = 0;
 2005              		.loc 12 75 0
 2006 002a 0022     		movs	r2, #0
  73:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[ZAXIS] = gyroZero[ZAXIS] - (gyroSample[ZAXIS] / gyroSampleCount);
 2007              		.loc 12 73 0
 2008 002c CCEB0101 		rsb	r1, ip, r1
 2009              		.loc 12 75 0
 2010 0030 1A60     		str	r2, [r3, #0]
  76:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[YAXIS] = 0;
 2011              		.loc 12 76 0
 2012 0032 5A60     		str	r2, [r3, #4]
  77:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[ZAXIS] = 0;
 2013              		.loc 12 77 0
 2014 0034 9A60     		str	r2, [r3, #8]
  78:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSampleCount = 0;
 2015              		.loc 12 78 0
 2016 0036 2A70     		strb	r2, [r5, #0]
 2017              	.LVL112:
 2018              	.LBB51:
  79:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  80:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   for (byte axis = 0; axis <= ZAXIS; axis++) {
  81:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     gyroRate[axis] = gyroADC[axis] * gyroScaleFactor;
 2019              		.loc 12 81 0
 2020 0038 01EE904A 		fmsr	s3, r4	@ int
 2021 003c 134A     		ldr	r2, .L122+12
 2022 003e 144B     		ldr	r3, .L122+16
 2023              	.LBE51:
  72:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroSample[YAXIS] / gyroSampleCount);
 2024              		.loc 12 72 0
 2025 0040 0290     		str	r0, [sp, #8]
 2026              	.LBB52:
 2027              		.loc 12 81 0
 2028 0042 00EE900A 		fmsr	s1, r0	@ int
 2029 0046 06EE901A 		fmsr	s13, r1	@ int
 2030 004a D2ED007A 		flds	s15, [r2, #0]
 2031 004e B8EEE11A 		fsitos	s2, s3
 2032 0052 B8EEE00A 		fsitos	s0, s1
 2033 0056 B8EEE67A 		fsitos	s14, s13
 2034 005a 21EE271A 		fmuls	s2, s2, s15
 2035 005e 20EE270A 		fmuls	s0, s0, s15
 2036 0062 67EE277A 		fmuls	s15, s14, s15
 2037              	.LBE52:
  73:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[ZAXIS] = gyroZero[ZAXIS] - (gyroSample[ZAXIS] / gyroSampleCount);
 2038              		.loc 12 73 0
 2039 0066 0391     		str	r1, [sp, #12]
 2040              	.LBB53:
 2041              		.loc 12 81 0
 2042 0068 83ED001A 		fsts	s2, [r3, #0]
 2043              	.LVL113:
 2044 006c 83ED010A 		fsts	s0, [r3, #4]
 2045              	.LVL114:
 2046 0070 C3ED027A 		fsts	s15, [r3, #8]
 2047              	.LVL115:
 2048              	.LBE53:
 2049              	.LBE50:
  82:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   }
  83:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  84:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroUpdateHeading();
  85:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 2050              		.loc 12 85 0
 2051 0074 04B0     		add	sp, sp, #16
 2052 0076 BDE87040 		pop	{r4, r5, r6, lr}
 2053              	.LBB54:
  84:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroUpdateHeading();
 2054              		.loc 12 84 0
 2055 007a FFF7FEBF 		b	_Z17gyroUpdateHeadingv
 2056              	.L123:
 2057 007e 00BF     		.align	2
 2058              	.L122:
 2059 0080 00000000 		.word	.LANCHOR32
 2060 0084 00000000 		.word	.LANCHOR33
 2061 0088 00000000 		.word	.LANCHOR31
 2062 008c 00000000 		.word	.LANCHOR26
 2063 0090 00000000 		.word	.LANCHOR27
 2064              	.LBE54:
 2065              		.cfi_endproc
 2066              	.LFE151:
 2068              		.section	.text._Z13calibrateGyrov,"ax",%progbits
 2069              		.align	1
 2070              		.global	_Z13calibrateGyrov
 2071              		.thumb
 2072              		.thumb_func
 2074              	_Z13calibrateGyrov:
 2075              	.LFB152:
  86:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  87:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  88:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void calibrateGyro() {
 2076              		.loc 12 88 0
 2077              		.cfi_startproc
 2078              		@ args = 0, pretend = 0, frame = 200
 2079              		@ frame_needed = 0, uses_anonymous_args = 0
 2080              	.LVL116:
 2081 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2082              	.LCFI23:
 2083              		.cfi_def_cfa_offset 20
 2084              		.cfi_offset 14, -4
 2085              		.cfi_offset 7, -8
 2086              		.cfi_offset 6, -12
 2087              		.cfi_offset 5, -16
 2088              		.cfi_offset 4, -20
  89:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   int findZero[FINDZERO];
  90:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  91:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   for (byte axis = 0; axis < 3; axis++) {
 2089              		.loc 12 91 0
 2090 0002 124D     		ldr	r5, .L132
  88:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void calibrateGyro() {
 2091              		.loc 12 88 0
 2092 0004 B3B0     		sub	sp, sp, #204
 2093              	.LCFI24:
 2094              		.cfi_def_cfa_offset 224
 2095              		.loc 12 91 0
 2096 0006 0024     		movs	r4, #0
 2097 0008 1CE0     		b	.L125
 2098              	.LVL117:
 2099              	.L129:
 2100              	.LBB55:
 2101              	.LBB56:
 2102              	.LBB57:
 2103              	.LBB58:
 2104              	.LBB59:
  92:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     for (int i=0; i<FINDZERO; i++) {
  93:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       readMPU6000Sensors();
 2105              		.loc 12 93 0
 2106 000a FFF7FEFF 		bl	_Z18readMPU6000Sensorsv
 2107 000e 104B     		ldr	r3, .L132+4
  94:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       short data;
  95:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       if(axis == XAXIS) {
 2108              		.loc 12 95 0
 2109 0010 0CB9     		cbnz	r4, .L126
  96:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     	  data = MPU6000.data.gyro.x;
 2110              		.loc 12 96 0
 2111 0012 1B89     		ldrh	r3, [r3, #8]
 2112              	.LVL118:
 2113 0014 03E0     		b	.L127
 2114              	.LVL119:
 2115              	.L126:
  97:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       } else if(axis == YAXIS) {
 2116              		.loc 12 97 0
 2117 0016 012C     		cmp	r4, #1
  98:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     	  data = MPU6000.data.gyro.y;
 2118              		.loc 12 98 0
 2119 0018 0CBF     		ite	eq
 2120 001a 5B89     		ldrheq	r3, [r3, #10]
 2121              	.LVL120:
  99:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       } else {
 100:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     	  data = MPU6000.data.gyro.z;
 2122              		.loc 12 100 0
 2123 001c 9B89     		ldrhne	r3, [r3, #12]
 2124              	.LVL121:
 2125              	.L127:
 101:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       }
 102:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       findZero[i] = data;
 2126              		.loc 12 102 0
 2127 001e 01AF     		add	r7, sp, #4
 2128 0020 1BB2     		sxth	r3, r3
 2129              	.LVL122:
 2130 0022 F351     		str	r3, [r6, r7]
 103:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       delay(10);
 2131              		.loc 12 103 0
 2132 0024 0A20     		movs	r0, #10
 2133 0026 0436     		adds	r6, r6, #4
 2134 0028 FFF7FEFF 		bl	_Z5delaym
 2135              	.LBE59:
  92:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     for (int i=0; i<FINDZERO; i++) {
 2136              		.loc 12 92 0
 2137 002c C42E     		cmp	r6, #196
 2138 002e ECD1     		bne	.L129
 2139              	.LBE58:
 104:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     }
 105:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     gyroZero[axis] = findMedianInt(findZero, FINDZERO);
 2140              		.loc 12 105 0
 2141 0030 3121     		movs	r1, #49
 2142 0032 3846     		mov	r0, r7
 2143 0034 FFF7FEFF 		bl	_Z13findMedianIntPii
 2144              	.LBE57:
  91:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   for (byte axis = 0; axis < 3; axis++) {
 2145              		.loc 12 91 0
 2146 0038 0134     		adds	r4, r4, #1
 2147 003a E4B2     		uxtb	r4, r4
 2148              	.LVL123:
 2149 003c 032C     		cmp	r4, #3
 2150              	.LBB60:
 2151              		.loc 12 105 0
 2152 003e 45F8040F 		str	r0, [r5, #4]!
 2153              	.LBE60:
  91:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   for (byte axis = 0; axis < 3; axis++) {
 2154              		.loc 12 91 0
 2155 0042 01D0     		beq	.L124
 2156              	.LVL124:
 2157              	.L125:
 2158              	.LBE56:
 2159              	.LBE55:
  88:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void calibrateGyro() {
 2160              		.loc 12 88 0 discriminator 1
 2161 0044 0026     		movs	r6, #0
 2162 0046 E0E7     		b	.L129
 2163              	.LVL125:
 2164              	.L124:
 106:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   }
 107:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 2165              		.loc 12 107 0
 2166 0048 33B0     		add	sp, sp, #204
 2167 004a F0BD     		pop	{r4, r5, r6, r7, pc}
 2168              	.L133:
 2169              		.align	2
 2170              	.L132:
 2171 004c FCFFFFFF 		.word	.LANCHOR31-4
 2172 0050 00000000 		.word	.LANCHOR22
 2173              		.cfi_endproc
 2174              	.LFE152:
 2176              		.section	.text._Z15initializeAccelv,"ax",%progbits
 2177              		.align	1
 2178              		.global	_Z15initializeAccelv
 2179              		.thumb
 2180              		.thumb_func
 2182              	_Z15initializeAccelv:
 2183              	.LFB153:
 2184              		.file 13 "../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h"
   1:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** /*
   2:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   AeroQuad v3.0 - May 2011
   3:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   Copyright (c) 2011 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
   7:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   This program is free software: you can redistribute it and/or modify
   8:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   it under the terms of the GNU General Public License as published by
   9:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   the Free Software Foundation, either version 3 of the License, or
  10:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   (at your option) any later version.
  11:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  12:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   This program is distributed in the hope that it will be useful,
  13:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   GNU General Public License for more details.
  16:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  17:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   You should have received a copy of the GNU General Public License
  18:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** */
  20:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  21:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** #ifndef _AEROQUAD_ACCELEROMETER_MPU6000_COMMON_H_
  22:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** #define _AEROQUAD_ACCELEROMETER_MPU6000_COMMON_H_
  23:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  24:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** #include <Platform_MPU6000.h>
  25:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** #include <Accelerometer.h>
  26:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  27:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void initializeAccel() {
 2185              		.loc 13 27 0
 2186              		.cfi_startproc
 2187              		@ args = 0, pretend = 0, frame = 0
 2188              		@ frame_needed = 0, uses_anonymous_args = 0
 2189              		@ link register save eliminated.
  28:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   initializeMPU6000Sensors();
  29:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** }
 2190              		.loc 13 29 0
  28:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   initializeMPU6000Sensors();
 2191              		.loc 13 28 0
 2192 0000 FFF7FEBF 		b	_Z24initializeMPU6000Sensorsv
 2193              		.cfi_endproc
 2194              	.LFE153:
 2196              		.section	.text._Z12measureAccelv,"ax",%progbits
 2197              		.align	1
 2198              		.global	_Z12measureAccelv
 2199              		.thumb
 2200              		.thumb_func
 2202              	_Z12measureAccelv:
 2203              	.LFB154:
  30:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  31:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  32:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void measureAccel() {
 2204              		.loc 13 32 0
 2205              		.cfi_startproc
 2206              		@ args = 0, pretend = 0, frame = 0
 2207              		@ frame_needed = 0, uses_anonymous_args = 0
 2208 0000 10B5     		push	{r4, lr}
 2209              	.LCFI25:
 2210              		.cfi_def_cfa_offset 8
 2211              		.cfi_offset 14, -4
 2212              		.cfi_offset 4, -8
  33:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   readMPU6000Accel();
 2213              		.loc 13 33 0
 2214 0002 FFF7FEFF 		bl	_Z16readMPU6000Accelv
  34:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  35:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[XAXIS] = MPU6000.data.accel.x * accelScaleFactor[XAXIS] + runTimeAccelBias[XAXIS];
 2215              		.loc 13 35 0
 2216 0006 1748     		ldr	r0, .L136
 2217 0008 1749     		ldr	r1, .L136+4
 2218 000a B0F90040 		ldrsh	r4, [r0, #0]
 2219 000e 174A     		ldr	r2, .L136+8
 2220 0010 174B     		ldr	r3, .L136+12
 2221 0012 04EE104A 		fmsr	s8, r4	@ int
  36:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[YAXIS] = MPU6000.data.accel.y * accelScaleFactor[YAXIS] + runTimeAccelBias[YAXIS];
 2222              		.loc 13 36 0
 2223 0016 B0F90240 		ldrsh	r4, [r0, #2]
  37:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[ZAXIS] = MPU6000.data.accel.z * accelScaleFactor[ZAXIS] + runTimeAccelBias[ZAXIS];
 2224              		.loc 13 37 0
 2225 001a B0F90400 		ldrsh	r0, [r0, #4]
  36:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[YAXIS] = MPU6000.data.accel.y * accelScaleFactor[YAXIS] + runTimeAccelBias[YAXIS];
 2226              		.loc 13 36 0
 2227 001e 02EE104A 		fmsr	s4, r4	@ int
 2228              		.loc 13 37 0
 2229 0022 00EE100A 		fmsr	s0, r0	@ int
  35:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[XAXIS] = MPU6000.data.accel.x * accelScaleFactor[XAXIS] + runTimeAccelBias[XAXIS];
 2230              		.loc 13 35 0
 2231 0026 B8EEC43A 		fsitos	s6, s8
 2232 002a D1ED003A 		flds	s7, [r1, #0]
 2233 002e D2ED002A 		flds	s5, [r2, #0]
  36:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[YAXIS] = MPU6000.data.accel.y * accelScaleFactor[YAXIS] + runTimeAccelBias[YAXIS];
 2234              		.loc 13 36 0
 2235 0032 B8EEC21A 		fsitos	s2, s4
 2236 0036 D1ED011A 		flds	s3, [r1, #4]
 2237 003a D2ED010A 		flds	s1, [r2, #4]
 2238              		.loc 13 37 0
 2239 003e F8EEC06A 		fsitos	s13, s0
 2240 0042 91ED027A 		flds	s14, [r1, #8]
 2241 0046 D2ED027A 		flds	s15, [r2, #8]
  35:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[XAXIS] = MPU6000.data.accel.x * accelScaleFactor[XAXIS] + runTimeAccelBias[XAXIS];
 2242              		.loc 13 35 0
 2243 004a 43EE232A 		fmacs	s5, s6, s7
  36:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[YAXIS] = MPU6000.data.accel.y * accelScaleFactor[YAXIS] + runTimeAccelBias[YAXIS];
 2244              		.loc 13 36 0
 2245 004e 41EE210A 		fmacs	s1, s2, s3
 2246              		.loc 13 37 0
 2247 0052 46EE877A 		fmacs	s15, s13, s14
  35:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[XAXIS] = MPU6000.data.accel.x * accelScaleFactor[XAXIS] + runTimeAccelBias[XAXIS];
 2248              		.loc 13 35 0
 2249 0056 C3ED002A 		fsts	s5, [r3, #0]
  36:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[YAXIS] = MPU6000.data.accel.y * accelScaleFactor[YAXIS] + runTimeAccelBias[YAXIS];
 2250              		.loc 13 36 0
 2251 005a C3ED010A 		fsts	s1, [r3, #4]
 2252              		.loc 13 37 0
 2253 005e C3ED027A 		fsts	s15, [r3, #8]
  38:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** }
 2254              		.loc 13 38 0
 2255 0062 10BD     		pop	{r4, pc}
 2256              	.L137:
 2257              		.align	2
 2258              	.L136:
 2259 0064 00000000 		.word	.LANCHOR22
 2260 0068 00000000 		.word	.LANCHOR35
 2261 006c 00000000 		.word	.LANCHOR36
 2262 0070 00000000 		.word	.LANCHOR34
 2263              		.cfi_endproc
 2264              	.LFE154:
 2266              		.section	.text._Z15measureAccelSumv,"ax",%progbits
 2267              		.align	1
 2268              		.global	_Z15measureAccelSumv
 2269              		.thumb
 2270              		.thumb_func
 2272              	_Z15measureAccelSumv:
 2273              	.LFB155:
  39:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  40:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void measureAccelSum() {
 2274              		.loc 13 40 0
 2275              		.cfi_startproc
 2276              		@ args = 0, pretend = 0, frame = 0
 2277              		@ frame_needed = 0, uses_anonymous_args = 0
 2278 0000 08B5     		push	{r3, lr}
 2279              	.LCFI26:
 2280              		.cfi_def_cfa_offset 8
 2281              		.cfi_offset 14, -4
 2282              		.cfi_offset 3, -8
  41:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   readMPU6000Accel();
 2283              		.loc 13 41 0
 2284 0002 FFF7FEFF 		bl	_Z16readMPU6000Accelv
  42:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSample[XAXIS] += MPU6000.data.accel.x;
 2285              		.loc 13 42 0
 2286 0006 0C4B     		ldr	r3, .L139
 2287 0008 0C4A     		ldr	r2, .L139+4
 2288 000a 1868     		ldr	r0, [r3, #0]
 2289 000c B2F900C0 		ldrsh	ip, [r2, #0]
 2290 0010 00EB0C01 		add	r1, r0, ip
 2291 0014 1960     		str	r1, [r3, #0]
  43:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSample[YAXIS] += MPU6000.data.accel.y;
 2292              		.loc 13 43 0
 2293 0016 5868     		ldr	r0, [r3, #4]
 2294 0018 B2F90210 		ldrsh	r1, [r2, #2]
  44:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSample[ZAXIS] += MPU6000.data.accel.z;
 2295              		.loc 13 44 0
 2296 001c B2F904C0 		ldrsh	ip, [r2, #4]
 2297 0020 9A68     		ldr	r2, [r3, #8]
  43:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSample[YAXIS] += MPU6000.data.accel.y;
 2298              		.loc 13 43 0
 2299 0022 4018     		adds	r0, r0, r1
 2300              		.loc 13 44 0
 2301 0024 02EB0C01 		add	r1, r2, ip
  43:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSample[YAXIS] += MPU6000.data.accel.y;
 2302              		.loc 13 43 0
 2303 0028 5860     		str	r0, [r3, #4]
 2304              		.loc 13 44 0
 2305 002a 9960     		str	r1, [r3, #8]
  45:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  46:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSampleCount++;
 2306              		.loc 13 46 0
 2307 002c 044B     		ldr	r3, .L139+8
 2308 002e 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 2309 0030 421C     		adds	r2, r0, #1
 2310 0032 1A70     		strb	r2, [r3, #0]
  47:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** }
 2311              		.loc 13 47 0
 2312 0034 08BD     		pop	{r3, pc}
 2313              	.L140:
 2314 0036 00BF     		.align	2
 2315              	.L139:
 2316 0038 00000000 		.word	.LANCHOR37
 2317 003c 00000000 		.word	.LANCHOR22
 2318 0040 00000000 		.word	.LANCHOR38
 2319              		.cfi_endproc
 2320              	.LFE155:
 2322              		.section	.text._Z20evaluateMetersPerSecv,"ax",%progbits
 2323              		.align	1
 2324              		.global	_Z20evaluateMetersPerSecv
 2325              		.thumb
 2326              		.thumb_func
 2328              	_Z20evaluateMetersPerSecv:
 2329              	.LFB156:
  48:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  49:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void evaluateMetersPerSec() {
 2330              		.loc 13 49 0
 2331              		.cfi_startproc
 2332              		@ args = 0, pretend = 0, frame = 0
 2333              		@ frame_needed = 0, uses_anonymous_args = 0
 2334              	.LVL126:
 2335 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2336              	.LCFI27:
 2337              		.cfi_def_cfa_offset 20
 2338              		.cfi_offset 14, -4
 2339              		.cfi_offset 7, -8
 2340              		.cfi_offset 6, -12
 2341              		.cfi_offset 5, -16
 2342              		.cfi_offset 4, -20
 2343              	.LBB61:
 2344              	.LBB62:
  50:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
  51:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (accelSample[axis] / accelSampleCount) * accelScaleFactor[axis] + runTim
 2345              		.loc 13 51 0
 2346 0002 114A     		ldr	r2, .L144
 2347 0004 114C     		ldr	r4, .L144+4
 2348 0006 1778     		ldrb	r7, [r2, #0]	@ zero_extendqisi2
 2349 0008 1148     		ldr	r0, .L144+8
 2350 000a 1249     		ldr	r1, .L144+12
 2351 000c 0023     		movs	r3, #0
 2352 000e 1646     		mov	r6, r2
 2353              	.LVL127:
 2354              	.L142:
 2355              		.loc 13 51 0 is_stmt 0 discriminator 2
 2356 0010 114D     		ldr	r5, .L144+16
 2357 0012 5A59     		ldr	r2, [r3, r5]
 2358 0014 92FBF7F2 		sdiv	r2, r2, r7
 2359 0018 00EE102A 		fmsr	s0, r2	@ int
 2360 001c 0434     		adds	r4, r4, #4
 2361 001e 0430     		adds	r0, r0, #4
 2362 0020 F8EEC06A 		fsitos	s13, s0
 2363 0024 94ED007A 		flds	s14, [r4, #0]
 2364 0028 D0ED007A 		flds	s15, [r0, #0]
 2365 002c 46EE877A 		fmacs	s15, s13, s14
  52:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   	accelSample[axis] = 0;
 2366              		.loc 13 52 0 is_stmt 1 discriminator 2
 2367 0030 0022     		movs	r2, #0
  51:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (accelSample[axis] / accelSampleCount) * accelScaleFactor[axis] + runTim
 2368              		.loc 13 51 0 discriminator 2
 2369 0032 17EE90CA 		fmrs	ip, s15
 2370              		.loc 13 52 0 discriminator 2
 2371 0036 5A51     		str	r2, [r3, r5]
 2372 0038 0433     		adds	r3, r3, #4
  50:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 2373              		.loc 13 50 0 discriminator 2
 2374 003a 0C2B     		cmp	r3, #12
  51:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (accelSample[axis] / accelSampleCount) * accelScaleFactor[axis] + runTim
 2375              		.loc 13 51 0 discriminator 2
 2376 003c 41F804CF 		str	ip, [r1, #4]!	@ float
  50:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 2377              		.loc 13 50 0 discriminator 2
 2378 0040 E6D1     		bne	.L142
 2379              	.LBE62:
  53:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   }
  54:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSampleCount = 0;
 2380              		.loc 13 54 0
 2381 0042 3270     		strb	r2, [r6, #0]
 2382              	.LBE61:
  55:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** }
 2383              		.loc 13 55 0
 2384 0044 F0BD     		pop	{r4, r5, r6, r7, pc}
 2385              	.L145:
 2386 0046 00BF     		.align	2
 2387              	.L144:
 2388 0048 00000000 		.word	.LANCHOR38
 2389 004c FCFFFFFF 		.word	.LANCHOR35-4
 2390 0050 FCFFFFFF 		.word	.LANCHOR36-4
 2391 0054 FCFFFFFF 		.word	.LANCHOR34-4
 2392 0058 00000000 		.word	.LANCHOR37
 2393              		.cfi_endproc
 2394              	.LFE156:
 2396              		.section	.text._Z16computeAccelBiasv,"ax",%progbits
 2397              		.align	1
 2398              		.global	_Z16computeAccelBiasv
 2399              		.thumb
 2400              		.thumb_func
 2402              	_Z16computeAccelBiasv:
 2403              	.LFB157:
  56:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  57:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void computeAccelBias() {
 2404              		.loc 13 57 0
 2405              		.cfi_startproc
 2406              		@ args = 0, pretend = 0, frame = 0
 2407              		@ frame_needed = 0, uses_anonymous_args = 0
 2408              	.LVL128:
 2409 0000 10B5     		push	{r4, lr}
 2410              	.LCFI28:
 2411              		.cfi_def_cfa_offset 8
 2412              		.cfi_offset 14, -4
 2413              		.cfi_offset 4, -8
 2414              	.LBB63:
 2415              	.LBB64:
  58:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (int samples = 0; samples < SAMPLECOUNT; samples++) {
 2416              		.loc 13 58 0
 2417 0002 0024     		movs	r4, #0
 2418 0004 08E0     		b	.L147
 2419              	.LVL129:
 2420              	.L148:
  59:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 	readMPU6000Sensors();
 2421              		.loc 13 59 0 discriminator 2
 2422 0006 FFF7FEFF 		bl	_Z18readMPU6000Sensorsv
  60:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     measureAccelSum();
 2423              		.loc 13 60 0 discriminator 2
 2424 000a FFF7FEFF 		bl	_Z15measureAccelSumv
  61:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     delayMicroseconds(2500);
 2425              		.loc 13 61 0 discriminator 2
 2426 000e 40F6C410 		movw	r0, #2500
 2427 0012 FFF7FEFF 		bl	_Z17delayMicrosecondsj
  58:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (int samples = 0; samples < SAMPLECOUNT; samples++) {
 2428              		.loc 13 58 0 discriminator 2
 2429 0016 0134     		adds	r4, r4, #1
 2430              	.LVL130:
 2431              	.L147:
  58:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (int samples = 0; samples < SAMPLECOUNT; samples++) {
 2432              		.loc 13 58 0 is_stmt 0 discriminator 1
 2433 0018 B4F5C87F 		cmp	r4, #400
 2434 001c F3D1     		bne	.L148
  58:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (int samples = 0; samples < SAMPLECOUNT; samples++) {
 2435              		.loc 13 58 0
 2436 001e 2048     		ldr	r0, .L152
 2437 0020 2049     		ldr	r1, .L152+4
 2438 0022 0023     		movs	r3, #0
 2439              	.LVL131:
 2440              	.L149:
 2441              	.LBE64:
 2442              	.LBB65:
  62:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   }
  63:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  64:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = 0; axis < 3; axis++) {
  65:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (float(accelSample[axis])/SAMPLECOUNT) * accelScaleFactor[axis];
 2443              		.loc 13 65 0 is_stmt 1 discriminator 2
 2444 0024 204C     		ldr	r4, .L152+8
 2445 0026 1A59     		ldr	r2, [r3, r4]
 2446 0028 00EE902A 		fmsr	s1, r2	@ int
 2447 002c 9FED1F0A 		flds	s0, .L152+12
 2448 0030 B8EEE07A 		fsitos	s14, s1
 2449 0034 0430     		adds	r0, r0, #4
 2450 0036 87EE007A 		fdivs	s14, s14, s0
 2451 003a D0ED007A 		flds	s15, [r0, #0]
 2452 003e 67EE277A 		fmuls	s15, s14, s15
 2453 0042 17EE902A 		fmrs	r2, s15
 2454 0046 41F8042F 		str	r2, [r1, #4]!	@ float
  66:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     accelSample[axis] = 0;
 2455              		.loc 13 66 0 discriminator 2
 2456 004a 0022     		movs	r2, #0
 2457 004c 1A51     		str	r2, [r3, r4]
 2458 004e 0433     		adds	r3, r3, #4
  64:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = 0; axis < 3; axis++) {
 2459              		.loc 13 64 0 discriminator 2
 2460 0050 0C2B     		cmp	r3, #12
 2461 0052 E7D1     		bne	.L149
 2462              	.LBE65:
  67:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   }
  68:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSampleCount = 0;
  69:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  70:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[XAXIS] = -meterPerSecSec[XAXIS];
 2463              		.loc 13 70 0
 2464 0054 1649     		ldr	r1, .L152+16
  68:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSampleCount = 0;
 2465              		.loc 13 68 0
 2466 0056 174B     		ldr	r3, .L152+20
 2467              		.loc 13 70 0
 2468 0058 1748     		ldr	r0, .L152+24
  68:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSampleCount = 0;
 2469              		.loc 13 68 0
 2470 005a 1A70     		strb	r2, [r3, #0]
  71:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[YAXIS] = -meterPerSecSec[YAXIS];
  72:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[ZAXIS] = -9.8065 - meterPerSecSec[ZAXIS];
 2471              		.loc 13 72 0
 2472 005c 91ED022A 		flds	s4, [r1, #8]
 2473 0060 DFED162A 		flds	s5, .L152+28
 2474 0064 72EEC21A 		fsubs	s3, s5, s4
  70:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[XAXIS] = -meterPerSecSec[XAXIS];
 2475              		.loc 13 70 0
 2476 0068 D1ED004A 		flds	s9, [r1, #0]
  73:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  74:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelOneG = abs(meterPerSecSec[ZAXIS] + runTimeAccelBias[ZAXIS]);
 2477              		.loc 13 74 0
 2478 006c 32EE211A 		fadds	s2, s4, s3
  71:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[YAXIS] = -meterPerSecSec[YAXIS];
 2479              		.loc 13 71 0
 2480 0070 D1ED013A 		flds	s7, [r1, #4]
 2481              		.loc 13 74 0
 2482 0074 B5EEC01A 		fcmpezs	s2
 2483 0078 F1EE10FA 		fmstat
 2484 007c 104B     		ldr	r3, .L152+32
  70:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[XAXIS] = -meterPerSecSec[XAXIS];
 2485              		.loc 13 70 0
 2486 007e B1EE644A 		fnegs	s8, s9
  71:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[YAXIS] = -meterPerSecSec[YAXIS];
 2487              		.loc 13 71 0
 2488 0082 B1EE633A 		fnegs	s6, s7
 2489              		.loc 13 74 0
 2490 0086 D8BF     		it	le
 2491 0088 B1EE411A 		fnegsle	s2, s2
  70:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[XAXIS] = -meterPerSecSec[XAXIS];
 2492              		.loc 13 70 0
 2493 008c 80ED004A 		fsts	s8, [r0, #0]
  71:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[YAXIS] = -meterPerSecSec[YAXIS];
 2494              		.loc 13 71 0
 2495 0090 80ED013A 		fsts	s6, [r0, #4]
  72:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[ZAXIS] = -9.8065 - meterPerSecSec[ZAXIS];
 2496              		.loc 13 72 0
 2497 0094 C0ED021A 		fsts	s3, [r0, #8]
 2498              		.loc 13 74 0
 2499 0098 83ED001A 		fsts	s2, [r3, #0]
 2500              	.LBE63:
  75:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** }
 2501              		.loc 13 75 0
 2502 009c 10BD     		pop	{r4, pc}
 2503              	.L153:
 2504 009e 00BF     		.align	2
 2505              	.L152:
 2506 00a0 FCFFFFFF 		.word	.LANCHOR35-4
 2507 00a4 FCFFFFFF 		.word	.LANCHOR34-4
 2508 00a8 00000000 		.word	.LANCHOR37
 2509 00ac 0000C843 		.word	1137180672
 2510 00b0 00000000 		.word	.LANCHOR34
 2511 00b4 00000000 		.word	.LANCHOR38
 2512 00b8 00000000 		.word	.LANCHOR36
 2513 00bc 6DE71CC1 		.word	-1055070355
 2514 00c0 00000000 		.word	.LANCHOR39
 2515              		.cfi_endproc
 2516              	.LFE157:
 2518              		.section	.text._Z24HardCodedAxisCalibrationv,"ax",%progbits
 2519              		.align	1
 2520              		.global	_Z24HardCodedAxisCalibrationv
 2521              		.thumb
 2522              		.thumb_func
 2524              	_Z24HardCodedAxisCalibrationv:
 2525              	.LFB158:
 2526              		.file 14 "../AeroQuad32/AeroQuad_STM32.h"
   1:../AeroQuad32/AeroQuad_STM32.h **** #define __STM32__
   2:../AeroQuad32/AeroQuad_STM32.h **** #define DEBUG_INIT
   3:../AeroQuad32/AeroQuad_STM32.h **** tSerial &Serial = SERIAL_VAR;
   4:../AeroQuad32/AeroQuad_STM32.h **** 
   5:../AeroQuad32/AeroQuad_STM32.h **** #define ADC_NUMBER_OF_BITS	12
   6:../AeroQuad32/AeroQuad_STM32.h **** 
   7:../AeroQuad32/AeroQuad_STM32.h **** 
   8:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BOARD_aeroquad32
   9:../AeroQuad32/AeroQuad_STM32.h **** 	#define STM32_BOARD_TYPE "aeroquad32"
  10:../AeroQuad32/AeroQuad_STM32.h **** 	#define LED_Green  Port2Pin('E', 6)
  11:../AeroQuad32/AeroQuad_STM32.h **** 	#define LED_Red    Port2Pin('E', 5)
  12:../AeroQuad32/AeroQuad_STM32.h **** 	#define LED_Yellow LED_Red
  13:../AeroQuad32/AeroQuad_STM32.h ****         #define A1       Port2Pin('B',0)
  14:../AeroQuad32/AeroQuad_STM32.h ****         #define A2       Port2Pin('C',4)
  15:../AeroQuad32/AeroQuad_STM32.h ****         #define A3       Port2Pin('B',1)
  16:../AeroQuad32/AeroQuad_STM32.h ****         #define A4       Port2Pin('C',5)
  17:../AeroQuad32/AeroQuad_STM32.h ****         #define A5       Port2Pin('C',2)
  18:../AeroQuad32/AeroQuad_STM32.h ****         #define A6       Port2Pin('C',3)
  19:../AeroQuad32/AeroQuad_STM32.h **** 
  20:../AeroQuad32/AeroQuad_STM32.h **** #endif
  21:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BOARD_aeroquad32mini
  22:../AeroQuad32/AeroQuad_STM32.h **** 	#define STM32_BOARD_TYPE "aeroquad32 mini"
  23:../AeroQuad32/AeroQuad_STM32.h **** 	#define LED_Green  13 // PA3
  24:../AeroQuad32/AeroQuad_STM32.h **** 	#define LED_Red    13
  25:../AeroQuad32/AeroQuad_STM32.h **** 	#define LED_Yellow 13
  26:../AeroQuad32/AeroQuad_STM32.h **** #endif
  27:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BOARD_freeflight
  28:../AeroQuad32/AeroQuad_STM32.h **** 	#define STM32_BOARD_TYPE "Free Flight"
  29:../AeroQuad32/AeroQuad_STM32.h **** 	#define LED_Green  Port2Pin('B', 4)
  30:../AeroQuad32/AeroQuad_STM32.h **** 	#define LED_Red    Port2Pin('B', 3)
  31:../AeroQuad32/AeroQuad_STM32.h **** 	#define LED_Yellow LED_Red
  32:../AeroQuad32/AeroQuad_STM32.h **** 	#define ITG3200_ADDRESS_ALTERNATE
  33:../AeroQuad32/AeroQuad_STM32.h **** #endif
  34:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BOARD_discovery_f4
  35:../AeroQuad32/AeroQuad_STM32.h **** 	#define STM32_BOARD_TYPE "Discovery F4"
  36:../AeroQuad32/AeroQuad_STM32.h **** 	#define LED_Green  Port2Pin('D', 12)
  37:../AeroQuad32/AeroQuad_STM32.h **** 	#define LED_Red    Port2Pin('D', 14)
  38:../AeroQuad32/AeroQuad_STM32.h **** 	#define LED_Yellow Port2Pin('D', 13)
  39:../AeroQuad32/AeroQuad_STM32.h **** #endif
  40:../AeroQuad32/AeroQuad_STM32.h **** 
  41:../AeroQuad32/AeroQuad_STM32.h **** #include <Device_I2C.h>
  42:../AeroQuad32/AeroQuad_STM32.h **** 
  43:../AeroQuad32/AeroQuad_STM32.h **** // Gyroscope declaration
  44:../AeroQuad32/AeroQuad_STM32.h **** #ifdef SENSORBOARD_ALA42
  45:../AeroQuad32/AeroQuad_STM32.h **** 	#include <Gyroscope_ITG3200_ala42.h>
  46:../AeroQuad32/AeroQuad_STM32.h **** #else
  47:../AeroQuad32/AeroQuad_STM32.h **** 	//#include <Gyroscope_ITG3200.h>
  48:../AeroQuad32/AeroQuad_STM32.h **** 	#include <Gyroscope_MPU6000.h>
  49:../AeroQuad32/AeroQuad_STM32.h **** #endif
  50:../AeroQuad32/AeroQuad_STM32.h **** 
  51:../AeroQuad32/AeroQuad_STM32.h **** // Accelerometer declaration
  52:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BOARD_freeflight
  53:../AeroQuad32/AeroQuad_STM32.h ****   #include <Accelerometer_ADXL345_9DOF.h>
  54:../AeroQuad32/AeroQuad_STM32.h **** #else
  55:../AeroQuad32/AeroQuad_STM32.h ****   //#include <Accelerometer_BMA180.h>
  56:../AeroQuad32/AeroQuad_STM32.h ****   //#include <Accelerometer_BMA180_ala42.h>
  57:../AeroQuad32/AeroQuad_STM32.h ****   #include <Accelerometer_MPU6000.h>
  58:../AeroQuad32/AeroQuad_STM32.h **** #endif
  59:../AeroQuad32/AeroQuad_STM32.h **** 
  60:../AeroQuad32/AeroQuad_STM32.h **** // Receiver Declaration
  61:../AeroQuad32/AeroQuad_STM32.h **** #if defined (ReceiverPPM) || defined (ReceiverHWPPM)
  62:../AeroQuad32/AeroQuad_STM32.h ****   #undef ReceiverPPM
  63:../AeroQuad32/AeroQuad_STM32.h ****   #undef ReceiverHWPPM
  64:../AeroQuad32/AeroQuad_STM32.h ****   #define RECEIVER_STM32PPM
  65:../AeroQuad32/AeroQuad_STM32.h **** #else
  66:../AeroQuad32/AeroQuad_STM32.h ****   #define RECEIVER_STM32
  67:../AeroQuad32/AeroQuad_STM32.h **** #endif
  68:../AeroQuad32/AeroQuad_STM32.h **** 
  69:../AeroQuad32/AeroQuad_STM32.h **** // Motor declaration
  70:../AeroQuad32/AeroQuad_STM32.h **** #define MOTOR_STM32
  71:../AeroQuad32/AeroQuad_STM32.h **** 
  72:../AeroQuad32/AeroQuad_STM32.h **** // heading mag hold declaration
  73:../AeroQuad32/AeroQuad_STM32.h **** #ifdef HeadingMagHold
  74:../AeroQuad32/AeroQuad_STM32.h **** 	#ifdef SENSORBOARD_ALA42
  75:../AeroQuad32/AeroQuad_STM32.h **** 		#define HMC5843
  76:../AeroQuad32/AeroQuad_STM32.h **** 	#else
  77:../AeroQuad32/AeroQuad_STM32.h **** 		#define HMC5883L
  78:../AeroQuad32/AeroQuad_STM32.h **** 	#endif
  79:../AeroQuad32/AeroQuad_STM32.h **** #endif
  80:../AeroQuad32/AeroQuad_STM32.h **** 
  81:../AeroQuad32/AeroQuad_STM32.h **** // Altitude declaration
  82:../AeroQuad32/AeroQuad_STM32.h **** #ifdef AltitudeHoldBaro
  83:../AeroQuad32/AeroQuad_STM32.h **** 	#ifdef SENSORBOARD_ALA42
  84:../AeroQuad32/AeroQuad_STM32.h **** 	  #define BMP085
  85:../AeroQuad32/AeroQuad_STM32.h **** 	#else
  86:../AeroQuad32/AeroQuad_STM32.h ****   	#define MS5611
  87:../AeroQuad32/AeroQuad_STM32.h ****   #endif
  88:../AeroQuad32/AeroQuad_STM32.h **** #endif
  89:../AeroQuad32/AeroQuad_STM32.h **** 
  90:../AeroQuad32/AeroQuad_STM32.h **** #ifdef AltitudeHoldRangeFinder
  91:../AeroQuad32/AeroQuad_STM32.h **** 	#define XLMAXSONAR
  92:../AeroQuad32/AeroQuad_STM32.h **** #endif
  93:../AeroQuad32/AeroQuad_STM32.h **** 
  94:../AeroQuad32/AeroQuad_STM32.h **** // Battery Monitor declaration
  95:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BattMonitor
  96:../AeroQuad32/AeroQuad_STM32.h **** 	#define BuzzerPin Port2Pin('A', 0)
  97:../AeroQuad32/AeroQuad_STM32.h **** 
  98:../AeroQuad32/AeroQuad_STM32.h **** 	#define BATT_AREF			3.3		// V
  99:../AeroQuad32/AeroQuad_STM32.h **** 
 100:../AeroQuad32/AeroQuad_STM32.h **** 	#ifdef BOARD_freeflight
 101:../AeroQuad32/AeroQuad_STM32.h **** 		#define BATT_R_HIGH			10.0	// kOhm
 102:../AeroQuad32/AeroQuad_STM32.h **** 		#define BATT_R_LOW			1.0		// kOhm
 103:../AeroQuad32/AeroQuad_STM32.h **** 		#define BATT_ANALOG_INPUT	Port2Pin('A', 4)
 104:../AeroQuad32/AeroQuad_STM32.h **** 		#define BATT_DIODE_LOSS		0.76
 105:../AeroQuad32/AeroQuad_STM32.h **** 	#else
 106:../AeroQuad32/AeroQuad_STM32.h **** 		#define BATT_R_HIGH			10.0	// kOhm
 107:../AeroQuad32/AeroQuad_STM32.h **** 		#define BATT_R_LOW			1.5		// kOhm
 108:../AeroQuad32/AeroQuad_STM32.h **** 		#define BATT_ANALOG_INPUT	Port2Pin('C', 0)
 109:../AeroQuad32/AeroQuad_STM32.h **** 		#define BATT_DIODE_LOSS		0.0
 110:../AeroQuad32/AeroQuad_STM32.h **** 	#endif
 111:../AeroQuad32/AeroQuad_STM32.h ****         #define BattDefaultConfig DEFINE_BATTERY(0, BATT_ANALOG_INPUT, (BATT_AREF * (BATT_R_HIGH + 
 112:../AeroQuad32/AeroQuad_STM32.h **** #endif
 113:../AeroQuad32/AeroQuad_STM32.h **** 
 114:../AeroQuad32/AeroQuad_STM32.h **** #ifdef OSD
 115:../AeroQuad32/AeroQuad_STM32.h **** 	#define MAX7456_OSD
 116:../AeroQuad32/AeroQuad_STM32.h **** #endif
 117:../AeroQuad32/AeroQuad_STM32.h **** 
 118:../AeroQuad32/AeroQuad_STM32.h **** #ifdef CameraControl
 119:../AeroQuad32/AeroQuad_STM32.h **** 	#define CameraControl_STM32
 120:../AeroQuad32/AeroQuad_STM32.h **** #endif
 121:../AeroQuad32/AeroQuad_STM32.h **** 
 122:../AeroQuad32/AeroQuad_STM32.h **** 
 123:../AeroQuad32/AeroQuad_STM32.h **** /**
 124:../AeroQuad32/AeroQuad_STM32.h ****  * Put AeroQuadSTM32 specific initialization need here
 125:../AeroQuad32/AeroQuad_STM32.h ****  */
 126:../AeroQuad32/AeroQuad_STM32.h **** 
 127:../AeroQuad32/AeroQuad_STM32.h **** void HardCodedAxisCalibration()
 128:../AeroQuad32/AeroQuad_STM32.h **** {
 2527              		.loc 14 128 0
 2528              		.cfi_startproc
 2529              		@ args = 0, pretend = 0, frame = 0
 2530              		@ frame_needed = 0, uses_anonymous_args = 0
 2531              		@ link register save eliminated.
 129:../AeroQuad32/AeroQuad_STM32.h ****   if(   (accelScaleFactor[XAXIS] == 1.0 && accelScaleFactor[YAXIS] == 1.0 && accelScaleFactor[ZAXIS
 2532              		.loc 14 129 0
 2533 0000 184B     		ldr	r3, .L158
 2534 0002 93ED007A 		flds	s14, [r3, #0]
 2535 0006 F7EE007A 		fconsts	s15, #112
 2536 000a B4EE677A 		fcmps	s14, s15
 2537 000e F1EE10FA 		fmstat
 2538 0012 0ED1     		bne	.L155
 2539              		.loc 14 129 0 is_stmt 0 discriminator 1
 2540 0014 93ED017A 		flds	s14, [r3, #4]
 2541 0018 B4EE677A 		fcmps	s14, s15
 2542 001c F1EE10FA 		fmstat
 2543 0020 1FD1     		bne	.L154
 2544              		.loc 14 129 0 discriminator 3
 2545 0022 93ED020A 		flds	s0, [r3, #8]
 2546 0026 B4EE670A 		fcmps	s0, s15
 2547 002a F1EE10FA 		fmstat
 2548 002e 13D0     		beq	.L157
 2549 0030 7047     		bx	lr
 2550              	.L155:
 2551              		.loc 14 129 0 discriminator 2
 2552 0032 B5EE407A 		fcmpzs	s14
 2553 0036 F1EE10FA 		fmstat
 2554 003a 12D1     		bne	.L154
 2555              		.loc 14 129 0 discriminator 4
 2556 003c D3ED017A 		flds	s15, [r3, #4]
 2557 0040 F5EE407A 		fcmpzs	s15
 2558 0044 F1EE10FA 		fmstat
 2559 0048 0BD1     		bne	.L154
 2560              		.loc 14 129 0 discriminator 5
 2561 004a D3ED020A 		flds	s1, [r3, #8]
 2562 004e F5EE400A 		fcmpzs	s1
 2563 0052 F1EE10FA 		fmstat
 2564 0056 04D1     		bne	.L154
 2565              	.L157:
 130:../AeroQuad32/AeroQuad_STM32.h ****      || (accelScaleFactor[XAXIS] == 0.0 && accelScaleFactor[YAXIS] == 0.0 && accelScaleFactor[ZAXIS
 131:../AeroQuad32/AeroQuad_STM32.h ****   ) {
 132:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BOARD_freeflight
 133:../AeroQuad32/AeroQuad_STM32.h ****     accelScaleFactor[XAXIS] = accelScaleFactor[YAXIS] = accelScaleFactor[ZAXIS] = -0.038;
 134:../AeroQuad32/AeroQuad_STM32.h **** #else
 135:../AeroQuad32/AeroQuad_STM32.h ****     #ifdef _AEROQUAD_PLATFORM_MPU6000_H_
 136:../AeroQuad32/AeroQuad_STM32.h ****       accelScaleFactor[XAXIS] = accelScaleFactor[YAXIS] = accelScaleFactor[ZAXIS] = 0.00119;
 137:../AeroQuad32/AeroQuad_STM32.h ****     #else
 138:../AeroQuad32/AeroQuad_STM32.h ****       accelScaleFactor[XAXIS] = accelScaleFactor[YAXIS] = accelScaleFactor[ZAXIS] = 0.0048;
 139:../AeroQuad32/AeroQuad_STM32.h ****     #endif
 140:../AeroQuad32/AeroQuad_STM32.h ****   	accelScaleFactor[YAXIS] *= -1;
 2566              		.loc 14 140 0 is_stmt 1
 2567 0058 034A     		ldr	r2, .L158+4
 136:../AeroQuad32/AeroQuad_STM32.h ****       accelScaleFactor[XAXIS] = accelScaleFactor[YAXIS] = accelScaleFactor[ZAXIS] = 0.00119;
 2568              		.loc 14 136 0
 2569 005a 0448     		ldr	r0, .L158+8
 2570              		.loc 14 140 0
 2571 005c 5A60     		str	r2, [r3, #4]	@ float
 136:../AeroQuad32/AeroQuad_STM32.h ****       accelScaleFactor[XAXIS] = accelScaleFactor[YAXIS] = accelScaleFactor[ZAXIS] = 0.00119;
 2572              		.loc 14 136 0
 2573 005e 1860     		str	r0, [r3, #0]	@ float
 141:../AeroQuad32/AeroQuad_STM32.h ****   	accelScaleFactor[ZAXIS] *= -1;
 2574              		.loc 14 141 0
 2575 0060 9A60     		str	r2, [r3, #8]	@ float
 2576              	.L154:
 2577 0062 7047     		bx	lr
 2578              	.L159:
 2579              		.align	2
 2580              	.L158:
 2581 0064 00000000 		.word	.LANCHOR35
 2582 0068 C6F99BBA 		.word	-1164183098
 2583 006c C6F99B3A 		.word	983300550
 2584              		.cfi_endproc
 2585              	.LFE158:
 2587              		.section	.text._Z12initPlatformv,"ax",%progbits
 2588              		.align	1
 2589              		.global	_Z12initPlatformv
 2590              		.thumb
 2591              		.thumb_func
 2593              	_Z12initPlatformv:
 2594              	.LFB159:
 142:../AeroQuad32/AeroQuad_STM32.h **** #endif
 143:../AeroQuad32/AeroQuad_STM32.h ****   }
 144:../AeroQuad32/AeroQuad_STM32.h **** }
 145:../AeroQuad32/AeroQuad_STM32.h **** 
 146:../AeroQuad32/AeroQuad_STM32.h **** 
 147:../AeroQuad32/AeroQuad_STM32.h **** 
 148:../AeroQuad32/AeroQuad_STM32.h **** void initPlatform() {
 2595              		.loc 14 148 0
 2596              		.cfi_startproc
 2597              		@ args = 0, pretend = 0, frame = 0
 2598              		@ frame_needed = 0, uses_anonymous_args = 0
 2599 0000 10B5     		push	{r4, lr}
 2600              	.LCFI29:
 2601              		.cfi_def_cfa_offset 8
 2602              		.cfi_offset 14, -4
 2603              		.cfi_offset 4, -8
 2604              	.LBB66:
 149:../AeroQuad32/AeroQuad_STM32.h **** 	pinMode(LED_Green, OUTPUT);
 2605              		.loc 14 149 0
 2606 0002 4620     		movs	r0, #70
 2607 0004 0021     		movs	r1, #0
 2608 0006 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 2609              	.LVL132:
 150:../AeroQuad32/AeroQuad_STM32.h **** 	for(byte ledloop=0; ledloop<10; ledloop++) {
 2610              		.loc 14 150 0
 2611 000a 0024     		movs	r4, #0
 2612              	.LVL133:
 2613              	.L161:
 2614              	.LBB67:
 151:../AeroQuad32/AeroQuad_STM32.h **** 		digitalWrite(LED_Green, ledloop & 1);
 2615              		.loc 14 151 0 discriminator 2
 2616 000c 4620     		movs	r0, #70
 2617 000e 04F00101 		and	r1, r4, #1
 150:../AeroQuad32/AeroQuad_STM32.h **** 	for(byte ledloop=0; ledloop<10; ledloop++) {
 2618              		.loc 14 150 0 discriminator 2
 2619 0012 0134     		adds	r4, r4, #1
 2620              		.loc 14 151 0 discriminator 2
 2621 0014 FFF7FEFF 		bl	_Z12digitalWritehh
 150:../AeroQuad32/AeroQuad_STM32.h **** 	for(byte ledloop=0; ledloop<10; ledloop++) {
 2622              		.loc 14 150 0 discriminator 2
 2623 0018 E4B2     		uxtb	r4, r4
 152:../AeroQuad32/AeroQuad_STM32.h **** 		delay(50);
 2624              		.loc 14 152 0 discriminator 2
 2625 001a 3220     		movs	r0, #50
 2626 001c FFF7FEFF 		bl	_Z5delaym
 2627              	.LVL134:
 150:../AeroQuad32/AeroQuad_STM32.h **** 	for(byte ledloop=0; ledloop<10; ledloop++) {
 2628              		.loc 14 150 0 discriminator 2
 2629 0020 0A2C     		cmp	r4, #10
 2630 0022 F3D1     		bne	.L161
 2631              	.LBE67:
 153:../AeroQuad32/AeroQuad_STM32.h **** 	}
 154:../AeroQuad32/AeroQuad_STM32.h **** 
 155:../AeroQuad32/AeroQuad_STM32.h **** 	pinMode(LED_Red, OUTPUT);
 2632              		.loc 14 155 0
 2633 0024 4520     		movs	r0, #69
 2634 0026 0021     		movs	r1, #0
 2635 0028 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 156:../AeroQuad32/AeroQuad_STM32.h **** 	digitalWrite(LED_Red, LOW);
 2636              		.loc 14 156 0
 2637 002c 4520     		movs	r0, #69
 2638 002e 0021     		movs	r1, #0
 2639 0030 FFF7FEFF 		bl	_Z12digitalWritehh
 157:../AeroQuad32/AeroQuad_STM32.h **** 	pinMode(LED_Yellow, OUTPUT);
 2640              		.loc 14 157 0
 2641 0034 4520     		movs	r0, #69
 2642 0036 0021     		movs	r1, #0
 2643 0038 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 158:../AeroQuad32/AeroQuad_STM32.h **** 	digitalWrite(LED_Yellow, LOW);
 2644              		.loc 14 158 0
 2645 003c 4520     		movs	r0, #69
 2646 003e 0021     		movs	r1, #0
 2647 0040 FFF7FEFF 		bl	_Z12digitalWritehh
 159:../AeroQuad32/AeroQuad_STM32.h **** 
 160:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BattMonitor
 161:../AeroQuad32/AeroQuad_STM32.h **** 	pinMode(BATT_ANALOG_INPUT, INPUT_ANALOG);
 2648              		.loc 14 161 0
 2649 0044 2020     		movs	r0, #32
 2650 0046 0321     		movs	r1, #3
 2651 0048 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 162:../AeroQuad32/AeroQuad_STM32.h **** 	pinMode(BuzzerPin, OUTPUT);
 2652              		.loc 14 162 0
 2653 004c 0020     		movs	r0, #0
 2654 004e 0146     		mov	r1, r0
 2655 0050 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 163:../AeroQuad32/AeroQuad_STM32.h **** 	digitalWrite(BuzzerPin, LOW);
 2656              		.loc 14 163 0
 2657 0054 0020     		movs	r0, #0
 2658 0056 0146     		mov	r1, r0
 2659 0058 FFF7FEFF 		bl	_Z12digitalWritehh
 164:../AeroQuad32/AeroQuad_STM32.h **** #endif
 165:../AeroQuad32/AeroQuad_STM32.h **** 
 166:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BOARD_aeroquad32
 167:../AeroQuad32/AeroQuad_STM32.h **** 	pinMode(A1, INPUT_ANALOG);
 2660              		.loc 14 167 0
 2661 005c 1020     		movs	r0, #16
 2662 005e 0321     		movs	r1, #3
 2663 0060 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 168:../AeroQuad32/AeroQuad_STM32.h **** 	pinMode(A2, INPUT_ANALOG);
 2664              		.loc 14 168 0
 2665 0064 2420     		movs	r0, #36
 2666 0066 0321     		movs	r1, #3
 2667 0068 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 169:../AeroQuad32/AeroQuad_STM32.h **** 	pinMode(A3, INPUT_ANALOG);
 2668              		.loc 14 169 0
 2669 006c 1120     		movs	r0, #17
 2670 006e 0321     		movs	r1, #3
 2671 0070 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 170:../AeroQuad32/AeroQuad_STM32.h **** 	pinMode(A4, INPUT_ANALOG);
 2672              		.loc 14 170 0
 2673 0074 2520     		movs	r0, #37
 2674 0076 0321     		movs	r1, #3
 2675 0078 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 171:../AeroQuad32/AeroQuad_STM32.h **** 	pinMode(A5, INPUT_ANALOG);
 2676              		.loc 14 171 0
 2677 007c 2220     		movs	r0, #34
 2678 007e 0321     		movs	r1, #3
 2679 0080 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 172:../AeroQuad32/AeroQuad_STM32.h **** 	pinMode(A6, INPUT_ANALOG);
 2680              		.loc 14 172 0
 2681 0084 2320     		movs	r0, #35
 2682 0086 0321     		movs	r1, #3
 2683 0088 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 173:../AeroQuad32/AeroQuad_STM32.h **** #endif
 174:../AeroQuad32/AeroQuad_STM32.h **** 
 175:../AeroQuad32/AeroQuad_STM32.h **** #ifdef DEBUG_INIT
 176:../AeroQuad32/AeroQuad_STM32.h ****   Serial.println("\r\nAeroQuad STM32, board type " STM32_BOARD_TYPE ", build date " __DATE__ " "__T
 2684              		.loc 14 176 0
 2685 008c 0848     		ldr	r0, .L163
 2686 008e 0949     		ldr	r1, .L163+4
 2687 0090 FFF7FEFF 		bl	_ZN5Print7printlnEPKc
 177:../AeroQuad32/AeroQuad_STM32.h **** #endif
 178:../AeroQuad32/AeroQuad_STM32.h **** 
 179:../AeroQuad32/AeroQuad_STM32.h **** 
 180:../AeroQuad32/AeroQuad_STM32.h **** // I2C setup
 181:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BOARD_aeroquad32
 182:../AeroQuad32/AeroQuad_STM32.h ****   Wire.begin(Port2Pin('B', 7), Port2Pin('B', 6)); // I2C1_SDA PB7, I2C1_SCL PB6
 2688              		.loc 14 182 0
 2689 0094 1721     		movs	r1, #23
 2690 0096 0848     		ldr	r0, .L163+8
 2691 0098 1622     		movs	r2, #22
 2692 009a FFF7FEFF 		bl	_ZN7TwoWire5beginEhh
 183:../AeroQuad32/AeroQuad_STM32.h **** #endif
 184:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BOARD_aeroquad32mini
 185:../AeroQuad32/AeroQuad_STM32.h ****   Wire.begin(16, 17); // I2C2_SDA PB11, I2C2_SCL PB10
 186:../AeroQuad32/AeroQuad_STM32.h **** #endif
 187:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BOARD_freeflight
 188:../AeroQuad32/AeroQuad_STM32.h ****   Wire.begin(Port2Pin('B', 11), Port2Pin('B', 10)); // I2C1_SDA PB11, I2C1_SCL PB10
 189:../AeroQuad32/AeroQuad_STM32.h **** #endif
 190:../AeroQuad32/AeroQuad_STM32.h **** #ifdef BOARD_discovery_f4
 191:../AeroQuad32/AeroQuad_STM32.h ****   Wire.begin(Port2Pin('B', 9), Port2Pin('B', 6)); // I2C1_SDA PB9, I2C1_SCL PB6
 192:../AeroQuad32/AeroQuad_STM32.h **** #endif
 193:../AeroQuad32/AeroQuad_STM32.h **** 
 194:../AeroQuad32/AeroQuad_STM32.h **** 
 195:../AeroQuad32/AeroQuad_STM32.h ****   HardCodedAxisCalibration();
 2693              		.loc 14 195 0
 2694 009e FFF7FEFF 		bl	_Z24HardCodedAxisCalibrationv
 196:../AeroQuad32/AeroQuad_STM32.h **** 
 197:../AeroQuad32/AeroQuad_STM32.h **** #ifdef DEBUG_INIT
 198:../AeroQuad32/AeroQuad_STM32.h ****   Serial.println("STM32 init done\r\n");
 2695              		.loc 14 198 0
 2696 00a2 0348     		ldr	r0, .L163
 2697 00a4 0549     		ldr	r1, .L163+12
 2698              	.LBE66:
 199:../AeroQuad32/AeroQuad_STM32.h **** #endif
 200:../AeroQuad32/AeroQuad_STM32.h **** }
 2699              		.loc 14 200 0
 2700 00a6 BDE81040 		pop	{r4, lr}
 2701              	.LBB68:
 198:../AeroQuad32/AeroQuad_STM32.h ****   Serial.println("STM32 init done\r\n");
 2702              		.loc 14 198 0
 2703 00aa FFF7FEBF 		b	_ZN5Print7printlnEPKc
 2704              	.L164:
 2705 00ae 00BF     		.align	2
 2706              	.L163:
 2707 00b0 00000000 		.word	SerialUSB
 2708 00b4 39000000 		.word	.LC4
 2709 00b8 00000000 		.word	Wire
 2710 00bc 82000000 		.word	.LC5
 2711              	.LBE68:
 2712              		.cfi_endproc
 2713              	.LFE159:
 2715              		.section	.text._Z11SignalAlivei,"ax",%progbits
 2716              		.align	1
 2717              		.global	_Z11SignalAlivei
 2718              		.thumb
 2719              		.thumb_func
 2721              	_Z11SignalAlivei:
 2722              	.LFB160:
 201:../AeroQuad32/AeroQuad_STM32.h **** 
 202:../AeroQuad32/AeroQuad_STM32.h **** 
 203:../AeroQuad32/AeroQuad_STM32.h **** void SignalAlive(int frameCounter) {
 2723              		.loc 14 203 0
 2724              		.cfi_startproc
 2725              		@ args = 0, pretend = 0, frame = 0
 2726              		@ frame_needed = 0, uses_anonymous_args = 0
 2727              		@ link register save eliminated.
 2728              	.LVL135:
 204:../AeroQuad32/AeroQuad_STM32.h ****   digitalWrite(LED_Green, (frameCounter/50) & 1);
 2729              		.loc 14 204 0
 2730 0000 3222     		movs	r2, #50
 2731 0002 90FBF2F1 		sdiv	r1, r0, r2
 2732 0006 01F00101 		and	r1, r1, #1
 2733 000a 4620     		movs	r0, #70
 2734              	.LVL136:
 205:../AeroQuad32/AeroQuad_STM32.h **** }
 2735              		.loc 14 205 0
 204:../AeroQuad32/AeroQuad_STM32.h ****   digitalWrite(LED_Green, (frameCounter/50) & 1);
 2736              		.loc 14 204 0
 2737 000c FFF7FEBF 		b	_Z12digitalWritehh
 2738              		.cfi_endproc
 2739              	.LFE160:
 2741              		.section	.text._Z22measureCriticalSensorsv,"ax",%progbits
 2742              		.align	1
 2743              		.global	_Z22measureCriticalSensorsv
 2744              		.thumb
 2745              		.thumb_func
 2747              	_Z22measureCriticalSensorsv:
 2748              	.LFB161:
 206:../AeroQuad32/AeroQuad_STM32.h **** 
 207:../AeroQuad32/AeroQuad_STM32.h **** unsigned long previousMeasureCriticalSensorsTime = 0;
 208:../AeroQuad32/AeroQuad_STM32.h **** void measureCriticalSensors() {
 2749              		.loc 14 208 0
 2750              		.cfi_startproc
 2751              		@ args = 0, pretend = 0, frame = 0
 2752              		@ frame_needed = 0, uses_anonymous_args = 0
 2753 0000 38B5     		push	{r3, r4, r5, lr}
 2754              	.LCFI30:
 2755              		.cfi_def_cfa_offset 16
 2756              		.cfi_offset 14, -4
 2757              		.cfi_offset 5, -8
 2758              		.cfi_offset 4, -12
 2759              		.cfi_offset 3, -16
 209:../AeroQuad32/AeroQuad_STM32.h ****   // read sensors not faster than every 1 ms
 210:../AeroQuad32/AeroQuad_STM32.h ****   if (currentTime - previousMeasureCriticalSensorsTime >= 1000) {
 2760              		.loc 14 210 0
 2761 0002 094D     		ldr	r5, .L168
 2762 0004 094C     		ldr	r4, .L168+4
 2763 0006 2A68     		ldr	r2, [r5, #0]
 2764 0008 2068     		ldr	r0, [r4, #0]
 2765 000a 131A     		subs	r3, r2, r0
 2766 000c B3F57A7F 		cmp	r3, #1000
 2767 0010 09D3     		bcc	.L166
 211:../AeroQuad32/AeroQuad_STM32.h ****     measureGyroSum();
 2768              		.loc 14 211 0
 2769 0012 FFF7FEFF 		bl	_Z14measureGyroSumv
 212:../AeroQuad32/AeroQuad_STM32.h ****     measureAccelSum();
 2770              		.loc 14 212 0
 2771 0016 FFF7FEFF 		bl	_Z15measureAccelSumv
 213:../AeroQuad32/AeroQuad_STM32.h **** 
 214:../AeroQuad32/AeroQuad_STM32.h ****     SignalAlive(frameCounter);
 2772              		.loc 14 214 0
 2773 001a 054B     		ldr	r3, .L168+8
 2774 001c 1868     		ldr	r0, [r3, #0]
 2775 001e FFF7FEFF 		bl	_Z11SignalAlivei
 215:../AeroQuad32/AeroQuad_STM32.h **** 
 216:../AeroQuad32/AeroQuad_STM32.h ****     previousMeasureCriticalSensorsTime = currentTime;
 2776              		.loc 14 216 0
 2777 0022 2968     		ldr	r1, [r5, #0]
 2778 0024 2160     		str	r1, [r4, #0]
 2779              	.L166:
 2780 0026 38BD     		pop	{r3, r4, r5, pc}
 2781              	.L169:
 2782              		.align	2
 2783              	.L168:
 2784 0028 00000000 		.word	.LANCHOR15
 2785 002c 00000000 		.word	.LANCHOR40
 2786 0030 00000000 		.word	.LANCHOR41
 2787              		.cfi_endproc
 2788              	.LFE161:
 2790              		.section	.text._Z29initializeBaseKinematicsParamv,"ax",%progbits
 2791              		.align	1
 2792              		.global	_Z29initializeBaseKinematicsParamv
 2793              		.thumb
 2794              		.thumb_func
 2796              	_Z29initializeBaseKinematicsParamv:
 2797              	.LFB162:
 2798              		.file 15 "../Libraries/AQ_Kinematics/Kinematics.h"
   1:../Libraries/AQ_Kinematics/Kinematics.h **** /*
   2:../Libraries/AQ_Kinematics/Kinematics.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Kinematics/Kinematics.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Kinematics/Kinematics.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Kinematics/Kinematics.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Kinematics/Kinematics.h ****  
   7:../Libraries/AQ_Kinematics/Kinematics.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Kinematics/Kinematics.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Kinematics/Kinematics.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Kinematics/Kinematics.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Kinematics/Kinematics.h **** 
  12:../Libraries/AQ_Kinematics/Kinematics.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Kinematics/Kinematics.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Kinematics/Kinematics.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Kinematics/Kinematics.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Kinematics/Kinematics.h **** 
  17:../Libraries/AQ_Kinematics/Kinematics.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Kinematics/Kinematics.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Kinematics/Kinematics.h **** */
  20:../Libraries/AQ_Kinematics/Kinematics.h **** 
  21:../Libraries/AQ_Kinematics/Kinematics.h **** #ifndef _AQ_KINEMATICS_
  22:../Libraries/AQ_Kinematics/Kinematics.h **** #define _AQ_KINEMATICS_
  23:../Libraries/AQ_Kinematics/Kinematics.h **** 
  24:../Libraries/AQ_Kinematics/Kinematics.h **** #include "GlobalDefined.h"
  25:../Libraries/AQ_Kinematics/Kinematics.h **** 
  26:../Libraries/AQ_Kinematics/Kinematics.h **** #define CF 0
  27:../Libraries/AQ_Kinematics/Kinematics.h **** #define KF 1
  28:../Libraries/AQ_Kinematics/Kinematics.h **** #define DCM 2
  29:../Libraries/AQ_Kinematics/Kinematics.h **** #define ARG 3
  30:../Libraries/AQ_Kinematics/Kinematics.h **** #define MARG 4
  31:../Libraries/AQ_Kinematics/Kinematics.h **** 
  32:../Libraries/AQ_Kinematics/Kinematics.h **** // This class is responsible for calculating vehicle attitude
  33:../Libraries/AQ_Kinematics/Kinematics.h **** byte kinematicsType = 0;
  34:../Libraries/AQ_Kinematics/Kinematics.h **** float kinematicsAngle[3] = {0.0,0.0,0.0};
  35:../Libraries/AQ_Kinematics/Kinematics.h **** float gyroAngle[2] = {0.0,0.0};
  36:../Libraries/AQ_Kinematics/Kinematics.h **** float correctedRateVector[3] = {0.0,0.0,0.0};
  37:../Libraries/AQ_Kinematics/Kinematics.h **** float earthAccel[3] = {0.0,0.0,0.0};
  38:../Libraries/AQ_Kinematics/Kinematics.h **** 
  39:../Libraries/AQ_Kinematics/Kinematics.h **** float accelCutoff = 0.0;
  40:../Libraries/AQ_Kinematics/Kinematics.h **** 
  41:../Libraries/AQ_Kinematics/Kinematics.h **** void initializeBaseKinematicsParam() {
 2799              		.loc 15 41 0
 2800              		.cfi_startproc
 2801              		@ args = 0, pretend = 0, frame = 0
 2802              		@ frame_needed = 0, uses_anonymous_args = 0
 2803              		@ link register save eliminated.
 2804              	.LVL137:
 2805              	.LBB69:
 2806              	.LBB70:
  42:../Libraries/AQ_Kinematics/Kinematics.h **** 
  43:../Libraries/AQ_Kinematics/Kinematics.h ****   for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
  44:../Libraries/AQ_Kinematics/Kinematics.h ****     kinematicsAngle[axis] = 0.0;
 2807              		.loc 15 44 0
 2808 0000 0448     		ldr	r0, .L171
 2809              	.LBE70:
  45:../Libraries/AQ_Kinematics/Kinematics.h ****   }
  46:../Libraries/AQ_Kinematics/Kinematics.h ****   gyroAngle[XAXIS] = 0;
 2810              		.loc 15 46 0
 2811 0002 054A     		ldr	r2, .L171+4
 2812              	.LBB71:
  44:../Libraries/AQ_Kinematics/Kinematics.h ****     kinematicsAngle[axis] = 0.0;
 2813              		.loc 15 44 0
 2814 0004 0023     		movs	r3, #0
 2815 0006 0360     		str	r3, [r0, #0]	@ float
 2816              	.LVL138:
 2817 0008 4360     		str	r3, [r0, #4]	@ float
 2818              	.LVL139:
 2819 000a 8360     		str	r3, [r0, #8]	@ float
 2820              	.LVL140:
 2821              	.LBE71:
 2822              		.loc 15 46 0
 2823 000c 1360     		str	r3, [r2, #0]	@ float
  47:../Libraries/AQ_Kinematics/Kinematics.h ****   gyroAngle[YAXIS] = 0;
 2824              		.loc 15 47 0
 2825 000e 5360     		str	r3, [r2, #4]	@ float
 2826              	.LBE69:
  48:../Libraries/AQ_Kinematics/Kinematics.h **** }
 2827              		.loc 15 48 0
 2828 0010 7047     		bx	lr
 2829              	.L172:
 2830 0012 00BF     		.align	2
 2831              	.L171:
 2832 0014 00000000 		.word	.LANCHOR42
 2833 0018 00000000 		.word	.LANCHOR43
 2834              		.cfi_endproc
 2835              	.LFE162:
 2837              		.section	.text._Z27kinematicsGetDegreesHeadingh,"ax",%progbits
 2838              		.align	1
 2839              		.global	_Z27kinematicsGetDegreesHeadingh
 2840              		.thumb
 2841              		.thumb_func
 2843              	_Z27kinematicsGetDegreesHeadingh:
 2844              	.LFB163:
  49:../Libraries/AQ_Kinematics/Kinematics.h **** 
  50:../Libraries/AQ_Kinematics/Kinematics.h **** void initializeKinematics(float hdgX, float hdgY);
  51:../Libraries/AQ_Kinematics/Kinematics.h **** void calculateKinematics(float rollRate,           float pitchRate,     float yawRate,       
  52:../Libraries/AQ_Kinematics/Kinematics.h ****                          float longitudinalAccel,  float lateralAccel,  float verticalAccel, 
  53:../Libraries/AQ_Kinematics/Kinematics.h ****                          float G_Dt);
  54:../Libraries/AQ_Kinematics/Kinematics.h **** float getGyroUnbias(byte axis);
  55:../Libraries/AQ_Kinematics/Kinematics.h **** void calibrateKinematics();
  56:../Libraries/AQ_Kinematics/Kinematics.h ****  
  57:../Libraries/AQ_Kinematics/Kinematics.h ****   // returns the kinematicsAngle of a specific axis in SI units (radians)
  58:../Libraries/AQ_Kinematics/Kinematics.h **** //  const float getData(byte axis) {
  59:../Libraries/AQ_Kinematics/Kinematics.h **** //    return kinematicsAngle[axis];
  60:../Libraries/AQ_Kinematics/Kinematics.h **** //  }
  61:../Libraries/AQ_Kinematics/Kinematics.h ****   // return heading as +PI/-PI
  62:../Libraries/AQ_Kinematics/Kinematics.h **** //  const float getHeading(byte axis) {
  63:../Libraries/AQ_Kinematics/Kinematics.h **** //    return(kinematicsAngle[axis]);
  64:../Libraries/AQ_Kinematics/Kinematics.h **** //  }
  65:../Libraries/AQ_Kinematics/Kinematics.h ****   
  66:../Libraries/AQ_Kinematics/Kinematics.h ****   // This really needs to be in Radians to be consistent
  67:../Libraries/AQ_Kinematics/Kinematics.h ****   // I'll fix later - AKA
  68:../Libraries/AQ_Kinematics/Kinematics.h ****   // returns heading in degrees as 0-360
  69:../Libraries/AQ_Kinematics/Kinematics.h **** const float kinematicsGetDegreesHeading(byte axis) {
 2845              		.loc 15 69 0
 2846              		.cfi_startproc
 2847              		@ args = 0, pretend = 0, frame = 0
 2848              		@ frame_needed = 0, uses_anonymous_args = 0
 2849              		@ link register save eliminated.
 2850              	.LVL141:
 2851              	.LBB72:
  70:../Libraries/AQ_Kinematics/Kinematics.h ****   float tDegrees;
  71:../Libraries/AQ_Kinematics/Kinematics.h ****     
  72:../Libraries/AQ_Kinematics/Kinematics.h ****   tDegrees = degrees(kinematicsAngle[axis]);
 2852              		.loc 15 72 0
 2853 0000 0A49     		ldr	r1, .L177
 2854 0002 01EB8003 		add	r3, r1, r0, lsl #2
 2855 0006 93ED007A 		flds	s14, [r3, #0]
 2856 000a DFED097A 		flds	s15, .L177+4
 2857 000e 67EE277A 		fmuls	s15, s14, s15
 2858              	.LVL142:
  73:../Libraries/AQ_Kinematics/Kinematics.h ****   if (tDegrees < 0.0)
 2859              		.loc 15 73 0
 2860 0012 F5EEC07A 		fcmpezs	s15
 2861 0016 F1EE10FA 		fmstat
  74:../Libraries/AQ_Kinematics/Kinematics.h ****     return (tDegrees + 360.0);
 2862              		.loc 15 74 0
 2863 001a 44BF     		itt	mi
 2864 001c 9FED057A 		fldsmi	s14, .L177+8
 2865 0020 77EE877A 		faddsmi	s15, s15, s14
 2866              	.LVL143:
 2867              	.LBE72:
  75:../Libraries/AQ_Kinematics/Kinematics.h ****   else
  76:../Libraries/AQ_Kinematics/Kinematics.h ****     return (tDegrees);
  77:../Libraries/AQ_Kinematics/Kinematics.h **** }
 2868              		.loc 15 77 0
 2869 0024 17EE900A 		fmrs	r0, s15
 2870              	.LVL144:
 2871 0028 7047     		bx	lr
 2872              	.L178:
 2873 002a 00BF     		.align	2
 2874              	.L177:
 2875 002c 00000000 		.word	.LANCHOR42
 2876 0030 E12E6542 		.word	1113927393
 2877 0034 0000B443 		.word	1135869952
 2878              		.cfi_endproc
 2879              	.LFE163:
 2881              		.global	__aeabi_f2d
 2882              		.global	__aeabi_d2f
 2883              		.section	.text._Z9argUpdatefffffff,"ax",%progbits
 2884              		.align	1
 2885              		.global	_Z9argUpdatefffffff
 2886              		.thumb
 2887              		.thumb_func
 2889              	_Z9argUpdatefffffff:
 2890              	.LFB164:
 2891              		.file 16 "../Libraries/AQ_Kinematics/Kinematics_ARG.h"
   1:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** /*
   2:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****  
   7:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  12:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  17:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** */
  20:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  21:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** #ifndef _AQ_KINEMATICS_ARG_
  22:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** #define _AQ_KINEMATICS_ARG_
  23:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  24:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //=================================================================================================
  25:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // IMU.c
  26:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // S.O.H. Madgwick
  27:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // 25th September 2010
  28:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //=================================================================================================
  29:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // Description:
  30:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //
  31:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // Quaternion implementation of the 'DCM filter' [Mayhony et al].
  32:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //
  33:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // User must define 'halfT' as the (sample period / 2), and the filter gains 'Kp' and 'Ki'.
  34:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //
  35:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // Global variables 'q0', 'q1', 'q2', 'q3' are the quaternion elements representing the estimated
  36:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // orientation.  See my report for an overview of the use of quaternions in this application.
  37:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //
  38:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // User must call 'IMUupdate()' every sample period and parse calibrated gyroscope ('gx', 'gy', 'gz
  39:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // and accelerometer ('ax', 'ay', 'ay') data.  Gyroscope units are radians/second, accelerometer 
  40:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // units are irrelevant as the vector is normalised.
  41:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //
  42:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //=================================================================================================
  43:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  44:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  45:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
  46:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // ARG - Accelerometer, Rate Gyro
  47:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
  48:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  49:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  50:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** #include "Kinematics.h"
  51:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  52:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** #include <AQMath.h>
  53:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  54:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float Kp = 0.0;                   					// proportional gain governs rate of convergence to accelero
  55:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float Ki = 0.0;                   					// integral gain governs rate of convergence of gyroscope bi
  56:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float halfT = 0.0;                					// half the sample period
  57:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float q0 = 0.0, q1 = 0.0, q2 = 0.0, q3 = 0.0;       // quaternion elements representing the estimat
  58:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float exInt = 0.0, eyInt = 0.0, ezInt = 0.0;  		// scaled integral error
  59:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
  60:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float previousEx = 0.0;
  61:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float previousEy = 0.0;
  62:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float previousEz = 0.0;
  63:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  64:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
  65:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // argUpdate
  66:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
  67:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void argUpdate(float gx, float gy, float gz, float ax, float ay, float az, float G_Dt) {
 2892              		.loc 16 67 0
 2893              		.cfi_startproc
 2894              		@ args = 12, pretend = 0, frame = 0
 2895              		@ frame_needed = 0, uses_anonymous_args = 0
 2896              	.LVL145:
 2897 0000 2DE9F84F 		push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2898              	.LCFI31:
 2899              		.cfi_def_cfa_offset 40
 2900              		.cfi_offset 14, -4
 2901              		.cfi_offset 11, -8
 2902              		.cfi_offset 10, -12
 2903              		.cfi_offset 9, -16
 2904              		.cfi_offset 8, -20
 2905              		.cfi_offset 7, -24
 2906              		.cfi_offset 6, -28
 2907              		.cfi_offset 5, -32
 2908              		.cfi_offset 4, -36
 2909              		.cfi_offset 3, -40
 2910 0004 2DED068B 		fstmfdd	sp!, {d8, d9, d10}
 2911              	.LCFI32:
 2912              		.cfi_def_cfa_offset 64
 2913              		.cfi_offset 84, -48
 2914              		.cfi_offset 82, -56
 2915              		.cfi_offset 80, -64
 2916              		.loc 16 67 0
 2917 0008 DDED108A 		flds	s17, [sp, #64]
 2918 000c 08EE103A 		fmsr	s16, r3
 2919              	.LBB73:
  68:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
  69:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   float norm;
  70:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   float vx, vy, vz;
  71:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   float q0i, q1i, q2i, q3i;
  72:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   float ex, ey, ez;
  73:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
  74:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   halfT = G_Dt/2;
  75:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
  76:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // normalise the measurements
  77:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(ax*ax + ay*ay + az*az);       
 2920              		.loc 16 77 0
 2921 0010 68EEA82A 		fmuls	s5, s17, s17
 2922 0014 48EE082A 		fmacs	s5, s16, s16
 2923              	.LBE73:
  67:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void argUpdate(float gx, float gy, float gz, float ax, float ay, float az, float G_Dt) {
 2924              		.loc 16 67 0
 2925 0018 9DED119A 		flds	s18, [sp, #68]
 2926              	.LBB74:
  74:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   halfT = G_Dt/2;
 2927              		.loc 16 74 0
 2928 001c DDED127A 		flds	s15, [sp, #72]
 2929              		.loc 16 77 0
 2930 0020 49EE092A 		fmacs	s5, s18, s18
  74:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   halfT = G_Dt/2;
 2931              		.loc 16 74 0
 2932 0024 B6EE003A 		fconsts	s6, #96
 2933 0028 27EE833A 		fmuls	s6, s15, s6
 2934 002c DFF83092 		ldr	r9, .L183+20
  78:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ax = ax / norm;
  79:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ay = ay / norm;
  80:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   az = az / norm;
  81:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****      	
  82:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // estimated direction of gravity and flux (v and w)
  83:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vx = 2*(q1*q3 - q0*q2);
 2935              		.loc 16 83 0
 2936 0030 864C     		ldr	r4, .L183
 2937 0032 874F     		ldr	r7, .L183+4
 2938 0034 874D     		ldr	r5, .L183+8
 2939 0036 884E     		ldr	r6, .L183+12
  84:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vy = 2*(q0*q1 + q2*q3);
  85:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vz = q0*q0 - q1*q1 - q2*q2 + q3*q3;
  86:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
  87:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // error is sum of cross product between reference direction of fields and direction measured by 
  88:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ex = (vy*az - vz*ay);
  89:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ey = (vz*ax - vx*az);
  90:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ez = (vx*ay - vy*ax);
  91:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
  92:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // integral error scaled integral gain
  93:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   exInt = exInt + ex*Ki;
 2940              		.loc 16 93 0
 2941 0038 DFF828A2 		ldr	sl, .L183+24
 2942 003c DFF828B2 		ldr	fp, .L183+28
  94:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   if (isSwitched(previousEx,ex)) {
 2943              		.loc 16 94 0
 2944 0040 DFF82882 		ldr	r8, .L183+32
  74:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   halfT = G_Dt/2;
 2945              		.loc 16 74 0
 2946 0044 89ED003A 		fsts	s6, [r9, #0]
 2947              	.LBE74:
  67:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void argUpdate(float gx, float gy, float gz, float ax, float ay, float az, float G_Dt) {
 2948              		.loc 16 67 0
 2949 0048 09EE900A 		fmsr	s19, r0
 2950              	.LBB75:
  77:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(ax*ax + ay*ay + az*az);       
 2951              		.loc 16 77 0
 2952 004c 12EE900A 		fmrs	r0, s5
 2953              	.LVL146:
 2954              	.LBE75:
  67:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void argUpdate(float gx, float gy, float gz, float ax, float ay, float az, float G_Dt) {
 2955              		.loc 16 67 0
 2956 0050 0AEE902A 		fmsr	s21, r2
 2957 0054 0AEE101A 		fmsr	s20, r1
 2958              	.LBB76:
  77:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(ax*ax + ay*ay + az*az);       
 2959              		.loc 16 77 0
 2960 0058 FFF7FEFF 		bl	__aeabi_f2d
 2961              	.LVL147:
 2962 005c FFF7FEFF 		bl	sqrt
 2963 0060 FFF7FEFF 		bl	__aeabi_d2f
 2964 0064 02EE100A 		fmsr	s4, r0
 2965              	.LVL148:
  79:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ay = ay / norm;
 2966              		.loc 16 79 0
 2967 0068 88EE825A 		fdivs	s10, s17, s4
 2968              		.loc 16 94 0
 2969 006c D8F80000 		ldr	r0, [r8, #0]	@ float
 2970              	.LVL149:
  80:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   az = az / norm;
 2971              		.loc 16 80 0
 2972 0070 C9EE023A 		fdivs	s7, s18, s4
  83:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vx = 2*(q1*q3 - q0*q2);
 2973              		.loc 16 83 0
 2974 0074 D4ED000A 		flds	s1, [r4, #0]
 2975 0078 97ED006A 		flds	s12, [r7, #0]
 2976 007c D5ED006A 		flds	s13, [r5, #0]
 2977 0080 96ED000A 		flds	s0, [r6, #0]
 2978 0084 66EE261A 		fmuls	s3, s12, s13
  84:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vy = 2*(q0*q1 + q2*q3);
 2979              		.loc 16 84 0
 2980 0088 26EEA01A 		fmuls	s2, s13, s1
  83:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vx = 2*(q1*q3 - q0*q2);
 2981              		.loc 16 83 0
 2982 008c 50EE201A 		fmscs	s3, s0, s1
  84:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vy = 2*(q0*q1 + q2*q3);
 2983              		.loc 16 84 0
 2984 0090 06EE001A 		fmacs	s2, s12, s0
  85:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vz = q0*q0 - q1*q1 - q2*q2 + q3*q3;
 2985              		.loc 16 85 0
 2986 0094 20EE000A 		fmuls	s0, s0, s0
 2987 0098 16EE060A 		fmscs	s0, s12, s12
  78:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ax = ax / norm;
 2988              		.loc 16 78 0
 2989 009c 88EE024A 		fdivs	s8, s16, s4
 2990              	.LVL150:
  85:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vz = q0*q0 - q1*q1 - q2*q2 + q3*q3;
 2991              		.loc 16 85 0
 2992 00a0 06EEE60A 		fnmacs	s0, s13, s13
 2993 00a4 00EEA00A 		fmacs	s0, s1, s1
  84:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vy = 2*(q0*q1 + q2*q3);
 2994              		.loc 16 84 0
 2995 00a8 71EE015A 		fadds	s11, s2, s2
  88:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ex = (vy*az - vz*ay);
 2996              		.loc 16 88 0
 2997 00ac 20EE058A 		fmuls	s16, s0, s10
 2998 00b0 15EEA38A 		fmscs	s16, s11, s7
  93:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   exInt = exInt + ex*Ki;
 2999              		.loc 16 93 0
 3000 00b4 DAED007A 		flds	s15, [sl, #0]
 3001 00b8 9BED007A 		flds	s14, [fp, #0]
 3002 00bc 48EE077A 		fmacs	s15, s16, s14
  83:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vx = 2*(q1*q3 - q0*q2);
 3003              		.loc 16 83 0
 3004 00c0 71EEA14A 		fadds	s9, s3, s3
 3005              	.LVL151:
  90:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ez = (vx*ay - vy*ax);
 3006              		.loc 16 90 0
 3007 00c4 25EE849A 		fmuls	s18, s11, s8
  89:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ey = (vz*ax - vx*az);
 3008              		.loc 16 89 0
 3009 00c8 64EEA38A 		fmuls	s17, s9, s7
 3010              		.loc 16 94 0
 3011 00cc 18EE101A 		fmrs	r1, s16
  89:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ey = (vz*ax - vx*az);
 3012              		.loc 16 89 0
 3013 00d0 50EE048A 		fmscs	s17, s0, s8
 3014              	.LVL152:
  90:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ez = (vx*ay - vy*ax);
 3015              		.loc 16 90 0
 3016 00d4 14EE859A 		fmscs	s18, s9, s10
 3017              	.LVL153:
  93:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   exInt = exInt + ex*Ki;
 3018              		.loc 16 93 0
 3019 00d8 CAED007A 		fsts	s15, [sl, #0]
 3020              		.loc 16 94 0
 3021 00dc FFF7FEFF 		bl	_Z10isSwitchedff
 3022              	.LVL154:
 3023 00e0 4346     		mov	r3, r8
 3024 00e2 10B1     		cbz	r0, .L180
  95:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     exInt = 0.0;
 3025              		.loc 16 95 0
 3026 00e4 0022     		movs	r2, #0
 3027 00e6 CAF80020 		str	r2, [sl, #0]	@ float
 3028              	.L180:
  96:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   }
  97:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEx = ex;
  98:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 	
  99:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eyInt = eyInt + ey*Ki;
 3029              		.loc 16 99 0
 3030 00ea DFF88491 		ldr	r9, .L183+36
 100:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   if (isSwitched(previousEy,ey)) {
 3031              		.loc 16 100 0
 3032 00ee DFF88481 		ldr	r8, .L183+40
  99:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eyInt = eyInt + ey*Ki;
 3033              		.loc 16 99 0
 3034 00f2 D9ED004A 		flds	s9, [r9, #0]
 3035 00f6 9BED007A 		flds	s14, [fp, #0]
 3036 00fa 48EE874A 		fmacs	s9, s17, s14
  97:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEx = ex;
 3037              		.loc 16 97 0
 3038 00fe 83ED008A 		fsts	s16, [r3, #0]
  99:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eyInt = eyInt + ey*Ki;
 3039              		.loc 16 99 0
 3040 0102 C9ED004A 		fsts	s9, [r9, #0]
 3041              		.loc 16 100 0
 3042 0106 D8F80000 		ldr	r0, [r8, #0]	@ float
 3043 010a 18EE901A 		fmrs	r1, s17
 3044 010e FFF7FEFF 		bl	_Z10isSwitchedff
 3045 0112 4346     		mov	r3, r8
 3046 0114 10B1     		cbz	r0, .L181
 101:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     eyInt = 0.0;
 3047              		.loc 16 101 0
 3048 0116 0020     		movs	r0, #0
 3049 0118 C9F80000 		str	r0, [r9, #0]	@ float
 3050              	.L181:
 102:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   }
 103:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEy = ey;
 104:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
 105:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ezInt = ezInt + ez*Ki;
 3051              		.loc 16 105 0
 3052 011c DFF85881 		ldr	r8, .L183+44
 3053 0120 9BED004A 		flds	s8, [fp, #0]
 3054 0124 98ED005A 		flds	s10, [r8, #0]
 3055 0128 09EE045A 		fmacs	s10, s18, s8
 106:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   if (isSwitched(previousEz,ez)) {
 3056              		.loc 16 106 0
 3057 012c DFF84CB1 		ldr	fp, .L183+48
 103:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEy = ey;
 3058              		.loc 16 103 0
 3059 0130 C3ED008A 		fsts	s17, [r3, #0]
 105:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ezInt = ezInt + ez*Ki;
 3060              		.loc 16 105 0
 3061 0134 88ED005A 		fsts	s10, [r8, #0]
 3062              		.loc 16 106 0
 3063 0138 DBF80000 		ldr	r0, [fp, #0]	@ float
 3064 013c 19EE101A 		fmrs	r1, s18
 3065 0140 FFF7FEFF 		bl	_Z10isSwitchedff
 3066 0144 4346     		mov	r3, r8
 3067 0146 5A46     		mov	r2, fp
 3068 0148 08B1     		cbz	r0, .L182
 107:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     ezInt = 0.0;
 3069              		.loc 16 107 0
 3070 014a 0021     		movs	r1, #0
 3071 014c 1960     		str	r1, [r3, #0]	@ float
 3072              	.L182:
 108:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   }
 109:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEz = ez;
 3073              		.loc 16 109 0
 3074 014e 82ED009A 		fsts	s18, [r2, #0]
 110:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 	
 111:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // adjusted gyroscope measurements
 112:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gx = gx + Kp*ex + exInt;
 3075              		.loc 16 112 0
 3076 0152 424A     		ldr	r2, .L183+16
 3077 0154 D2ED000A 		flds	s1, [r2, #0]
 113:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gy = gy + Kp*ey + eyInt;
 114:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gz = gz + Kp*ez + ezInt;
 3078              		.loc 16 114 0
 3079 0158 40EE89AA 		fmacs	s21, s1, s18
 3080              	.LVL155:
 112:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gx = gx + Kp*ex + exInt;
 3081              		.loc 16 112 0
 3082 015c 40EE889A 		fmacs	s19, s1, s16
 3083              	.LVL156:
 113:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gy = gy + Kp*ey + eyInt;
 3084              		.loc 16 113 0
 3085 0160 00EEA8AA 		fmacs	s20, s1, s17
 3086              	.LVL157:
 3087              		.loc 16 114 0
 3088 0164 D3ED003A 		flds	s7, [r3, #0]
 113:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gy = gy + Kp*ey + eyInt;
 3089              		.loc 16 113 0
 3090 0168 D9ED006A 		flds	s13, [r9, #0]
 112:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gx = gx + Kp*ex + exInt;
 3091              		.loc 16 112 0
 3092 016c 9AED006A 		flds	s12, [sl, #0]
 3093              		.loc 16 114 0
 3094 0170 7AEEA3AA 		fadds	s21, s21, s7
 115:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
 116:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // integrate quaternion rate and normalise
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 3095              		.loc 16 117 0
 3096 0174 D5ED004A 		flds	s9, [r5, #0]
 113:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gy = gy + Kp*ey + eyInt;
 3097              		.loc 16 113 0
 3098 0178 3AEE26AA 		fadds	s20, s20, s13
 118:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1i = ( q0*gx + q2*gz - q3*gy) * halfT;
 3099              		.loc 16 118 0
 3100 017c 97ED007A 		flds	s14, [r7, #0]
 112:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gx = gx + Kp*ex + exInt;
 3101              		.loc 16 112 0
 3102 0180 79EE869A 		fadds	s19, s19, s12
 3103              	.LVL158:
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 3104              		.loc 16 117 0
 3105 0184 96ED005A 		flds	s10, [r6, #0]
 3106              		.loc 16 118 0
 3107 0188 64EEAA5A 		fmuls	s11, s9, s21
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 3108              		.loc 16 117 0
 3109 018c 24EE8A0A 		fmuls	s0, s9, s20
 3110              		.loc 16 118 0
 3111 0190 47EE295A 		fmacs	s11, s14, s19
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 3112              		.loc 16 117 0
 3113 0194 94ED001A 		flds	s2, [r4, #0]
 3114 0198 15EE690A 		fnmscs	s0, s10, s19
 3115              		.loc 16 118 0
 3116 019c 41EE4A5A 		fnmacs	s11, s2, s20
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 3117              		.loc 16 117 0
 3118 01a0 2F4B     		ldr	r3, .L183+20
 119:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2i = ( q0*gy - q1*gz + q3*gx) * halfT;
 3119              		.loc 16 119 0
 3120 01a2 25EE2A4A 		fmuls	s8, s10, s21
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 3121              		.loc 16 117 0
 3122 01a6 01EE6A0A 		fnmacs	s0, s2, s21
 3123              		.loc 16 119 0
 3124 01aa 17EE0A4A 		fmscs	s8, s14, s20
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 3125              		.loc 16 117 0
 3126 01ae 93ED003A 		flds	s6, [r3, #0]
 3127              	.LVL159:
 120:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3i = ( q0*gz + q1*gy - q2*gx) * halfT;
 121:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 += q0i;
 122:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 += q1i;
 3128              		.loc 16 122 0
 3129 01b2 F0EE452A 		fcpys	s5, s10
 120:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3i = ( q0*gz + q1*gy - q2*gx) * halfT;
 3130              		.loc 16 120 0
 3131 01b6 65EE0A7A 		fmuls	s15, s10, s20
 3132              		.loc 16 122 0
 3133 01ba 45EE832A 		fmacs	s5, s11, s6
 119:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2i = ( q0*gy - q1*gz + q3*gx) * halfT;
 3134              		.loc 16 119 0
 3135 01be 01EE294A 		fmacs	s8, s2, s19
 121:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 += q0i;
 3136              		.loc 16 121 0
 3137 01c2 B0EE472A 		fcpys	s4, s14
 120:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3i = ( q0*gz + q1*gy - q2*gx) * halfT;
 3138              		.loc 16 120 0
 3139 01c6 47EE2A7A 		fmacs	s15, s14, s21
 121:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 += q0i;
 3140              		.loc 16 121 0
 3141 01ca 00EE032A 		fmacs	s4, s0, s6
 123:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 += q2i;
 3142              		.loc 16 123 0
 3143 01ce F0EE641A 		fcpys	s3, s9
 120:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3i = ( q0*gz + q1*gy - q2*gx) * halfT;
 3144              		.loc 16 120 0
 3145 01d2 44EEE97A 		fnmacs	s15, s9, s19
 3146              		.loc 16 123 0
 3147 01d6 44EE031A 		fmacs	s3, s8, s6
 124:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3 += q3i;
 125:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
 126:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // normalise quaternion
 127:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(q0*q0 + q1*q1 + q2*q2 + q3*q3);
 3148              		.loc 16 127 0
 3149 01da 22EEA26A 		fmuls	s12, s5, s5
 3150 01de 02EE026A 		fmacs	s12, s4, s4
 124:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3 += q3i;
 3151              		.loc 16 124 0
 3152 01e2 07EE831A 		fmacs	s2, s15, s6
 3153              		.loc 16 127 0
 3154 01e6 01EEA16A 		fmacs	s12, s3, s3
 3155 01ea 01EE016A 		fmacs	s12, s2, s2
 121:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 += q0i;
 3156              		.loc 16 121 0
 3157 01ee 87ED002A 		fsts	s4, [r7, #0]
 3158              		.loc 16 127 0
 3159 01f2 16EE100A 		fmrs	r0, s12
 122:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 += q1i;
 3160              		.loc 16 122 0
 3161 01f6 C6ED002A 		fsts	s5, [r6, #0]
 123:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 += q2i;
 3162              		.loc 16 123 0
 3163 01fa C5ED001A 		fsts	s3, [r5, #0]
 124:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3 += q3i;
 3164              		.loc 16 124 0
 3165 01fe 84ED001A 		fsts	s2, [r4, #0]
 3166              		.loc 16 127 0
 3167 0202 FFF7FEFF 		bl	__aeabi_f2d
 3168              	.LVL160:
 3169 0206 FFF7FEFF 		bl	sqrt
 3170 020a FFF7FEFF 		bl	__aeabi_d2f
 128:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 = q0 / norm;
 3171              		.loc 16 128 0
 3172 020e D7ED006A 		flds	s13, [r7, #0]
 127:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(q0*q0 + q1*q1 + q2*q2 + q3*q3);
 3173              		.loc 16 127 0
 3174 0212 05EE900A 		fmsr	s11, r0
 3175              	.LVL161:
 129:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 = q1 / norm;
 3176              		.loc 16 129 0
 3177 0216 D6ED000A 		flds	s1, [r6, #0]
 130:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 = q2 / norm;
 3178              		.loc 16 130 0
 3179 021a D5ED003A 		flds	s7, [r5, #0]
 131:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3 = q3 / norm;
 3180              		.loc 16 131 0
 3181 021e 94ED000A 		flds	s0, [r4, #0]
 128:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 = q0 / norm;
 3182              		.loc 16 128 0
 3183 0222 C6EEA56A 		fdivs	s13, s13, s11
 129:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 = q1 / norm;
 3184              		.loc 16 129 0
 3185 0226 C0EEA50A 		fdivs	s1, s1, s11
 130:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 = q2 / norm;
 3186              		.loc 16 130 0
 3187 022a C3EEA53A 		fdivs	s7, s7, s11
 3188              		.loc 16 131 0
 3189 022e C0EE255A 		fdivs	s11, s0, s11
 128:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 = q0 / norm;
 3190              		.loc 16 128 0
 3191 0232 C7ED006A 		fsts	s13, [r7, #0]
 129:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 = q1 / norm;
 3192              		.loc 16 129 0
 3193 0236 C6ED000A 		fsts	s1, [r6, #0]
 130:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 = q2 / norm;
 3194              		.loc 16 130 0
 3195 023a C5ED003A 		fsts	s7, [r5, #0]
 3196              		.loc 16 131 0
 3197 023e C4ED005A 		fsts	s11, [r4, #0]
 3198              	.LBE76:
 132:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** }
 3199              		.loc 16 132 0
 3200 0242 BDEC068B 		fldmfdd	sp!, {d8, d9, d10}
 3201 0246 BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3202              	.L184:
 3203 024a 00BF     		.align	2
 3204              	.L183:
 3205 024c 00000000 		.word	.LANCHOR46
 3206 0250 00000000 		.word	.LANCHOR47
 3207 0254 00000000 		.word	.LANCHOR48
 3208 0258 00000000 		.word	.LANCHOR45
 3209 025c 00000000 		.word	.LANCHOR56
 3210 0260 00000000 		.word	.LANCHOR44
 3211 0264 00000000 		.word	.LANCHOR49
 3212 0268 00000000 		.word	.LANCHOR50
 3213 026c 00000000 		.word	.LANCHOR51
 3214 0270 00000000 		.word	.LANCHOR52
 3215 0274 00000000 		.word	.LANCHOR53
 3216 0278 00000000 		.word	.LANCHOR54
 3217 027c 00000000 		.word	.LANCHOR55
 3218              		.cfi_endproc
 3219              	.LFE164:
 3221              		.section	.text._Z11eulerAnglesv,"ax",%progbits
 3222              		.align	1
 3223              		.global	_Z11eulerAnglesv
 3224              		.thumb
 3225              		.thumb_func
 3227              	_Z11eulerAnglesv:
 3228              	.LFB165:
 133:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
 134:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void eulerAngles()
 135:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** {
 3229              		.loc 16 135 0
 3230              		.cfi_startproc
 3231              		@ args = 0, pretend = 0, frame = 0
 3232              		@ frame_needed = 0, uses_anonymous_args = 0
 3233 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 3234              	.LCFI33:
 3235              		.cfi_def_cfa_offset 32
 3236              		.cfi_offset 14, -4
 3237              		.cfi_offset 9, -8
 3238              		.cfi_offset 8, -12
 3239              		.cfi_offset 7, -16
 3240              		.cfi_offset 6, -20
 3241              		.cfi_offset 5, -24
 3242              		.cfi_offset 4, -28
 3243              		.cfi_offset 3, -32
 136:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[XAXIS]  = atan2(2 * (q0*q1 + q2*q3), 1 - 2 *(q1*q1 + q2*q2));
 3244              		.loc 16 136 0
 3245 0004 3C4C     		ldr	r4, .L186
 3246 0006 3D4E     		ldr	r6, .L186+4
 3247 0008 3D4D     		ldr	r5, .L186+8
 3248 000a 3E4F     		ldr	r7, .L186+12
 135:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** {
 3249              		.loc 16 135 0
 3250 000c 2DED048B 		fstmfdd	sp!, {d8, d9}
 3251              	.LCFI34:
 3252              		.cfi_def_cfa_offset 48
 3253              		.cfi_offset 82, -40
 3254              		.cfi_offset 80, -48
 3255              		.loc 16 136 0
 3256 0010 D4ED005A 		flds	s11, [r4, #0]
 3257 0014 96ED008A 		flds	s16, [r6, #0]
 3258 0018 D5ED007A 		flds	s15, [r5, #0]
 3259 001c D7ED008A 		flds	s17, [r7, #0]
 3260 0020 68EE255A 		fmuls	s11, s16, s11
 3261 0024 48EEA75A 		fmacs	s11, s17, s15
 3262 0028 B7EE009A 		fconsts	s18, #112
 3263 002c 35EEA55A 		fadds	s10, s11, s11
 3264 0030 15EE100A 		fmrs	r0, s10
 3265 0034 FFF7FEFF 		bl	__aeabi_f2d
 3266 0038 68EE084A 		fmuls	s9, s16, s16
 3267 003c 48EEA84A 		fmacs	s9, s17, s17
 3268 0040 8046     		mov	r8, r0
 3269 0042 34EEA44A 		fadds	s8, s9, s9
 3270 0046 8946     		mov	r9, r1
 3271 0048 79EE443A 		fsubs	s7, s18, s8
 3272 004c 13EE900A 		fmrs	r0, s7
 3273 0050 FFF7FEFF 		bl	__aeabi_f2d
 3274 0054 0246     		mov	r2, r0
 3275 0056 0B46     		mov	r3, r1
 3276 0058 4046     		mov	r0, r8
 3277 005a 4946     		mov	r1, r9
 3278 005c FFF7FEFF 		bl	atan2
 3279 0060 FFF7FEFF 		bl	__aeabi_d2f
 137:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[YAXIS] = asin(2 * (q0*q2 - q1*q3));
 3280              		.loc 16 137 0
 3281 0064 97ED006A 		flds	s12, [r7, #0]
 3282 0068 D4ED002A 		flds	s5, [r4, #0]
 3283 006c D5ED006A 		flds	s13, [r5, #0]
 3284 0070 96ED003A 		flds	s6, [r6, #0]
 3285 0074 66EE222A 		fmuls	s5, s12, s5
 3286 0078 56EE832A 		fmscs	s5, s13, s6
 136:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[XAXIS]  = atan2(2 * (q0*q1 + q2*q3), 1 - 2 *(q1*q1 + q2*q2));
 3287              		.loc 16 136 0
 3288 007c DFF88880 		ldr	r8, .L186+16
 3289              		.loc 16 137 0
 3290 0080 32EEA22A 		fadds	s4, s5, s5
 136:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[XAXIS]  = atan2(2 * (q0*q1 + q2*q3), 1 - 2 *(q1*q1 + q2*q2));
 3291              		.loc 16 136 0
 3292 0084 C8F80000 		str	r0, [r8, #0]	@ float
 3293              		.loc 16 137 0
 3294 0088 12EE100A 		fmrs	r0, s4
 3295 008c FFF7FEFF 		bl	__aeabi_f2d
 3296 0090 FFF7FEFF 		bl	asin
 3297 0094 FFF7FEFF 		bl	__aeabi_d2f
 138:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[ZAXIS]   = atan2(2 * (q0*q3 + q1*q2), 1 - 2 *(q2*q2 + q3*q3));
 3298              		.loc 16 138 0
 3299 0098 D6ED008A 		flds	s17, [r6, #0]
 3300 009c D7ED001A 		flds	s3, [r7, #0]
 3301 00a0 95ED007A 		flds	s14, [r5, #0]
 3302 00a4 94ED008A 		flds	s16, [r4, #0]
 3303 00a8 68EEA11A 		fmuls	s3, s17, s3
 3304 00ac 48EE071A 		fmacs	s3, s16, s14
 137:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[YAXIS] = asin(2 * (q0*q2 - q1*q3));
 3305              		.loc 16 137 0
 3306 00b0 C8F80400 		str	r0, [r8, #4]	@ float
 3307              		.loc 16 138 0
 3308 00b4 31EEA11A 		fadds	s2, s3, s3
 3309 00b8 11EE100A 		fmrs	r0, s2
 3310 00bc FFF7FEFF 		bl	__aeabi_f2d
 3311 00c0 68EE080A 		fmuls	s1, s16, s16
 3312 00c4 48EEA80A 		fmacs	s1, s17, s17
 3313 00c8 0446     		mov	r4, r0
 3314 00ca 30EEA00A 		fadds	s0, s1, s1
 3315 00ce 0D46     		mov	r5, r1
 3316 00d0 79EE407A 		fsubs	s15, s18, s0
 3317 00d4 17EE900A 		fmrs	r0, s15
 3318 00d8 FFF7FEFF 		bl	__aeabi_f2d
 3319 00dc 0246     		mov	r2, r0
 3320 00de 0B46     		mov	r3, r1
 3321 00e0 2046     		mov	r0, r4
 3322 00e2 2946     		mov	r1, r5
 3323 00e4 FFF7FEFF 		bl	atan2
 3324 00e8 FFF7FEFF 		bl	__aeabi_d2f
 3325 00ec C8F80800 		str	r0, [r8, #8]	@ float
 139:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** }
 3326              		.loc 16 139 0
 3327 00f0 BDEC048B 		fldmfdd	sp!, {d8, d9}
 3328 00f4 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 3329              	.L187:
 3330              		.align	2
 3331              	.L186:
 3332 00f8 00000000 		.word	.LANCHOR46
 3333 00fc 00000000 		.word	.LANCHOR48
 3334 0100 00000000 		.word	.LANCHOR47
 3335 0104 00000000 		.word	.LANCHOR45
 3336 0108 00000000 		.word	.LANCHOR42
 3337              		.cfi_endproc
 3338              	.LFE165:
 3340              		.section	.text._Z20initializeKinematicsv,"ax",%progbits
 3341              		.align	1
 3342              		.global	_Z20initializeKinematicsv
 3343              		.thumb
 3344              		.thumb_func
 3346              	_Z20initializeKinematicsv:
 3347              	.LFB166:
 140:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
 141:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
 142:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // Initialize ARG
 143:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
 144:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
 145:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void initializeKinematics() 
 146:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** {
 3348              		.loc 16 146 0
 3349              		.cfi_startproc
 3350              		@ args = 0, pretend = 0, frame = 0
 3351              		@ frame_needed = 0, uses_anonymous_args = 0
 3352 0000 08B5     		push	{r3, lr}
 3353              	.LCFI35:
 3354              		.cfi_def_cfa_offset 8
 3355              		.cfi_offset 14, -4
 3356              		.cfi_offset 3, -8
 147:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   initializeBaseKinematicsParam();
 3357              		.loc 16 147 0
 3358 0002 FFF7FEFF 		bl	_Z29initializeBaseKinematicsParamv
 148:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 = 1.0;
 3359              		.loc 16 148 0
 3360 0006 0F4B     		ldr	r3, .L189
 149:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 = 0.0;
 3361              		.loc 16 149 0
 3362 0008 0F49     		ldr	r1, .L189+4
 150:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 = 0.0;
 3363              		.loc 16 150 0
 3364 000a 1048     		ldr	r0, .L189+8
 151:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3 = 0.0;
 3365              		.loc 16 151 0
 3366 000c 104A     		ldr	r2, .L189+12
 148:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 = 1.0;
 3367              		.loc 16 148 0
 3368 000e 4FF07E5C 		mov	ip, #1065353216
 3369 0012 C3F800C0 		str	ip, [r3, #0]	@ float
 149:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 = 0.0;
 3370              		.loc 16 149 0
 3371 0016 0023     		movs	r3, #0
 3372 0018 0B60     		str	r3, [r1, #0]	@ float
 150:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 = 0.0;
 3373              		.loc 16 150 0
 3374 001a 0360     		str	r3, [r0, #0]	@ float
 3375              		.loc 16 151 0
 3376 001c 1360     		str	r3, [r2, #0]	@ float
 152:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   exInt = 0.0;
 3377              		.loc 16 152 0
 3378 001e 0D49     		ldr	r1, .L189+16
 153:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eyInt = 0.0;
 3379              		.loc 16 153 0
 3380 0020 0D48     		ldr	r0, .L189+20
 154:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ezInt = 0.0;
 3381              		.loc 16 154 0
 3382 0022 0E4A     		ldr	r2, .L189+24
 152:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   exInt = 0.0;
 3383              		.loc 16 152 0
 3384 0024 0B60     		str	r3, [r1, #0]	@ float
 153:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eyInt = 0.0;
 3385              		.loc 16 153 0
 3386 0026 0360     		str	r3, [r0, #0]	@ float
 3387              		.loc 16 154 0
 3388 0028 1360     		str	r3, [r2, #0]	@ float
 155:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 	
 156:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEx = 0;
 3389              		.loc 16 156 0
 3390 002a 0D49     		ldr	r1, .L189+28
 157:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEy = 0;
 3391              		.loc 16 157 0
 3392 002c 0D48     		ldr	r0, .L189+32
 158:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEz = 0;
 3393              		.loc 16 158 0
 3394 002e 0E4A     		ldr	r2, .L189+36
 156:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEx = 0;
 3395              		.loc 16 156 0
 3396 0030 0B60     		str	r3, [r1, #0]	@ float
 157:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEy = 0;
 3397              		.loc 16 157 0
 3398 0032 0360     		str	r3, [r0, #0]	@ float
 3399              		.loc 16 158 0
 3400 0034 1360     		str	r3, [r2, #0]	@ float
 159:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
 160:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   Kp = 0.2; // 2.0;
 3401              		.loc 16 160 0
 3402 0036 0D48     		ldr	r0, .L189+40
 3403 0038 0D49     		ldr	r1, .L189+44
 161:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   Ki = 0.0005; //0.005;
 3404              		.loc 16 161 0
 3405 003a 0E4A     		ldr	r2, .L189+48
 3406 003c 0E4B     		ldr	r3, .L189+52
 160:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   Kp = 0.2; // 2.0;
 3407              		.loc 16 160 0
 3408 003e 0860     		str	r0, [r1, #0]	@ float
 3409              		.loc 16 161 0
 3410 0040 1A60     		str	r2, [r3, #0]	@ float
 162:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** }
 3411              		.loc 16 162 0
 3412 0042 08BD     		pop	{r3, pc}
 3413              	.L190:
 3414              		.align	2
 3415              	.L189:
 3416 0044 00000000 		.word	.LANCHOR47
 3417 0048 00000000 		.word	.LANCHOR45
 3418 004c 00000000 		.word	.LANCHOR48
 3419 0050 00000000 		.word	.LANCHOR46
 3420 0054 00000000 		.word	.LANCHOR49
 3421 0058 00000000 		.word	.LANCHOR52
 3422 005c 00000000 		.word	.LANCHOR54
 3423 0060 00000000 		.word	.LANCHOR51
 3424 0064 00000000 		.word	.LANCHOR53
 3425 0068 00000000 		.word	.LANCHOR55
 3426 006c CDCC4C3E 		.word	1045220557
 3427 0070 00000000 		.word	.LANCHOR56
 3428 0074 6F12033A 		.word	973279855
 3429 0078 00000000 		.word	.LANCHOR50
 3430              		.cfi_endproc
 3431              	.LFE166:
 3433              		.section	.text._Z19calculateKinematicsfffffff,"ax",%progbits
 3434              		.align	1
 3435              		.global	_Z19calculateKinematicsfffffff
 3436              		.thumb
 3437              		.thumb_func
 3439              	_Z19calculateKinematicsfffffff:
 3440              	.LFB167:
 163:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
 164:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
 165:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // Calculate ARG
 166:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
 167:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void calculateKinematics(float rollRate,          float pitchRate,    float yawRate,  
 168:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****                          float longitudinalAccel, float lateralAccel, float verticalAccel, 
 169:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****                          float G_DT) {
 3441              		.loc 16 169 0
 3442              		.cfi_startproc
 3443              		@ args = 12, pretend = 0, frame = 0
 3444              		@ frame_needed = 0, uses_anonymous_args = 0
 3445              	.LVL162:
 3446 0000 1FB5     		push	{r0, r1, r2, r3, r4, lr}
 3447              	.LCFI36:
 3448              		.cfi_def_cfa_offset 24
 3449              		.cfi_offset 14, -4
 3450              		.cfi_offset 4, -8
 3451              		.cfi_offset 3, -12
 3452              		.cfi_offset 2, -16
 3453              		.cfi_offset 1, -20
 3454              		.cfi_offset 0, -24
 170:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
 171:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   argUpdate(rollRate,          pitchRate,    yawRate, 
 172:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****             longitudinalAccel, lateralAccel, verticalAccel,  
 173:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 		    G_Dt);
 3455              		.loc 16 173 0
 3456 0002 DDF818E0 		ldr	lr, [sp, #24]	@ float
 3457 0006 DDF81CC0 		ldr	ip, [sp, #28]	@ float
 3458 000a 074C     		ldr	r4, .L192
 3459 000c CDF800E0 		str	lr, [sp, #0]	@ float
 3460 0010 CDF804C0 		str	ip, [sp, #4]	@ float
 3461 0014 2468     		ldr	r4, [r4, #0]	@ float
 3462 0016 0294     		str	r4, [sp, #8]	@ float
 3463 0018 FFF7FEFF 		bl	_Z9argUpdatefffffff
 3464              	.LVL163:
 174:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eulerAngles();
 175:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** }
 3465              		.loc 16 175 0
 3466 001c 04B0     		add	sp, sp, #16
 3467 001e BDE81040 		pop	{r4, lr}
 174:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eulerAngles();
 3468              		.loc 16 174 0
 3469 0022 FFF7FEBF 		b	_Z11eulerAnglesv
 3470              	.L193:
 3471 0026 00BF     		.align	2
 3472              	.L192:
 3473 0028 00000000 		.word	.LANCHOR57
 3474              		.cfi_endproc
 3475              	.LFE167:
 3477              		.section	.text._Z13getGyroUnbiash,"ax",%progbits
 3478              		.align	1
 3479              		.global	_Z13getGyroUnbiash
 3480              		.thumb
 3481              		.thumb_func
 3483              	_Z13getGyroUnbiash:
 3484              	.LFB168:
 176:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
 177:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float getGyroUnbias(byte axis) {
 3485              		.loc 16 177 0
 3486              		.cfi_startproc
 3487              		@ args = 0, pretend = 0, frame = 0
 3488              		@ frame_needed = 0, uses_anonymous_args = 0
 3489              		@ link register save eliminated.
 3490              	.LVL164:
 178:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   return correctedRateVector[axis];
 3491              		.loc 16 178 0
 3492 0000 0249     		ldr	r1, .L195
 3493 0002 01EB8003 		add	r3, r1, r0, lsl #2
 179:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** }
 3494              		.loc 16 179 0
 3495 0006 1868     		ldr	r0, [r3, #0]	@ float
 3496              	.LVL165:
 3497 0008 7047     		bx	lr
 3498              	.L196:
 3499 000a 00BF     		.align	2
 3500              	.L195:
 3501 000c 00000000 		.word	.LANCHOR58
 3502              		.cfi_endproc
 3503              	.LFE168:
 3505              		.section	.text._Z19calibrateKinematicsv,"ax",%progbits
 3506              		.align	1
 3507              		.global	_Z19calibrateKinematicsv
 3508              		.thumb
 3509              		.thumb_func
 3511              	_Z19calibrateKinematicsv:
 3512              	.LFB169:
 180:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
 181:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void calibrateKinematics() {}
 3513              		.loc 16 181 0
 3514              		.cfi_startproc
 3515              		@ args = 0, pretend = 0, frame = 0
 3516              		@ frame_needed = 0, uses_anonymous_args = 0
 3517              		@ link register save eliminated.
 3518              		.loc 16 181 0
 3519 0000 7047     		bx	lr
 3520              		.cfi_endproc
 3521              	.LFE169:
 3523              		.section	.text._Z7FrqInitiP9timer_devi,"ax",%progbits
 3524              		.align	1
 3525              		.global	_Z7FrqInitiP9timer_devi
 3526              		.thumb
 3527              		.thumb_func
 3529              	_Z7FrqInitiP9timer_devi:
 3530              	.LFB170:
  80:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** {
 3531              		.loc 4 80 0
 3532              		.cfi_startproc
 3533              		@ args = 0, pretend = 0, frame = 0
 3534              		@ frame_needed = 0, uses_anonymous_args = 0
 3535              	.LVL166:
 3536 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3537              	.LCFI37:
 3538              		.cfi_def_cfa_offset 24
 3539              		.cfi_offset 14, -4
 3540              		.cfi_offset 7, -8
 3541              		.cfi_offset 6, -12
 3542              		.cfi_offset 5, -16
 3543              		.cfi_offset 4, -20
 3544              		.cfi_offset 3, -24
 3545              	.LBB77:
  83:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.TimerDev     = aTimer;
 3546              		.loc 4 83 0
 3547 0002 244D     		ldr	r5, .L201
 3548 0004 2960     		str	r1, [r5, #0]
  84:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer_gen_reg_map *timer = aTimer->regs.gen;
 3549              		.loc 4 84 0
 3550 0006 0C68     		ldr	r4, [r1, #0]
  81:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   aTimerChannel--;  // transform timer channel numbering from 1-4 to 0-3
 3551              		.loc 4 81 0
 3552 0008 561E     		subs	r6, r2, #1
 3553              	.LVL167:
  87:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.Timer_ccr    = &timer->CCR1 + aTimerChannel;
 3554              		.loc 4 87 0
 3555 000a B100     		lsls	r1, r6, #2
 3556              	.LVL168:
  90:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   int TimerEnable = (1 << (4*aTimerChannel));
 3557              		.loc 4 90 0
 3558 000c 0127     		movs	r7, #1
 3559 000e 07FA01F7 		lsl	r7, r7, r1
 3560              	.LVL169:
  87:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.Timer_ccr    = &timer->CCR1 + aTimerChannel;
 3561              		.loc 4 87 0
 3562 0012 04F1340E 		add	lr, r4, #52
  91:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.PolarityMask = TimerEnable << 1;
 3563              		.loc 4 91 0
 3564 0016 7B00     		lsls	r3, r7, #1
  87:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.Timer_ccr    = &timer->CCR1 + aTimerChannel;
 3565              		.loc 4 87 0
 3566 0018 0EEB0102 		add	r2, lr, r1
  85:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.TimerRegs    = timer;
 3567              		.loc 4 85 0
 3568 001c 6C60     		str	r4, [r5, #4]
  87:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.Timer_ccr    = &timer->CCR1 + aTimerChannel;
 3569              		.loc 4 87 0
 3570 001e AA60     		str	r2, [r5, #8]
  88:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.TimerChannel = aTimerChannel;
 3571              		.loc 4 88 0
 3572 0020 2E61     		str	r6, [r5, #16]
  91:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.PolarityMask = TimerEnable << 1;
 3573              		.loc 4 91 0
 3574 0022 6B61     		str	r3, [r5, #20]
  93:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   uint32 clock_speed = rcc_dev_timer_clk_speed(FrqData.TimerDev->clk_id);
 3575              		.loc 4 93 0
 3576 0024 2868     		ldr	r0, [r5, #0]
 3577              	.LVL170:
 3578 0026 0079     		ldrb	r0, [r0, #4]	@ zero_extendqisi2
 3579 0028 FFF7FEFF 		bl	rcc_dev_timer_clk_speed
 3580              	.LVL171:
  94:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->PSC	= (clock_speed/1000000)-1;
 3581              		.loc 4 94 0
 3582 002c 1A4A     		ldr	r2, .L201+4
 3583 002e B0FBF2F1 		udiv	r1, r0, r2
 3584 0032 4B1E     		subs	r3, r1, #1
  96:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CR1	= 0;
 3585              		.loc 4 96 0
 3586 0034 0022     		movs	r2, #0
  95:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->ARR	= 0xffff;
 3587              		.loc 4 95 0
 3588 0036 4FF6FF70 		movw	r0, #65535
 3589              	.LVL172:
  94:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->PSC	= (clock_speed/1000000)-1;
 3590              		.loc 4 94 0
 3591 003a A362     		str	r3, [r4, #40]
  95:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->ARR	= 0xffff;
 3592              		.loc 4 95 0
 3593 003c E062     		str	r0, [r4, #44]
  96:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CR1	= 0;
 3594              		.loc 4 96 0
 3595 003e 2260     		str	r2, [r4, #0]
  97:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->DIER &= ~(1);
 3596              		.loc 4 97 0
 3597 0040 E168     		ldr	r1, [r4, #12]
 3598 0042 21F00103 		bic	r3, r1, #1
 3599 0046 E360     		str	r3, [r4, #12]
  99:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CCER &= ~TimerEnable; // Disable timer
 3600              		.loc 4 99 0
 3601 0048 206A     		ldr	r0, [r4, #32]
 3602 004a 20EA0702 		bic	r2, r0, r7
 3603 004e 2262     		str	r2, [r4, #32]
 100:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CCER &= ~(FrqData.PolarityMask);
 3604              		.loc 4 100 0
 3605 0050 236A     		ldr	r3, [r4, #32]
 3606 0052 6969     		ldr	r1, [r5, #20]
 112:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   if(aTimerChannel < 2) {
 3607              		.loc 4 112 0
 3608 0054 012E     		cmp	r6, #1
 100:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CCER &= ~(FrqData.PolarityMask);
 3609              		.loc 4 100 0
 3610 0056 23EA0103 		bic	r3, r3, r1
 3611 005a 2362     		str	r3, [r4, #32]
 113:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     mr = &(timer->CCMR1);
 3612              		.loc 4 113 0
 3613 005c D4BF     		ite	le
 3614 005e 04F11803 		addle	r3, r4, #24
 3615              	.LVL173:
 115:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     mr = &(timer->CCMR2);
 3616              		.loc 4 115 0
 3617 0062 04F11C03 		addgt	r3, r4, #28
 3618              	.LVL174:
 117:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   *mr &= ~(0xFF << (8*(aTimerChannel&1)));	// prescaler 1
 3619              		.loc 4 117 0
 3620 0066 06F00100 		and	r0, r6, #1
 3621 006a 1968     		ldr	r1, [r3, #0]
 3622 006c C000     		lsls	r0, r0, #3
 3623 006e FF22     		movs	r2, #255
 3624 0070 02FA00FC 		lsl	ip, r2, r0
 3625 0074 21EA0C06 		bic	r6, r1, ip
 3626              	.LVL175:
 3627 0078 1E60     		str	r6, [r3, #0]
 118:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   *mr |= 0x61 << (8*(aTimerChannel&1));		// 0x61 -> 6=filter, 1=inputs 1,2,3,4
 3628              		.loc 4 118 0
 3629 007a 1A68     		ldr	r2, [r3, #0]
 3630 007c 6121     		movs	r1, #97
 3631 007e 01FA00F6 		lsl	r6, r1, r0
 3632 0082 1643     		orrs	r6, r6, r2
 3633 0084 1E60     		str	r6, [r3, #0]
 120:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CCER |= TimerEnable; // Enable
 3634              		.loc 4 120 0
 3635 0086 206A     		ldr	r0, [r4, #32]
 121:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CR1 = 1;
 3636              		.loc 4 121 0
 3637 0088 0123     		movs	r3, #1
 3638              	.LVL176:
 120:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CCER |= TimerEnable; // Enable
 3639              		.loc 4 120 0
 3640 008a 0743     		orrs	r7, r7, r0
 3641              	.LVL177:
 3642 008c 2762     		str	r7, [r4, #32]
 121:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CR1 = 1;
 3643              		.loc 4 121 0
 3644 008e 2360     		str	r3, [r4, #0]
 3645              	.LBE77:
 130:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** }
 3646              		.loc 4 130 0
 3647 0090 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3648              	.L202:
 3649 0092 00BF     		.align	2
 3650              	.L201:
 3651 0094 00000000 		.word	.LANCHOR0
 3652 0098 40420F00 		.word	1000000
 3653              		.cfi_endproc
 3654              	.LFE170:
 3656              		.section	.text._Z18InitFrqMeasurementv,"ax",%progbits
 3657              		.align	1
 3658              		.global	_Z18InitFrqMeasurementv
 3659              		.thumb
 3660              		.thumb_func
 3662              	_Z18InitFrqMeasurementv:
 3663              	.LFB172:
 157:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 158:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** void InitFrqMeasurement()
 159:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** {
 3664              		.loc 4 159 0
 3665              		.cfi_startproc
 3666              		@ args = 0, pretend = 0, frame = 0
 3667              		@ frame_needed = 0, uses_anonymous_args = 0
 3668              	.LVL178:
 3669 0000 38B5     		push	{r3, r4, r5, lr}
 3670              	.LCFI38:
 3671              		.cfi_def_cfa_offset 16
 3672              		.cfi_offset 14, -4
 3673              		.cfi_offset 5, -8
 3674              		.cfi_offset 4, -12
 3675              		.cfi_offset 3, -16
 3676              	.LBB78:
 160:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 161:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #ifdef STM32_TIMER_DEBUG
 162:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Serial.println("InitFrqMeasurement");
 163:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #endif
 164:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   int pin = receiverPin;
 165:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer_dev *timer_num = PIN_MAP[pin].timer_device;
 3677              		.loc 4 165 0
 3678 0002 0F4C     		ldr	r4, .L205
 166:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 167:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   currentChannel=8;
 3679              		.loc 4 167 0
 3680 0004 0F4B     		ldr	r3, .L205+4
 165:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer_dev *timer_num = PIN_MAP[pin].timer_device;
 3681              		.loc 4 165 0
 3682 0006 D4F8F453 		ldr	r5, [r4, #1012]
 3683              	.LVL179:
 3684              		.loc 4 167 0
 3685 000a 0822     		movs	r2, #8
 3686 000c 1A70     		strb	r2, [r3, #0]
 168:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   if(timer_num == NULL) {
 3687              		.loc 4 168 0
 3688 000e ADB1     		cbz	r5, .L203
 169:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #ifdef STM32_TIMER_DEBUG
 170:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     Serial.print("InitFrqMeasurement: invalid PWM input ");
 171:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     Serial.print(pin);
 172:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     Serial.println();
 173:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #endif
 174:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   } else {
 175:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #ifdef STM32F2
 176:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     gpio_set_mode(PIN_MAP[pin].gpio_device, PIN_MAP[pin].gpio_bit, GPIO_AF_INPUT_PD);
 3689              		.loc 4 176 0
 3690 0010 D4F8F003 		ldr	r0, [r4, #1008]
 3691 0014 94F8FC13 		ldrb	r1, [r4, #1020]	@ zero_extendqisi2
 3692 0018 0A22     		movs	r2, #10
 3693 001a FFF7FEFF 		bl	gpio_set_mode
 3694              	.LVL180:
 177:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #else
 178:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     pinMode(pin, INPUT_PULLDOWN);
 179:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #endif
 180:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     
 181:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #ifdef STM32_TIMER_DEBUG
 182:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     timer_gen_reg_map *timer = PIN_MAP[pin].timer_device->regs.gen;
 183:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     Serial.print("pin ");
 184:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     Serial.print(pin);
 185:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     Serial.print(" timerbase ");
 186:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     Serial.print((int32)timer,16);
 187:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     Serial.println();
 188:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #endif
 189:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     FrqInit(1500, timer_num, PIN_MAP[pin].timer_channel);
 3695              		.loc 4 189 0
 3696 001e 2946     		mov	r1, r5
 3697 0020 94F8FD23 		ldrb	r2, [r4, #1021]	@ zero_extendqisi2
 3698 0024 40F2DC50 		movw	r0, #1500
 3699 0028 FFF7FEFF 		bl	_Z7FrqInitiP9timer_devi
 190:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     
 191:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     timer_attach_interrupt(timer_num, PIN_MAP[pin].timer_channel, FrqChange);
 3700              		.loc 4 191 0
 3701 002c 94F8FD13 		ldrb	r1, [r4, #1021]	@ zero_extendqisi2
 3702 0030 054A     		ldr	r2, .L205+8
 3703 0032 2846     		mov	r0, r5
 3704              	.LBE78:
 192:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   }
 193:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   
 194:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #ifdef STM32_TIMER_DEBUG
 195:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Serial.println("InitFrqMeasurement done");
 196:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #endif
 197:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** }
 3705              		.loc 4 197 0
 3706 0034 BDE83840 		pop	{r3, r4, r5, lr}
 3707              	.LBB79:
 191:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     timer_attach_interrupt(timer_num, PIN_MAP[pin].timer_channel, FrqChange);
 3708              		.loc 4 191 0
 3709 0038 FFF7FEBF 		b	timer_attach_interrupt
 3710              	.L203:
 3711 003c 38BD     		pop	{r3, r4, r5, pc}
 3712              	.L206:
 3713 003e 00BF     		.align	2
 3714              	.L205:
 3715 0040 00000000 		.word	PIN_MAP
 3716 0044 00000000 		.word	.LANCHOR1
 3717 0048 00000000 		.word	_Z9FrqChangev
 3718              	.LBE79:
 3719              		.cfi_endproc
 3720              	.LFE172:
 3722              		.section	.text._Z18initializeReceiveri,"ax",%progbits
 3723              		.align	1
 3724              		.global	_Z18initializeReceiveri
 3725              		.thumb
 3726              		.thumb_func
 3728              	_Z18initializeReceiveri:
 3729              	.LFB173:
 198:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 199:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 200:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 201:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** ///////////////////////////////////////////////////////////////////////////////
 202:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** // interface part starts here
 203:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 204:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** void initializeReceiver(int nbChannel = 8) {
 3730              		.loc 4 204 0
 3731              		.cfi_startproc
 3732              		@ args = 0, pretend = 0, frame = 0
 3733              		@ frame_needed = 0, uses_anonymous_args = 0
 3734              	.LVL181:
 3735 0000 08B5     		push	{r3, lr}
 3736              	.LCFI39:
 3737              		.cfi_def_cfa_offset 8
 3738              		.cfi_offset 14, -4
 3739              		.cfi_offset 3, -8
 205:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 206:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   initializeReceiverParam(nbChannel);
 3740              		.loc 4 206 0
 3741 0002 FFF7FEFF 		bl	_Z23initializeReceiverParami
 3742              	.LVL182:
 207:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   InitFrqMeasurement();
 208:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** }
 3743              		.loc 4 208 0
 3744 0006 BDE80840 		pop	{r3, lr}
 207:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   InitFrqMeasurement();
 3745              		.loc 4 207 0
 3746 000a FFF7FEBF 		b	_Z18InitFrqMeasurementv
 3747              		.cfi_endproc
 3748              	.LFE173:
 3750              		.section	.text._Z18getRawChannelValueh,"ax",%progbits
 3751              		.align	1
 3752              		.global	_Z18getRawChannelValueh
 3753              		.thumb
 3754              		.thumb_func
 3756              	_Z18getRawChannelValueh:
 3757              	.LFB174:
 209:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 210:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 211:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** int getRawChannelValue(const byte channel) {
 3758              		.loc 4 211 0
 3759              		.cfi_startproc
 3760              		@ args = 0, pretend = 0, frame = 0
 3761              		@ frame_needed = 0, uses_anonymous_args = 0
 3762              		@ link register save eliminated.
 3763              	.LVL183:
 212:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   return rawChannelValue[ReceiverChannelMap[channel]];
 3764              		.loc 4 212 0
 3765 0000 0249     		ldr	r1, .L209
 213:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** }
 3766              		.loc 4 213 0
 3767 0002 034B     		ldr	r3, .L209+4
 212:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   return rawChannelValue[ReceiverChannelMap[channel]];
 3768              		.loc 4 212 0
 3769 0004 0A5C     		ldrb	r2, [r1, r0]	@ zero_extendqisi2
 3770              		.loc 4 213 0
 3771 0006 33F81200 		ldrh	r0, [r3, r2, lsl #1]
 3772              	.LVL184:
 3773 000a 7047     		bx	lr
 3774              	.L210:
 3775              		.align	2
 3776              	.L209:
 3777 000c 00000000 		.word	.LANCHOR59
 3778 0010 00000000 		.word	.LANCHOR2
 3779              		.cfi_endproc
 3780              	.LFE174:
 3782              		.section	.text._Z12readReceiverv,"ax",%progbits
 3783              		.align	1
 3784              		.global	_Z12readReceiverv
 3785              		.thumb
 3786              		.thumb_func
 3788              	_Z12readReceiverv:
 3789              	.LFB122:
  87:../Libraries/AQ_Receiver/Receiver.h **** {
 3790              		.loc 7 87 0
 3791              		.cfi_startproc
 3792              		@ args = 0, pretend = 0, frame = 0
 3793              		@ frame_needed = 0, uses_anonymous_args = 0
 3794              	.LVL185:
 3795 0000 38B5     		push	{r3, r4, r5, lr}
 3796              	.LCFI40:
 3797              		.cfi_def_cfa_offset 16
 3798              		.cfi_offset 14, -4
 3799              		.cfi_offset 5, -8
 3800              		.cfi_offset 4, -12
 3801              		.cfi_offset 3, -16
 3802              	.LBB80:
  88:../Libraries/AQ_Receiver/Receiver.h ****   for(byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 3803              		.loc 7 88 0
 3804 0002 0024     		movs	r4, #0
 3805 0004 33E0     		b	.L212
 3806              	.LVL186:
 3807              	.L213:
  91:../Libraries/AQ_Receiver/Receiver.h ****     receiverData[channel] = (receiverSlope[channel] * getRawChannelValue(channel)) + receiverOffset
 3808              		.loc 7 91 0 discriminator 2
 3809 0006 2046     		mov	r0, r4
 3810 0008 FFF7FEFF 		bl	_Z18getRawChannelValueh
 3811 000c 2D49     		ldr	r1, .L218
 3812 000e 02EE900A 		fmsr	s5, r0	@ int
 3813 0012 2D48     		ldr	r0, .L218+4
 3814 0014 A300     		lsls	r3, r4, #2
 3815 0016 CA18     		adds	r2, r1, r3
 3816 0018 C118     		adds	r1, r0, r3
 3817 001a 92ED007A 		flds	s14, [r2, #0]
 3818 001e 91ED002A 		flds	s4, [r1, #0]
 3819 0022 F8EEE26A 		fsitos	s13, s5
 3820 0026 294A     		ldr	r2, .L218+8
  93:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = filterSmooth(receiverData[channel], receiverCommandSmooth[chan
 3821              		.loc 7 93 0 discriminator 2
 3822 0028 2949     		ldr	r1, .L218+12
  91:../Libraries/AQ_Receiver/Receiver.h ****     receiverData[channel] = (receiverSlope[channel] * getRawChannelValue(channel)) + receiverOffset
 3823              		.loc 7 91 0 discriminator 2
 3824 002a 06EE872A 		fmacs	s4, s13, s14
  93:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = filterSmooth(receiverData[channel], receiverCommandSmooth[chan
 3825              		.loc 7 93 0 discriminator 2
 3826 002e CB18     		adds	r3, r1, r3
  91:../Libraries/AQ_Receiver/Receiver.h ****     receiverData[channel] = (receiverSlope[channel] * getRawChannelValue(channel)) + receiverOffset
 3827              		.loc 7 91 0 discriminator 2
 3828 0030 FDEEC21A 		ftosizs	s3, s4
 3829 0034 11EE900A 		fmrs	r0, s3	@ int
 3830 0038 42F82400 		str	r0, [r2, r4, lsl #2]
  93:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = filterSmooth(receiverData[channel], receiverCommandSmooth[chan
 3831              		.loc 7 93 0 discriminator 2
 3832 003c 55F82420 		ldr	r2, [r5, r4, lsl #2]
 3833 0040 01EE102A 		fmsr	s2, r2	@ int
 3834 0044 F8EEE17A 		fsitos	s15, s3
 3835 0048 F8EEC10A 		fsitos	s1, s2
 3836 004c 17EE900A 		fmrs	r0, s15
 3837 0050 10EE901A 		fmrs	r1, s1
 3838 0054 1A68     		ldr	r2, [r3, #0]	@ float
 3839 0056 FFF7FEFF 		bl	_Z12filterSmoothfff
 3840 005a 00EE100A 		fmsr	s0, r0
 3841 005e BDEEC06A 		ftosizs	s12, s0
 3842 0062 16EE100A 		fmrs	r0, s12	@ int
 3843 0066 45F82400 		str	r0, [r5, r4, lsl #2]
  88:../Libraries/AQ_Receiver/Receiver.h ****   for(byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 3844              		.loc 7 88 0 discriminator 2
 3845 006a 0134     		adds	r4, r4, #1
 3846              	.LVL187:
 3847 006c E4B2     		uxtb	r4, r4
 3848              	.LVL188:
 3849              	.L212:
  88:../Libraries/AQ_Receiver/Receiver.h ****   for(byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 3850              		.loc 7 88 0 is_stmt 0 discriminator 1
 3851 006e 194D     		ldr	r5, .L218+16
 3852 0070 2A68     		ldr	r2, [r5, #0]
 3853 0072 194D     		ldr	r5, .L218+20
 3854 0074 9442     		cmp	r4, r2
 3855 0076 C6DB     		blt	.L213
 3856              	.LVL189:
 3857              	.LBE80:
 3858              	.LBB81:
  98:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommand[channel] = ((receiverCommandSmooth[channel] - receiverZero[channel]) * receiver
 3859              		.loc 7 98 0 is_stmt 1
 3860 0078 184C     		ldr	r4, .L218+24
 3861              	.LVL190:
 3862 007a 94ED007A 		flds	s14, [r4, #0]
 3863 007e 0023     		movs	r3, #0
 3864              	.LVL191:
 3865              	.L214:
  98:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommand[channel] = ((receiverCommandSmooth[channel] - receiverZero[channel]) * receiver
 3866              		.loc 7 98 0 is_stmt 0 discriminator 2
 3867 0080 1749     		ldr	r1, .L218+28
 3868 0082 EC58     		ldr	r4, [r5, r3]
 3869 0084 5858     		ldr	r0, [r3, r1]
 3870 0086 1749     		ldr	r1, .L218+32
 3871 0088 241A     		subs	r4, r4, r0
 3872 008a 05EE104A 		fmsr	s10, r4	@ int
 3873 008e 04EE900A 		fmsr	s9, r0	@ int
 3874 0092 B8EEC54A 		fsitos	s8, s10
 3875 0096 F8EEE43A 		fsitos	s7, s9
 3876 009a 44EE073A 		fmacs	s7, s8, s14
 3877 009e BDEEE33A 		ftosizs	s6, s7
 3878 00a2 13EE100A 		fmrs	r0, s6	@ int
 3879 00a6 5850     		str	r0, [r3, r1]
 3880 00a8 0433     		adds	r3, r3, #4
  97:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < THROTTLE; channel++) {
 3881              		.loc 7 97 0 is_stmt 1 discriminator 2
 3882 00aa 0C2B     		cmp	r3, #12
 3883 00ac E8D1     		bne	.L214
  97:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < THROTTLE; channel++) {
 3884              		.loc 7 97 0 is_stmt 0
 3885 00ae 0323     		movs	r3, #3
 3886 00b0 05E0     		b	.L215
 3887              	.LVL192:
 3888              	.L216:
 3889              	.LBE81:
 3890              	.LBB82:
 102:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommand[channel] = receiverCommandSmooth[channel];
 3891              		.loc 7 102 0 is_stmt 1 discriminator 2
 3892 00b2 55F82300 		ldr	r0, [r5, r3, lsl #2]
 3893 00b6 41F82300 		str	r0, [r1, r3, lsl #2]
 101:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = THROTTLE; channel < lastReceiverChannel; channel++) {
 3894              		.loc 7 101 0 discriminator 2
 3895 00ba 0133     		adds	r3, r3, #1
 3896              	.LVL193:
 3897 00bc DBB2     		uxtb	r3, r3
 3898              	.LVL194:
 3899              	.L215:
 101:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = THROTTLE; channel < lastReceiverChannel; channel++) {
 3900              		.loc 7 101 0 is_stmt 0 discriminator 1
 3901 00be 9342     		cmp	r3, r2
 3902 00c0 F7DB     		blt	.L216
 3903              	.LBE82:
 104:../Libraries/AQ_Receiver/Receiver.h **** }
 3904              		.loc 7 104 0 is_stmt 1
 3905 00c2 38BD     		pop	{r3, r4, r5, pc}
 3906              	.L219:
 3907              		.align	2
 3908              	.L218:
 3909 00c4 00000000 		.word	.LANCHOR12
 3910 00c8 00000000 		.word	.LANCHOR13
 3911 00cc 00000000 		.word	.LANCHOR60
 3912 00d0 00000000 		.word	.LANCHOR14
 3913 00d4 00000000 		.word	.LANCHOR9
 3914 00d8 00000000 		.word	.LANCHOR10
 3915 00dc 00000000 		.word	.LANCHOR61
 3916 00e0 00000000 		.word	.LANCHOR11
 3917 00e4 00000000 		.word	.LANCHOR6
 3918              		.cfi_endproc
 3919              	.LFE122:
 3921              		.section	.text._Z15setChannelValuehi,"ax",%progbits
 3922              		.align	1
 3923              		.global	_Z15setChannelValuehi
 3924              		.thumb
 3925              		.thumb_func
 3927              	_Z15setChannelValuehi:
 3928              	.LFB175:
 214:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 215:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 216:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** void setChannelValue(byte channel,int value) {
 3929              		.loc 4 216 0
 3930              		.cfi_startproc
 3931              		@ args = 0, pretend = 0, frame = 0
 3932              		@ frame_needed = 0, uses_anonymous_args = 0
 3933              		@ link register save eliminated.
 3934              	.LVL195:
 217:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** }
 3935              		.loc 4 217 0
 3936 0000 7047     		bx	lr
 3937              		.cfi_endproc
 3938              	.LFE175:
 3940              		.section	.text._Z14_initMotorInfoii,"ax",%progbits
 3941              		.align	1
 3942              		.global	_Z14_initMotorInfoii
 3943              		.thumb
 3944              		.thumb_func
 3946              	_Z14_initMotorInfoii:
 3947              	.LFB177:
 3948              		.file 17 "../Libraries/AQ_Motors/Motors_STM32.h"
   1:../Libraries/AQ_Motors/Motors_STM32.h **** #ifndef _AEROQUAD_MOTORS_STM32_H_
   2:../Libraries/AQ_Motors/Motors_STM32.h **** #define _AEROQUAD_MOTORS_STM32_H_
   3:../Libraries/AQ_Motors/Motors_STM32.h **** 
   4:../Libraries/AQ_Motors/Motors_STM32.h **** #if defined(AeroQuadSTM32)
   5:../Libraries/AQ_Motors/Motors_STM32.h **** 
   6:../Libraries/AQ_Motors/Motors_STM32.h **** #include "Motors.h"
   7:../Libraries/AQ_Motors/Motors_STM32.h **** 
   8:../Libraries/AQ_Motors/Motors_STM32.h **** ////////////////////////////////////////////////////////
   9:../Libraries/AQ_Motors/Motors_STM32.h **** // definition section
  10:../Libraries/AQ_Motors/Motors_STM32.h **** 
  11:../Libraries/AQ_Motors/Motors_STM32.h **** #define PWM_FREQUENCY 400 // Hz
  12:../Libraries/AQ_Motors/Motors_STM32.h **** 
  13:../Libraries/AQ_Motors/Motors_STM32.h **** #if defined(BOARD_aeroquad32)
  14:../Libraries/AQ_Motors/Motors_STM32.h ****   static byte stm32_motor_mapping[] = {
  15:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('C',  9),
  16:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('C',  8),
  17:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('C',  7),
  18:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('C',  6),
  19:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('A', 15),
  20:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('B',  3),
  21:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('B',  4),
  22:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('B',  5)
  23:../Libraries/AQ_Motors/Motors_STM32.h ****   };
  24:../Libraries/AQ_Motors/Motors_STM32.h **** #elif defined(BOARD_aeroquad32mini)
  25:../Libraries/AQ_Motors/Motors_STM32.h ****   static byte stm32_motor_mapping[] = {3, 9, 10, 11, 12, 13};
  26:../Libraries/AQ_Motors/Motors_STM32.h **** #elif defined(BOARD_freeflight)
  27:../Libraries/AQ_Motors/Motors_STM32.h ****   static byte stm32_motor_mapping[] = {
  28:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('B',  6),
  29:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('B',  7),
  30:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('B',  8),
  31:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('B',  9),
  32:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('A',  8),
  33:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('A', 11)
  34:../Libraries/AQ_Motors/Motors_STM32.h ****   };
  35:../Libraries/AQ_Motors/Motors_STM32.h **** #elif defined(BOARD_discovery_f4)
  36:../Libraries/AQ_Motors/Motors_STM32.h ****   static byte stm32_motor_mapping[] = {
  37:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('C',  9),
  38:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('C',  8),
  39:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('C',  7),
  40:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('C',  6),
  41:../Libraries/AQ_Motors/Motors_STM32.h **** 	// pin mapping for motor 5-8 not specified, yet
  42:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('A', 15),
  43:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('B',  3),
  44:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('B',  4),
  45:../Libraries/AQ_Motors/Motors_STM32.h ****     Port2Pin('B',  5)
  46:../Libraries/AQ_Motors/Motors_STM32.h ****   };
  47:../Libraries/AQ_Motors/Motors_STM32.h **** #else
  48:../Libraries/AQ_Motors/Motors_STM32.h ****   #error "No motor pinout defined for this STM32 board"
  49:../Libraries/AQ_Motors/Motors_STM32.h **** #endif
  50:../Libraries/AQ_Motors/Motors_STM32.h **** 
  51:../Libraries/AQ_Motors/Motors_STM32.h **** 
  52:../Libraries/AQ_Motors/Motors_STM32.h **** ////////////////////////////////////////////////////////
  53:../Libraries/AQ_Motors/Motors_STM32.h **** // code section
  54:../Libraries/AQ_Motors/Motors_STM32.h **** 
  55:../Libraries/AQ_Motors/Motors_STM32.h **** #define PWM_PERIODE (1000000/PWM_FREQUENCY)
  56:../Libraries/AQ_Motors/Motors_STM32.h **** 
  57:../Libraries/AQ_Motors/Motors_STM32.h ****   // private section
  58:../Libraries/AQ_Motors/Motors_STM32.h ****   static int _stm32_motor_number;
  59:../Libraries/AQ_Motors/Motors_STM32.h **** 
  60:../Libraries/AQ_Motors/Motors_STM32.h ****   struct _sMotorInfo {
  61:../Libraries/AQ_Motors/Motors_STM32.h **** 	int			pin;
  62:../Libraries/AQ_Motors/Motors_STM32.h ****     timer_dev 	*timer_device;	/**< Pin's timer device, if any. */
  63:../Libraries/AQ_Motors/Motors_STM32.h ****     uint8 		timer_channel;  /**< Timer channel, or 0 if none. */
  64:../Libraries/AQ_Motors/Motors_STM32.h ****   } MotorInfo[8];
  65:../Libraries/AQ_Motors/Motors_STM32.h **** 
  66:../Libraries/AQ_Motors/Motors_STM32.h ****   void _initMotorInfo(int motor, int pin) {
 3949              		.loc 17 66 0
 3950              		.cfi_startproc
 3951              		@ args = 0, pretend = 0, frame = 0
 3952              		@ frame_needed = 0, uses_anonymous_args = 0
 3953              	.LVL196:
  67:../Libraries/AQ_Motors/Motors_STM32.h **** 	  MotorInfo[motor].pin           = pin;
 3954              		.loc 17 67 0
 3955 0000 0C22     		movs	r2, #12
 3956 0002 4243     		muls	r2, r0, r2
 3957 0004 054B     		ldr	r3, .L222
  66:../Libraries/AQ_Motors/Motors_STM32.h ****   void _initMotorInfo(int motor, int pin) {
 3958              		.loc 17 66 0
 3959 0006 10B5     		push	{r4, lr}
 3960              	.LCFI41:
 3961              		.cfi_def_cfa_offset 8
 3962              		.cfi_offset 14, -4
 3963              		.cfi_offset 4, -8
 3964              		.loc 17 67 0
 3965 0008 9C18     		adds	r4, r3, r2
 3966 000a 9950     		str	r1, [r3, r2]
  68:../Libraries/AQ_Motors/Motors_STM32.h **** 	  MotorInfo[motor].timer_device  = PIN_MAP[pin].timer_device;
 3967              		.loc 17 68 0
 3968 000c 044A     		ldr	r2, .L222+4
 3969 000e 02EB0111 		add	r1, r2, r1, lsl #4
 3970              	.LVL197:
 3971 0012 4868     		ldr	r0, [r1, #4]
 3972              	.LVL198:
 3973 0014 6060     		str	r0, [r4, #4]
  69:../Libraries/AQ_Motors/Motors_STM32.h **** 	  MotorInfo[motor].timer_channel = PIN_MAP[pin].timer_channel;
 3974              		.loc 17 69 0
 3975 0016 4B7B     		ldrb	r3, [r1, #13]	@ zero_extendqisi2
 3976 0018 2372     		strb	r3, [r4, #8]
  70:../Libraries/AQ_Motors/Motors_STM32.h ****   }
 3977              		.loc 17 70 0
 3978 001a 10BD     		pop	{r4, pc}
 3979              	.L223:
 3980              		.align	2
 3981              	.L222:
 3982 001c 00000000 		.word	.LANCHOR62
 3983 0020 00000000 		.word	PIN_MAP
 3984              		.cfi_endproc
 3985              	.LFE177:
 3987              		.section	.text._Z11writeMotorsv,"ax",%progbits
 3988              		.align	1
 3989              		.global	_Z11writeMotorsv
 3990              		.thumb
 3991              		.thumb_func
 3993              	_Z11writeMotorsv:
 3994              	.LFB179:
  71:../Libraries/AQ_Motors/Motors_STM32.h **** 
  72:../Libraries/AQ_Motors/Motors_STM32.h ****   // global section
  73:../Libraries/AQ_Motors/Motors_STM32.h **** 
  74:../Libraries/AQ_Motors/Motors_STM32.h ****   void initializeMotors(NB_Motors numbers) {
  75:../Libraries/AQ_Motors/Motors_STM32.h **** 	_stm32_motor_number = sizeof(stm32_motor_mapping)/sizeof(stm32_motor_mapping[0]);
  76:../Libraries/AQ_Motors/Motors_STM32.h **** 	if(numbers < _stm32_motor_number) {
  77:../Libraries/AQ_Motors/Motors_STM32.h **** 		_stm32_motor_number = numbers;
  78:../Libraries/AQ_Motors/Motors_STM32.h **** 	}
  79:../Libraries/AQ_Motors/Motors_STM32.h **** 
  80:../Libraries/AQ_Motors/Motors_STM32.h **** 	int motor;
  81:../Libraries/AQ_Motors/Motors_STM32.h ****     for(motor=0; motor < _stm32_motor_number; motor++) {
  82:../Libraries/AQ_Motors/Motors_STM32.h ****     	_initMotorInfo(motor, stm32_motor_mapping[motor]);
  83:../Libraries/AQ_Motors/Motors_STM32.h **** 
  84:../Libraries/AQ_Motors/Motors_STM32.h ****     	int prescaler = rcc_dev_timer_clk_speed(MotorInfo[motor].timer_device->clk_id)/1000000 - 1;
  85:../Libraries/AQ_Motors/Motors_STM32.h ****     	timer_set_prescaler(MotorInfo[motor].timer_device, prescaler);
  86:../Libraries/AQ_Motors/Motors_STM32.h ****     	timer_set_reload(MotorInfo[motor].timer_device, PWM_PERIODE);
  87:../Libraries/AQ_Motors/Motors_STM32.h **** 
  88:../Libraries/AQ_Motors/Motors_STM32.h ****     	pinMode(MotorInfo[motor].pin, PWM);
  89:../Libraries/AQ_Motors/Motors_STM32.h ****     }
  90:../Libraries/AQ_Motors/Motors_STM32.h **** 
  91:../Libraries/AQ_Motors/Motors_STM32.h ****     // sync timer
  92:../Libraries/AQ_Motors/Motors_STM32.h ****     for(motor=0; motor < _stm32_motor_number; motor++) {
  93:../Libraries/AQ_Motors/Motors_STM32.h ****     	timer_generate_update(MotorInfo[motor].timer_device);
  94:../Libraries/AQ_Motors/Motors_STM32.h ****     }
  95:../Libraries/AQ_Motors/Motors_STM32.h **** 
  96:../Libraries/AQ_Motors/Motors_STM32.h ****     commandAllMotors(1000);
  97:../Libraries/AQ_Motors/Motors_STM32.h **** 	//Serial.println("motor init done\r\n");
  98:../Libraries/AQ_Motors/Motors_STM32.h ****   }
  99:../Libraries/AQ_Motors/Motors_STM32.h **** 
 100:../Libraries/AQ_Motors/Motors_STM32.h ****   void writeMotors(void) {
 3995              		.loc 17 100 0
 3996              		.cfi_startproc
 3997              		@ args = 0, pretend = 0, frame = 0
 3998              		@ frame_needed = 0, uses_anonymous_args = 0
 3999              	.LVL199:
 4000 0000 70B5     		push	{r4, r5, r6, lr}
 4001              	.LCFI42:
 4002              		.cfi_def_cfa_offset 16
 4003              		.cfi_offset 14, -4
 4004              		.cfi_offset 6, -8
 4005              		.cfi_offset 5, -12
 4006              		.cfi_offset 4, -16
 4007              	.LBB83:
 101:../Libraries/AQ_Motors/Motors_STM32.h **** 	for(int motor=0; motor < _stm32_motor_number; motor++) {
 4008              		.loc 17 101 0
 4009 0002 0A4C     		ldr	r4, .L227
 4010 0004 0A4E     		ldr	r6, .L227+4
 4011 0006 0025     		movs	r5, #0
 4012 0008 09E0     		b	.L225
 4013              	.LVL200:
 4014              	.L226:
 102:../Libraries/AQ_Motors/Motors_STM32.h **** 	   	timer_set_compare(MotorInfo[motor].timer_device, MotorInfo[motor].timer_channel,  motorCommand
 4015              		.loc 17 102 0 discriminator 2
 4016 000a 56F8042F 		ldr	r2, [r6, #4]!
 4017 000e 54F80C0C 		ldr	r0, [r4, #-12]
 4018 0012 14F8081C 		ldrb	r1, [r4, #-8]	@ zero_extendqisi2
 4019 0016 92B2     		uxth	r2, r2
 4020 0018 FFF7FEFF 		bl	timer_set_compare
 101:../Libraries/AQ_Motors/Motors_STM32.h **** 	for(int motor=0; motor < _stm32_motor_number; motor++) {
 4021              		.loc 17 101 0 discriminator 2
 4022 001c 0135     		adds	r5, r5, #1
 4023              	.LVL201:
 4024              	.L225:
 101:../Libraries/AQ_Motors/Motors_STM32.h **** 	for(int motor=0; motor < _stm32_motor_number; motor++) {
 4025              		.loc 17 101 0 is_stmt 0 discriminator 1
 4026 001e 0548     		ldr	r0, .L227+8
 4027 0020 0368     		ldr	r3, [r0, #0]
 4028 0022 0C34     		adds	r4, r4, #12
 4029 0024 9D42     		cmp	r5, r3
 4030 0026 F0DB     		blt	.L226
 4031              	.LBE83:
 103:../Libraries/AQ_Motors/Motors_STM32.h **** 	}
 104:../Libraries/AQ_Motors/Motors_STM32.h ****   }
 4032              		.loc 17 104 0 is_stmt 1
 4033 0028 70BD     		pop	{r4, r5, r6, pc}
 4034              	.L228:
 4035 002a 00BF     		.align	2
 4036              	.L227:
 4037 002c 04000000 		.word	.LANCHOR62+4
 4038 0030 FCFFFFFF 		.word	.LANCHOR63-4
 4039 0034 00000000 		.word	.LANCHOR64
 4040              		.cfi_endproc
 4041              	.LFE179:
 4043              		.section	.text._Z16commandAllMotorsi,"ax",%progbits
 4044              		.align	1
 4045              		.global	_Z16commandAllMotorsi
 4046              		.thumb
 4047              		.thumb_func
 4049              	_Z16commandAllMotorsi:
 4050              	.LFB180:
 105:../Libraries/AQ_Motors/Motors_STM32.h **** 
 106:../Libraries/AQ_Motors/Motors_STM32.h ****   void commandAllMotors(int _motorCommand) {   // Sends commands to all motors
 4051              		.loc 17 106 0
 4052              		.cfi_startproc
 4053              		@ args = 0, pretend = 0, frame = 0
 4054              		@ frame_needed = 0, uses_anonymous_args = 0
 4055              	.LVL202:
 4056 0000 70B5     		push	{r4, r5, r6, lr}
 4057              	.LCFI43:
 4058              		.cfi_def_cfa_offset 16
 4059              		.cfi_offset 14, -4
 4060              		.cfi_offset 6, -8
 4061              		.cfi_offset 5, -12
 4062              		.cfi_offset 4, -16
 4063              		.loc 17 106 0
 4064 0002 0646     		mov	r6, r0
 4065              	.LBB84:
 107:../Libraries/AQ_Motors/Motors_STM32.h **** 	for(int motor=0; motor < _stm32_motor_number; motor++) {
 4066              		.loc 17 107 0
 4067 0004 084C     		ldr	r4, .L232
 4068 0006 0025     		movs	r5, #0
 4069 0008 07E0     		b	.L230
 4070              	.LVL203:
 4071              	.L231:
 108:../Libraries/AQ_Motors/Motors_STM32.h **** 	   	timer_set_compare(MotorInfo[motor].timer_device, MotorInfo[motor].timer_channel, _motorCommand
 4072              		.loc 17 108 0 discriminator 2
 4073 000a 54F80C0C 		ldr	r0, [r4, #-12]
 4074 000e 14F8081C 		ldrb	r1, [r4, #-8]	@ zero_extendqisi2
 4075 0012 B2B2     		uxth	r2, r6
 4076 0014 FFF7FEFF 		bl	timer_set_compare
 107:../Libraries/AQ_Motors/Motors_STM32.h **** 	for(int motor=0; motor < _stm32_motor_number; motor++) {
 4077              		.loc 17 107 0 discriminator 2
 4078 0018 0135     		adds	r5, r5, #1
 4079              	.LVL204:
 4080              	.L230:
 107:../Libraries/AQ_Motors/Motors_STM32.h **** 	for(int motor=0; motor < _stm32_motor_number; motor++) {
 4081              		.loc 17 107 0 is_stmt 0 discriminator 1
 4082 001a 0448     		ldr	r0, .L232+4
 4083 001c 0368     		ldr	r3, [r0, #0]
 4084 001e 0C34     		adds	r4, r4, #12
 4085 0020 9D42     		cmp	r5, r3
 4086 0022 F2DB     		blt	.L231
 4087              	.LBE84:
 109:../Libraries/AQ_Motors/Motors_STM32.h **** 	}
 110:../Libraries/AQ_Motors/Motors_STM32.h ****   }
 4088              		.loc 17 110 0 is_stmt 1
 4089 0024 70BD     		pop	{r4, r5, r6, pc}
 4090              	.L233:
 4091 0026 00BF     		.align	2
 4092              	.L232:
 4093 0028 04000000 		.word	.LANCHOR62+4
 4094 002c 00000000 		.word	.LANCHOR64
 4095              		.cfi_endproc
 4096              	.LFE180:
 4098              		.section	.text._Z16initializeMotors9NB_Motors,"ax",%progbits
 4099              		.align	1
 4100              		.global	_Z16initializeMotors9NB_Motors
 4101              		.thumb
 4102              		.thumb_func
 4104              	_Z16initializeMotors9NB_Motors:
 4105              	.LFB178:
  74:../Libraries/AQ_Motors/Motors_STM32.h ****   void initializeMotors(NB_Motors numbers) {
 4106              		.loc 17 74 0
 4107              		.cfi_startproc
 4108              		@ args = 0, pretend = 0, frame = 0
 4109              		@ frame_needed = 0, uses_anonymous_args = 0
 4110              	.LVL205:
 4111 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 4112              	.LCFI44:
 4113              		.cfi_def_cfa_offset 24
 4114              		.cfi_offset 14, -4
 4115              		.cfi_offset 7, -8
 4116              		.cfi_offset 6, -12
 4117              		.cfi_offset 5, -16
 4118              		.cfi_offset 4, -20
 4119              		.cfi_offset 3, -24
 4120 0002 1F4F     		ldr	r7, .L240
 4121              	.LBB98:
  77:../Libraries/AQ_Motors/Motors_STM32.h **** 		_stm32_motor_number = numbers;
 4122              		.loc 17 77 0
 4123 0004 1F4E     		ldr	r6, .L240+4
 4124 0006 0728     		cmp	r0, #7
 4125 0008 C8BF     		it	gt
 4126 000a 0820     		movgt	r0, #8
 4127              	.LVL206:
 4128 000c 3860     		str	r0, [r7, #0]
 4129              	.LBE98:
  74:../Libraries/AQ_Motors/Motors_STM32.h ****   void initializeMotors(NB_Motors numbers) {
 4130              		.loc 17 74 0
 4131 000e 3546     		mov	r5, r6
 4132 0010 0024     		movs	r4, #0
 4133 0012 1BE0     		b	.L236
 4134              	.LVL207:
 4135              	.L237:
 4136              	.LBB119:
 4137              	.LBB99:
 4138              	.LBB100:
  82:../Libraries/AQ_Motors/Motors_STM32.h ****     	_initMotorInfo(motor, stm32_motor_mapping[motor]);
 4139              		.loc 17 82 0 discriminator 2
 4140 0014 1C4A     		ldr	r2, .L240+8
 4141 0016 2046     		mov	r0, r4
 4142 0018 115D     		ldrb	r1, [r2, r4]	@ zero_extendqisi2
 4143 001a FFF7FEFF 		bl	_Z14_initMotorInfoii
  84:../Libraries/AQ_Motors/Motors_STM32.h ****     	int prescaler = rcc_dev_timer_clk_speed(MotorInfo[motor].timer_device->clk_id)/1000000 - 1;
 4144              		.loc 17 84 0 discriminator 2
 4145 001e 55F80C0C 		ldr	r0, [r5, #-12]
 4146 0022 0079     		ldrb	r0, [r0, #4]	@ zero_extendqisi2
 4147 0024 FFF7FEFF 		bl	rcc_dev_timer_clk_speed
 4148              	.LVL208:
 4149 0028 1849     		ldr	r1, .L240+12
 4150              	.LBB101:
 4151              	.LBB102:
 682:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->PSC = psc;
 4152              		.loc 1 682 0 discriminator 2
 4153 002a 55F80C3C 		ldr	r3, [r5, #-12]
 4154              	.LBE102:
 4155              	.LBE101:
  84:../Libraries/AQ_Motors/Motors_STM32.h ****     	int prescaler = rcc_dev_timer_clk_speed(MotorInfo[motor].timer_device->clk_id)/1000000 - 1;
 4156              		.loc 17 84 0 discriminator 2
 4157 002e B0FBF1F2 		udiv	r2, r0, r1
 4158              	.LBB106:
 4159              	.LBB103:
 682:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->PSC = psc;
 4160              		.loc 1 682 0 discriminator 2
 4161 0032 1B68     		ldr	r3, [r3, #0]
 4162              	.LBE103:
 4163              	.LBE106:
  84:../Libraries/AQ_Motors/Motors_STM32.h ****     	int prescaler = rcc_dev_timer_clk_speed(MotorInfo[motor].timer_device->clk_id)/1000000 - 1;
 4164              		.loc 17 84 0 discriminator 2
 4165 0034 511E     		subs	r1, r2, #1
 4166              	.LBB107:
 4167              	.LBB104:
 682:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->PSC = psc;
 4168              		.loc 1 682 0 discriminator 2
 4169 0036 88B2     		uxth	r0, r1
 4170              	.LVL209:
 4171              	.LBE104:
 4172              	.LBE107:
 4173              	.LBB108:
 4174              	.LBB109:
 700:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->ARR = arr;
 4175              		.loc 1 700 0 discriminator 2
 4176 0038 40F6C412 		movw	r2, #2500
 4177              	.LBE109:
 4178              	.LBE108:
 4179              	.LBB111:
 4180              	.LBB105:
 682:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->PSC = psc;
 4181              		.loc 1 682 0 discriminator 2
 4182 003c 9862     		str	r0, [r3, #40]
 4183              	.LVL210:
 4184              	.LBE105:
 4185              	.LBE111:
 4186              	.LBB112:
 4187              	.LBB110:
 700:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->ARR = arr;
 4188              		.loc 1 700 0 discriminator 2
 4189 003e DA62     		str	r2, [r3, #44]
 4190              	.LBE110:
 4191              	.LBE112:
  88:../Libraries/AQ_Motors/Motors_STM32.h ****     	pinMode(MotorInfo[motor].pin, PWM);
 4192              		.loc 17 88 0 discriminator 2
 4193 0040 15F8100C 		ldrb	r0, [r5, #-16]	@ zero_extendqisi2
 4194 0044 0721     		movs	r1, #7
 4195              	.LVL211:
 4196 0046 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 4197              	.LVL212:
 4198              	.LBE100:
  81:../Libraries/AQ_Motors/Motors_STM32.h ****     for(motor=0; motor < _stm32_motor_number; motor++) {
 4199              		.loc 17 81 0 discriminator 2
 4200 004a 0134     		adds	r4, r4, #1
 4201              	.LVL213:
 4202              	.L236:
  81:../Libraries/AQ_Motors/Motors_STM32.h ****     for(motor=0; motor < _stm32_motor_number; motor++) {
 4203              		.loc 17 81 0 is_stmt 0 discriminator 1
 4204 004c 3968     		ldr	r1, [r7, #0]
 4205 004e 0C35     		adds	r5, r5, #12
 4206 0050 8C42     		cmp	r4, r1
 4207 0052 DFDB     		blt	.L237
  81:../Libraries/AQ_Motors/Motors_STM32.h ****     for(motor=0; motor < _stm32_motor_number; motor++) {
 4208              		.loc 17 81 0
 4209 0054 0023     		movs	r3, #0
 4210 0056 09E0     		b	.L238
 4211              	.LVL214:
 4212              	.L239:
 4213              	.LBE99:
 4214              	.LBB113:
 4215              	.LBB114:
 725:../Libmaple/libmaple/libmaple/timer.h **** 
 726:../Libmaple/libmaple/libmaple/timer.h **** /**
 727:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Generate an update event for the given timer.
 728:../Libmaple/libmaple/libmaple/timer.h ****  *
 729:../Libmaple/libmaple/libmaple/timer.h ****  * Normally, this will cause the prescaler and auto-reload values in
 730:../Libmaple/libmaple/libmaple/timer.h ****  * the PSC and ARR registers to take immediate effect.  However, this
 731:../Libmaple/libmaple/libmaple/timer.h ****  * function will do nothing if the UDIS bit is set in the timer's CR1
 732:../Libmaple/libmaple/libmaple/timer.h ****  * register (UDIS is cleared by default).
 733:../Libmaple/libmaple/libmaple/timer.h ****  *
 734:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer device to generate an update for.
 735:../Libmaple/libmaple/libmaple/timer.h ****  */
 736:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_generate_update(timer_dev *dev) {
 737:../Libmaple/libmaple/libmaple/timer.h ****     *bb_perip(&(dev->regs).bas->EGR, TIMER_EGR_UG_BIT) = 1;
 4216              		.loc 1 737 0 is_stmt 1 discriminator 2
 4217 0058 56F80C0C 		ldr	r0, [r6, #-12]
 4218 005c 0268     		ldr	r2, [r0, #0]
 4219              	.LVL215:
 4220              	.LBB115:
 4221              	.LBB116:
 4222              	.LBB117:
 4223              	.LBB118:
 4224              		.file 18 "../Libmaple/libmaple/libmaple/bitband.h"
   1:../Libmaple/libmaple/libmaple/bitband.h **** /******************************************************************************
   2:../Libmaple/libmaple/libmaple/bitband.h ****  * The MIT License
   3:../Libmaple/libmaple/libmaple/bitband.h ****  *
   4:../Libmaple/libmaple/libmaple/bitband.h ****  * Copyright (c) 2011 LeafLabs, LLC.
   5:../Libmaple/libmaple/libmaple/bitband.h ****  *
   6:../Libmaple/libmaple/libmaple/bitband.h ****  * Permission is hereby granted, free of charge, to any person
   7:../Libmaple/libmaple/libmaple/bitband.h ****  * obtaining a copy of this software and associated documentation
   8:../Libmaple/libmaple/libmaple/bitband.h ****  * files (the "Software"), to deal in the Software without
   9:../Libmaple/libmaple/libmaple/bitband.h ****  * restriction, including without limitation the rights to use, copy,
  10:../Libmaple/libmaple/libmaple/bitband.h ****  * modify, merge, publish, distribute, sublicense, and/or sell copies
  11:../Libmaple/libmaple/libmaple/bitband.h ****  * of the Software, and to permit persons to whom the Software is
  12:../Libmaple/libmaple/libmaple/bitband.h ****  * furnished to do so, subject to the following conditions:
  13:../Libmaple/libmaple/libmaple/bitband.h ****  *
  14:../Libmaple/libmaple/libmaple/bitband.h ****  * The above copyright notice and this permission notice shall be
  15:../Libmaple/libmaple/libmaple/bitband.h ****  * included in all copies or substantial portions of the Software.
  16:../Libmaple/libmaple/libmaple/bitband.h ****  *
  17:../Libmaple/libmaple/libmaple/bitband.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  18:../Libmaple/libmaple/libmaple/bitband.h ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  19:../Libmaple/libmaple/libmaple/bitband.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20:../Libmaple/libmaple/libmaple/bitband.h ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  21:../Libmaple/libmaple/libmaple/bitband.h ****  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  22:../Libmaple/libmaple/libmaple/bitband.h ****  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  23:../Libmaple/libmaple/libmaple/bitband.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  24:../Libmaple/libmaple/libmaple/bitband.h ****  * SOFTWARE.
  25:../Libmaple/libmaple/libmaple/bitband.h ****  *****************************************************************************/
  26:../Libmaple/libmaple/libmaple/bitband.h **** 
  27:../Libmaple/libmaple/libmaple/bitband.h **** /**
  28:../Libmaple/libmaple/libmaple/bitband.h ****  * @file bitband.h
  29:../Libmaple/libmaple/libmaple/bitband.h ****  *
  30:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Bit-banding utility functions
  31:../Libmaple/libmaple/libmaple/bitband.h ****  */
  32:../Libmaple/libmaple/libmaple/bitband.h **** 
  33:../Libmaple/libmaple/libmaple/bitband.h **** #include "libmaple_types.h"
  34:../Libmaple/libmaple/libmaple/bitband.h **** 
  35:../Libmaple/libmaple/libmaple/bitband.h **** #ifndef _BITBAND_H_
  36:../Libmaple/libmaple/libmaple/bitband.h **** #define _BITBAND_H_
  37:../Libmaple/libmaple/libmaple/bitband.h **** 
  38:../Libmaple/libmaple/libmaple/bitband.h **** #define BB_SRAM_REF      0x20000000
  39:../Libmaple/libmaple/libmaple/bitband.h **** #define BB_SRAM_BASE     0x22000000
  40:../Libmaple/libmaple/libmaple/bitband.h **** #define BB_PERI_REF      0x40000000
  41:../Libmaple/libmaple/libmaple/bitband.h **** #define BB_PERI_BASE     0x42000000
  42:../Libmaple/libmaple/libmaple/bitband.h **** 
  43:../Libmaple/libmaple/libmaple/bitband.h **** static inline volatile uint32* __bb_addr(volatile void*,
  44:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32,
  45:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32,
  46:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32);
  47:../Libmaple/libmaple/libmaple/bitband.h **** 
  48:../Libmaple/libmaple/libmaple/bitband.h **** /**
  49:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Obtain a pointer to the bit-band address corresponding to a
  50:../Libmaple/libmaple/libmaple/bitband.h ****  * bit in a volatile SRAM address.
  51:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the bit-banded SRAM region
  52:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit     Bit in address to bit-band
  53:../Libmaple/libmaple/libmaple/bitband.h ****  */
  54:../Libmaple/libmaple/libmaple/bitband.h **** static inline volatile uint32* bb_sramp(volatile void *address, uint32 bit) {
  55:../Libmaple/libmaple/libmaple/bitband.h ****     return __bb_addr(address, bit, BB_SRAM_BASE, BB_SRAM_REF);
  56:../Libmaple/libmaple/libmaple/bitband.h **** }
  57:../Libmaple/libmaple/libmaple/bitband.h **** 
  58:../Libmaple/libmaple/libmaple/bitband.h **** /**
  59:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Get a bit from an address in the SRAM bit-band region.
  60:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the SRAM bit-band region to read from
  61:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit Bit in address to read
  62:../Libmaple/libmaple/libmaple/bitband.h ****  * @return bit's value in address.
  63:../Libmaple/libmaple/libmaple/bitband.h ****  */
  64:../Libmaple/libmaple/libmaple/bitband.h **** static inline uint8 bb_sram_get_bit(volatile void *address, uint32 bit) {
  65:../Libmaple/libmaple/libmaple/bitband.h ****     return *bb_sramp(address, bit);
  66:../Libmaple/libmaple/libmaple/bitband.h **** }
  67:../Libmaple/libmaple/libmaple/bitband.h **** 
  68:../Libmaple/libmaple/libmaple/bitband.h **** /**
  69:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Set a bit in an address in the SRAM bit-band region.
  70:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the SRAM bit-band region to write to
  71:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit Bit in address to write to
  72:../Libmaple/libmaple/libmaple/bitband.h ****  * @param val Value to write for bit, either 0 or 1.
  73:../Libmaple/libmaple/libmaple/bitband.h ****  */
  74:../Libmaple/libmaple/libmaple/bitband.h **** static inline void bb_sram_set_bit(volatile void *address,
  75:../Libmaple/libmaple/libmaple/bitband.h ****                                    uint32 bit,
  76:../Libmaple/libmaple/libmaple/bitband.h ****                                    uint8 val) {
  77:../Libmaple/libmaple/libmaple/bitband.h ****     *bb_sramp(address, bit) = val;
  78:../Libmaple/libmaple/libmaple/bitband.h **** }
  79:../Libmaple/libmaple/libmaple/bitband.h **** 
  80:../Libmaple/libmaple/libmaple/bitband.h **** /**
  81:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Obtain a pointer to the bit-band address corresponding to a
  82:../Libmaple/libmaple/libmaple/bitband.h ****  * bit in a peripheral address.
  83:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the bit-banded peripheral region
  84:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit     Bit in address to bit-band
  85:../Libmaple/libmaple/libmaple/bitband.h ****  */
  86:../Libmaple/libmaple/libmaple/bitband.h **** static inline volatile uint32* bb_perip(volatile void *address, uint32 bit) {
  87:../Libmaple/libmaple/libmaple/bitband.h ****     return __bb_addr(address, bit, BB_PERI_BASE, BB_PERI_REF);
  88:../Libmaple/libmaple/libmaple/bitband.h **** }
  89:../Libmaple/libmaple/libmaple/bitband.h **** 
  90:../Libmaple/libmaple/libmaple/bitband.h **** /**
  91:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Get a bit from an address in the peripheral bit-band region.
  92:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the peripheral bit-band region to read from
  93:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit Bit in address to read
  94:../Libmaple/libmaple/libmaple/bitband.h ****  * @return bit's value in address.
  95:../Libmaple/libmaple/libmaple/bitband.h ****  */
  96:../Libmaple/libmaple/libmaple/bitband.h **** static inline uint8 bb_peri_get_bit(volatile void *address, uint32 bit) {
  97:../Libmaple/libmaple/libmaple/bitband.h ****     return *bb_perip(address, bit);
  98:../Libmaple/libmaple/libmaple/bitband.h **** }
  99:../Libmaple/libmaple/libmaple/bitband.h **** 
 100:../Libmaple/libmaple/libmaple/bitband.h **** /**
 101:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Set a bit in an address in the peripheral bit-band region.
 102:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the peripheral bit-band region to write to
 103:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit Bit in address to write to
 104:../Libmaple/libmaple/libmaple/bitband.h ****  * @param val Value to write for bit, either 0 or 1.
 105:../Libmaple/libmaple/libmaple/bitband.h ****  */
 106:../Libmaple/libmaple/libmaple/bitband.h **** static inline void bb_peri_set_bit(volatile void *address,
 107:../Libmaple/libmaple/libmaple/bitband.h ****                                    uint32 bit,
 108:../Libmaple/libmaple/libmaple/bitband.h ****                                    uint8 val) {
 109:../Libmaple/libmaple/libmaple/bitband.h ****     *bb_perip(address, bit) = val;
 110:../Libmaple/libmaple/libmaple/bitband.h **** }
 111:../Libmaple/libmaple/libmaple/bitband.h **** 
 112:../Libmaple/libmaple/libmaple/bitband.h **** static inline volatile uint32* __bb_addr(volatile void *address,
 113:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32 bit,
 114:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32 bb_base,
 115:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32 bb_ref) {
 116:../Libmaple/libmaple/libmaple/bitband.h ****     return (volatile uint32*)(bb_base + ((uint32)address - bb_ref) * 32 +
 117:../Libmaple/libmaple/libmaple/bitband.h ****                               bit * 4);
 4225              		.loc 18 117 0 discriminator 2
 4226 005e 5001     		lsls	r0, r2, #5
 4227 0060 00F18442 		add	r2, r0, #1107296256
 4228              	.LBE118:
 4229              	.LBE117:
 4230              	.LBE116:
 4231              	.LBE115:
 4232              		.loc 1 737 0 discriminator 2
 4233 0064 0120     		movs	r0, #1
 4234 0066 C2F88002 		str	r0, [r2, #640]
 4235              	.LBE114:
 4236              	.LBE113:
  92:../Libraries/AQ_Motors/Motors_STM32.h ****     for(motor=0; motor < _stm32_motor_number; motor++) {
 4237              		.loc 17 92 0 discriminator 2
 4238 006a 1B18     		adds	r3, r3, r0
 4239              	.LVL216:
 4240              	.L238:
  92:../Libraries/AQ_Motors/Motors_STM32.h ****     for(motor=0; motor < _stm32_motor_number; motor++) {
 4241              		.loc 17 92 0 is_stmt 0 discriminator 1
 4242 006c 0C36     		adds	r6, r6, #12
 4243 006e 8B42     		cmp	r3, r1
 4244 0070 F2DB     		blt	.L239
  96:../Libraries/AQ_Motors/Motors_STM32.h ****     commandAllMotors(1000);
 4245              		.loc 17 96 0 is_stmt 1
 4246 0072 4FF47A70 		mov	r0, #1000
 4247              	.LBE119:
  98:../Libraries/AQ_Motors/Motors_STM32.h ****   }
 4248              		.loc 17 98 0
 4249 0076 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 4250              	.LBB120:
  96:../Libraries/AQ_Motors/Motors_STM32.h ****     commandAllMotors(1000);
 4251              		.loc 17 96 0
 4252 007a FFF7FEBF 		b	_Z16commandAllMotorsi
 4253              	.LVL217:
 4254              	.L241:
 4255 007e 00BF     		.align	2
 4256              	.L240:
 4257 0080 00000000 		.word	.LANCHOR64
 4258 0084 04000000 		.word	.LANCHOR62+4
 4259 0088 00000000 		.word	.LANCHOR65
 4260 008c 40420F00 		.word	1000000
 4261              	.LBE120:
 4262              		.cfi_endproc
 4263              	.LFE178:
 4265              		.section	.text._Z11pulseMotorsh,"ax",%progbits
 4266              		.align	1
 4267              		.global	_Z11pulseMotorsh
 4268              		.thumb
 4269              		.thumb_func
 4271              	_Z11pulseMotorsh:
 4272              	.LFB176:
 4273              		.file 19 "../Libraries/AQ_Motors/Motors.h"
   1:../Libraries/AQ_Motors/Motors.h **** /*
   2:../Libraries/AQ_Motors/Motors.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Motors/Motors.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Motors/Motors.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Motors/Motors.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Motors/Motors.h ****  
   7:../Libraries/AQ_Motors/Motors.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Motors/Motors.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Motors/Motors.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Motors/Motors.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Motors/Motors.h **** 
  12:../Libraries/AQ_Motors/Motors.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Motors/Motors.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Motors/Motors.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Motors/Motors.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Motors/Motors.h **** 
  17:../Libraries/AQ_Motors/Motors.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Motors/Motors.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Motors/Motors.h **** */
  20:../Libraries/AQ_Motors/Motors.h **** 
  21:../Libraries/AQ_Motors/Motors.h **** 
  22:../Libraries/AQ_Motors/Motors.h **** #ifndef _AEROQUAD_MOTORS_H_
  23:../Libraries/AQ_Motors/Motors.h **** #define _AEROQUAD_MOTORS_H_
  24:../Libraries/AQ_Motors/Motors.h **** 
  25:../Libraries/AQ_Motors/Motors.h **** #include "Arduino.h"
  26:../Libraries/AQ_Motors/Motors.h **** 
  27:../Libraries/AQ_Motors/Motors.h **** #define MOTOR1 0
  28:../Libraries/AQ_Motors/Motors.h **** #define MOTOR2 1
  29:../Libraries/AQ_Motors/Motors.h **** #define MOTOR3 2
  30:../Libraries/AQ_Motors/Motors.h **** #define MOTOR4 3
  31:../Libraries/AQ_Motors/Motors.h **** #define MOTOR5 4
  32:../Libraries/AQ_Motors/Motors.h **** #define MOTOR6 5
  33:../Libraries/AQ_Motors/Motors.h **** #define MOTOR7 6
  34:../Libraries/AQ_Motors/Motors.h **** #define MOTOR8 7
  35:../Libraries/AQ_Motors/Motors.h **** #define MINCOMMAND 1000
  36:../Libraries/AQ_Motors/Motors.h **** #define MAXCOMMAND 2000
  37:../Libraries/AQ_Motors/Motors.h **** 
  38:../Libraries/AQ_Motors/Motors.h **** enum NB_Motors{
  39:../Libraries/AQ_Motors/Motors.h ****   FOUR_Motors = 4,
  40:../Libraries/AQ_Motors/Motors.h ****   SIX_Motors = 6,
  41:../Libraries/AQ_Motors/Motors.h ****   EIGHT_Motors = 8
  42:../Libraries/AQ_Motors/Motors.h **** };
  43:../Libraries/AQ_Motors/Motors.h **** 
  44:../Libraries/AQ_Motors/Motors.h **** NB_Motors numberOfMotors = FOUR_Motors;
  45:../Libraries/AQ_Motors/Motors.h **** int motorCommand[8] = {0,0,0,0,0,0,0,0};  // LASTMOTOR not know here, so, default at 8 @todo : Kenn
  46:../Libraries/AQ_Motors/Motors.h ****   
  47:../Libraries/AQ_Motors/Motors.h **** void initializeMotors(NB_Motors numbers = FOUR_Motors);
  48:../Libraries/AQ_Motors/Motors.h **** void writeMotors();
  49:../Libraries/AQ_Motors/Motors.h **** void commandAllMotors(int command);
  50:../Libraries/AQ_Motors/Motors.h **** 
  51:../Libraries/AQ_Motors/Motors.h **** void pulseMotors(byte nbPulse) {
 4274              		.loc 19 51 0
 4275              		.cfi_startproc
 4276              		@ args = 0, pretend = 0, frame = 0
 4277              		@ frame_needed = 0, uses_anonymous_args = 0
 4278              	.LVL218:
 4279 0000 38B5     		push	{r3, r4, r5, lr}
 4280              	.LCFI45:
 4281              		.cfi_def_cfa_offset 16
 4282              		.cfi_offset 14, -4
 4283              		.cfi_offset 5, -8
 4284              		.cfi_offset 4, -12
 4285              		.cfi_offset 3, -16
 4286              		.loc 19 51 0
 4287 0002 0546     		mov	r5, r0
 4288              	.LBB121:
  52:../Libraries/AQ_Motors/Motors.h ****   for (byte i = 0; i < nbPulse; i++) {
 4289              		.loc 19 52 0
 4290 0004 0024     		movs	r4, #0
 4291 0006 0FE0     		b	.L243
 4292              	.LVL219:
 4293              	.L244:
  53:../Libraries/AQ_Motors/Motors.h ****     commandAllMotors(MINCOMMAND + 100);
 4294              		.loc 19 53 0 discriminator 2
 4295 0008 40F24C40 		movw	r0, #1100
 4296 000c FFF7FEFF 		bl	_Z16commandAllMotorsi
  54:../Libraries/AQ_Motors/Motors.h ****     delay(250);
 4297              		.loc 19 54 0 discriminator 2
 4298 0010 FA20     		movs	r0, #250
 4299 0012 FFF7FEFF 		bl	_Z5delaym
  55:../Libraries/AQ_Motors/Motors.h ****     commandAllMotors(MINCOMMAND);
 4300              		.loc 19 55 0 discriminator 2
 4301 0016 4FF47A70 		mov	r0, #1000
 4302 001a FFF7FEFF 		bl	_Z16commandAllMotorsi
  56:../Libraries/AQ_Motors/Motors.h ****     delay(250);
 4303              		.loc 19 56 0 discriminator 2
 4304 001e FA20     		movs	r0, #250
 4305 0020 FFF7FEFF 		bl	_Z5delaym
  52:../Libraries/AQ_Motors/Motors.h ****   for (byte i = 0; i < nbPulse; i++) {
 4306              		.loc 19 52 0 discriminator 2
 4307 0024 0134     		adds	r4, r4, #1
 4308              	.LVL220:
 4309 0026 E4B2     		uxtb	r4, r4
 4310              	.LVL221:
 4311              	.L243:
  52:../Libraries/AQ_Motors/Motors.h ****   for (byte i = 0; i < nbPulse; i++) {
 4312              		.loc 19 52 0 is_stmt 0 discriminator 1
 4313 0028 AC42     		cmp	r4, r5
 4314 002a EDD1     		bne	.L244
 4315              	.LBE121:
  57:../Libraries/AQ_Motors/Motors.h ****   }
  58:../Libraries/AQ_Motors/Motors.h **** }
 4316              		.loc 19 58 0 is_stmt 1
 4317 002c 38BD     		pop	{r3, r4, r5, pc}
 4318              		.cfi_endproc
 4319              	.LFE176:
 4321              		.section	.text._Z8getHdgXYh,"ax",%progbits
 4322              		.align	1
 4323              		.global	_Z8getHdgXYh
 4324              		.thumb
 4325              		.thumb_func
 4327              	_Z8getHdgXYh:
 4328              	.LFB181:
 4329              		.file 20 "../Libraries/AQ_Compass/Compass.h"
   1:../Libraries/AQ_Compass/Compass.h **** /*
   2:../Libraries/AQ_Compass/Compass.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Compass/Compass.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Compass/Compass.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Compass/Compass.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Compass/Compass.h ****  
   7:../Libraries/AQ_Compass/Compass.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Compass/Compass.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Compass/Compass.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Compass/Compass.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Compass/Compass.h **** 
  12:../Libraries/AQ_Compass/Compass.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Compass/Compass.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Compass/Compass.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Compass/Compass.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Compass/Compass.h **** 
  17:../Libraries/AQ_Compass/Compass.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Compass/Compass.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Compass/Compass.h **** */
  20:../Libraries/AQ_Compass/Compass.h **** 
  21:../Libraries/AQ_Compass/Compass.h **** 
  22:../Libraries/AQ_Compass/Compass.h **** #ifndef _AEROQUAD_COMPASS_H_
  23:../Libraries/AQ_Compass/Compass.h **** #define _AEROQUAD_COMPASS_H_
  24:../Libraries/AQ_Compass/Compass.h **** 
  25:../Libraries/AQ_Compass/Compass.h **** #include "Arduino.h"
  26:../Libraries/AQ_Compass/Compass.h **** 
  27:../Libraries/AQ_Compass/Compass.h **** float hdgX = 0.0;
  28:../Libraries/AQ_Compass/Compass.h **** float hdgY = 0.0;
  29:../Libraries/AQ_Compass/Compass.h **** 
  30:../Libraries/AQ_Compass/Compass.h **** float measuredMagX = 0.0;
  31:../Libraries/AQ_Compass/Compass.h **** float measuredMagY = 0.0;
  32:../Libraries/AQ_Compass/Compass.h **** float measuredMagZ = 0.0;
  33:../Libraries/AQ_Compass/Compass.h **** float measuredMag[3] = {0.0,0.0,0.0};
  34:../Libraries/AQ_Compass/Compass.h **** float rawMag[3] = {0.0,0.0,0.0};
  35:../Libraries/AQ_Compass/Compass.h **** float magBias[3] = {0.0,0.0,0.0};
  36:../Libraries/AQ_Compass/Compass.h **** 
  37:../Libraries/AQ_Compass/Compass.h **** //float magMax[3] = {0.0,0.0,0.0};
  38:../Libraries/AQ_Compass/Compass.h **** //float magMin[3] = {0.0,0.0,0.0};
  39:../Libraries/AQ_Compass/Compass.h **** float magScale[3] = {1.0,1.0,1.0};
  40:../Libraries/AQ_Compass/Compass.h **** //float magOffset[3] = {0.0,0.0,0.0};
  41:../Libraries/AQ_Compass/Compass.h **** //float magBias[3] = {0.0, 0.0, 0.0};
  42:../Libraries/AQ_Compass/Compass.h **** 
  43:../Libraries/AQ_Compass/Compass.h **** void initializeMagnetometer();
  44:../Libraries/AQ_Compass/Compass.h **** void measureMagnetometer(float roll, float pitch);
  45:../Libraries/AQ_Compass/Compass.h **** 
  46:../Libraries/AQ_Compass/Compass.h **** const float getHdgXY(byte axis) {
 4330              		.loc 20 46 0
 4331              		.cfi_startproc
 4332              		@ args = 0, pretend = 0, frame = 0
 4333              		@ frame_needed = 0, uses_anonymous_args = 0
 4334              		@ link register save eliminated.
 4335              	.LVL222:
  47:../Libraries/AQ_Compass/Compass.h ****   if (axis == XAXIS) {
 4336              		.loc 20 47 0
 4337 0000 10B9     		cbnz	r0, .L246
  48:../Libraries/AQ_Compass/Compass.h ****     return hdgX;
 4338              		.loc 20 48 0
 4339 0002 034B     		ldr	r3, .L248
 4340 0004 1868     		ldr	r0, [r3, #0]	@ float
 4341              	.LVL223:
 4342 0006 7047     		bx	lr
 4343              	.LVL224:
 4344              	.L246:
  49:../Libraries/AQ_Compass/Compass.h ****   } else {
  50:../Libraries/AQ_Compass/Compass.h ****     return hdgY;
 4345              		.loc 20 50 0
 4346 0008 0248     		ldr	r0, .L248+4
 4347              	.LVL225:
 4348 000a 0068     		ldr	r0, [r0, #0]	@ float
  51:../Libraries/AQ_Compass/Compass.h ****   }
  52:../Libraries/AQ_Compass/Compass.h **** }
 4349              		.loc 20 52 0
 4350 000c 7047     		bx	lr
 4351              	.L249:
 4352 000e 00BF     		.align	2
 4353              	.L248:
 4354 0010 00000000 		.word	.LANCHOR66
 4355 0014 00000000 		.word	.LANCHOR67
 4356              		.cfi_endproc
 4357              	.LFE181:
 4359              		.section	.text._Z22getMagnetometerRawDatah,"ax",%progbits
 4360              		.align	1
 4361              		.global	_Z22getMagnetometerRawDatah
 4362              		.thumb
 4363              		.thumb_func
 4365              	_Z22getMagnetometerRawDatah:
 4366              	.LFB182:
  53:../Libraries/AQ_Compass/Compass.h **** 
  54:../Libraries/AQ_Compass/Compass.h **** const int getMagnetometerRawData(byte axis) {
 4367              		.loc 20 54 0
 4368              		.cfi_startproc
 4369              		@ args = 0, pretend = 0, frame = 0
 4370              		@ frame_needed = 0, uses_anonymous_args = 0
 4371              		@ link register save eliminated.
 4372              	.LVL226:
  55:../Libraries/AQ_Compass/Compass.h ****   return rawMag[axis];
 4373              		.loc 20 55 0
 4374 0000 0449     		ldr	r1, .L251
 4375 0002 01EB8003 		add	r3, r1, r0, lsl #2
 4376 0006 93ED000A 		flds	s0, [r3, #0]
  56:../Libraries/AQ_Compass/Compass.h **** }
 4377              		.loc 20 56 0
 4378 000a FDEEC07A 		ftosizs	s15, s0
 4379 000e 17EE900A 		fmrs	r0, s15	@ int
 4380              	.LVL227:
 4381 0012 7047     		bx	lr
 4382              	.L252:
 4383              		.align	2
 4384              	.L251:
 4385 0014 00000000 		.word	.LANCHOR68
 4386              		.cfi_endproc
 4387              	.LFE182:
 4389              		.section	.text._Z19getMagnetometerDatah,"ax",%progbits
 4390              		.align	1
 4391              		.global	_Z19getMagnetometerDatah
 4392              		.thumb
 4393              		.thumb_func
 4395              	_Z19getMagnetometerDatah:
 4396              	.LFB183:
  57:../Libraries/AQ_Compass/Compass.h **** 
  58:../Libraries/AQ_Compass/Compass.h **** const int getMagnetometerData(byte axis) {
 4397              		.loc 20 58 0
 4398              		.cfi_startproc
 4399              		@ args = 0, pretend = 0, frame = 0
 4400              		@ frame_needed = 0, uses_anonymous_args = 0
 4401              		@ link register save eliminated.
 4402              	.LVL228:
  59:../Libraries/AQ_Compass/Compass.h ****   return measuredMag[axis];
 4403              		.loc 20 59 0
 4404 0000 0449     		ldr	r1, .L254
 4405 0002 01EB8003 		add	r3, r1, r0, lsl #2
 4406 0006 93ED000A 		flds	s0, [r3, #0]
  60:../Libraries/AQ_Compass/Compass.h **** }
 4407              		.loc 20 60 0
 4408 000a FDEEC07A 		ftosizs	s15, s0
 4409 000e 17EE900A 		fmrs	r0, s15	@ int
 4410              	.LVL229:
 4411 0012 7047     		bx	lr
 4412              	.L255:
 4413              		.align	2
 4414              	.L254:
 4415 0014 00000000 		.word	.LANCHOR69
 4416              		.cfi_endproc
 4417              	.LFE183:
 4419              		.section	.text._Z18getAbsoluteHeadingv,"ax",%progbits
 4420              		.align	1
 4421              		.global	_Z18getAbsoluteHeadingv
 4422              		.thumb
 4423              		.thumb_func
 4425              	_Z18getAbsoluteHeadingv:
 4426              	.LFB184:
  61:../Libraries/AQ_Compass/Compass.h **** 
  62:../Libraries/AQ_Compass/Compass.h **** 
  63:../Libraries/AQ_Compass/Compass.h **** const float getAbsoluteHeading() {
 4427              		.loc 20 63 0
 4428              		.cfi_startproc
 4429              		@ args = 0, pretend = 0, frame = 0
 4430              		@ frame_needed = 0, uses_anonymous_args = 0
 4431              	.LBB122:
  64:../Libraries/AQ_Compass/Compass.h ****   float heading = atan2(hdgY, hdgX);
 4432              		.loc 20 64 0
 4433 0000 1048     		ldr	r0, .L260
 4434              	.LBE122:
  63:../Libraries/AQ_Compass/Compass.h **** const float getAbsoluteHeading() {
 4435              		.loc 20 63 0
 4436 0002 38B5     		push	{r3, r4, r5, lr}
 4437              	.LCFI46:
 4438              		.cfi_def_cfa_offset 16
 4439              		.cfi_offset 14, -4
 4440              		.cfi_offset 5, -8
 4441              		.cfi_offset 4, -12
 4442              		.cfi_offset 3, -16
 4443              	.LBB123:
 4444              		.loc 20 64 0
 4445 0004 0068     		ldr	r0, [r0, #0]	@ float
 4446 0006 FFF7FEFF 		bl	__aeabi_f2d
 4447 000a 0F4B     		ldr	r3, .L260+4
 4448 000c 0446     		mov	r4, r0
 4449 000e 1868     		ldr	r0, [r3, #0]	@ float
 4450 0010 0D46     		mov	r5, r1
 4451 0012 FFF7FEFF 		bl	__aeabi_f2d
 4452 0016 0246     		mov	r2, r0
 4453 0018 0B46     		mov	r3, r1
 4454 001a 2046     		mov	r0, r4
 4455 001c 2946     		mov	r1, r5
 4456 001e FFF7FEFF 		bl	atan2
 4457 0022 FFF7FEFF 		bl	__aeabi_d2f
 4458 0026 07EE900A 		fmsr	s15, r0
 4459              	.LVL230:
  65:../Libraries/AQ_Compass/Compass.h ****   if (heading < 0) {
 4460              		.loc 20 65 0
 4461 002a F5EEC07A 		fcmpezs	s15
 4462 002e F1EE10FA 		fmstat
  66:../Libraries/AQ_Compass/Compass.h **** 	heading += radians(360);
 4463              		.loc 20 66 0
 4464 0032 44BF     		itt	mi
 4465 0034 9FED057A 		fldsmi	s14, .L260+8
 4466 0038 77EE877A 		faddsmi	s15, s15, s14
 4467              	.LVL231:
 4468              	.LBE123:
  67:../Libraries/AQ_Compass/Compass.h ****   }
  68:../Libraries/AQ_Compass/Compass.h ****   return heading;
  69:../Libraries/AQ_Compass/Compass.h **** }
 4469              		.loc 20 69 0
 4470 003c 17EE900A 		fmrs	r0, s15
 4471 0040 38BD     		pop	{r3, r4, r5, pc}
 4472              	.L261:
 4473 0042 00BF     		.align	2
 4474              	.L260:
 4475 0044 00000000 		.word	.LANCHOR67
 4476 0048 00000000 		.word	.LANCHOR66
 4477 004c DB0FC940 		.word	1086918619
 4478              		.cfi_endproc
 4479              	.LFE184:
 4481              		.section	.text._Z23initializeHeadingFusionv,"ax",%progbits
 4482              		.align	1
 4483              		.global	_Z23initializeHeadingFusionv
 4484              		.thumb
 4485              		.thumb_func
 4487              	_Z23initializeHeadingFusionv:
 4488              	.LFB185:
 4489              		.file 21 "../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h"
   1:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** /*
   2:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   AeroQuad v3.0 - May 2011
   3:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   Copyright (c) 2011 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****  
   7:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  12:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  17:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** */
  20:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  21:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** /*
  22:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****  * eventually, it's about the normal DCM processor and I KNOW that this is heavy!
  23:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****  * Still, this is the best result I did get with my knowledge that give good attitude
  24:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****  * estimator with the AGR and pretty good true heading computation at the same time
  25:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****  * 
  26:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****  * @Kenny9999
  27:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****  * I'm open to anything more lighweight working and FLIGHT TESTED
  28:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****  */
  29:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** #ifndef _AQ_HEADING_FUSION_PROCESSOR_COMP_FILTER_
  30:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** #define _AQ_HEADING_FUSION_PROCESSOR_COMP_FILTER_
  31:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  32:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** #include "Compass.h"
  33:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  34:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** #if defined UseGPS
  35:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   #include "MagnetometerDeclinationDB.h"
  36:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** #endif  
  37:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  38:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** float trueNorthHeading = 0.0;
  39:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** float compassDeclination = 0.0;
  40:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  41:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** float filter1 = 1.0 / (1.0 + 0.002);
  42:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** float filter2 = 1 - filter1;
  43:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** int headingGyroZero = 0;
  44:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** float localHeading = 0.0;
  45:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  46:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** void initializeHeadingFusion() {
 4490              		.loc 21 46 0
 4491              		.cfi_startproc
 4492              		@ args = 0, pretend = 0, frame = 0
 4493              		@ frame_needed = 0, uses_anonymous_args = 0
  47:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  48:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   headingGyroZero = gyroZero[ZAXIS];
 4494              		.loc 21 48 0
 4495 0000 0449     		ldr	r1, .L263
 4496 0002 0548     		ldr	r0, .L263+4
 4497 0004 8A68     		ldr	r2, [r1, #8]
  46:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** void initializeHeadingFusion() {
 4498              		.loc 21 46 0
 4499 0006 08B5     		push	{r3, lr}
 4500              	.LCFI47:
 4501              		.cfi_def_cfa_offset 8
 4502              		.cfi_offset 14, -4
 4503              		.cfi_offset 3, -8
 4504              		.loc 21 48 0
 4505 0008 0260     		str	r2, [r0, #0]
  49:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   gyroHeading = getAbsoluteHeading();
 4506              		.loc 21 49 0
 4507 000a FFF7FEFF 		bl	_Z18getAbsoluteHeadingv
 4508 000e 034B     		ldr	r3, .L263+8
 4509 0010 1860     		str	r0, [r3, #0]	@ float
  50:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** }
 4510              		.loc 21 50 0
 4511 0012 08BD     		pop	{r3, pc}
 4512              	.L264:
 4513              		.align	2
 4514              	.L263:
 4515 0014 00000000 		.word	.LANCHOR31
 4516 0018 00000000 		.word	.LANCHOR70
 4517 001c 00000000 		.word	.LANCHOR28
 4518              		.cfi_endproc
 4519              	.LFE185:
 4521              		.global	__aeabi_dsub
 4522              		.global	__aeabi_dadd
 4523              		.section	.text._Z16calculateHeadingv,"ax",%progbits
 4524              		.align	1
 4525              		.global	_Z16calculateHeadingv
 4526              		.thumb
 4527              		.thumb_func
 4529              	_Z16calculateHeadingv:
 4530              	.LFB186:
  51:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  52:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** void calculateHeading() {
 4531              		.loc 21 52 0
 4532              		.cfi_startproc
 4533              		@ args = 0, pretend = 0, frame = 0
 4534              		@ frame_needed = 0, uses_anonymous_args = 0
 4535 0000 10B5     		push	{r4, lr}
 4536              	.LCFI48:
 4537              		.cfi_def_cfa_offset 8
 4538              		.cfi_offset 14, -4
 4539              		.cfi_offset 4, -8
 4540 0002 2DED028B 		fstmfdd	sp!, {d8}
 4541              	.LCFI49:
 4542              		.cfi_def_cfa_offset 16
 4543              		.cfi_offset 80, -16
 4544              	.LBB124:
  53:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  54:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   float compass = getAbsoluteHeading();
 4545              		.loc 21 54 0
 4546 0006 FFF7FEFF 		bl	_Z18getAbsoluteHeadingv
 4547              	.LVL232:
  55:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   if (compass > PI) {
 4548              		.loc 21 55 0
 4549 000a 9FED438A 		flds	s16, .L279+16
 4550 000e 07EE100A 		fmsr	s14, r0
 4551 0012 B4EEC87A 		fcmpes	s14, s16
 4552 0016 F1EE10FA 		fmstat
 4553 001a 06DD     		ble	.L266
  56:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****     compass = fmod(compass,PI) - PI;
 4554              		.loc 21 56 0
 4555 001c FFF7FEFF 		bl	__aeabi_f2d
 4556              	.LVL233:
 4557 0020 39A3     		adr	r3, .L279
 4558 0022 D3E90023 		ldrd	r2, [r3]
 4559 0026 FFF7FEFF 		bl	fmod
 4560              	.L266:
  57:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   }
  58:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  59:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   if (headingGyroZero != gyroZero[ZAXIS]) {
 4561              		.loc 21 59 0
 4562 002a 3C48     		ldr	r0, .L279+20
 4563 002c 3C4A     		ldr	r2, .L279+24
 4564 002e 8168     		ldr	r1, [r0, #8]
 4565 0030 1368     		ldr	r3, [r2, #0]
 4566 0032 3C4C     		ldr	r4, .L279+28
 4567 0034 8B42     		cmp	r3, r1
 4568 0036 3C4B     		ldr	r3, .L279+32
 4569 0038 04D0     		beq	.L268
  60:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****     gyroHeading = localHeading;
 4570              		.loc 21 60 0
 4571 003a D4F800C0 		ldr	ip, [r4, #0]	@ float
  61:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****     headingGyroZero = gyroZero[ZAXIS];
 4572              		.loc 21 61 0
 4573 003e 1160     		str	r1, [r2, #0]
  60:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****     gyroHeading = localHeading;
 4574              		.loc 21 60 0
 4575 0040 C3F800C0 		str	ip, [r3, #0]	@ float
 4576              	.L268:
  62:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   }
  63:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  64:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   float adjustedGyroHeading = fmod(gyroHeading,(PI*2));
 4577              		.loc 21 64 0
 4578 0044 1868     		ldr	r0, [r3, #0]	@ float
 4579 0046 FFF7FEFF 		bl	__aeabi_f2d
 4580 004a 31A3     		adr	r3, .L279+8
 4581 004c D3E90023 		ldrd	r2, [r3]
 4582 0050 FFF7FEFF 		bl	fmod
 4583 0054 FFF7FEFF 		bl	__aeabi_d2f
 4584 0058 07EE900A 		fmsr	s15, r0
 4585              	.LVL234:
  65:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   int divider = abs(adjustedGyroHeading) / PI;
 4586              		.loc 21 65 0
 4587 005c F5EEC07A 		fcmpezs	s15
 4588 0060 F1EE10FA 		fmstat
 4589 0064 08DD     		ble	.L276
 4590              	.LVL235:
 4591              		.loc 21 65 0 is_stmt 0 discriminator 1
 4592 0066 C7EE880A 		fdivs	s1, s15, s16
 4593 006a BDEEE00A 		ftosizs	s0, s1
 4594 006e 10EE101A 		fmrs	r1, s0	@ int
  66:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   if (adjustedGyroHeading > 0) {
  67:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****     if (divider == 1) {
 4595              		.loc 21 67 0 is_stmt 1 discriminator 1
 4596 0072 0129     		cmp	r1, #1
 4597 0074 30D1     		bne	.L272
 4598 0076 0AE0     		b	.L277
 4599              	.LVL236:
 4600              	.L276:
  65:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   int divider = abs(adjustedGyroHeading) / PI;
 4601              		.loc 21 65 0 discriminator 2
 4602 0078 F1EE671A 		fnegs	s3, s15
 4603 007c C1EE881A 		fdivs	s3, s3, s16
 4604 0080 BDEEE11A 		ftosizs	s2, s3
 4605 0084 11EE102A 		fmrs	r2, s2	@ int
  68:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 	  adjustedGyroHeading = -(PI - fmod(adjustedGyroHeading,PI));
  69:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****     }
  70:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   }
  71:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   else {
  72:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****     if (divider == 1) {
 4606              		.loc 21 72 0 discriminator 2
 4607 0088 012A     		cmp	r2, #1
 4608 008a 25D1     		bne	.L272
 4609 008c 14E0     		b	.L278
 4610              	.LVL237:
 4611              	.L277:
  68:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 	  adjustedGyroHeading = -(PI - fmod(adjustedGyroHeading,PI));
 4612              		.loc 21 68 0
 4613 008e FFF7FEFF 		bl	__aeabi_f2d
 4614              	.LVL238:
 4615 0092 1DA3     		adr	r3, .L279
 4616 0094 D3E90023 		ldrd	r2, [r3]
 4617 0098 FFF7FEFF 		bl	fmod
 4618 009c 0246     		mov	r2, r0
 4619 009e 0B46     		mov	r3, r1
 4620 00a0 19A1     		adr	r1, .L279
 4621 00a2 D1E90001 		ldrd	r0, [r1]
 4622 00a6 FFF7FEFF 		bl	__aeabi_dsub
 4623 00aa FFF7FEFF 		bl	__aeabi_d2f
 4624 00ae 07EE100A 		fmsr	s14, r0
 4625 00b2 F1EE477A 		fnegs	s15, s14
 4626              	.LVL239:
 4627 00b6 0FE0     		b	.L272
 4628              	.LVL240:
 4629              	.L278:
  73:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 	  adjustedGyroHeading = fmod(adjustedGyroHeading,PI) + PI;
 4630              		.loc 21 73 0
 4631 00b8 FFF7FEFF 		bl	__aeabi_f2d
 4632              	.LVL241:
 4633 00bc 12A3     		adr	r3, .L279
 4634 00be D3E90023 		ldrd	r2, [r3]
 4635 00c2 FFF7FEFF 		bl	fmod
 4636 00c6 10A3     		adr	r3, .L279
 4637 00c8 D3E90023 		ldrd	r2, [r3]
 4638 00cc FFF7FEFF 		bl	__aeabi_dadd
 4639 00d0 FFF7FEFF 		bl	__aeabi_d2f
 4640 00d4 07EE900A 		fmsr	s15, r0
 4641              	.LVL242:
 4642              	.L272:
  74:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****     }
  75:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   }
  76:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  77:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   // Complementry filter from http://chiefdelphi.com/media/papers/2010
  78:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   localHeading = (filter1 * adjustedGyroHeading) + (filter2 * getAbsoluteHeading());
 4643              		.loc 21 78 0
 4644 00d8 1449     		ldr	r1, .L279+36
 4645 00da 1548     		ldr	r0, .L279+40
 4646 00dc 91ED002A 		flds	s4, [r1, #0]
 4647 00e0 90ED008A 		flds	s16, [r0, #0]
 4648 00e4 67EE828A 		fmuls	s17, s15, s4
 4649 00e8 FFF7FEFF 		bl	_Z18getAbsoluteHeadingv
 4650              	.LVL243:
 4651 00ec 07EE900A 		fmsr	s15, r0
 4652 00f0 48EE278A 		fmacs	s17, s16, s15
  79:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  80:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   trueNorthHeading = localHeading;
 4653              		.loc 21 80 0
 4654 00f4 0F4B     		ldr	r3, .L279+44
  78:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   localHeading = (filter1 * adjustedGyroHeading) + (filter2 * getAbsoluteHeading());
 4655              		.loc 21 78 0
 4656 00f6 C4ED008A 		fsts	s17, [r4, #0]
 4657              		.loc 21 80 0
 4658 00fa C3ED008A 		fsts	s17, [r3, #0]
 4659              	.LBE124:
  81:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   #if defined UseGPS
  82:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****     if( compassDeclination != 0.0 ) {
  83:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 
  84:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 	  trueNorthHeading = trueNorthHeading + compassDeclination;
  85:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 	  if (trueNorthHeading > M_PI)  {  // Angle normalization (-180 deg, 180 deg)
  86:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 	    trueNorthHeading -= (2.0 * M_PI);
  87:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 	  } 
  88:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 	  else if (trueNorthHeading < -M_PI){
  89:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 	    trueNorthHeading += (2.0 * M_PI);
  90:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** 	  }
  91:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****     }
  92:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h ****   #endif
  93:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** }
 4660              		.loc 21 93 0
 4661 00fe BDEC028B 		fldmfdd	sp!, {d8}
 4662 0102 10BD     		pop	{r4, pc}
 4663              	.L280:
 4664 0104 AFF30080 		.align	3
 4665              	.L279:
 4666 0108 00000060 		.word	1610612736
 4667 010c FB210940 		.word	1074340347
 4668 0110 00000060 		.word	1610612736
 4669 0114 FB211940 		.word	1075388923
 4670 0118 DB0F4940 		.word	1078530011
 4671 011c 00000000 		.word	.LANCHOR31
 4672 0120 00000000 		.word	.LANCHOR70
 4673 0124 00000000 		.word	.LANCHOR71
 4674 0128 00000000 		.word	.LANCHOR28
 4675 012c 00000000 		.word	.LANCHOR72
 4676 0130 00000000 		.word	.LANCHOR73
 4677 0134 00000000 		.word	.LANCHOR74
 4678              		.cfi_endproc
 4679              	.LFE186:
 4681              		.section	.text._Z15readSpecificMagPf,"ax",%progbits
 4682              		.align	1
 4683              		.global	_Z15readSpecificMagPf
 4684              		.thumb
 4685              		.thumb_func
 4687              	_Z15readSpecificMagPf:
 4688              	.LFB189:
 4689              		.file 22 "../Libraries/AQ_Compass/Magnetometer_HMC5883L.h"
   1:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** /*
   2:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** 
   7:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   This program is free software: you can redistribute it and/or modify
   8:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   it under the terms of the GNU General Public License as published by
   9:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   the Free Software Foundation, either version 3 of the License, or
  10:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   (at your option) any later version.
  11:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** 
  12:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   This program is distributed in the hope that it will be useful,
  13:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   GNU General Public License for more details.
  16:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** 
  17:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   You should have received a copy of the GNU General Public License
  18:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** */
  20:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** 
  21:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** 
  22:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** #ifndef _AEROQUAD_MAGNETOMETER_HMC5883L_H_
  23:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** #define _AEROQUAD_MAGNETOMETER_HMC5883L_H_
  24:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** 
  25:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** #include "Compass.h"
  26:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** 
  27:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** #include "Arduino.h"
  28:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** 
  29:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** #include "Magnetometer_HMC58xx.h"
  30:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** 
  31:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** void readSpecificMag(float *rawMag) {
 4690              		.loc 22 31 0
 4691              		.cfi_startproc
 4692              		@ args = 0, pretend = 0, frame = 0
 4693              		@ frame_needed = 0, uses_anonymous_args = 0
 4694              	.LVL244:
 4695 0000 10B5     		push	{r4, lr}
 4696              	.LCFI50:
 4697              		.cfi_def_cfa_offset 8
 4698              		.cfi_offset 14, -4
 4699              		.cfi_offset 4, -8
 4700              		.loc 22 31 0
 4701 0002 0446     		mov	r4, r0
  32:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** 
  33:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   #if defined(SPARKFUN_9DOF_5883L)
  34:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     // JI - 1/4/12 - Add _5883L to define
  35:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     // JI - 11/24/11 - SparkFun DOF on v2p1 Shield Configuration
  36:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     // JI - 11/24/11 - 5883L X axis points aft
  37:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     // JI - 11/24/11 - 5883L Sensor Orientation 3
  38:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     rawMag[XAXIS] = -readShortI2C();
  39:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     rawMag[ZAXIS] = -readShortI2C();
  40:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     rawMag[YAXIS] =  readShortI2C();
  41:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   #elif defined(SPARKFUN_5883L_BOB)
  42:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     // JI - 11/24/11 - Sparkfun 5883L Breakout Board Upside Down on v2p0 shield
  43:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     // JI - 11/24/11 - 5883L is upside down, X axis points forward
  44:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     // JI - 11/24/11 - 5883L Sensor Orientation 5
  45:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     rawMag[XAXIS] = readShortI2C();
  46:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     rawMag[ZAXIS] = readShortI2C();
  47:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     rawMag[YAXIS] = readShortI2C();
  48:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   #elif defined (HMC5883L)  // baloo
  49:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     rawMag[YAXIS] =  readShortI2C();
 4702              		.loc 22 49 0
 4703 0004 FFF7FEFF 		bl	_Z12readShortI2Cv
 4704              	.LVL245:
 4705 0008 01EE900A 		fmsr	s3, r0	@ int
 4706 000c B8EEE11A 		fsitos	s2, s3
 4707 0010 84ED011A 		fsts	s2, [r4, #4]
  50:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     rawMag[ZAXIS] = -readShortI2C();
 4708              		.loc 22 50 0
 4709 0014 FFF7FEFF 		bl	_Z12readShortI2Cv
 4710 0018 4042     		negs	r0, r0
 4711 001a 00EE900A 		fmsr	s1, r0	@ int
 4712 001e B8EEE00A 		fsitos	s0, s1
 4713 0022 84ED020A 		fsts	s0, [r4, #8]
  51:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     rawMag[XAXIS] =  readShortI2C();
 4714              		.loc 22 51 0
 4715 0026 FFF7FEFF 		bl	_Z12readShortI2Cv
 4716 002a 07EE100A 		fmsr	s14, r0	@ int
 4717 002e F8EEC77A 		fsitos	s15, s14
 4718 0032 C4ED007A 		fsts	s15, [r4, #0]
  52:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   #else 
  53:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****     #error Define HMC5883L Orientation
  54:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h ****   #endif
  55:../Libraries/AQ_Compass/Magnetometer_HMC5883L.h **** }
 4719              		.loc 22 55 0
 4720 0036 10BD     		pop	{r4, pc}
 4721              		.cfi_endproc
 4722              	.LFE189:
 4724              		.section	.text._Z19measureMagnetometerff,"ax",%progbits
 4725              		.align	1
 4726              		.global	_Z19measureMagnetometerff
 4727              		.thumb
 4728              		.thumb_func
 4730              	_Z19measureMagnetometerff:
 4731              	.LFB188:
 4732              		.file 23 "../Libraries/AQ_Compass/Magnetometer_HMC58xx.h"
   1:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** /*
   2:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   AeroQuad v3.0 - April 2011
   3:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   www.AeroQuad.com 
   4:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   Copyright (c) 2011 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****  
   7:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  12:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  17:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** */
  20:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  21:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  22:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** #ifndef _AEROQUAD_MAGNETOMETER_HMC58XX_H_
  23:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** #define _AEROQUAD_MAGNETOMETER_HMC58XX_H_
  24:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  25:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** #include "Compass.h"
  26:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  27:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** #include "Arduino.h"
  28:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  29:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** #define COMPASS_ADDRESS 0x1E
  30:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** #define COMPASS_IDENTITY 0x10
  31:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  32:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** //#define SENSOR_GAIN 0x00  // +/- 0.7 Ga
  33:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** #define SENSOR_GAIN 0x20  // +/- 1.0 Ga (default)
  34:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** //#define SENSOR_GAIN 0x40  // +/- 1.5 Ga
  35:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** //#define SENSOR_GAIN 0x60  // +/- 2.0 Ga
  36:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** //#define SENSOR_GAIN 0x80  // +/- 3.2 Ga
  37:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** //#define SENSOR_GAIN 0xA0  // +/- 3.8 Ga
  38:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** //#define SENSOR_GAIN 0xC0  // +/- 4.5 Ga
  39:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** //#define SENSOR_GAIN 0xE0  // +/- 6.5 Ga (not recommended)
  40:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  41:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** void readSpecificMag(float *rawMag);
  42:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  43:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  44:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** void initializeMagnetometer() {
  45:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  46:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   delay(10);                             // Power up delay **
  47:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****    
  48:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   if (readWhoI2C(COMPASS_ADDRESS) == COMPASS_IDENTITY) {
  49:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 	  vehicleState |= MAG_DETECTED;
  50:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   }    
  51:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  52:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   updateRegisterI2C(COMPASS_ADDRESS, 0x01, SENSOR_GAIN); // Gain as defined above
  53:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   delay(20);
  54:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   updateRegisterI2C(COMPASS_ADDRESS, 0x02, 0x01); // start single conversion
  55:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   delay(20);
  56:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  57:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measureMagnetometer(0.0, 0.0);  // Assume 1st measurement at 0 degrees roll and 0 degrees pitch
  58:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** }
  59:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  60:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** void measureMagnetometer(float roll, float pitch) {
 4733              		.loc 23 60 0
 4734              		.cfi_startproc
 4735              		@ args = 0, pretend = 0, frame = 0
 4736              		@ frame_needed = 0, uses_anonymous_args = 0
 4737              	.LVL246:
 4738 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 4739              	.LCFI51:
 4740              		.cfi_def_cfa_offset 24
 4741              		.cfi_offset 14, -4
 4742              		.cfi_offset 7, -8
 4743              		.cfi_offset 6, -12
 4744              		.cfi_offset 5, -16
 4745              		.cfi_offset 4, -20
 4746              		.cfi_offset 3, -24
 4747              	.LBB125:
  61:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****     
  62:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   sendByteI2C(COMPASS_ADDRESS, 0x03);
  63:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   Wire.requestFrom(COMPASS_ADDRESS, 6);
  64:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  65:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   readSpecificMag(rawMag);
 4748              		.loc 23 65 0
 4749 0002 4A4D     		ldr	r5, .L283
  66:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  67:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   updateRegisterI2C(COMPASS_ADDRESS, 0x02, 0x01); // start single conversion
  68:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  69:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMagX = rawMag[XAXIS] * magScale[XAXIS] + magBias[XAXIS];
  70:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMagY = rawMag[YAXIS] * magScale[YAXIS] + magBias[YAXIS];
 4750              		.loc 23 70 0
 4751 0004 4A4C     		ldr	r4, .L283+4
 4752              	.LBE125:
  60:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** void measureMagnetometer(float roll, float pitch) {
 4753              		.loc 23 60 0
 4754 0006 2DED088B 		fstmfdd	sp!, {d8, d9, d10, d11}
 4755              	.LCFI52:
 4756              		.cfi_def_cfa_offset 56
 4757              		.cfi_offset 86, -32
 4758              		.cfi_offset 84, -40
 4759              		.cfi_offset 82, -48
 4760              		.cfi_offset 80, -56
  60:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** void measureMagnetometer(float roll, float pitch) {
 4761              		.loc 23 60 0
 4762 000a 0746     		mov	r7, r0	@ float
 4763 000c 0E46     		mov	r6, r1	@ float
 4764              	.LBB126:
  62:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   sendByteI2C(COMPASS_ADDRESS, 0x03);
 4765              		.loc 23 62 0
 4766 000e 1E20     		movs	r0, #30
 4767              	.LVL247:
 4768 0010 0321     		movs	r1, #3
 4769              	.LVL248:
 4770 0012 FFF7FEFF 		bl	_Z11sendByteI2Cih
  63:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   Wire.requestFrom(COMPASS_ADDRESS, 6);
 4771              		.loc 23 63 0
 4772 0016 1E21     		movs	r1, #30
 4773 0018 0622     		movs	r2, #6
 4774 001a 4648     		ldr	r0, .L283+8
 4775 001c FFF7FEFF 		bl	_ZN7TwoWire11requestFromEii
  65:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   readSpecificMag(rawMag);
 4776              		.loc 23 65 0
 4777 0020 2846     		mov	r0, r5
 4778 0022 FFF7FEFF 		bl	_Z15readSpecificMagPf
  67:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   updateRegisterI2C(COMPASS_ADDRESS, 0x02, 0x01); // start single conversion
 4779              		.loc 23 67 0
 4780 0026 1E20     		movs	r0, #30
 4781 0028 0221     		movs	r1, #2
 4782 002a 0122     		movs	r2, #1
 4783 002c FFF7FEFF 		bl	_Z17updateRegisterI2Cihh
  69:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMagX = rawMag[XAXIS] * magScale[XAXIS] + magBias[XAXIS];
 4784              		.loc 23 69 0
 4785 0030 414B     		ldr	r3, .L283+12
 4786 0032 4248     		ldr	r0, .L283+16
 4787 0034 4249     		ldr	r1, .L283+20
  71:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMagZ = rawMag[ZAXIS] * magScale[ZAXIS] + magBias[ZAXIS];
 4788              		.loc 23 71 0
 4789 0036 434A     		ldr	r2, .L283+24
  69:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMagX = rawMag[XAXIS] * magScale[XAXIS] + magBias[XAXIS];
 4790              		.loc 23 69 0
 4791 0038 95ED004A 		flds	s8, [r5, #0]
 4792 003c D0ED004A 		flds	s9, [r0, #0]
 4793 0040 D3ED009A 		flds	s19, [r3, #0]
  70:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMagY = rawMag[YAXIS] * magScale[YAXIS] + magBias[YAXIS];
 4794              		.loc 23 70 0
 4795 0044 95ED013A 		flds	s6, [r5, #4]
  69:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMagX = rawMag[XAXIS] * magScale[XAXIS] + magBias[XAXIS];
 4796              		.loc 23 69 0
 4797 0048 44EE249A 		fmacs	s19, s8, s9
  70:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMagY = rawMag[YAXIS] * magScale[YAXIS] + magBias[YAXIS];
 4798              		.loc 23 70 0
 4799 004c D0ED013A 		flds	s7, [r0, #4]
 4800 0050 93ED019A 		flds	s18, [r3, #4]
 4801              		.loc 23 71 0
 4802 0054 95ED022A 		flds	s4, [r5, #8]
 4803 0058 D0ED022A 		flds	s5, [r0, #8]
 4804 005c D3ED028A 		flds	s17, [r3, #8]
  70:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMagY = rawMag[YAXIS] * magScale[YAXIS] + magBias[YAXIS];
 4805              		.loc 23 70 0
 4806 0060 03EE239A 		fmacs	s18, s6, s7
 4807              		.loc 23 71 0
 4808 0064 42EE228A 		fmacs	s17, s4, s5
  69:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMagX = rawMag[XAXIS] * magScale[XAXIS] + magBias[XAXIS];
 4809              		.loc 23 69 0
 4810 0068 C1ED009A 		fsts	s19, [r1, #0]
  72:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   
  73:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMag[XAXIS] = measuredMagX;
 4811              		.loc 23 73 0
 4812 006c 3649     		ldr	r1, .L283+28
  71:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMagZ = rawMag[ZAXIS] * magScale[ZAXIS] + magBias[ZAXIS];
 4813              		.loc 23 71 0
 4814 006e C2ED008A 		fsts	s17, [r2, #0]
  70:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMagY = rawMag[YAXIS] * magScale[YAXIS] + magBias[YAXIS];
 4815              		.loc 23 70 0
 4816 0072 84ED009A 		fsts	s18, [r4, #0]
  74:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMag[YAXIS] = measuredMagY;
  75:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMag[ZAXIS] = measuredMagZ;
 4817              		.loc 23 75 0
 4818 0076 C1ED028A 		fsts	s17, [r1, #8]
  76:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   
  77:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   const float cosRoll =  cos(roll);
 4819              		.loc 23 77 0
 4820 007a 3846     		mov	r0, r7	@ float
  73:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMag[XAXIS] = measuredMagX;
 4821              		.loc 23 73 0
 4822 007c C1ED009A 		fsts	s19, [r1, #0]
  74:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measuredMag[YAXIS] = measuredMagY;
 4823              		.loc 23 74 0
 4824 0080 81ED019A 		fsts	s18, [r1, #4]
 4825              		.loc 23 77 0
 4826 0084 FFF7FEFF 		bl	__aeabi_f2d
 4827 0088 0446     		mov	r4, r0
 4828 008a 0D46     		mov	r5, r1
 4829 008c FFF7FEFF 		bl	cos
 4830 0090 FFF7FEFF 		bl	__aeabi_d2f
  78:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   const float sinRoll =  sin(roll);
 4831              		.loc 23 78 0
 4832 0094 2946     		mov	r1, r5
  77:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   const float cosRoll =  cos(roll);
 4833              		.loc 23 77 0
 4834 0096 0BEE100A 		fmsr	s22, r0
 4835              	.LVL249:
 4836              		.loc 23 78 0
 4837 009a 2046     		mov	r0, r4
 4838              	.LVL250:
 4839 009c FFF7FEFF 		bl	sin
 4840 00a0 FFF7FEFF 		bl	__aeabi_d2f
 4841 00a4 0AEE900A 		fmsr	s21, r0
 4842              	.LVL251:
  79:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   const float cosPitch = cos(pitch);
 4843              		.loc 23 79 0
 4844 00a8 3046     		mov	r0, r6	@ float
 4845              	.LVL252:
 4846 00aa FFF7FEFF 		bl	__aeabi_f2d
 4847 00ae 0446     		mov	r4, r0
 4848 00b0 0D46     		mov	r5, r1
 4849 00b2 FFF7FEFF 		bl	cos
 4850 00b6 0646     		mov	r6, r0
 4851              	.LVL253:
 4852 00b8 0F46     		mov	r7, r1
 4853              	.LVL254:
  80:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   const float sinPitch = sin(pitch);
 4854              		.loc 23 80 0
 4855 00ba 2046     		mov	r0, r4
 4856 00bc 2946     		mov	r1, r5
 4857 00be FFF7FEFF 		bl	sin
 4858 00c2 FFF7FEFF 		bl	__aeabi_d2f
  79:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   const float cosPitch = cos(pitch);
 4859              		.loc 23 79 0
 4860 00c6 3946     		mov	r1, r7
 4861              		.loc 23 80 0
 4862 00c8 0AEE100A 		fmsr	s20, r0
 4863              	.LVL255:
  79:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   const float cosPitch = cos(pitch);
 4864              		.loc 23 79 0
 4865 00cc 3046     		mov	r0, r6
 4866              	.LVL256:
 4867 00ce FFF7FEFF 		bl	__aeabi_d2f
  81:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  82:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   const float magX = (float)measuredMagX * cosPitch + 
  83:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****                      (float)measuredMagY * sinRoll * sinPitch + 
  84:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****                      (float)measuredMagZ * cosRoll * sinPitch;
 4868              		.loc 23 84 0
 4869 00d2 69EE2A1A 		fmuls	s3, s18, s21
 4870 00d6 01EE100A 		fmsr	s2, r0
 4871 00da 21EE8A8A 		fmuls	s16, s3, s20
 4872 00de 09EE818A 		fmacs	s16, s19, s2
 4873 00e2 68EE8B0A 		fmuls	s1, s17, s22
  85:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****            
  86:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   const float magY = (float)measuredMagY * cosRoll - 
  87:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****                      (float)measuredMagZ * sinRoll;
 4874              		.loc 23 87 0
 4875 00e6 68EEAA8A 		fmuls	s17, s17, s21
 4876 00ea 59EE0B8A 		fmscs	s17, s18, s22
  84:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****                      (float)measuredMagZ * cosRoll * sinPitch;
 4877              		.loc 23 84 0
 4878 00ee 00EE8A8A 		fmacs	s16, s1, s20
 4879              	.LVL257:
  88:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 
  89:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   const float tmp  = sqrt(magX * magX + magY * magY);
 4880              		.loc 23 89 0
 4881 00f2 28EEA80A 		fmuls	s0, s17, s17
 4882 00f6 08EE080A 		fmacs	s0, s16, s16
  90:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****    
  91:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   hdgX = magX / tmp;
  92:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   hdgY = -magY / tmp;
 4883              		.loc 23 92 0
 4884 00fa F1EE688A 		fnegs	s17, s17
 4885              	.LVL258:
  89:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   const float tmp  = sqrt(magX * magX + magY * magY);
 4886              		.loc 23 89 0
 4887 00fe 10EE100A 		fmrs	r0, s0
 4888 0102 FFF7FEFF 		bl	__aeabi_f2d
 4889 0106 FFF7FEFF 		bl	sqrt
 4890 010a FFF7FEFF 		bl	__aeabi_d2f
 4891 010e 07EE900A 		fmsr	s15, r0
 4892              	.LVL259:
  91:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   hdgX = magX / tmp;
 4893              		.loc 23 91 0
 4894 0112 88EE277A 		fdivs	s14, s16, s15
 4895 0116 0D48     		ldr	r0, .L283+32
 4896              	.LVL260:
 4897              		.loc 23 92 0
 4898 0118 0D4B     		ldr	r3, .L283+36
 4899 011a C8EEA77A 		fdivs	s15, s17, s15
 4900              	.LVL261:
  91:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   hdgX = magX / tmp;
 4901              		.loc 23 91 0
 4902 011e 80ED007A 		fsts	s14, [r0, #0]
 4903              		.loc 23 92 0
 4904 0122 C3ED007A 		fsts	s15, [r3, #0]
 4905              	.LBE126:
  93:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** }
 4906              		.loc 23 93 0
 4907 0126 BDEC088B 		fldmfdd	sp!, {d8, d9, d10, d11}
 4908 012a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 4909              	.L284:
 4910              		.align	2
 4911              	.L283:
 4912 012c 00000000 		.word	.LANCHOR68
 4913 0130 00000000 		.word	.LANCHOR78
 4914 0134 00000000 		.word	Wire
 4915 0138 00000000 		.word	.LANCHOR76
 4916 013c 00000000 		.word	.LANCHOR75
 4917 0140 00000000 		.word	.LANCHOR77
 4918 0144 00000000 		.word	.LANCHOR79
 4919 0148 00000000 		.word	.LANCHOR69
 4920 014c 00000000 		.word	.LANCHOR66
 4921 0150 00000000 		.word	.LANCHOR67
 4922              		.cfi_endproc
 4923              	.LFE188:
 4925              		.section	.text._Z22initializeMagnetometerv,"ax",%progbits
 4926              		.align	1
 4927              		.global	_Z22initializeMagnetometerv
 4928              		.thumb
 4929              		.thumb_func
 4931              	_Z22initializeMagnetometerv:
 4932              	.LFB187:
  44:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** void initializeMagnetometer() {
 4933              		.loc 23 44 0
 4934              		.cfi_startproc
 4935              		@ args = 0, pretend = 0, frame = 0
 4936              		@ frame_needed = 0, uses_anonymous_args = 0
  46:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   delay(10);                             // Power up delay **
 4937              		.loc 23 46 0
 4938 0000 0A20     		movs	r0, #10
  44:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** void initializeMagnetometer() {
 4939              		.loc 23 44 0
 4940 0002 08B5     		push	{r3, lr}
 4941              	.LCFI53:
 4942              		.cfi_def_cfa_offset 8
 4943              		.cfi_offset 14, -4
 4944              		.cfi_offset 3, -8
  46:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   delay(10);                             // Power up delay **
 4945              		.loc 23 46 0
 4946 0004 FFF7FEFF 		bl	_Z5delaym
  48:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   if (readWhoI2C(COMPASS_ADDRESS) == COMPASS_IDENTITY) {
 4947              		.loc 23 48 0
 4948 0008 1E20     		movs	r0, #30
 4949 000a FFF7FEFF 		bl	_Z10readWhoI2Ci
 4950 000e 1028     		cmp	r0, #16
 4951 0010 04D1     		bne	.L286
  49:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** 	  vehicleState |= MAG_DETECTED;
 4952              		.loc 23 49 0
 4953 0012 0D4B     		ldr	r3, .L287
 4954 0014 1868     		ldr	r0, [r3, #0]
 4955 0016 40F00402 		orr	r2, r0, #4
 4956 001a 1A60     		str	r2, [r3, #0]
 4957              	.L286:
  52:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   updateRegisterI2C(COMPASS_ADDRESS, 0x01, SENSOR_GAIN); // Gain as defined above
 4958              		.loc 23 52 0
 4959 001c 0121     		movs	r1, #1
 4960 001e 2022     		movs	r2, #32
 4961 0020 1E20     		movs	r0, #30
 4962 0022 FFF7FEFF 		bl	_Z17updateRegisterI2Cihh
  53:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   delay(20);
 4963              		.loc 23 53 0
 4964 0026 1420     		movs	r0, #20
 4965 0028 FFF7FEFF 		bl	_Z5delaym
  54:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   updateRegisterI2C(COMPASS_ADDRESS, 0x02, 0x01); // start single conversion
 4966              		.loc 23 54 0
 4967 002c 0221     		movs	r1, #2
 4968 002e 1E20     		movs	r0, #30
 4969 0030 0122     		movs	r2, #1
 4970 0032 FFF7FEFF 		bl	_Z17updateRegisterI2Cihh
  55:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   delay(20);
 4971              		.loc 23 55 0
 4972 0036 1420     		movs	r0, #20
 4973 0038 FFF7FEFF 		bl	_Z5delaym
  57:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measureMagnetometer(0.0, 0.0);  // Assume 1st measurement at 0 degrees roll and 0 degrees pitch
 4974              		.loc 23 57 0
 4975 003c 0020     		movs	r0, #0
 4976 003e 0146     		mov	r1, r0	@ float
  58:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h **** }
 4977              		.loc 23 58 0
 4978 0040 BDE80840 		pop	{r3, lr}
  57:../Libraries/AQ_Compass/Magnetometer_HMC58xx.h ****   measureMagnetometer(0.0, 0.0);  // Assume 1st measurement at 0 degrees roll and 0 degrees pitch
 4979              		.loc 23 57 0
 4980 0044 FFF7FEBF 		b	_Z19measureMagnetometerff
 4981              	.L288:
 4982              		.align	2
 4983              	.L287:
 4984 0048 00000000 		.word	.LANCHOR21
 4985              		.cfi_endproc
 4986              	.LFE187:
 4988              		.section	.text._Z15getBaroAltitudev,"ax",%progbits
 4989              		.align	1
 4990              		.global	_Z15getBaroAltitudev
 4991              		.thumb
 4992              		.thumb_func
 4994              	_Z15getBaroAltitudev:
 4995              	.LFB190:
 4996              		.file 24 "../Libraries/AQ_BarometricSensor/BarometricSensor.h"
   1:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** /*
   2:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   www.AeroQuad.com
   4:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****  
   7:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   (at your option) any later version. 
  11:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** 
  12:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** 
  17:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** */
  20:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** 
  21:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** #ifndef _AQ_BAROMETRIC_SENSOR_
  22:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** #define _AQ_BAROMETRIC_SENSOR_
  23:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** 
  24:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** #include "Arduino.h"
  25:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** #include "GlobalDefined.h"
  26:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** 
  27:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** float baroAltitude      = 0.0; 
  28:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** float baroRawAltitude   = 0.0;
  29:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** float baroGroundAltitude = 0.0;
  30:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** float baroSmoothFactor   = 0.02;
  31:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   
  32:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** // **********************************************************************
  33:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** // The following function calls must be defined inside any new subclasses
  34:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** // **********************************************************************
  35:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** void initializeBaro(); 
  36:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** void measureBaro();
  37:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** void measureBaroSum();
  38:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** void evaluateBaroAltitude();
  39:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   
  40:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** // *********************************************************
  41:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** // The following functions are common between all subclasses
  42:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** // *********************************************************
  43:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** const float getBaroAltitude() {
 4997              		.loc 24 43 0
 4998              		.cfi_startproc
 4999              		@ args = 0, pretend = 0, frame = 0
 5000              		@ frame_needed = 0, uses_anonymous_args = 0
 5001              		@ link register save eliminated.
  44:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   return baroAltitude - baroGroundAltitude;
 5002              		.loc 24 44 0
 5003 0000 0548     		ldr	r0, .L290
 5004 0002 064B     		ldr	r3, .L290+4
 5005 0004 90ED007A 		flds	s14, [r0, #0]
 5006 0008 93ED000A 		flds	s0, [r3, #0]
  45:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** }
 5007              		.loc 24 45 0
 5008 000c 77EE407A 		fsubs	s15, s14, s0
 5009 0010 17EE900A 		fmrs	r0, s15
 5010 0014 7047     		bx	lr
 5011              	.L291:
 5012 0016 00BF     		.align	2
 5013              	.L290:
 5014 0018 00000000 		.word	.LANCHOR80
 5015 001c 00000000 		.word	.LANCHOR81
 5016              		.cfi_endproc
 5017              	.LFE190:
 5019              		.section	.text._ZL15hottv4UpdateAltv,"ax",%progbits
 5020              		.align	1
 5021              		.thumb
 5022              		.thumb_func
 5024              	_ZL15hottv4UpdateAltv:
 5025              	.LFB263:
 148:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static int32_t hottv4UpdateAlt() {
 5026              		.loc 5 148 0
 5027              		.cfi_startproc
 5028              		@ args = 0, pretend = 0, frame = 0
 5029              		@ frame_needed = 0, uses_anonymous_args = 0
 5030              	.LVL262:
 5031 0000 08B5     		push	{r3, lr}
 5032              	.LCFI54:
 5033              		.cfi_def_cfa_offset 8
 5034              		.cfi_offset 14, -4
 5035              		.cfi_offset 3, -8
 5036              	.LBB127:
 152:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   alt = (int)getBaroAltitude() + 500;  // 500 == 0m
 5037              		.loc 5 152 0
 5038 0002 FFF7FEFF 		bl	_Z15getBaroAltitudev
 5039 0006 00EE100A 		fmsr	s0, r0
 5040 000a FDEEC07A 		ftosizs	s15, s0
 161:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(alt > maxAltitude) maxAltitude = alt;
 5041              		.loc 5 161 0
 5042 000e 084B     		ldr	r3, .L295
 152:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   alt = (int)getBaroAltitude() + 500;  // 500 == 0m
 5043              		.loc 5 152 0
 5044 0010 17EE900A 		fmrs	r0, s15	@ int
 161:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(alt > maxAltitude) maxAltitude = alt;
 5045              		.loc 5 161 0
 5046 0014 1A68     		ldr	r2, [r3, #0]
 152:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   alt = (int)getBaroAltitude() + 500;  // 500 == 0m
 5047              		.loc 5 152 0
 5048 0016 00F5FA70 		add	r0, r0, #500
 5049              	.LVL263:
 161:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(alt > maxAltitude) maxAltitude = alt;
 5050              		.loc 5 161 0
 5051 001a 9042     		cmp	r0, r2
 5052 001c 01DD     		ble	.L293
 161:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(alt > maxAltitude) maxAltitude = alt;
 5053              		.loc 5 161 0 is_stmt 0 discriminator 1
 5054 001e 1860     		str	r0, [r3, #0]
 5055 0020 08BD     		pop	{r3, pc}
 5056              	.L293:
 162:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   else if(alt < minAltitude) minAltitude = alt;
 5057              		.loc 5 162 0 is_stmt 1
 5058 0022 044B     		ldr	r3, .L295+4
 5059 0024 1968     		ldr	r1, [r3, #0]
 5060 0026 8842     		cmp	r0, r1
 5061 0028 B8BF     		it	lt
 5062 002a 1860     		strlt	r0, [r3, #0]
 5063              	.LBE127:
 165:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 5064              		.loc 5 165 0
 5065 002c 08BD     		pop	{r3, pc}
 5066              	.L296:
 5067 002e 00BF     		.align	2
 5068              	.L295:
 5069 0030 00000000 		.word	.LANCHOR82
 5070 0034 00000000 		.word	.LANCHOR83
 5071              		.cfi_endproc
 5072              	.LFE263:
 5074              		.section	.text._Z10MS5611crc4Pt,"ax",%progbits
 5075              		.align	1
 5076              		.global	_Z10MS5611crc4Pt
 5077              		.thumb
 5078              		.thumb_func
 5080              	_Z10MS5611crc4Pt:
 5081              	.LFB192:
 5082              		.file 25 "../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h"
   1:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** /*
   2:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   www.AeroQuad.com
   4:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
   7:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   This program is free software: you can redistribute it and/or modify
   8:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   it under the terms of the GNU General Public License as published by
   9:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   the Free Software Foundation, either version 3 of the License, or
  10:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   (at your option) any later version.
  11:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  12:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   This program is distributed in the hope that it will be useful,
  13:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   GNU General Public License for more details.
  16:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  17:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   You should have received a copy of the GNU General Public License
  18:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** */
  20:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  21:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** // parts of this code were taken from AN520, an early version of fabio's library and the AQ BMP085 
  22:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  23:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #ifndef _AQ_BAROMETRIC_SENSOR_MS5611_
  24:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define _AQ_BAROMETRIC_SENSOR_MS5611_
  25:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  26:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #include "BarometricSensor.h"
  27:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #include "Device_I2C.h"
  28:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #include <AQMath.h>
  29:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  30:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  31:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** //#define DEBUG_MS5611
  32:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS5611_I2C_ADDRESS         0x76
  33:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  34:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_PROM_BASE_ADDR  0xA0
  35:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_PROM_REG_COUNT  8     // number of registers in the PROM
  36:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_D1_Pressure     0x40
  37:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_D2_Temperature  0x50
  38:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_RESET           0x1E
  39:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  40:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** // D1 and D2 result size (bytes)
  41:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_D1D2_SIZE       3
  42:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  43:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** // OSR (Over Sampling Ratio) constants
  44:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_OSR_256         0x00
  45:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_OSR_512         0x02
  46:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_OSR_1024        0x04
  47:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_OSR_2048        0x06
  48:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_OSR_4096        0x08
  49:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  50:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** unsigned short MS5611Prom[MS561101BA_PROM_REG_COUNT];
  51:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  52:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** long MS5611lastRawTemperature;
  53:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** long MS5611lastRawPressure;
  54:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** int64_t MS5611_sens=0;
  55:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** int64_t MS5611_offset=0;
  56:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  57:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** // taken from AN520
  58:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** unsigned char MS5611crc4(unsigned short n_prom[])
  59:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** {
 5083              		.loc 25 59 0
 5084              		.cfi_startproc
 5085              		@ args = 0, pretend = 0, frame = 0
 5086              		@ frame_needed = 0, uses_anonymous_args = 0
 5087              	.LVL264:
 5088 0000 30B5     		push	{r4, r5, lr}
 5089              	.LCFI55:
 5090              		.cfi_def_cfa_offset 12
 5091              		.cfi_offset 14, -4
 5092              		.cfi_offset 5, -8
 5093              		.cfi_offset 4, -12
 5094              	.LBB128:
  60:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	unsigned short n_rem = 0;               // crc reminder
  61:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	unsigned short crc_read;            // original value of the crc
  62:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  63:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	crc_read  = n_prom[7];               //save read CRC
 5095              		.loc 25 63 0
 5096 0002 C489     		ldrh	r4, [r0, #14]
 5097              	.LVL265:
  64:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	n_prom[7] = (0xFF00 & (n_prom[7])); //CRC byte is replaced by 0
  65:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  66:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	for (int cnt = 0; cnt < 16; cnt++) {   // operation is performed on bytes
 5098              		.loc 25 66 0
 5099 0004 0022     		movs	r2, #0
  64:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	n_prom[7] = (0xFF00 & (n_prom[7])); //CRC byte is replaced by 0
 5100              		.loc 25 64 0
 5101 0006 24F0FF03 		bic	r3, r4, #255
 5102 000a C381     		strh	r3, [r0, #14]	@ movhi
 5103              	.LVL266:
  60:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	unsigned short n_rem = 0;               // crc reminder
 5104              		.loc 25 60 0
 5105 000c 1346     		mov	r3, r2
 5106              	.LVL267:
 5107              	.L303:
 5108 000e 5110     		asrs	r1, r2, #1
 5109              	.LBB129:
 5110              	.LBB130:
  67:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	    // choose LSB or MSB
  68:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		if (cnt%2 == 1) {
 5111              		.loc 25 68 0
 5112 0010 12F0010F 		tst	r2, #1
  69:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			n_rem ^= (n_prom[cnt>>1]) & 0x00FF;
 5113              		.loc 25 69 0
 5114 0014 15BF     		itete	ne
 5115 0016 10F81110 		ldrbne	r1, [r0, r1, lsl #1]	@ zero_extendqisi2
  70:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		} else {
  71:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			n_rem ^= n_prom[cnt>>1] >> 8;
 5116              		.loc 25 71 0
 5117 001a 30F81110 		ldrheq	r1, [r0, r1, lsl #1]
  69:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			n_rem ^= (n_prom[cnt>>1]) & 0x00FF;
 5118              		.loc 25 69 0
 5119 001e 4B40     		eorne	r3, r1, r3
 5120              	.LVL268:
 5121              		.loc 25 71 0
 5122 0020 83EA1123 		eoreq	r3, r3, r1, lsr #8
 5123              	.LVL269:
 5124              	.LBE130:
 5125              	.LBE129:
  60:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	unsigned short n_rem = 0;               // crc reminder
 5126              		.loc 25 60 0
 5127 0024 0821     		movs	r1, #8
 5128              	.LVL270:
 5129              	.L302:
 5130              	.LBB133:
 5131              	.LBB132:
 5132              	.LBB131:
  72:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		}
  73:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  74:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		for (int n_bit = 8; n_bit > 0; n_bit--) {
  75:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			if (n_rem & (0x8000)) {
 5133              		.loc 25 75 0
 5134 0026 13F4004F 		tst	r3, #32768
 5135 002a 4FEA4303 		lsl	r3, r3, #1
  76:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 				n_rem = (n_rem << 1) ^ 0x3000;
 5136              		.loc 25 76 0
 5137 002e 1DBF     		ittte	ne
 5138 0030 83F44055 		eorne	r5, r3, #12288
 5139 0034 4FF6FE73 		movwne	r3, #65534
 5140 0038 2B40     		andne	r3, r5, r3
 5141              	.LVL271:
  77:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			} else {
  78:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 				n_rem = (n_rem << 1);
 5142              		.loc 25 78 0
 5143 003a 9BB2     		uxtheq	r3, r3
 5144              	.LVL272:
  74:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		for (int n_bit = 8; n_bit > 0; n_bit--) {
 5145              		.loc 25 74 0
 5146 003c 0139     		subs	r1, r1, #1
 5147 003e F2D1     		bne	.L302
 5148              	.LBE131:
 5149              	.LBE132:
  66:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	for (int cnt = 0; cnt < 16; cnt++) {   // operation is performed on bytes
 5150              		.loc 25 66 0
 5151 0040 0132     		adds	r2, r2, #1
 5152              	.LVL273:
 5153 0042 102A     		cmp	r2, #16
 5154 0044 E3D1     		bne	.L303
 5155              	.LVL274:
 5156              	.LBE133:
  79:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			}
  80:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		}
  81:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	}
  82:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  83:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	n_rem = (n_rem >> 12) & 0xF; // // final 4-bit reminder is CRC code
  84:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  85:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	n_prom[7] = crc_read; // restore the crc_read to its original place
 5157              		.loc 25 85 0
 5158 0046 C481     		strh	r4, [r0, #14]	@ movhi
 5159              	.LBE128:
  86:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  87:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	return (n_rem);
  88:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5160              		.loc 25 88 0
 5161 0048 180B     		lsrs	r0, r3, #12
 5162              	.LVL275:
 5163 004a 30BD     		pop	{r4, r5, pc}
 5164              		.cfi_endproc
 5165              	.LFE192:
 5167              		.section	.text._Z14MS5611readPROMi,"ax",%progbits
 5168              		.align	1
 5169              		.global	_Z14MS5611readPROMi
 5170              		.thumb
 5171              		.thumb_func
 5173              	_Z14MS5611readPROMi:
 5174              	.LFB193:
  89:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  90:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** int MS5611readPROM(int addr)
  91:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** {
 5175              		.loc 25 91 0
 5176              		.cfi_startproc
 5177              		@ args = 0, pretend = 0, frame = 0
 5178              		@ frame_needed = 0, uses_anonymous_args = 0
 5179              	.LVL276:
 5180 0000 70B5     		push	{r4, r5, r6, lr}
 5181              	.LCFI56:
 5182              		.cfi_def_cfa_offset 16
 5183              		.cfi_offset 14, -4
 5184              		.cfi_offset 6, -8
 5185              		.cfi_offset 5, -12
 5186              		.cfi_offset 4, -16
 5187              	.LBB134:
 5188              	.LBB135:
  92:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	for (int i=0;i<MS561101BA_PROM_REG_COUNT; i++) {
  93:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		sendByteI2C(addr, MS561101BA_PROM_BASE_ADDR + 2*i);
  94:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		if(Wire.requestFrom(addr, 2) == 2) {
  95:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			MS5611Prom[i] = readWordI2C();
  96:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			//print("%d  %5d\r\n", i, MS5611Prom[i]);
  97:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		} else {
  98:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			return 0;
 5189              		.loc 25 98 0
 5190 0002 124D     		ldr	r5, .L311
 5191              	.LBE135:
 5192              	.LBE134:
  91:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** {
 5193              		.loc 25 91 0
 5194 0004 0646     		mov	r6, r0
 5195 0006 A024     		movs	r4, #160
 5196              	.LVL277:
 5197              	.L308:
 5198              	.LBB138:
 5199              	.LBB136:
  93:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		sendByteI2C(addr, MS561101BA_PROM_BASE_ADDR + 2*i);
 5200              		.loc 25 93 0
 5201 0008 3046     		mov	r0, r6
 5202 000a 2146     		mov	r1, r4
 5203 000c FFF7FEFF 		bl	_Z11sendByteI2Cih
  94:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		if(Wire.requestFrom(addr, 2) == 2) {
 5204              		.loc 25 94 0
 5205 0010 0222     		movs	r2, #2
 5206 0012 0F48     		ldr	r0, .L311+4
 5207 0014 3146     		mov	r1, r6
 5208 0016 FFF7FEFF 		bl	_ZN7TwoWire11requestFromEii
 5209 001a 0228     		cmp	r0, #2
 5210 001c 13D1     		bne	.L309
  95:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			MS5611Prom[i] = readWordI2C();
 5211              		.loc 25 95 0
 5212 001e FFF7FEFF 		bl	_Z11readWordI2Cv
 5213 0022 0234     		adds	r4, r4, #2
 5214 0024 E4B2     		uxtb	r4, r4
  92:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	for (int i=0;i<MS561101BA_PROM_REG_COUNT; i++) {
 5215              		.loc 25 92 0
 5216 0026 B02C     		cmp	r4, #176
  95:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			MS5611Prom[i] = readWordI2C();
 5217              		.loc 25 95 0
 5218 0028 25F8020F 		strh	r0, [r5, #2]!	@ movhi
  92:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	for (int i=0;i<MS561101BA_PROM_REG_COUNT; i++) {
 5219              		.loc 25 92 0
 5220 002c ECD1     		bne	.L308
 5221              	.LBE136:
  99:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		}
 100:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	}
 101:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 102:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	int crc     = MS5611crc4(MS5611Prom);
 5222              		.loc 25 102 0
 5223 002e 094C     		ldr	r4, .L311+8
 5224 0030 2046     		mov	r0, r4
 5225 0032 FFF7FEFF 		bl	_Z10MS5611crc4Pt
 5226              	.LVL278:
 103:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	int crcProm = MS5611Prom[7] & 0xf;
 5227              		.loc 25 103 0
 5228 0036 E289     		ldrh	r2, [r4, #14]
 5229 0038 02F00F01 		and	r1, r2, #15
  98:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			return 0;
 5230              		.loc 25 98 0
 5231 003c 431A     		subs	r3, r0, r1
 5232 003e 5842     		rsbs	r0, r3, #0
 5233              	.LVL279:
 5234 0040 40EB0300 		adc	r0, r0, r3
 5235 0044 70BD     		pop	{r4, r5, r6, pc}
 5236              	.LVL280:
 5237              	.L309:
 5238              	.LBB137:
 5239 0046 0020     		movs	r0, #0
 5240              	.LBE137:
 5241              	.LBE138:
 104:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	//print("crc calculated %d,  prom %d, crc is %s\r\n", crc, crcProm, (crc == crcProm) ? "good" : "b
 105:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	if(crc == crcProm) {
 106:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		return 1;
 107:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	}
 108:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	return 0;
 109:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5242              		.loc 25 109 0
 5243 0048 70BD     		pop	{r4, r5, r6, pc}
 5244              	.L312:
 5245 004a 00BF     		.align	2
 5246              	.L311:
 5247 004c FEFFFFFF 		.word	.LANCHOR84-2
 5248 0050 00000000 		.word	Wire
 5249 0054 00000000 		.word	.LANCHOR84
 5250              		.cfi_endproc
 5251              	.LFE193:
 5253              		.section	.text._Z11MS5611reseti,"ax",%progbits
 5254              		.align	1
 5255              		.global	_Z11MS5611reseti
 5256              		.thumb
 5257              		.thumb_func
 5259              	_Z11MS5611reseti:
 5260              	.LFB194:
 110:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 111:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void MS5611reset(int addr) {
 5261              		.loc 25 111 0
 5262              		.cfi_startproc
 5263              		@ args = 0, pretend = 0, frame = 0
 5264              		@ frame_needed = 0, uses_anonymous_args = 0
 5265              		@ link register save eliminated.
 5266              	.LVL281:
 112:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	sendByteI2C(addr, MS561101BA_RESET);
 5267              		.loc 25 112 0
 5268 0000 1E21     		movs	r1, #30
 113:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5269              		.loc 25 113 0
 112:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	sendByteI2C(addr, MS561101BA_RESET);
 5270              		.loc 25 112 0
 5271 0002 FFF7FEBF 		b	_Z11sendByteI2Cih
 5272              	.LVL282:
 5273              		.cfi_endproc
 5274              	.LFE194:
 5276              		.section	.text._Z20MS5611readConversioni,"ax",%progbits
 5277              		.align	1
 5278              		.global	_Z20MS5611readConversioni
 5279              		.thumb
 5280              		.thumb_func
 5282              	_Z20MS5611readConversioni:
 5283              	.LFB195:
 114:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 115:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 116:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 117:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** float pressure			 = 0;
 118:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** long rawPressure         = 0;
 119:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** long rawTemperature      = 0;
 120:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** byte pressureCount       = 0;
 121:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** float pressureFactor     = 1/5.255;
 122:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** boolean isReadPressure   = false;
 123:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** float rawPressureSum     = 0;
 124:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** byte rawPressureSumCount = 0;
 125:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 126:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** unsigned long MS5611readConversion(int addr) {
 5284              		.loc 25 126 0
 5285              		.cfi_startproc
 5286              		@ args = 0, pretend = 0, frame = 0
 5287              		@ frame_needed = 0, uses_anonymous_args = 0
 5288              	.LVL283:
 5289 0000 10B5     		push	{r4, lr}
 5290              	.LCFI57:
 5291              		.cfi_def_cfa_offset 8
 5292              		.cfi_offset 14, -4
 5293              		.cfi_offset 4, -8
 5294              	.LBB139:
 127:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   unsigned long conversion = 0;
 128:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 129:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   // start read sequence
 130:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   sendByteI2C(addr, 0);
 5295              		.loc 25 130 0
 5296 0002 0021     		movs	r1, #0
 5297              	.LBE139:
 126:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** unsigned long MS5611readConversion(int addr) {
 5298              		.loc 25 126 0
 5299 0004 0446     		mov	r4, r0
 5300              	.LBB140:
 5301              		.loc 25 130 0
 5302 0006 FFF7FEFF 		bl	_Z11sendByteI2Cih
 5303              	.LVL284:
 131:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Wire.requestFrom(addr, MS561101BA_D1D2_SIZE);
 5304              		.loc 25 131 0
 5305 000a 0322     		movs	r2, #3
 5306 000c 2146     		mov	r1, r4
 5307 000e 0B48     		ldr	r0, .L317
 5308 0010 FFF7FEFF 		bl	_ZN7TwoWire11requestFromEii
 132:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   if(Wire.available() == MS561101BA_D1D2_SIZE) {
 5309              		.loc 25 132 0
 5310 0014 0948     		ldr	r0, .L317
 5311 0016 FFF7FEFF 		bl	_ZN7TwoWire9availableEv
 5312 001a 0328     		cmp	r0, #3
 5313 001c 0BD1     		bne	.L316
 133:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     conversion = (readByteI2C() << 16) | (readByteI2C() << 8) | (readByteI2C() << 0);
 5314              		.loc 25 133 0
 5315 001e FFF7FEFF 		bl	_Z11readByteI2Cv
 5316 0022 0446     		mov	r4, r0
 5317              	.LVL285:
 5318 0024 FFF7FEFF 		bl	_Z11readByteI2Cv
 5319 0028 0002     		lsls	r0, r0, #8
 5320 002a 40EA0444 		orr	r4, r0, r4, lsl #16
 5321 002e FFF7FEFF 		bl	_Z11readByteI2Cv
 5322 0032 2043     		orrs	r0, r0, r4
 5323              	.LVL286:
 5324 0034 10BD     		pop	{r4, pc}
 5325              	.LVL287:
 5326              	.L316:
 134:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   } else {
 135:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     conversion = 0;
 5327              		.loc 25 135 0
 5328 0036 0020     		movs	r0, #0
 5329              	.LVL288:
 5330              	.LBE140:
 136:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   }
 137:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 138:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   return conversion;
 139:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5331              		.loc 25 139 0
 5332 0038 10BD     		pop	{r4, pc}
 5333              	.L318:
 5334 003a 00BF     		.align	2
 5335              	.L317:
 5336 003c 00000000 		.word	Wire
 5337              		.cfi_endproc
 5338              	.LFE195:
 5340              		.section	.text._Z21requestRawTemperaturev,"ax",%progbits
 5341              		.align	1
 5342              		.global	_Z21requestRawTemperaturev
 5343              		.thumb
 5344              		.thumb_func
 5346              	_Z21requestRawTemperaturev:
 5347              	.LFB196:
 140:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 141:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 142:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void requestRawTemperature()
 143:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** {
 5348              		.loc 25 143 0
 5349              		.cfi_startproc
 5350              		@ args = 0, pretend = 0, frame = 0
 5351              		@ frame_needed = 0, uses_anonymous_args = 0
 5352              		@ link register save eliminated.
 144:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   sendByteI2C(MS5611_I2C_ADDRESS, MS561101BA_D2_Temperature + MS561101BA_OSR_4096);
 5353              		.loc 25 144 0
 5354 0000 7620     		movs	r0, #118
 5355 0002 5821     		movs	r1, #88
 145:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5356              		.loc 25 145 0
 144:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   sendByteI2C(MS5611_I2C_ADDRESS, MS561101BA_D2_Temperature + MS561101BA_OSR_4096);
 5357              		.loc 25 144 0
 5358 0004 FFF7FEBF 		b	_Z11sendByteI2Cih
 5359              		.cfi_endproc
 5360              	.LFE196:
 5362              		.section	.text._Z18readRawTemperaturev,"ax",%progbits
 5363              		.align	1
 5364              		.global	_Z18readRawTemperaturev
 5365              		.thumb
 5366              		.thumb_func
 5368              	_Z18readRawTemperaturev:
 5369              	.LFB197:
 146:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 147:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 148:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** unsigned long readRawTemperature()
 149:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** {
 5370              		.loc 25 149 0
 5371              		.cfi_startproc
 5372              		@ args = 0, pretend = 0, frame = 0
 5373              		@ frame_needed = 0, uses_anonymous_args = 0
 5374 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 5375              	.LCFI58:
 5376              		.cfi_def_cfa_offset 32
 5377              		.cfi_offset 14, -4
 5378              		.cfi_offset 9, -8
 5379              		.cfi_offset 8, -12
 5380              		.cfi_offset 7, -16
 5381              		.cfi_offset 6, -20
 5382              		.cfi_offset 5, -24
 5383              		.cfi_offset 4, -28
 5384              		.cfi_offset 3, -32
 5385              	.LBB141:
 150:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   // see datasheet page 7 for formulas
 151:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611lastRawTemperature = MS5611readConversion(MS5611_I2C_ADDRESS);
 5386              		.loc 25 151 0
 5387 0004 7620     		movs	r0, #118
 5388 0006 FFF7FEFF 		bl	_Z20MS5611readConversioni
 152:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   int64_t dT     = MS5611lastRawTemperature - (((long)MS5611Prom[5]) << 8);
 5389              		.loc 25 152 0
 5390 000a 1849     		ldr	r1, .L321
 151:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611lastRawTemperature = MS5611readConversion(MS5611_I2C_ADDRESS);
 5391              		.loc 25 151 0
 5392 000c 184A     		ldr	r2, .L321+4
 153:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611_offset  = (((int64_t)MS5611Prom[2]) << 16) + ((MS5611Prom[4] * dT) >> 7);
 5393              		.loc 25 153 0
 5394 000e 8B88     		ldrh	r3, [r1, #4]
 152:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   int64_t dT     = MS5611lastRawTemperature - (((long)MS5611Prom[5]) << 8);
 5395              		.loc 25 152 0
 5396 0010 4C89     		ldrh	r4, [r1, #10]
 151:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611lastRawTemperature = MS5611readConversion(MS5611_I2C_ADDRESS);
 5397              		.loc 25 151 0
 5398 0012 1060     		str	r0, [r2, #0]
 5399              		.loc 25 153 0
 5400 0014 4FEA0348 		lsl	r8, r3, #16
 152:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   int64_t dT     = MS5611lastRawTemperature - (((long)MS5611Prom[5]) << 8);
 5401              		.loc 25 152 0
 5402 0018 2402     		lsls	r4, r4, #8
 5403              		.loc 25 153 0
 5404 001a 0B89     		ldrh	r3, [r1, #8]
 5405 001c 154D     		ldr	r5, .L321+8
 152:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   int64_t dT     = MS5611lastRawTemperature - (((long)MS5611Prom[5]) << 8);
 5406              		.loc 25 152 0
 5407 001e 041B     		subs	r4, r0, r4
 5408              		.loc 25 153 0
 5409 0020 A3FB0467 		umull	r6, r7, r3, r4
 152:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   int64_t dT     = MS5611lastRawTemperature - (((long)MS5611Prom[5]) << 8);
 5410              		.loc 25 152 0
 5411 0024 4FEAE47C 		asr	ip, r4, #31
 5412              	.LVL289:
 5413              		.loc 25 153 0
 5414 0028 03FB0C77 		mla	r7, r3, ip, r7
 5415 002c F209     		lsrs	r2, r6, #7
 5416 002e 42EA4762 		orr	r2, r2, r7, lsl #25
 5417 0032 FB11     		asrs	r3, r7, #7
 5418 0034 4FF00009 		mov	r9, #0
 5419 0038 12EB0802 		adds	r2, r2, r8
 5420 003c 43EB0903 		adc	r3, r3, r9
 5421 0040 C5E90023 		strd	r2, [r5]
 154:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611_sens    = (((int64_t)MS5611Prom[1]) << 15) + ((MS5611Prom[3] * dT) >> 8);
 5422              		.loc 25 154 0
 5423 0044 4B88     		ldrh	r3, [r1, #2]
 5424 0046 DE03     		lsls	r6, r3, #15
 5425 0048 CB88     		ldrh	r3, [r1, #6]
 5426 004a 0B49     		ldr	r1, .L321+12
 5427 004c A3FB0445 		umull	r4, r5, r3, r4
 5428              	.LVL290:
 5429 0050 03FB0C55 		mla	r5, r3, ip, r5
 5430 0054 220A     		lsrs	r2, r4, #8
 5431 0056 42EA0562 		orr	r2, r2, r5, lsl #24
 5432 005a 0027     		movs	r7, #0
 5433 005c 2B12     		asrs	r3, r5, #8
 5434 005e 9219     		adds	r2, r2, r6
 5435 0060 43EB0703 		adc	r3, r3, r7
 5436 0064 C1E90023 		strd	r2, [r1]
 5437              	.LBE141:
 155:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 156:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 157:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #ifdef DEBUG_MS5611
 158:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Serial.print(" rT: ");
 159:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Serial.print(MS5611lastRawTemperature);
 160:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #endif
 161:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 162:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   return MS5611lastRawTemperature;
 163:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5438              		.loc 25 163 0
 5439 0068 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 5440              	.L322:
 5441              		.align	2
 5442              	.L321:
 5443 006c 00000000 		.word	.LANCHOR84
 5444 0070 00000000 		.word	.LANCHOR85
 5445 0074 00000000 		.word	.LANCHOR86
 5446 0078 00000000 		.word	.LANCHOR87
 5447              		.cfi_endproc
 5448              	.LFE197:
 5450              		.global	__aeabi_l2f
 5451              		.section	.text._Z15readTemperaturev,"ax",%progbits
 5452              		.align	1
 5453              		.global	_Z15readTemperaturev
 5454              		.thumb
 5455              		.thumb_func
 5457              	_Z15readTemperaturev:
 5458              	.LFB198:
 164:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 165:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 166:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** float readTemperature()
 167:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** {
 5459              		.loc 25 167 0
 5460              		.cfi_startproc
 5461              		@ args = 0, pretend = 0, frame = 0
 5462              		@ frame_needed = 0, uses_anonymous_args = 0
 5463 0000 38B5     		push	{r3, r4, r5, lr}
 5464              	.LCFI59:
 5465              		.cfi_def_cfa_offset 16
 5466              		.cfi_offset 14, -4
 5467              		.cfi_offset 5, -8
 5468              		.cfi_offset 4, -12
 5469              		.cfi_offset 3, -16
 168:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   return ((1<<5)*2000 + (((MS5611lastRawTemperature - ((int64_t)MS5611Prom[5] << 8)) * MS5611Prom[6
 5470              		.loc 25 168 0
 5471 0002 124D     		ldr	r5, .L324
 5472 0004 124B     		ldr	r3, .L324+4
 5473 0006 6C89     		ldrh	r4, [r5, #10]
 5474 0008 1968     		ldr	r1, [r3, #0]
 5475 000a 2002     		lsls	r0, r4, #8
 5476 000c CB17     		asrs	r3, r1, #31
 5477 000e AC89     		ldrh	r4, [r5, #12]
 5478 0010 0A46     		mov	r2, r1
 5479 0012 0021     		movs	r1, #0
 5480 0014 121A     		subs	r2, r2, r0
 5481 0016 63EB0103 		sbc	r3, r3, r1
 5482 001a A2FB0401 		umull	r0, r1, r2, r4
 5483 001e 04FB0311 		mla	r1, r4, r3, r1
 5484 0022 820C     		lsrs	r2, r0, #18
 5485 0024 42EA8132 		orr	r2, r2, r1, lsl #14
 5486 0028 4FF47A40 		mov	r0, #64000
 5487 002c 8B14     		asrs	r3, r1, #18
 5488 002e 0021     		movs	r1, #0
 5489 0030 8018     		adds	r0, r0, r2
 5490 0032 41EB0301 		adc	r1, r1, r3
 5491 0036 FFF7FEFF 		bl	__aeabi_l2f
 169:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5492              		.loc 25 169 0
 5493 003a DFED067A 		flds	s15, .L324+8
 5494 003e 06EE900A 		fmsr	s13, r0
 5495 0042 C6EEA76A 		fdivs	s13, s13, s15
 5496 0046 16EE900A 		fmrs	r0, s13
 5497 004a 38BD     		pop	{r3, r4, r5, pc}
 5498              	.L325:
 5499              		.align	2
 5500              	.L324:
 5501 004c 00000000 		.word	.LANCHOR84
 5502 0050 00000000 		.word	.LANCHOR85
 5503 0054 00004845 		.word	1162346496
 5504              		.cfi_endproc
 5505              	.LFE198:
 5507              		.section	.text._Z18requestRawPressurev,"ax",%progbits
 5508              		.align	1
 5509              		.global	_Z18requestRawPressurev
 5510              		.thumb
 5511              		.thumb_func
 5513              	_Z18requestRawPressurev:
 5514              	.LFB199:
 170:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 171:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void requestRawPressure()
 172:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** {
 5515              		.loc 25 172 0
 5516              		.cfi_startproc
 5517              		@ args = 0, pretend = 0, frame = 0
 5518              		@ frame_needed = 0, uses_anonymous_args = 0
 5519              		@ link register save eliminated.
 173:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   sendByteI2C(MS5611_I2C_ADDRESS, MS561101BA_D1_Pressure + MS561101BA_OSR_4096);
 5520              		.loc 25 173 0
 5521 0000 7620     		movs	r0, #118
 5522 0002 4821     		movs	r1, #72
 174:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5523              		.loc 25 174 0
 173:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   sendByteI2C(MS5611_I2C_ADDRESS, MS561101BA_D1_Pressure + MS561101BA_OSR_4096);
 5524              		.loc 25 173 0
 5525 0004 FFF7FEBF 		b	_Z11sendByteI2Cih
 5526              		.cfi_endproc
 5527              	.LFE199:
 5529              		.section	.text._Z15readRawPressurev,"ax",%progbits
 5530              		.align	1
 5531              		.global	_Z15readRawPressurev
 5532              		.thumb
 5533              		.thumb_func
 5535              	_Z15readRawPressurev:
 5536              	.LFB200:
 175:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 176:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** float readRawPressure()
 177:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** {
 5537              		.loc 25 177 0
 5538              		.cfi_startproc
 5539              		@ args = 0, pretend = 0, frame = 0
 5540              		@ frame_needed = 0, uses_anonymous_args = 0
 5541 0000 38B5     		push	{r3, r4, r5, lr}
 5542              	.LCFI60:
 5543              		.cfi_def_cfa_offset 16
 5544              		.cfi_offset 14, -4
 5545              		.cfi_offset 5, -8
 5546              		.cfi_offset 4, -12
 5547              		.cfi_offset 3, -16
 178:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611lastRawPressure = MS5611readConversion(MS5611_I2C_ADDRESS);
 5548              		.loc 25 178 0
 5549 0002 7620     		movs	r0, #118
 5550 0004 FFF7FEFF 		bl	_Z20MS5611readConversioni
 5551 0008 124B     		ldr	r3, .L328
 179:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #ifdef DEBUG_MS5611
 180:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   //print(" dT: %6d  off: %6u p %6u  sens: %6d  ", (int32)dT, (unsigned int32)off, (unsigned int32)
 181:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Serial.print(" rP: ");
 182:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Serial.print(MS5611lastRawPressure);
 183:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #endif
 184:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 185:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   return (((( MS5611lastRawPressure * MS5611_sens) >> 21) - MS5611_offset) >> (15-5)) / ((float)(1<
 5552              		.loc 25 185 0
 5553 000a 1349     		ldr	r1, .L328+4
 178:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611lastRawPressure = MS5611readConversion(MS5611_I2C_ADDRESS);
 5554              		.loc 25 178 0
 5555 000c 1860     		str	r0, [r3, #0]
 5556              		.loc 25 185 0
 5557 000e 0B68     		ldr	r3, [r1, #0]
 5558 0010 4968     		ldr	r1, [r1, #4]
 5559 0012 C217     		asrs	r2, r0, #31
 5560 0014 4143     		muls	r1, r0, r1
 5561 0016 03FB0212 		mla	r2, r3, r2, r1
 5562 001a A3FB0001 		umull	r0, r1, r3, r0
 5563 001e 0F4B     		ldr	r3, .L328+8
 5564 0020 5118     		adds	r1, r2, r1
 5565 0022 D3E90023 		ldrd	r2, [r3]
 5566 0026 440D     		lsrs	r4, r0, #21
 5567 0028 44EAC124 		orr	r4, r4, r1, lsl #11
 5568 002c 4D15     		asrs	r5, r1, #21
 5569 002e A21A     		subs	r2, r4, r2
 5570 0030 65EB0303 		sbc	r3, r5, r3
 5571 0034 900A     		lsrs	r0, r2, #10
 5572 0036 40EA8350 		orr	r0, r0, r3, lsl #22
 5573 003a 9912     		asrs	r1, r3, #10
 5574 003c FFF7FEFF 		bl	__aeabi_l2f
 186:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5575              		.loc 25 186 0
 5576 0040 DFED077A 		flds	s15, .L328+12
 5577 0044 06EE900A 		fmsr	s13, r0
 5578 0048 66EEA76A 		fmuls	s13, s13, s15
 5579 004c 16EE900A 		fmrs	r0, s13
 5580 0050 38BD     		pop	{r3, r4, r5, pc}
 5581              	.L329:
 5582 0052 00BF     		.align	2
 5583              	.L328:
 5584 0054 00000000 		.word	.LANCHOR88
 5585 0058 00000000 		.word	.LANCHOR87
 5586 005c 00000000 		.word	.LANCHOR86
 5587 0060 0000003D 		.word	1023410176
 5588              		.cfi_endproc
 5589              	.LFE200:
 5591              		.section	.text._Z14measureBaroSumv,"ax",%progbits
 5592              		.align	1
 5593              		.global	_Z14measureBaroSumv
 5594              		.thumb
 5595              		.thumb_func
 5597              	_Z14measureBaroSumv:
 5598              	.LFB203:
 187:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 188:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** bool baroGroundUpdateDone = false;
 189:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** unsigned long baroStartTime;
 190:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 191:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void initializeBaro() {
 192:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroStartTime = micros();
 193:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 194:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressure = 0;
 195:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroGroundAltitude = 0;
 196:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressureFactor = 1/5.255;
 197:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 198:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611reset(MS5611_I2C_ADDRESS); // reset the device to populate its internal PROM registers
 199:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   delay(3); // some safety time
 200:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 201:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   if(MS5611readPROM(MS5611_I2C_ADDRESS) ) {
 202:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	  vehicleState |= BARO_DETECTED;
 203:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   }
 204:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 205:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   requestRawTemperature(); // setup up next measure() for temperature
 206:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   isReadPressure = false;
 207:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressureCount = 0;
 208:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   delay(10);
 209:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureBaroSum(); // read temperature
 210:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   delay(10);
 211:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureBaro(); // read pressure
 212:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   delay(10);
 213:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 214:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureGroundBaro();
 215:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureGroundBaro();
 216:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 217:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #if 0
 218:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   // check if measured ground altitude is valid
 219:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   while (abs(baroRawAltitude - baroGroundAltitude) > 10) {
 220:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     delay(26);
 221:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     measureGroundBaro();
 222:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   }
 223:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #endif
 224:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroAltitude = baroGroundAltitude;
 225:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 226:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 227:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void measureBaro() {
 228:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureBaroSum();
 229:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   evaluateBaroAltitude();
 230:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 231:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 232:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void measureBaroSum() {
 5599              		.loc 25 232 0
 5600              		.cfi_startproc
 5601              		@ args = 0, pretend = 0, frame = 0
 5602              		@ frame_needed = 0, uses_anonymous_args = 0
 5603 0000 38B5     		push	{r3, r4, r5, lr}
 5604              	.LCFI61:
 5605              		.cfi_def_cfa_offset 16
 5606              		.cfi_offset 14, -4
 5607              		.cfi_offset 5, -8
 5608              		.cfi_offset 4, -12
 5609              		.cfi_offset 3, -16
 233:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   // switch between pressure and temperature measurements
 234:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   if (isReadPressure) {
 5610              		.loc 25 234 0
 5611 0002 164C     		ldr	r4, .L335
 5612 0004 2378     		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 232:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void measureBaroSum() {
 5613              		.loc 25 232 0
 5614 0006 2DED028B 		fstmfdd	sp!, {d8}
 5615              	.LCFI62:
 5616              		.cfi_def_cfa_offset 24
 5617              		.cfi_offset 80, -24
 5618              		.loc 25 234 0
 5619 000a F3B1     		cbz	r3, .L331
 235:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     rawPressureSum += readRawPressure();
 5620              		.loc 25 235 0
 5621 000c 144D     		ldr	r5, .L335+4
 5622 000e 95ED008A 		flds	s16, [r5, #0]
 5623 0012 FFF7FEFF 		bl	_Z15readRawPressurev
 5624 0016 07EE900A 		fmsr	s15, r0
 236:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     rawPressureSumCount++;
 5625              		.loc 25 236 0
 5626 001a 1249     		ldr	r1, .L335+8
 235:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     rawPressureSum += readRawPressure();
 5627              		.loc 25 235 0
 5628 001c 38EE278A 		fadds	s16, s16, s15
 5629 0020 85ED008A 		fsts	s16, [r5, #0]
 5630              		.loc 25 236 0
 5631 0024 0D78     		ldrb	r5, [r1, #0]	@ zero_extendqisi2
 5632 0026 6A1C     		adds	r2, r5, #1
 237:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     if (pressureCount == 20) {
 5633              		.loc 25 237 0
 5634 0028 0F4D     		ldr	r5, .L335+12
 236:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     rawPressureSumCount++;
 5635              		.loc 25 236 0
 5636 002a 0A70     		strb	r2, [r1, #0]
 5637              		.loc 25 237 0
 5638 002c 2878     		ldrb	r0, [r5, #0]	@ zero_extendqisi2
 5639 002e 1428     		cmp	r0, #20
 5640 0030 05D1     		bne	.L332
 238:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****       requestRawTemperature();
 5641              		.loc 25 238 0
 5642 0032 FFF7FEFF 		bl	_Z21requestRawTemperaturev
 239:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****       pressureCount = 0;
 5643              		.loc 25 239 0
 5644 0036 0023     		movs	r3, #0
 5645 0038 2B70     		strb	r3, [r5, #0]
 240:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****       isReadPressure = false;
 5646              		.loc 25 240 0
 5647 003a 2370     		strb	r3, [r4, #0]
 5648 003c 01E0     		b	.L333
 5649              	.L332:
 241:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     } else {
 242:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****       requestRawPressure();
 5650              		.loc 25 242 0
 5651 003e FFF7FEFF 		bl	_Z18requestRawPressurev
 5652              	.L333:
 243:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	}
 244:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     pressureCount++;
 5653              		.loc 25 244 0
 5654 0042 2A78     		ldrb	r2, [r5, #0]	@ zero_extendqisi2
 5655 0044 501C     		adds	r0, r2, #1
 5656 0046 2870     		strb	r0, [r5, #0]
 5657 0048 05E0     		b	.L330
 5658              	.L331:
 245:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   } else { // select must equal TEMPERATURE
 246:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     readRawTemperature();
 5659              		.loc 25 246 0
 5660 004a FFF7FEFF 		bl	_Z18readRawTemperaturev
 247:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     requestRawPressure();
 5661              		.loc 25 247 0
 5662 004e FFF7FEFF 		bl	_Z18requestRawPressurev
 248:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     isReadPressure = true;
 5663              		.loc 25 248 0
 5664 0052 0121     		movs	r1, #1
 5665 0054 2170     		strb	r1, [r4, #0]
 5666              	.L330:
 249:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   }
 250:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5667              		.loc 25 250 0
 5668 0056 BDEC028B 		fldmfdd	sp!, {d8}
 5669 005a 38BD     		pop	{r3, r4, r5, pc}
 5670              	.L336:
 5671              		.align	2
 5672              	.L335:
 5673 005c 00000000 		.word	.LANCHOR89
 5674 0060 00000000 		.word	.LANCHOR90
 5675 0064 00000000 		.word	.LANCHOR91
 5676 0068 00000000 		.word	.LANCHOR92
 5677              		.cfi_endproc
 5678              	.LFE203:
 5680              		.global	__aeabi_dmul
 5681              		.section	.text._Z20evaluateBaroAltitudev,"ax",%progbits
 5682              		.align	1
 5683              		.global	_Z20evaluateBaroAltitudev
 5684              		.thumb
 5685              		.thumb_func
 5687              	_Z20evaluateBaroAltitudev:
 5688              	.LFB204:
 251:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 252:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** bool MS5611_first_read = true;
 253:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 254:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void evaluateBaroAltitude() {
 5689              		.loc 25 254 0
 5690              		.cfi_startproc
 5691              		@ args = 0, pretend = 0, frame = 0
 5692              		@ frame_needed = 0, uses_anonymous_args = 0
 5693 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 5694              	.LCFI63:
 5695              		.cfi_def_cfa_offset 24
 5696              		.cfi_offset 14, -4
 5697              		.cfi_offset 7, -8
 5698              		.cfi_offset 6, -12
 5699              		.cfi_offset 5, -16
 5700              		.cfi_offset 4, -20
 5701              		.cfi_offset 3, -24
 5702              	.LBB142:
 255:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   if (rawPressureSumCount == 0) { // it may occur at init time that no pressure has been read yet!
 5703              		.loc 25 255 0
 5704 0002 2D4D     		ldr	r5, .L341+8
 5705 0004 2B78     		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 5706 0006 002B     		cmp	r3, #0
 5707 0008 51D0     		beq	.L337
 256:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     return;
 257:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   }
 258:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 259:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressure = rawPressureSum / rawPressureSumCount;
 5708              		.loc 25 259 0
 5709 000a 06EE903A 		fmsr	s13, r3	@ int
 5710 000e 2B4C     		ldr	r4, .L341+12
 5711 0010 2B4B     		ldr	r3, .L341+16
 5712 0012 94ED007A 		flds	s14, [r4, #0]
 5713 0016 F8EEE67A 		fsitos	s15, s13
 5714 001a C7EE277A 		fdivs	s15, s14, s15
 260:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 261:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroRawAltitude = 44330 * (1 - pow(pressure/101325.0, pressureFactor)); // returns absolute baroA
 5715              		.loc 25 261 0
 5716 001e 9FED297A 		flds	s14, .L341+20
 5717 0022 C7EE876A 		fdivs	s13, s15, s14
 259:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressure = rawPressureSum / rawPressureSumCount;
 5718              		.loc 25 259 0
 5719 0026 C3ED007A 		fsts	s15, [r3, #0]
 5720              		.loc 25 261 0
 5721 002a 16EE900A 		fmrs	r0, s13
 5722 002e FFF7FEFF 		bl	__aeabi_f2d
 5723 0032 254B     		ldr	r3, .L341+24
 5724 0034 0646     		mov	r6, r0
 5725 0036 1868     		ldr	r0, [r3, #0]	@ float
 5726 0038 0F46     		mov	r7, r1
 5727 003a FFF7FEFF 		bl	__aeabi_f2d
 5728 003e 0246     		mov	r2, r0
 5729 0040 0B46     		mov	r3, r1
 5730 0042 3046     		mov	r0, r6
 5731 0044 3946     		mov	r1, r7
 5732 0046 FFF7FEFF 		bl	pow
 5733 004a 0246     		mov	r2, r0
 5734 004c 0B46     		mov	r3, r1
 5735 004e 0020     		movs	r0, #0
 5736 0050 1E49     		ldr	r1, .L341+28
 5737 0052 1F4E     		ldr	r6, .L341+32
 5738 0054 FFF7FEFF 		bl	__aeabi_dsub
 5739 0058 15A3     		adr	r3, .L341
 5740 005a D3E90023 		ldrd	r2, [r3]
 5741 005e FFF7FEFF 		bl	__aeabi_dmul
 5742 0062 FFF7FEFF 		bl	__aeabi_d2f
 5743 0066 1B4B     		ldr	r3, .L341+36
 5744 0068 1860     		str	r0, [r3, #0]	@ float
 262:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   // use calculation below in case you need a smaller binary file for CPUs having just 32KB flash R
 263:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   // baroRawAltitude = (101325.0-pressure)/4096*346;
 264:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 265:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   if(MS5611_first_read) {
 5745              		.loc 25 265 0
 5746 006a 1B4B     		ldr	r3, .L341+40
 5747 006c 1978     		ldrb	r1, [r3, #0]	@ zero_extendqisi2
 5748 006e 19B1     		cbz	r1, .L339
 266:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     baroAltitude = baroRawAltitude;
 267:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     MS5611_first_read = false;
 5749              		.loc 25 267 0
 5750 0070 0022     		movs	r2, #0
 266:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     baroAltitude = baroRawAltitude;
 5751              		.loc 25 266 0
 5752 0072 3060     		str	r0, [r6, #0]	@ float
 5753              		.loc 25 267 0
 5754 0074 1A70     		strb	r2, [r3, #0]
 5755 0076 05E0     		b	.L340
 5756              	.L339:
 268:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   } else {
 269:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     baroAltitude = filterSmooth(baroRawAltitude, baroAltitude, baroSmoothFactor);
 5757              		.loc 25 269 0
 5758 0078 184B     		ldr	r3, .L341+44
 5759 007a 3168     		ldr	r1, [r6, #0]	@ float
 5760 007c 1A68     		ldr	r2, [r3, #0]	@ float
 5761 007e FFF7FEFF 		bl	_Z12filterSmoothfff
 5762 0082 3060     		str	r0, [r6, #0]	@ float
 5763              	.L340:
 270:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   }
 271:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 272:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #ifdef DEBUG_MS5611_b
 273:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Serial.print("  p ");
 274:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Serial.print(pressure);
 275:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Serial.print("  bra ");
 276:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Serial.print(baroRawAltitude);
 277:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Serial.print("  ba ");
 278:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Serial.print(baroAltitude);
 279:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Serial.println();
 280:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #endif
 281:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 282:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   rawPressureSum = 0.0;
 5764              		.loc 25 282 0
 5765 0084 0022     		movs	r2, #0
 5766 0086 2260     		str	r2, [r4, #0]	@ float
 283:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   rawPressureSumCount = 0;
 284:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 285:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   // set ground altitude after a delay, so sensor has time to heat up
 286:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   const unsigned long updateDelayInSeconds = 10;
 287:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   if(!baroGroundUpdateDone && (micros()-baroStartTime) > updateDelayInSeconds*1000000) {
 5767              		.loc 25 287 0
 5768 0088 154C     		ldr	r4, .L341+48
 5769 008a 2078     		ldrb	r0, [r4, #0]	@ zero_extendqisi2
 283:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   rawPressureSumCount = 0;
 5770              		.loc 25 283 0
 5771 008c 0021     		movs	r1, #0
 5772 008e 2970     		strb	r1, [r5, #0]
 5773              	.LVL291:
 5774              		.loc 25 287 0
 5775 0090 68B9     		cbnz	r0, .L337
 5776              		.loc 25 287 0 is_stmt 0 discriminator 1
 5777 0092 FFF7FEFF 		bl	_ZL6microsv
 5778 0096 1349     		ldr	r1, .L341+52
 5779 0098 0B68     		ldr	r3, [r1, #0]
 5780 009a C3EB000C 		rsb	ip, r3, r0
 5781 009e 1248     		ldr	r0, .L341+56
 5782 00a0 8445     		cmp	ip, r0
 5783 00a2 04D9     		bls	.L337
 288:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	  baroGroundAltitude = baroAltitude;
 5784              		.loc 25 288 0 is_stmt 1 discriminator 4
 5785 00a4 3068     		ldr	r0, [r6, #0]	@ float
 5786 00a6 114B     		ldr	r3, .L341+60
 289:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	  baroGroundUpdateDone = true;
 5787              		.loc 25 289 0 discriminator 4
 5788 00a8 0122     		movs	r2, #1
 288:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	  baroGroundAltitude = baroAltitude;
 5789              		.loc 25 288 0 discriminator 4
 5790 00aa 1860     		str	r0, [r3, #0]	@ float
 5791              		.loc 25 289 0 discriminator 4
 5792 00ac 2270     		strb	r2, [r4, #0]
 5793              	.LVL292:
 5794              	.L337:
 5795 00ae F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 5796              	.L342:
 5797              		.align	3
 5798              	.L341:
 5799 00b0 00000000 		.word	0
 5800 00b4 40A5E540 		.word	1088791872
 5801 00b8 00000000 		.word	.LANCHOR91
 5802 00bc 00000000 		.word	.LANCHOR90
 5803 00c0 00000000 		.word	.LANCHOR93
 5804 00c4 80E6C547 		.word	1204151936
 5805 00c8 00000000 		.word	.LANCHOR94
 5806 00cc 0000F03F 		.word	1072693248
 5807 00d0 00000000 		.word	.LANCHOR80
 5808 00d4 00000000 		.word	.LANCHOR95
 5809 00d8 00000000 		.word	.LANCHOR96
 5810 00dc 00000000 		.word	.LANCHOR97
 5811 00e0 00000000 		.word	.LANCHOR98
 5812 00e4 00000000 		.word	.LANCHOR99
 5813 00e8 80969800 		.word	10000000
 5814 00ec 00000000 		.word	.LANCHOR81
 5815              	.LBE142:
 5816              		.cfi_endproc
 5817              	.LFE204:
 5819              		.section	.text._Z11measureBarov,"ax",%progbits
 5820              		.align	1
 5821              		.global	_Z11measureBarov
 5822              		.thumb
 5823              		.thumb_func
 5825              	_Z11measureBarov:
 5826              	.LFB202:
 227:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void measureBaro() {
 5827              		.loc 25 227 0
 5828              		.cfi_startproc
 5829              		@ args = 0, pretend = 0, frame = 0
 5830              		@ frame_needed = 0, uses_anonymous_args = 0
 5831 0000 08B5     		push	{r3, lr}
 5832              	.LCFI64:
 5833              		.cfi_def_cfa_offset 8
 5834              		.cfi_offset 14, -4
 5835              		.cfi_offset 3, -8
 228:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureBaroSum();
 5836              		.loc 25 228 0
 5837 0002 FFF7FEFF 		bl	_Z14measureBaroSumv
 230:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5838              		.loc 25 230 0
 5839 0006 BDE80840 		pop	{r3, lr}
 229:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   evaluateBaroAltitude();
 5840              		.loc 25 229 0
 5841 000a FFF7FEBF 		b	_Z20evaluateBaroAltitudev
 5842              		.cfi_endproc
 5843              	.LFE202:
 5845              		.section	.text._Z17measureGroundBarov,"ax",%progbits
 5846              		.align	1
 5847              		.global	_Z17measureGroundBarov
 5848              		.thumb
 5849              		.thumb_func
 5851              	_Z17measureGroundBarov:
 5852              	.LFB191:
  46:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****  
  47:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** void measureGroundBaro() {
 5853              		.loc 24 47 0
 5854              		.cfi_startproc
 5855              		@ args = 0, pretend = 0, frame = 0
 5856              		@ frame_needed = 0, uses_anonymous_args = 0
 5857              	.LVL293:
 5858 0000 10B5     		push	{r4, lr}
 5859              	.LCFI65:
 5860              		.cfi_def_cfa_offset 8
 5861              		.cfi_offset 14, -4
 5862              		.cfi_offset 4, -8
 5863 0002 2DED028B 		fstmfdd	sp!, {d8}
 5864              	.LCFI66:
 5865              		.cfi_def_cfa_offset 16
 5866              		.cfi_offset 80, -16
  48:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   // measure initial ground pressure (multiple samples)
  49:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   float altSum = 0.0;
 5867              		.loc 24 49 0
 5868 0006 9FED0C8A 		flds	s16, .L347
  47:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** void measureGroundBaro() {
 5869              		.loc 24 47 0
 5870 000a 1924     		movs	r4, #25
 5871              	.LVL294:
 5872              	.L345:
 5873              	.LBB143:
 5874              	.LBB144:
  50:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   for (int i=0; i < 25; i++) {
  51:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****     measureBaro();
 5875              		.loc 24 51 0 discriminator 2
 5876 000c FFF7FEFF 		bl	_Z11measureBarov
  52:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** 	altSum += baroRawAltitude;
 5877              		.loc 24 52 0 discriminator 2
 5878 0010 0A4B     		ldr	r3, .L347+4
 5879 0012 D3ED007A 		flds	s15, [r3, #0]
  53:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****     delay(12);
 5880              		.loc 24 53 0 discriminator 2
 5881 0016 0C20     		movs	r0, #12
  52:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** 	altSum += baroRawAltitude;
 5882              		.loc 24 52 0 discriminator 2
 5883 0018 38EE278A 		fadds	s16, s16, s15
 5884              	.LVL295:
 5885              		.loc 24 53 0 discriminator 2
 5886 001c FFF7FEFF 		bl	_Z5delaym
  50:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   for (int i=0; i < 25; i++) {
 5887              		.loc 24 50 0 discriminator 2
 5888 0020 013C     		subs	r4, r4, #1
 5889 0022 F3D1     		bne	.L345
 5890              	.LBE144:
  54:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   }
  55:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   baroGroundAltitude = altSum / 25;
 5891              		.loc 24 55 0
 5892 0024 B3EE090A 		fconsts	s0, #57
 5893 0028 88EE000A 		fdivs	s0, s16, s0
 5894 002c 0448     		ldr	r0, .L347+8
 5895 002e 80ED000A 		fsts	s0, [r0, #0]
 5896              	.LBE143:
  56:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** }
 5897              		.loc 24 56 0
 5898 0032 BDEC028B 		fldmfdd	sp!, {d8}
 5899 0036 10BD     		pop	{r4, pc}
 5900              	.L348:
 5901              		.align	2
 5902              	.L347:
 5903 0038 00000000 		.word	0
 5904 003c 00000000 		.word	.LANCHOR95
 5905 0040 00000000 		.word	.LANCHOR81
 5906              		.cfi_endproc
 5907              	.LFE191:
 5909              		.section	.text._Z14initializeBarov,"ax",%progbits
 5910              		.align	1
 5911              		.global	_Z14initializeBarov
 5912              		.thumb
 5913              		.thumb_func
 5915              	_Z14initializeBarov:
 5916              	.LFB201:
 191:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void initializeBaro() {
 5917              		.loc 25 191 0
 5918              		.cfi_startproc
 5919              		@ args = 0, pretend = 0, frame = 0
 5920              		@ frame_needed = 0, uses_anonymous_args = 0
 5921 0000 10B5     		push	{r4, lr}
 5922              	.LCFI67:
 5923              		.cfi_def_cfa_offset 8
 5924              		.cfi_offset 14, -4
 5925              		.cfi_offset 4, -8
 192:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroStartTime = micros();
 5926              		.loc 25 192 0
 5927 0002 FFF7FEFF 		bl	_ZL6microsv
 5928 0006 1A4C     		ldr	r4, .L351
 194:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressure = 0;
 5929              		.loc 25 194 0
 5930 0008 1A49     		ldr	r1, .L351+4
 192:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroStartTime = micros();
 5931              		.loc 25 192 0
 5932 000a 2060     		str	r0, [r4, #0]
 196:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressureFactor = 1/5.255;
 5933              		.loc 25 196 0
 5934 000c 1A4A     		ldr	r2, .L351+8
 5935 000e 1B4B     		ldr	r3, .L351+12
 195:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroGroundAltitude = 0;
 5936              		.loc 25 195 0
 5937 0010 1B4C     		ldr	r4, .L351+16
 196:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressureFactor = 1/5.255;
 5938              		.loc 25 196 0
 5939 0012 1A60     		str	r2, [r3, #0]	@ float
 194:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressure = 0;
 5940              		.loc 25 194 0
 5941 0014 0020     		movs	r0, #0
 5942 0016 0860     		str	r0, [r1, #0]	@ float
 195:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroGroundAltitude = 0;
 5943              		.loc 25 195 0
 5944 0018 2060     		str	r0, [r4, #0]	@ float
 198:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611reset(MS5611_I2C_ADDRESS); // reset the device to populate its internal PROM registers
 5945              		.loc 25 198 0
 5946 001a 7620     		movs	r0, #118
 5947 001c FFF7FEFF 		bl	_Z11MS5611reseti
 199:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   delay(3); // some safety time
 5948              		.loc 25 199 0
 5949 0020 0320     		movs	r0, #3
 5950 0022 FFF7FEFF 		bl	_Z5delaym
 201:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   if(MS5611readPROM(MS5611_I2C_ADDRESS) ) {
 5951              		.loc 25 201 0
 5952 0026 7620     		movs	r0, #118
 5953 0028 FFF7FEFF 		bl	_Z14MS5611readPROMi
 5954 002c 20B1     		cbz	r0, .L350
 202:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	  vehicleState |= BARO_DETECTED;
 5955              		.loc 25 202 0
 5956 002e 154B     		ldr	r3, .L351+20
 5957 0030 1868     		ldr	r0, [r3, #0]
 5958 0032 40F00802 		orr	r2, r0, #8
 5959 0036 1A60     		str	r2, [r3, #0]
 5960              	.L350:
 205:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   requestRawTemperature(); // setup up next measure() for temperature
 5961              		.loc 25 205 0
 5962 0038 FFF7FEFF 		bl	_Z21requestRawTemperaturev
 206:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   isReadPressure = false;
 5963              		.loc 25 206 0
 5964 003c 1249     		ldr	r1, .L351+24
 207:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressureCount = 0;
 5965              		.loc 25 207 0
 5966 003e 1348     		ldr	r0, .L351+28
 206:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   isReadPressure = false;
 5967              		.loc 25 206 0
 5968 0040 0023     		movs	r3, #0
 5969 0042 0B70     		strb	r3, [r1, #0]
 207:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressureCount = 0;
 5970              		.loc 25 207 0
 5971 0044 0370     		strb	r3, [r0, #0]
 208:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   delay(10);
 5972              		.loc 25 208 0
 5973 0046 0A20     		movs	r0, #10
 5974 0048 FFF7FEFF 		bl	_Z5delaym
 209:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureBaroSum(); // read temperature
 5975              		.loc 25 209 0
 5976 004c FFF7FEFF 		bl	_Z14measureBaroSumv
 210:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   delay(10);
 5977              		.loc 25 210 0
 5978 0050 0A20     		movs	r0, #10
 5979 0052 FFF7FEFF 		bl	_Z5delaym
 211:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureBaro(); // read pressure
 5980              		.loc 25 211 0
 5981 0056 FFF7FEFF 		bl	_Z11measureBarov
 212:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   delay(10);
 5982              		.loc 25 212 0
 5983 005a 0A20     		movs	r0, #10
 5984 005c FFF7FEFF 		bl	_Z5delaym
 214:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureGroundBaro();
 5985              		.loc 25 214 0
 5986 0060 FFF7FEFF 		bl	_Z17measureGroundBarov
 215:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureGroundBaro();
 5987              		.loc 25 215 0
 5988 0064 FFF7FEFF 		bl	_Z17measureGroundBarov
 224:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroAltitude = baroGroundAltitude;
 5989              		.loc 25 224 0
 5990 0068 2168     		ldr	r1, [r4, #0]	@ float
 5991 006a 094A     		ldr	r2, .L351+32
 5992 006c 1160     		str	r1, [r2, #0]	@ float
 225:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5993              		.loc 25 225 0
 5994 006e 10BD     		pop	{r4, pc}
 5995              	.L352:
 5996              		.align	2
 5997              	.L351:
 5998 0070 00000000 		.word	.LANCHOR99
 5999 0074 00000000 		.word	.LANCHOR93
 6000 0078 AEDC423E 		.word	1044569262
 6001 007c 00000000 		.word	.LANCHOR94
 6002 0080 00000000 		.word	.LANCHOR81
 6003 0084 00000000 		.word	.LANCHOR21
 6004 0088 00000000 		.word	.LANCHOR89
 6005 008c 00000000 		.word	.LANCHOR92
 6006 0090 00000000 		.word	.LANCHOR80
 6007              		.cfi_endproc
 6008              	.LFE201:
 6010              		.section	.text._Z30setBatteryCellVoltageThresholdf,"ax",%progbits
 6011              		.align	1
 6012              		.global	_Z30setBatteryCellVoltageThresholdf
 6013              		.thumb
 6014              		.thumb_func
 6016              	_Z30setBatteryCellVoltageThresholdf:
 6017              	.LFB205:
 6018              		.file 26 "../Libraries/AQ_BatteryMonitor/BatteryMonitor.h"
   1:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** /*
   2:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   AeroQuad v3.0 - May 2011
   3:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   www.AeroQuad.com
   4:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   Copyright (c) 2011 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
   7:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   This program is free software: you can redistribute it and/or modify
   8:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   it under the terms of the GNU General Public License as published by
   9:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   the Free Software Foundation, either version 3 of the License, or
  10:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   (at your option) any later version.
  11:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  12:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   This program is distributed in the hope that it will be useful,
  13:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   GNU General Public License for more details.
  16:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  17:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   You should have received a copy of the GNU General Public License
  18:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** */
  20:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  21:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** #ifndef _AQ_BATTERY_MONITOR_
  22:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** #define _AQ_BATTERY_MONITOR_
  23:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  24:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** #include <BatteryMonitorTypes.h>
  25:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  26:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** #define BM_WARNING_RATIO 1.1
  27:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  28:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** byte    numberOfBatteries = 0; 
  29:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** boolean batteryAlarm      = false;
  30:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** boolean batteryWarning    = false;
  31:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** byte    buzzerState       = 0;
  32:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  33:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** unsigned short batteryAlarmCellVoltage   = 333; // 9.9V on 3S
  34:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** unsigned short batteryWarningCellVoltage = 366; // 11.0V on 3S
  35:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  36:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** void setBatteryCellVoltageThreshold(float alarmVoltage) {
 6019              		.loc 26 36 0
 6020              		.cfi_startproc
 6021              		@ args = 0, pretend = 0, frame = 0
 6022              		@ frame_needed = 0, uses_anonymous_args = 0
 6023              		@ link register save eliminated.
 6024              	.LVL296:
 6025              		.loc 26 36 0
 6026 0000 07EE100A 		fmsr	s14, r0
  37:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   
  38:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   batteryAlarmCellVoltage   = alarmVoltage*100.0;
 6027              		.loc 26 38 0
 6028 0004 9FED0B0A 		flds	s0, .L354
  39:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   batteryWarningCellVoltage = alarmVoltage*BM_WARNING_RATIO*100.0;
 6029              		.loc 26 39 0
 6030 0008 DFED0B6A 		flds	s13, .L354+4
  38:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   batteryAlarmCellVoltage   = alarmVoltage*100.0;
 6031              		.loc 26 38 0
 6032 000c 27EE001A 		fmuls	s2, s14, s0
 6033              		.loc 26 39 0
 6034 0010 27EE267A 		fmuls	s14, s14, s13
  38:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   batteryAlarmCellVoltage   = alarmVoltage*100.0;
 6035              		.loc 26 38 0
 6036 0014 FCEEC10A 		ftouizs	s1, s2
 6037              		.loc 26 39 0
 6038 0018 27EE000A 		fmuls	s0, s14, s0
  38:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   batteryAlarmCellVoltage   = alarmVoltage*100.0;
 6039              		.loc 26 38 0
 6040 001c 10EE900A 		fmrs	r0, s1	@ int
 6041              	.LVL297:
 6042              		.loc 26 39 0
 6043 0020 FCEEC07A 		ftouizs	s15, s0
  38:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   batteryAlarmCellVoltage   = alarmVoltage*100.0;
 6044              		.loc 26 38 0
 6045 0024 0549     		ldr	r1, .L354+8
 6046              		.loc 26 39 0
 6047 0026 064B     		ldr	r3, .L354+12
  38:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   batteryAlarmCellVoltage   = alarmVoltage*100.0;
 6048              		.loc 26 38 0
 6049 0028 0880     		strh	r0, [r1, #0]	@ movhi
 6050              		.loc 26 39 0
 6051 002a 17EE902A 		fmrs	r2, s15	@ int
 6052 002e 1A80     		strh	r2, [r3, #0]	@ movhi
  40:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** }
 6053              		.loc 26 40 0
 6054 0030 7047     		bx	lr
 6055              	.L355:
 6056 0032 00BF     		.align	2
 6057              	.L354:
 6058 0034 0000C842 		.word	1120403456
 6059 0038 CDCC8C3F 		.word	1066192077
 6060 003c 00000000 		.word	.LANCHOR100
 6061 0040 00000000 		.word	.LANCHOR101
 6062              		.cfi_endproc
 6063              	.LFE205:
 6065              		.section	.text._Z12resetBatteryh,"ax",%progbits
 6066              		.align	1
 6067              		.global	_Z12resetBatteryh
 6068              		.thumb
 6069              		.thumb_func
 6071              	_Z12resetBatteryh:
 6072              	.LFB206:
  41:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  42:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** // Reset Battery statistics
  43:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** void resetBattery(byte batno) {
 6073              		.loc 26 43 0
 6074              		.cfi_startproc
 6075              		@ args = 0, pretend = 0, frame = 0
 6076              		@ frame_needed = 0, uses_anonymous_args = 0
 6077              		@ link register save eliminated.
 6078              	.LVL298:
  44:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  45:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   if (batno < numberOfBatteries) {
 6079              		.loc 26 45 0
 6080 0000 0949     		ldr	r1, .L358
 6081 0002 0B78     		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 6082 0004 8342     		cmp	r3, r0
 6083 0006 0ED9     		bls	.L356
  46:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     batteryData[batno].voltage      = 1200;
 6084              		.loc 26 46 0
 6085 0008 0849     		ldr	r1, .L358+4
 6086 000a 1822     		movs	r2, #24
 6087 000c 02FB0010 		mla	r0, r2, r0, r1
 6088              	.LVL299:
 6089 0010 4FF49663 		mov	r3, #1200	@ movhi
 6090 0014 C380     		strh	r3, [r0, #6]	@ movhi
  47:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** #ifdef BM_EXTENDED
  48:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     batteryData[batno].minVoltage   = 9900;
 6091              		.loc 26 48 0
 6092 0016 42F2AC61 		movw	r1, 9900	@ movhi
  49:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     batteryData[batno].current      = 0;
 6093              		.loc 26 49 0
 6094 001a 0023     		movs	r3, #0
  50:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     batteryData[batno].maxCurrent   = 0;
 6095              		.loc 26 50 0
 6096 001c 0022     		movs	r2, #0
  48:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     batteryData[batno].minVoltage   = 9900;
 6097              		.loc 26 48 0
 6098 001e 0181     		strh	r1, [r0, #8]	@ movhi
  49:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     batteryData[batno].current      = 0;
 6099              		.loc 26 49 0
 6100 0020 0382     		strh	r3, [r0, #16]	@ movhi
 6101              		.loc 26 50 0
 6102 0022 4282     		strh	r2, [r0, #18]	@ movhi
  51:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     batteryData[batno].usedCapacity = 0;
 6103              		.loc 26 51 0
 6104 0024 4361     		str	r3, [r0, #20]
 6105              	.L356:
 6106 0026 7047     		bx	lr
 6107              	.L359:
 6108              		.align	2
 6109              	.L358:
 6110 0028 00000000 		.word	.LANCHOR102
 6111 002c 00000000 		.word	.LANCHOR103
 6112              		.cfi_endproc
 6113              	.LFE206:
 6115              		.section	.text._Z19batteryGetCellCounth,"ax",%progbits
 6116              		.align	1
 6117              		.global	_Z19batteryGetCellCounth
 6118              		.thumb
 6119              		.thumb_func
 6121              	_Z19batteryGetCellCounth:
 6122              	.LFB208:
  52:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** #endif
  53:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   }
  54:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** }
  55:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  56:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** void initializeBatteryMonitor(byte nb, float alarmVoltage) {
  57:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  58:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   numberOfBatteries = nb;
  59:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   setBatteryCellVoltageThreshold(alarmVoltage);
  60:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   for (int i = 0; i < numberOfBatteries; i++) {
  61:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     resetBattery(i);
  62:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   }
  63:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   measureBatteryVoltage(0); // Initial measurement
  64:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** }
  65:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  66:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** byte batteryGetCellCount(byte batNo) {
 6123              		.loc 26 66 0
 6124              		.cfi_startproc
 6125              		@ args = 0, pretend = 0, frame = 0
 6126              		@ frame_needed = 0, uses_anonymous_args = 0
 6127              		@ link register save eliminated.
 6128              	.LVL300:
  67:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   if (batteryData[batNo].cells) {
 6129              		.loc 26 67 0
 6130 0000 084B     		ldr	r3, .L364
 6131 0002 1822     		movs	r2, #24
 6132 0004 02FB0033 		mla	r3, r2, r0, r3
 6133 0008 5878     		ldrb	r0, [r3, #1]	@ zero_extendqisi2
 6134              	.LVL301:
 6135 000a 50B9     		cbnz	r0, .L361
  68:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     return batteryData[batNo].cells;
  69:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   }
  70:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   else if (batteryData[batNo].voltage < 500) {
 6136              		.loc 26 70 0
 6137 000c D888     		ldrh	r0, [r3, #6]
 6138 000e B0F5FA7F 		cmp	r0, #500
 6139 0012 05D3     		bcc	.L362
  71:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     return 1;
  72:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   }
  73:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   else if (batteryData[batNo].voltage < 860) {
  74:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     return 2;
 6140              		.loc 26 74 0
 6141 0014 B0F5577F 		cmp	r0, #860
 6142 0018 2CBF     		ite	cs
 6143 001a 0320     		movcs	r0, #3
 6144 001c 0220     		movcc	r0, #2
 6145 001e 7047     		bx	lr
 6146              	.L362:
  71:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     return 1;
 6147              		.loc 26 71 0
 6148 0020 0120     		movs	r0, #1
 6149              	.L361:
  75:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   }
  76:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   else {
  77:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     return 3;
  78:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   }
  79:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** }
 6150              		.loc 26 79 0
 6151 0022 7047     		bx	lr
 6152              	.L365:
 6153              		.align	2
 6154              	.L364:
 6155 0024 00000000 		.word	.LANCHOR103
 6156              		.cfi_endproc
 6157              	.LFE208:
 6159              		.section	.text._Z14batteryIsAlarmh,"ax",%progbits
 6160              		.align	1
 6161              		.global	_Z14batteryIsAlarmh
 6162              		.thumb
 6163              		.thumb_func
 6165              	_Z14batteryIsAlarmh:
 6166              	.LFB209:
  80:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  81:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** boolean batteryIsAlarm(byte batNo) {
 6167              		.loc 26 81 0
 6168              		.cfi_startproc
 6169              		@ args = 0, pretend = 0, frame = 0
 6170              		@ frame_needed = 0, uses_anonymous_args = 0
 6171              	.LVL302:
 6172 0000 10B5     		push	{r4, lr}
 6173              	.LCFI68:
 6174              		.cfi_def_cfa_offset 8
 6175              		.cfi_offset 14, -4
 6176              		.cfi_offset 4, -8
 6177              		.loc 26 81 0
 6178 0002 0446     		mov	r4, r0
  82:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  83:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   if (batteryData[batNo].voltage < batteryGetCellCount(batNo) * batteryAlarmCellVoltage) {
 6179              		.loc 26 83 0
 6180 0004 FFF7FEFF 		bl	_Z19batteryGetCellCounth
 6181              	.LVL303:
 6182 0008 064A     		ldr	r2, .L367
 6183 000a 1821     		movs	r1, #24
 6184 000c 01FB0423 		mla	r3, r1, r4, r2
 6185 0010 0549     		ldr	r1, .L367+4
 6186 0012 DB88     		ldrh	r3, [r3, #6]
 6187 0014 0A88     		ldrh	r2, [r1, #0]
 6188 0016 5043     		muls	r0, r2, r0
  84:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     return true;
  85:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   }
  86:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   return false;
  87:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** }
 6189              		.loc 26 87 0
 6190 0018 8342     		cmp	r3, r0
 6191 001a ACBF     		ite	ge
 6192 001c 0020     		movge	r0, #0
 6193 001e 0120     		movlt	r0, #1
 6194 0020 10BD     		pop	{r4, pc}
 6195              	.L368:
 6196 0022 00BF     		.align	2
 6197              	.L367:
 6198 0024 00000000 		.word	.LANCHOR103
 6199 0028 00000000 		.word	.LANCHOR100
 6200              		.cfi_endproc
 6201              	.LFE209:
 6203              		.section	.text._Z16batteryIsWarningh,"ax",%progbits
 6204              		.align	1
 6205              		.global	_Z16batteryIsWarningh
 6206              		.thumb
 6207              		.thumb_func
 6209              	_Z16batteryIsWarningh:
 6210              	.LFB210:
  88:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  89:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** boolean batteryIsWarning(byte batNo) {
 6211              		.loc 26 89 0
 6212              		.cfi_startproc
 6213              		@ args = 0, pretend = 0, frame = 0
 6214              		@ frame_needed = 0, uses_anonymous_args = 0
 6215              	.LVL304:
 6216 0000 10B5     		push	{r4, lr}
 6217              	.LCFI69:
 6218              		.cfi_def_cfa_offset 8
 6219              		.cfi_offset 14, -4
 6220              		.cfi_offset 4, -8
 6221              		.loc 26 89 0
 6222 0002 0446     		mov	r4, r0
  90:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  91:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   if (batteryData[batNo].voltage < batteryGetCellCount(batNo) * batteryWarningCellVoltage) {
 6223              		.loc 26 91 0
 6224 0004 FFF7FEFF 		bl	_Z19batteryGetCellCounth
 6225              	.LVL305:
 6226 0008 064A     		ldr	r2, .L370
 6227 000a 1821     		movs	r1, #24
 6228 000c 01FB0423 		mla	r3, r1, r4, r2
 6229 0010 0549     		ldr	r1, .L370+4
 6230 0012 DB88     		ldrh	r3, [r3, #6]
 6231 0014 0A88     		ldrh	r2, [r1, #0]
 6232 0016 5043     		muls	r0, r2, r0
  92:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     return true;
  93:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   }
  94:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   return false;
  95:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** }
 6233              		.loc 26 95 0
 6234 0018 8342     		cmp	r3, r0
 6235 001a ACBF     		ite	ge
 6236 001c 0020     		movge	r0, #0
 6237 001e 0120     		movlt	r0, #1
 6238 0020 10BD     		pop	{r4, pc}
 6239              	.L371:
 6240 0022 00BF     		.align	2
 6241              	.L370:
 6242 0024 00000000 		.word	.LANCHOR103
 6243 0028 00000000 		.word	.LANCHOR101
 6244              		.cfi_endproc
 6245              	.LFE210:
 6247              		.section	.text._Z21measureBatteryVoltaget,"ax",%progbits
 6248              		.align	1
 6249              		.global	_Z21measureBatteryVoltaget
 6250              		.thumb
 6251              		.thumb_func
 6253              	_Z21measureBatteryVoltaget:
 6254              	.LFB211:
  96:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  97:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** void measureBatteryVoltage(unsigned short deltaTime) {
 6255              		.loc 26 97 0
 6256              		.cfi_startproc
 6257              		@ args = 0, pretend = 0, frame = 0
 6258              		@ frame_needed = 0, uses_anonymous_args = 0
 6259              	.LVL306:
 6260 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 6261              	.LCFI70:
 6262              		.cfi_def_cfa_offset 32
 6263              		.cfi_offset 14, -4
 6264              		.cfi_offset 9, -8
 6265              		.cfi_offset 8, -12
 6266              		.cfi_offset 7, -16
 6267              		.cfi_offset 6, -20
 6268              		.cfi_offset 5, -24
 6269              		.cfi_offset 4, -28
 6270              		.cfi_offset 3, -32
 6271              	.LBB145:
  98:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** 
  99:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   batteryAlarm = false;  
 6272              		.loc 26 99 0
 6273 0004 2E4B     		ldr	r3, .L383
 100:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   batteryWarning = false;
 6274              		.loc 26 100 0
 6275 0006 2F4F     		ldr	r7, .L383+4
 6276 0008 2F4C     		ldr	r4, .L383+8
  99:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   batteryAlarm = false;  
 6277              		.loc 26 99 0
 6278 000a 0025     		movs	r5, #0
 6279              	.LBE145:
  97:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** void measureBatteryVoltage(unsigned short deltaTime) {
 6280              		.loc 26 97 0
 6281 000c 8146     		mov	r9, r0
 6282              	.LBB147:
  99:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   batteryAlarm = false;  
 6283              		.loc 26 99 0
 6284 000e 1D70     		strb	r5, [r3, #0]
 6285              		.loc 26 100 0
 6286 0010 3D70     		strb	r5, [r7, #0]
 6287              	.LVL307:
 6288 0012 9846     		mov	r8, r3
 6289              	.LBB146:
 101:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   for (int i = 0; i < numberOfBatteries; i++) {
 6290              		.loc 26 101 0
 6291 0014 4EE0     		b	.L373
 6292              	.LVL308:
 6293              	.L382:
 102:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     batteryData[i].voltage = (long)analogRead(batteryData[i].vPin) * batteryData[i].vScale / (1L<<A
 6294              		.loc 26 102 0
 6295 0016 2078     		ldrb	r0, [r4, #0]	@ zero_extendqisi2
 6296 0018 FFF7FEFF 		bl	_Z10analogReadh
 6297 001c B4F90260 		ldrsh	r6, [r4, #2]
 6298 0020 B4F804C0 		ldrh	ip, [r4, #4]
 103:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** #ifdef BM_EXTENDED
 104:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     if (batteryData[i].voltage < batteryData[i].minVoltage) {
 6299              		.loc 26 104 0
 6300 0024 2289     		ldrh	r2, [r4, #8]
 102:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     batteryData[i].voltage = (long)analogRead(batteryData[i].vPin) * batteryData[i].vScale / (1L<<A
 6301              		.loc 26 102 0
 6302 0026 4643     		muls	r6, r0, r6
 6303 0028 44BF     		itt	mi
 6304 002a 06F57E66 		addmi	r6, r6, #4064
 6305 002e 1F36     		addmi	r6, r6, #31
 6306 0030 0CEB2631 		add	r1, ip, r6, asr #12
 6307 0034 88B2     		uxth	r0, r1
 6308              		.loc 26 104 0
 6309 0036 8242     		cmp	r2, r0
 105:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****       batteryData[i].minVoltage = batteryData[i].voltage;
 6310              		.loc 26 105 0
 6311 0038 88BF     		it	hi
 6312 003a 2081     		strhhi	r0, [r4, #8]	@ movhi
 102:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     batteryData[i].voltage = (long)analogRead(batteryData[i].vPin) * batteryData[i].vScale / (1L<<A
 6313              		.loc 26 102 0
 6314 003c E080     		strh	r0, [r4, #6]	@ movhi
 106:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     }
 107:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     if (batteryData[i].cPin != BM_NOPIN) {
 6315              		.loc 26 107 0
 6316 003e A07A     		ldrb	r0, [r4, #10]	@ zero_extendqisi2
 6317 0040 FF28     		cmp	r0, #255
 6318 0042 27D0     		beq	.L376
 108:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****       batteryData[i].current = (long)analogRead(batteryData[i].cPin) * batteryData[i].cScale * 10 /
 6319              		.loc 26 108 0
 6320 0044 FFF7FEFF 		bl	_Z10analogReadh
 6321 0048 B4F90C60 		ldrsh	r6, [r4, #12]
 6322 004c E289     		ldrh	r2, [r4, #14]
 6323 004e 4643     		muls	r6, r0, r6
 6324 0050 0A23     		movs	r3, #10
 6325 0052 5E43     		muls	r6, r3, r6
 6326 0054 44BF     		itt	mi
 6327 0056 06F57E66 		addmi	r6, r6, #4064
 6328 005a 1F36     		addmi	r6, r6, #31
 6329 005c 0A21     		movs	r1, #10
 6330 005e 4A43     		muls	r2, r1, r2
 6331 0060 02EB263C 		add	ip, r2, r6, asr #12
 109:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****       if (batteryData[i].current > batteryData[i].maxCurrent) { 
 6332              		.loc 26 109 0
 6333 0064 B4F91230 		ldrsh	r3, [r4, #18]
 108:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****       batteryData[i].current = (long)analogRead(batteryData[i].cPin) * batteryData[i].cScale * 10 /
 6334              		.loc 26 108 0
 6335 0068 A4F810C0 		strh	ip, [r4, #16]	@ movhi
 6336              		.loc 26 109 0
 6337 006c 0FFA8CF0 		sxth	r0, ip
 110:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****         batteryData[i].maxCurrent = batteryData[i].current;
 111:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****       }
 112:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****       // current in 10mA , time in ms -> usedCapacity in uAh  // i.e. / 360 <=> * ( 91 / 32768 )
 113:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****       batteryData[i].usedCapacity += (long)batteryData[i].current * (long)deltaTime * 91 / 32768;
 6338              		.loc 26 113 0
 6339 0070 B4F91060 		ldrsh	r6, [r4, #16]
 6340 0074 6269     		ldr	r2, [r4, #20]
 109:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****       if (batteryData[i].current > batteryData[i].maxCurrent) { 
 6341              		.loc 26 109 0
 6342 0076 8342     		cmp	r3, r0
 110:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****         batteryData[i].maxCurrent = batteryData[i].current;
 6343              		.loc 26 110 0
 6344 0078 B8BF     		it	lt
 6345 007a A4F812C0 		strhlt	ip, [r4, #18]	@ movhi
 6346              		.loc 26 113 0
 6347 007e 09FB06F0 		mul	r0, r9, r6
 6348 0082 5B21     		movs	r1, #91
 6349 0084 4843     		muls	r0, r1, r0
 6350 0086 44BF     		itt	mi
 6351 0088 00F5FE40 		addmi	r0, r0, #32512
 6352 008c FF30     		addmi	r0, r0, #255
 6353 008e 02EBE033 		add	r3, r2, r0, asr #15
 6354 0092 6361     		str	r3, [r4, #20]
 6355              	.L376:
 114:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     }
 115:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** #endif
 116:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     if (batteryIsAlarm(i)) {
 6356              		.loc 26 116 0
 6357 0094 EEB2     		uxtb	r6, r5
 6358 0096 3046     		mov	r0, r6
 6359 0098 FFF7FEFF 		bl	_Z14batteryIsAlarmh
 6360 009c 10B1     		cbz	r0, .L380
 117:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****       batteryAlarm = true;
 6361              		.loc 26 117 0
 6362 009e 0120     		movs	r0, #1
 6363 00a0 88F80000 		strb	r0, [r8, #0]
 6364              	.L380:
 118:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     }
 119:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     if (batteryIsWarning(i)) {
 6365              		.loc 26 119 0
 6366 00a4 3046     		mov	r0, r6
 6367 00a6 FFF7FEFF 		bl	_Z16batteryIsWarningh
 6368 00aa 08B1     		cbz	r0, .L381
 120:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****       batteryWarning = true;
 6369              		.loc 26 120 0
 6370 00ac 0122     		movs	r2, #1
 6371 00ae 3A70     		strb	r2, [r7, #0]
 6372              	.L381:
 101:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   for (int i = 0; i < numberOfBatteries; i++) {
 6373              		.loc 26 101 0
 6374 00b0 0135     		adds	r5, r5, #1
 6375              	.LVL309:
 6376 00b2 1834     		adds	r4, r4, #24
 6377              	.LVL310:
 6378              	.L373:
 101:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   for (int i = 0; i < numberOfBatteries; i++) {
 6379              		.loc 26 101 0 is_stmt 0 discriminator 1
 6380 00b4 054B     		ldr	r3, .L383+12
 6381 00b6 1978     		ldrb	r1, [r3, #0]	@ zero_extendqisi2
 6382 00b8 8D42     		cmp	r5, r1
 6383 00ba ACDB     		blt	.L382
 6384              	.LBE146:
 6385              	.LBE147:
 121:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     }
 122:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   }  
 123:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** }
 6386              		.loc 26 123 0 is_stmt 1
 6387 00bc BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 6388              	.L384:
 6389              		.align	2
 6390              	.L383:
 6391 00c0 00000000 		.word	.LANCHOR104
 6392 00c4 00000000 		.word	.LANCHOR105
 6393 00c8 00000000 		.word	.LANCHOR103
 6394 00cc 00000000 		.word	.LANCHOR102
 6395              		.cfi_endproc
 6396              	.LFE211:
 6398              		.section	.text._Z24initializeBatteryMonitorhf,"ax",%progbits
 6399              		.align	1
 6400              		.global	_Z24initializeBatteryMonitorhf
 6401              		.thumb
 6402              		.thumb_func
 6404              	_Z24initializeBatteryMonitorhf:
 6405              	.LFB207:
  56:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** void initializeBatteryMonitor(byte nb, float alarmVoltage) {
 6406              		.loc 26 56 0
 6407              		.cfi_startproc
 6408              		@ args = 0, pretend = 0, frame = 0
 6409              		@ frame_needed = 0, uses_anonymous_args = 0
 6410              	.LVL311:
 6411 0000 38B5     		push	{r3, r4, r5, lr}
 6412              	.LCFI71:
 6413              		.cfi_def_cfa_offset 16
 6414              		.cfi_offset 14, -4
 6415              		.cfi_offset 5, -8
 6416              		.cfi_offset 4, -12
 6417              		.cfi_offset 3, -16
 6418              	.LBB148:
  58:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   numberOfBatteries = nb;
 6419              		.loc 26 58 0
 6420 0002 094C     		ldr	r4, .L388
 6421 0004 2070     		strb	r0, [r4, #0]
  59:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   setBatteryCellVoltageThreshold(alarmVoltage);
 6422              		.loc 26 59 0
 6423 0006 0846     		mov	r0, r1	@ float
 6424              	.LVL312:
 6425 0008 FFF7FEFF 		bl	_Z30setBatteryCellVoltageThresholdf
 6426              	.LVL313:
 6427              	.LBB149:
  60:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   for (int i = 0; i < numberOfBatteries; i++) {
 6428              		.loc 26 60 0
 6429 000c 0025     		movs	r5, #0
 6430 000e 03E0     		b	.L386
 6431              	.LVL314:
 6432              	.L387:
  61:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****     resetBattery(i);
 6433              		.loc 26 61 0 discriminator 2
 6434 0010 E8B2     		uxtb	r0, r5
 6435 0012 FFF7FEFF 		bl	_Z12resetBatteryh
  60:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   for (int i = 0; i < numberOfBatteries; i++) {
 6436              		.loc 26 60 0 discriminator 2
 6437 0016 0135     		adds	r5, r5, #1
 6438              	.LVL315:
 6439              	.L386:
  60:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   for (int i = 0; i < numberOfBatteries; i++) {
 6440              		.loc 26 60 0 is_stmt 0 discriminator 1
 6441 0018 2378     		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 6442 001a 9D42     		cmp	r5, r3
 6443 001c F8DB     		blt	.L387
 6444              	.LBE149:
  63:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   measureBatteryVoltage(0); // Initial measurement
 6445              		.loc 26 63 0 is_stmt 1
 6446 001e 0020     		movs	r0, #0
 6447              	.LBE148:
  64:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h **** }
 6448              		.loc 26 64 0
 6449 0020 BDE83840 		pop	{r3, r4, r5, lr}
 6450              	.LBB150:
  63:../Libraries/AQ_BatteryMonitor/BatteryMonitor.h ****   measureBatteryVoltage(0); // Initial measurement
 6451              		.loc 26 63 0
 6452 0024 FFF7FEBF 		b	_Z21measureBatteryVoltaget
 6453              	.L389:
 6454              		.align	2
 6455              	.L388:
 6456 0028 00000000 		.word	.LANCHOR102
 6457              	.LBE150:
 6458              		.cfi_endproc
 6459              	.LFE207:
 6461              		.section	.text._Z17applyMotorCommandv,"ax",%progbits
 6462              		.align	1
 6463              		.global	_Z17applyMotorCommandv
 6464              		.thumb
 6465              		.thumb_func
 6467              	_Z17applyMotorCommandv:
 6468              	.LFB212:
 6469              		.file 27 "../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h"
   1:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** /*
   2:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   www.AeroQuad.com
   4:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****  
   7:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   (at your option) any later version. 
  11:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****  
  12:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****  
  17:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** */
  20:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  21:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #ifndef _AQ_PROCESS_FLIGHT_CONTROL_X_MODE_H_
  22:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #define _AQ_PROCESS_FLIGHT_CONTROL_X_MODE_H_
  23:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  24:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** /*
  25:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****        CW  0....Front....0 CCW
  26:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****            ......***......    
  27:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****            ......***......    
  28:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****            ......***......    
  29:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****       CCW  0....Back.....0  CW
  30:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** */
  31:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  32:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #include "FlightControlVariable.h"
  33:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  34:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #ifdef OLD_MOTOR_NUMBERING  
  35:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define FRONT_LEFT  MOTOR1
  36:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define REAR_RIGHT  MOTOR2
  37:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define FRONT_RIGHT MOTOR3
  38:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define REAR_LEFT   MOTOR4
  39:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #else
  40:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define FRONT_LEFT  MOTOR1
  41:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define FRONT_RIGHT MOTOR2
  42:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define REAR_RIGHT  MOTOR3
  43:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define REAR_LEFT   MOTOR4
  44:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #endif
  45:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #define LASTMOTOR   MOTOR4+1
  46:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  47:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** int motorMaxCommand[4] = {0,0,0,0};
  48:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** int motorMinCommand[4] = {0,0,0,0};
  49:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** int motorConfiguratorCommand[4] = {0,0,0,0};
  50:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  51:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #if !defined FRONT_YAW_CORRECTION
  52:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define FRONT_YAW_CORRECTION 1
  53:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define REAR_YAW_CORRECTION 1
  54:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #endif  
  55:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  56:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** void applyMotorCommand() {
 6470              		.loc 27 56 0
 6471              		.cfi_startproc
 6472              		@ args = 0, pretend = 0, frame = 0
 6473              		@ frame_needed = 0, uses_anonymous_args = 0
  57:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_LEFT]  = throttle - motorAxisCommandPitch + motorAxisCommandRoll - (YAW_DIRECT
 6474              		.loc 27 57 0
 6475 0000 0D48     		ldr	r0, .L391
 6476 0002 0E49     		ldr	r1, .L391+4
 6477 0004 0E4A     		ldr	r2, .L391+8
 6478 0006 0F4B     		ldr	r3, .L391+12
  56:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** void applyMotorCommand() {
 6479              		.loc 27 56 0
 6480 0008 70B5     		push	{r4, r5, r6, lr}
 6481              	.LCFI72:
 6482              		.cfi_def_cfa_offset 16
 6483              		.cfi_offset 14, -4
 6484              		.cfi_offset 6, -8
 6485              		.cfi_offset 5, -12
 6486              		.cfi_offset 4, -16
 6487              		.loc 27 57 0
 6488 000a 0468     		ldr	r4, [r0, #0]
 6489 000c 0868     		ldr	r0, [r1, #0]
 6490 000e 1168     		ldr	r1, [r2, #0]
 6491 0010 1A68     		ldr	r2, [r3, #0]
 6492 0012 0D4B     		ldr	r3, .L391+16
 6493 0014 C0EB040C 		rsb	ip, r0, r4
  58:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_RIGHT] = throttle - motorAxisCommandPitch - motorAxisCommandRoll + (YAW_DIRECT
  59:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[REAR_LEFT]   = throttle + motorAxisCommandPitch + motorAxisCommandRoll + (YAW_DIRECT
 6494              		.loc 27 59 0
 6495 0018 2018     		adds	r0, r4, r0
  57:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_LEFT]  = throttle - motorAxisCommandPitch + motorAxisCommandRoll - (YAW_DIRECT
 6496              		.loc 27 57 0
 6497 001a 0CEB0106 		add	r6, ip, r1
  58:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_RIGHT] = throttle - motorAxisCommandPitch - motorAxisCommandRoll + (YAW_DIRECT
 6498              		.loc 27 58 0
 6499 001e C1EB0C05 		rsb	r5, r1, ip
 6500              		.loc 27 59 0
 6501 0022 4418     		adds	r4, r0, r1
  60:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[REAR_RIGHT]  = throttle + motorAxisCommandPitch - motorAxisCommandRoll - (YAW_DIRECT
 6502              		.loc 27 60 0
 6503 0024 411A     		subs	r1, r0, r1
  57:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_LEFT]  = throttle - motorAxisCommandPitch + motorAxisCommandRoll - (YAW_DIRECT
 6504              		.loc 27 57 0
 6505 0026 B61A     		subs	r6, r6, r2
  58:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_RIGHT] = throttle - motorAxisCommandPitch - motorAxisCommandRoll + (YAW_DIRECT
 6506              		.loc 27 58 0
 6507 0028 AD18     		adds	r5, r5, r2
  59:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[REAR_LEFT]   = throttle + motorAxisCommandPitch + motorAxisCommandRoll + (YAW_DIRECT
 6508              		.loc 27 59 0
 6509 002a A418     		adds	r4, r4, r2
 6510              		.loc 27 60 0
 6511 002c 8A1A     		subs	r2, r1, r2
  57:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_LEFT]  = throttle - motorAxisCommandPitch + motorAxisCommandRoll - (YAW_DIRECT
 6512              		.loc 27 57 0
 6513 002e 1E60     		str	r6, [r3, #0]
  58:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_RIGHT] = throttle - motorAxisCommandPitch - motorAxisCommandRoll + (YAW_DIRECT
 6514              		.loc 27 58 0
 6515 0030 5D60     		str	r5, [r3, #4]
  59:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[REAR_LEFT]   = throttle + motorAxisCommandPitch + motorAxisCommandRoll + (YAW_DIRECT
 6516              		.loc 27 59 0
 6517 0032 DC60     		str	r4, [r3, #12]
 6518              		.loc 27 60 0
 6519 0034 9A60     		str	r2, [r3, #8]
  61:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** }
 6520              		.loc 27 61 0
 6521 0036 70BD     		pop	{r4, r5, r6, pc}
 6522              	.L392:
 6523              		.align	2
 6524              	.L391:
 6525 0038 00000000 		.word	.LANCHOR106
 6526 003c 00000000 		.word	.LANCHOR107
 6527 0040 00000000 		.word	.LANCHOR108
 6528 0044 00000000 		.word	.LANCHOR109
 6529 0048 00000000 		.word	.LANCHOR63
 6530              		.cfi_endproc
 6531              	.LFE212:
 6533              		.section	.text._Z19processAltitudeHoldv,"ax",%progbits
 6534              		.align	1
 6535              		.global	_Z19processAltitudeHoldv
 6536              		.thumb
 6537              		.thumb_func
 6539              	_Z19processAltitudeHoldv:
 6540              	.LFB213:
 6541              		.file 28 "C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h"
   1:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** /*
   2:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   AeroQuad v3.0.1 - February 2012
   3:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   www.AeroQuad.com
   4:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   An Open Source Arduino based multicopter.
   6:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****  
   7:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   This program is free software: you can redistribute it and/or modify 
   8:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   it under the terms of the GNU General Public License as published by 
   9:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   (at your option) any later version. 
  11:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****  
  12:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   This program is distributed in the hope that it will be useful, 
  13:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   GNU General Public License for more details. 
  16:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****  
  17:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   You should have received a copy of the GNU General Public License 
  18:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** */
  20:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** 
  21:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** // FlightControl.pde is responsible for combining sensor measurements and
  22:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** // transmitter commands into motor commands for the defined flight configuration (X, +, etc.)
  23:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** //////////////////////////////////////////////////////////////////////////////
  24:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** /////////////////////////// calculateFlightError /////////////////////////////
  25:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** //////////////////////////////////////////////////////////////////////////////
  26:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** 
  27:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** #ifndef _AQ_ALTITUDE_CONTROL_PROCESSOR_H_
  28:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** #define _AQ_ALTITUDE_CONTROL_PROCESSOR_H_
  29:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** 
  30:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** 
  31:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
  32:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** 
  33:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** #define INVALID_THROTTLE_CORRECTION -1000
  34:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** #define ALTITUDE_BUMP_SPEED 0.01
  35:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** 
  36:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** 
  37:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** /**
  38:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****  * processAltitudeHold
  39:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****  * 
  40:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****  * This function is responsible to process the throttle correction 
  41:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****  * to keep the current altitude if selected by the user 
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****  */
  43:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** void processAltitudeHold()
  44:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** {
 6542              		.loc 28 44 0
 6543              		.cfi_startproc
 6544              		@ args = 0, pretend = 0, frame = 0
 6545              		@ frame_needed = 0, uses_anonymous_args = 0
 6546 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 6547              	.LCFI73:
 6548              		.cfi_def_cfa_offset 24
 6549              		.cfi_offset 14, -4
 6550              		.cfi_offset 8, -8
 6551              		.cfi_offset 7, -12
 6552              		.cfi_offset 6, -16
 6553              		.cfi_offset 5, -20
 6554              		.cfi_offset 4, -24
 6555              	.LBB151:
  45:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   // ****************************** Altitude Adjust *************************
  46:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   // Thanks to Honk for his work with altitude hold
  47:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   // http://aeroquad.com/showthread.php?792-Problems-with-BMP085-I2C-barometer
  48:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   // Thanks to Sherbakov for his work in Z Axis dampening
  49:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   // http://aeroquad.com/showthread.php?359-Stable-flight-logic...&p=10325&viewfull=1#post10325
  50:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   if (altitudeHoldState == ON) {
 6556              		.loc 28 50 0
 6557 0004 274F     		ldr	r7, .L402
 6558 0006 284C     		ldr	r4, .L402+4
 6559 0008 3B78     		ldrb	r3, [r7, #0]	@ zero_extendqisi2
 6560 000a 284D     		ldr	r5, .L402+8
 6561 000c 012B     		cmp	r3, #1
 6562 000e 44D1     		bne	.L394
 6563              	.LVL316:
 6564              	.LBB152:
  51:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h **** 
  52:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     int altitudeHoldThrottleCorrection = INVALID_THROTTLE_CORRECTION;
  53:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     // computer altitude error!
  54:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     #if defined AltitudeHoldRangeFinder
  55:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       if (isOnRangerRange(rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX])) {
  56:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         if (sonarAltitudeToHoldTarget == INVALID_RANGE) {
  57:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****           sonarAltitudeToHoldTarget = rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX];
  58:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         }
  59:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         altitudeHoldThrottleCorrection = updatePID(sonarAltitudeToHoldTarget, rangeFinderRange[ALTI
  60:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         altitudeHoldThrottleCorrection = constrain(altitudeHoldThrottleCorrection, minThrottleAdjus
  61:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       }
  62:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     #endif
  63:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     #if defined AltitudeHoldBaro
  64:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       if (altitudeHoldThrottleCorrection == INVALID_THROTTLE_CORRECTION) {
  65:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         altitudeHoldThrottleCorrection = updatePID(baroAltitudeToHoldTarget, getBaroAltitude(), &PI
 6565              		.loc 28 65 0
 6566 0010 274E     		ldr	r6, .L402+12
 6567 0012 FFF7FEFF 		bl	_Z15getBaroAltitudev
 6568 0016 D6F80080 		ldr	r8, [r6, #0]	@ float
 6569 001a 264A     		ldr	r2, .L402+16
 6570 001c 0146     		mov	r1, r0	@ float
 6571 001e 4046     		mov	r0, r8	@ float
 6572 0020 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 6573 0024 00EE100A 		fmsr	s0, r0
  66:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         altitudeHoldThrottleCorrection = constrain(altitudeHoldThrottleCorrection, minThrottleAdjus
 6574              		.loc 28 66 0
 6575 0028 2349     		ldr	r1, .L402+20
  65:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         altitudeHoldThrottleCorrection = updatePID(baroAltitudeToHoldTarget, getBaroAltitude(), &PI
 6576              		.loc 28 65 0
 6577 002a FDEEC07A 		ftosizs	s15, s0
 6578              		.loc 28 66 0
 6579 002e 0B68     		ldr	r3, [r1, #0]
  65:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         altitudeHoldThrottleCorrection = updatePID(baroAltitudeToHoldTarget, getBaroAltitude(), &PI
 6580              		.loc 28 65 0
 6581 0030 17EE900A 		fmrs	r0, s15	@ int
 6582              	.LVL317:
 6583              		.loc 28 66 0
 6584 0034 9842     		cmp	r0, r3
 6585 0036 04DB     		blt	.L395
 6586              		.loc 28 66 0 is_stmt 0 discriminator 2
 6587 0038 204A     		ldr	r2, .L402+24
 6588 003a 1368     		ldr	r3, [r2, #0]
 6589 003c 9842     		cmp	r0, r3
 6590 003e B8BF     		it	lt
 6591 0040 0346     		movlt	r3, r0
 6592              	.L395:
 6593              	.LVL318:
  67:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       }
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     #endif        
  69:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     if (altitudeHoldThrottleCorrection == INVALID_THROTTLE_CORRECTION) {
 6594              		.loc 28 69 0 is_stmt 1 discriminator 6
 6595 0042 13F57A7F 		cmn	r3, #1000
 6596 0046 28D0     		beq	.L394
 6597              	.L396:
  70:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       throttle = receiverCommand[THROTTLE];
  71:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       return;
  72:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     }
  73:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     if (abs(altitudeHoldThrottle - receiverCommand[THROTTLE]) > altitudeHoldPanicStickMovement) {
 6598              		.loc 28 74 0
 6599 0048 1D49     		ldr	r1, .L402+28
 6600 004a 1E48     		ldr	r0, .L402+32
 6601 004c 0A68     		ldr	r2, [r1, #0]
 6602 004e E968     		ldr	r1, [r5, #12]
 6603 0050 0068     		ldr	r0, [r0, #0]
 6604 0052 551A     		subs	r5, r2, r1
 6605 0054 002D     		cmp	r5, #0
 6606 0056 B8BF     		it	lt
 6607 0058 6D42     		rsblt	r5, r5, #0
 6608 005a 8542     		cmp	r5, r0
 6609 005c 02DD     		ble	.L398
  75:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       altitudeHoldState = ALTPANIC; // too rapid of stick movement so PANIC out of ALTHOLD
 6610              		.loc 28 75 0
 6611 005e 0220     		movs	r0, #2
 6612 0060 3870     		strb	r0, [r7, #0]
 6613 0062 18E0     		b	.L399
 6614              	.L398:
  76:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     } 
  77:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     else {
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       
  79:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       if (receiverCommand[THROTTLE] > (altitudeHoldThrottle + altitudeHoldBump)) { // AKA changed t
 6615              		.loc 28 79 0
 6616 0064 184D     		ldr	r5, .L402+36
 6617 0066 2868     		ldr	r0, [r5, #0]
 6618 0068 1518     		adds	r5, r2, r0
 6619 006a A942     		cmp	r1, r5
 6620 006c 07DD     		ble	.L400
  80:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         #if defined AltitudeHoldBaro
  81:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****           baroAltitudeToHoldTarget += ALTITUDE_BUMP_SPEED;
 6621              		.loc 28 81 0
 6622 006e 96ED007A 		flds	s14, [r6, #0]
 6623 0072 9FED161A 		flds	s2, .L402+40
 6624 0076 77EE010A 		fadds	s1, s14, s2
 6625 007a C6ED000A 		fsts	s1, [r6, #0]
 6626              	.L400:
  82:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         #endif
  83:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         #if defined AltitudeHoldRangeFinder
  84:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****           float newalt = sonarAltitudeToHoldTarget + ALTITUDE_BUMP_SPEED;
  85:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****           if (isOnRangerRange(newalt)) {
  86:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****             sonarAltitudeToHoldTarget = newalt;
  87:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****           }
  88:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         #endif
  89:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       }
  90:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       
  91:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       if (receiverCommand[THROTTLE] < (altitudeHoldThrottle - altitudeHoldBump)) { // AKA change to
 6627              		.loc 28 91 0
 6628 007e C0EB020C 		rsb	ip, r0, r2
 6629 0082 6145     		cmp	r1, ip
 6630 0084 07DA     		bge	.L399
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         #if defined AltitudeHoldBaro
  93:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****           baroAltitudeToHoldTarget -= ALTITUDE_BUMP_SPEED;
 6631              		.loc 28 93 0
 6632 0086 D6ED002A 		flds	s5, [r6, #0]
 6633 008a 9FED102A 		flds	s4, .L402+40
 6634 008e 72EEC21A 		fsubs	s3, s5, s4
 6635 0092 C6ED001A 		fsts	s3, [r6, #0]
 6636              	.L399:
  94:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         #endif
  95:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         #if defined AltitudeHoldRangeFinder
  96:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****           float newalt = sonarAltitudeToHoldTarget - ALTITUDE_BUMP_SPEED;
  97:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****           if (isOnRangerRange(newalt)) {
  98:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****             sonarAltitudeToHoldTarget = newalt;
  99:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****           }
 100:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****         #endif
 101:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****       }
 102:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     }
 103:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     throttle = altitudeHoldThrottle + altitudeHoldThrottleCorrection;// + zDampeningThrottleCorrect
 6637              		.loc 28 103 0
 6638 0096 D318     		adds	r3, r2, r3
 6639              	.LVL319:
 6640 0098 00E0     		b	.L401
 6641              	.L394:
 6642              	.LBE152:
 104:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   }
 105:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****   else {
 106:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AltitudeControlProcessor.h ****     throttle = receiverCommand[THROTTLE];
 6643              		.loc 28 106 0
 6644 009a EB68     		ldr	r3, [r5, #12]
 6645              	.L401:
 6646 009c 2360     		str	r3, [r4, #0]
 6647 009e BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 6648              	.L403:
 6649 00a2 00BF     		.align	2
 6650              	.L402:
 6651 00a4 00000000 		.word	.LANCHOR5
 6652 00a8 00000000 		.word	.LANCHOR106
 6653 00ac 00000000 		.word	.LANCHOR6
 6654 00b0 00000000 		.word	.LANCHOR110
 6655 00b4 E0000000 		.word	.LANCHOR17+224
 6656 00b8 00000000 		.word	.LANCHOR111
 6657 00bc 00000000 		.word	.LANCHOR112
 6658 00c0 00000000 		.word	.LANCHOR7
 6659 00c4 00000000 		.word	.LANCHOR113
 6660 00c8 00000000 		.word	.LANCHOR8
 6661 00cc 0AD7233C 		.word	1008981770
 6662              	.LBE151:
 6663              		.cfi_endproc
 6664              	.LFE213:
 6666              		.section	.text._Z20calculateFlightErrorv,"ax",%progbits
 6667              		.align	1
 6668              		.global	_Z20calculateFlightErrorv
 6669              		.thumb
 6670              		.thumb_func
 6672              	_Z20calculateFlightErrorv:
 6673              	.LFB214:
 6674              		.file 29 "C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad/FlightControlProcessor.h"
   1:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** /*
   2:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   AeroQuad v3.0.1 - February 2012
   3:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   www.AeroQuad.com
   4:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   An Open Source Arduino based multicopter.
   6:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  
   7:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   This program is free software: you can redistribute it and/or modify 
   8:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   it under the terms of the GNU General Public License as published by 
   9:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   (at your option) any later version. 
  11:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  
  12:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   This program is distributed in the hope that it will be useful, 
  13:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   GNU General Public License for more details. 
  16:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  
  17:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   You should have received a copy of the GNU General Public License 
  18:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** */
  20:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
  21:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** // FlightControl.pde is responsible for combining sensor measurements and
  22:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** // transmitter commands into motor commands for the defined flight configuration (X, +, etc.)
  23:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
  24:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
  25:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** #ifndef _AQ_PROCESS_FLIGHT_CONTROL_H_
  26:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** #define _AQ_PROCESS_FLIGHT_CONTROL_H_
  27:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
  28:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** #define ATTITUDE_SCALING (0.75 * PWM2RAD)
  29:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
  30:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
  31:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** /**
  32:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * calculateFlightError
  33:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  *
  34:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * Calculate roll/pitch axis error with gyro/accel data to
  35:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * compute motor command thrust so used command are executed
  36:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  */
  37:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** void calculateFlightError()
  38:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** {
 6675              		.loc 29 38 0
 6676              		.cfi_startproc
 6677              		@ args = 0, pretend = 0, frame = 0
 6678              		@ frame_needed = 0, uses_anonymous_args = 0
 6679 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, sl, lr}
 6680              	.LCFI74:
 6681              		.cfi_def_cfa_offset 32
 6682              		.cfi_offset 14, -4
 6683              		.cfi_offset 10, -8
 6684              		.cfi_offset 9, -12
 6685              		.cfi_offset 8, -16
 6686              		.cfi_offset 7, -20
 6687              		.cfi_offset 6, -24
 6688              		.cfi_offset 5, -28
 6689              		.cfi_offset 4, -32
 6690 0004 2DED028B 		fstmfdd	sp!, {d8}
 6691              	.LCFI75:
 6692              		.cfi_def_cfa_offset 40
 6693              		.cfi_offset 80, -40
 6694              	.LBB153:
  39:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #if defined (UseGPSNavigator)
  40:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     if (navigationState == ON || positionHoldState == ON) {
  41:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       float rollAttitudeCmd  = updatePID((receiverCommand[XAXIS] - receiverZero[XAXIS] + gpsRollAxi
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       float pitchAttitudeCmd = updatePID((receiverCommand[YAXIS] - receiverZero[YAXIS] + gpsPitchAx
  43:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorAxisCommandRoll   = updatePID(rollAttitudeCmd, gyroRate[XAXIS], &PID[ATTITUDE_GYRO_XAXIS
  44:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorAxisCommandPitch  = updatePID(pitchAttitudeCmd, -gyroRate[YAXIS], &PID[ATTITUDE_GYRO_YAX
  45:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
  46:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     else
  47:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #endif
  48:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if (flightMode == ATTITUDE_FLIGHT_MODE) {
 6695              		.loc 29 48 0
 6696 0008 3D48     		ldr	r0, .L407
 6697 000a 3E4C     		ldr	r4, .L407+4
 6698 000c 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 6699 000e 3E4E     		ldr	r6, .L407+8
 6700 0010 3E4D     		ldr	r5, .L407+12
 6701 0012 012B     		cmp	r3, #1
 6702 0014 46D1     		bne	.L405
 6703              	.LBB154:
  49:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     float rollAttitudeCmd  = updatePID((receiverCommand[XAXIS] - receiverZero[XAXIS]) * ATTITUDE_SC
 6704              		.loc 29 49 0
 6705 0016 DFF81C91 		ldr	r9, .L407+52
 6706 001a DFF81C81 		ldr	r8, .L407+56
 6707 001e D9F80020 		ldr	r2, [r9, #0]
 6708 0022 D8F80070 		ldr	r7, [r8, #0]
 6709 0026 D11B     		subs	r1, r2, r7
 6710 0028 03EE101A 		fmsr	s6, r1	@ int
 6711 002c 9FED388A 		flds	s16, .L407+16
 6712 0030 F8EEC32A 		fsitos	s5, s6
 6713 0034 374F     		ldr	r7, .L407+20
 6714 0036 384A     		ldr	r2, .L407+24
 6715 0038 3968     		ldr	r1, [r7, #0]	@ float
 6716 003a 22EE882A 		fmuls	s4, s5, s16
 6717 003e 12EE100A 		fmrs	r0, s4
 6718 0042 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
  50:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     float pitchAttitudeCmd = updatePID((receiverCommand[YAXIS] - receiverZero[YAXIS]) * ATTITUDE_SC
 6719              		.loc 29 50 0
 6720 0046 D8F80430 		ldr	r3, [r8, #4]
 6721 004a 7A68     		ldr	r2, [r7, #4]	@ float
  49:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     float rollAttitudeCmd  = updatePID((receiverCommand[XAXIS] - receiverZero[XAXIS]) * ATTITUDE_SC
 6722              		.loc 29 49 0
 6723 004c 8246     		mov	sl, r0	@ float
 6724              	.LVL320:
 6725              		.loc 29 50 0
 6726 004e D9F80400 		ldr	r0, [r9, #4]
 6727              	.LVL321:
 6728 0052 C3EB000C 		rsb	ip, r3, r0
 6729 0056 01EE90CA 		fmsr	s3, ip	@ int
 6730 005a B8EEE11A 		fsitos	s2, s3
 6731 005e 82F00041 		eor	r1, r2, #-2147483648
 6732 0062 21EE087A 		fmuls	s14, s2, s16
 6733 0066 2D4A     		ldr	r2, .L407+28
 6734 0068 17EE100A 		fmrs	r0, s14
 6735 006c FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
  51:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorAxisCommandRoll   = updatePID(rollAttitudeCmd, gyroRate[XAXIS], &PID[ATTITUDE_GYRO_XAXIS_P
 6736              		.loc 29 51 0
 6737 0070 2168     		ldr	r1, [r4, #0]	@ float
 6738 0072 2B4A     		ldr	r2, .L407+32
  50:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     float pitchAttitudeCmd = updatePID((receiverCommand[YAXIS] - receiverZero[YAXIS]) * ATTITUDE_SC
 6739              		.loc 29 50 0
 6740 0074 0746     		mov	r7, r0	@ float
 6741              	.LVL322:
 6742              		.loc 29 51 0
 6743 0076 5046     		mov	r0, sl	@ float
 6744              	.LVL323:
 6745 0078 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 6746 007c 00EE900A 		fmsr	s1, r0
  52:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorAxisCommandPitch  = updatePID(pitchAttitudeCmd, -gyroRate[YAXIS], &PID[ATTITUDE_GYRO_YAXIS
 6747              		.loc 29 52 0
 6748 0080 6168     		ldr	r1, [r4, #4]	@ float
 6749 0082 284A     		ldr	r2, .L407+36
  51:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorAxisCommandRoll   = updatePID(rollAttitudeCmd, gyroRate[XAXIS], &PID[ATTITUDE_GYRO_XAXIS_P
 6750              		.loc 29 51 0
 6751 0084 FDEEE07A 		ftosizs	s15, s1
 6752              		.loc 29 52 0
 6753 0088 3846     		mov	r0, r7	@ float
 6754 008a 81F00041 		eor	r1, r1, #-2147483648
  51:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorAxisCommandRoll   = updatePID(rollAttitudeCmd, gyroRate[XAXIS], &PID[ATTITUDE_GYRO_XAXIS_P
 6755              		.loc 29 51 0
 6756 008e C6ED007A 		fsts	s15, [r6, #0]	@ int
 6757              		.loc 29 52 0
 6758 0092 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 6759 0096 00EE100A 		fmsr	s0, r0
 6760 009a FDEEC06A 		ftosizs	s13, s0
 6761 009e C5ED006A 		fsts	s13, [r5, #0]	@ int
 6762 00a2 28E0     		b	.L404
 6763              	.LVL324:
 6764              	.L405:
 6765              	.LBE154:
  53:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
  54:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   else {
  55:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorAxisCommandRoll = updatePID(getReceiverSIData(XAXIS), gyroRate[XAXIS]*rotationSpeedFactor,
 6766              		.loc 29 55 0
 6767 00a4 204F     		ldr	r7, .L407+40
 6768 00a6 0020     		movs	r0, #0
 6769 00a8 FFF7FEFF 		bl	_Z17getReceiverSIDatah
 6770 00ac D4ED000A 		flds	s1, [r4, #0]
 6771 00b0 D7ED007A 		flds	s15, [r7, #0]
 6772 00b4 20EEA70A 		fmuls	s0, s1, s15
 6773 00b8 1C4A     		ldr	r2, .L407+44
 6774 00ba 10EE101A 		fmrs	r1, s0
 6775 00be FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 6776 00c2 06EE900A 		fmsr	s13, r0
 6777 00c6 BDEEE66A 		ftosizs	s12, s13
  56:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorAxisCommandPitch = updatePID(getReceiverSIData(YAXIS), -gyroRate[YAXIS]*rotationSpeedFacto
 6778              		.loc 29 56 0
 6779 00ca 0120     		movs	r0, #1
  55:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorAxisCommandRoll = updatePID(getReceiverSIData(XAXIS), gyroRate[XAXIS]*rotationSpeedFactor,
 6780              		.loc 29 55 0
 6781 00cc 86ED006A 		fsts	s12, [r6, #0]	@ int
 6782              		.loc 29 56 0
 6783 00d0 FFF7FEFF 		bl	_Z17getReceiverSIDatah
 6784 00d4 94ED015A 		flds	s10, [r4, #4]
 6785 00d8 D7ED005A 		flds	s11, [r7, #0]
 6786 00dc 65EE654A 		fnmuls	s9, s10, s11
 6787 00e0 134A     		ldr	r2, .L407+48
 6788 00e2 14EE901A 		fmrs	r1, s9
 6789 00e6 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 6790 00ea 04EE100A 		fmsr	s8, r0
 6791 00ee FDEEC43A 		ftosizs	s7, s8
 6792 00f2 C5ED003A 		fsts	s7, [r5, #0]	@ int
 6793              	.L404:
 6794              	.LBE153:
  57:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
  58:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** }
 6795              		.loc 29 58 0
 6796 00f6 BDEC028B 		fldmfdd	sp!, {d8}
 6797 00fa BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, sl, pc}
 6798              	.L408:
 6799 00fe 00BF     		.align	2
 6800              	.L407:
 6801 0100 00000000 		.word	.LANCHOR114
 6802 0104 00000000 		.word	.LANCHOR27
 6803 0108 00000000 		.word	.LANCHOR108
 6804 010c 00000000 		.word	.LANCHOR107
 6805 0110 A69BC43A 		.word	985963430
 6806 0114 00000000 		.word	.LANCHOR42
 6807 0118 54000000 		.word	.LANCHOR17+84
 6808 011c 70000000 		.word	.LANCHOR17+112
 6809 0120 A8000000 		.word	.LANCHOR17+168
 6810 0124 C4000000 		.word	.LANCHOR17+196
 6811 0128 00000000 		.word	.LANCHOR115
 6812 012c 00000000 		.word	.LANCHOR17
 6813 0130 1C000000 		.word	.LANCHOR17+28
 6814 0134 00000000 		.word	.LANCHOR6
 6815 0138 00000000 		.word	.LANCHOR11
 6816              		.cfi_endproc
 6817              	.LFE214:
 6819              		.section	.text._Z19processCalibrateESCv,"ax",%progbits
 6820              		.align	1
 6821              		.global	_Z19processCalibrateESCv
 6822              		.thumb
 6823              		.thumb_func
 6825              	_Z19processCalibrateESCv:
 6826              	.LFB215:
  59:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
  60:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** /**
  61:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * processCalibrateESC
  62:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * 
  63:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * Proces esc calibration command with the help of the configurator
  64:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  */
  65:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** void processCalibrateESC()
  66:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** {
 6827              		.loc 29 66 0
 6828              		.cfi_startproc
 6829              		@ args = 0, pretend = 0, frame = 0
 6830              		@ frame_needed = 0, uses_anonymous_args = 0
 6831              		@ link register save eliminated.
 6832              	.LBB155:
 6833              	.LBB156:
  67:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   switch (calibrateESC) { // used for calibrating ESC's
 6834              		.loc 29 67 0
 6835 0000 1B4B     		ldr	r3, .L423
 6836 0002 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 6837 0004 1B4B     		ldr	r3, .L423+4
 6838 0006 032A     		cmp	r2, #3
 6839 0008 0CD0     		beq	.L412
 6840 000a 052A     		cmp	r2, #5
 6841 000c 19D0     		beq	.L418
 6842 000e 012A     		cmp	r2, #1
 6843              	.LVL325:
 6844              	.LBB157:
 6845              	.LBB158:
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   case 1:
  69:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++)
  70:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = MAXCOMMAND;
 6846              		.loc 29 70 0
 6847 0010 0CBF     		ite	eq
 6848 0012 4FF4FA62 		moveq	r2, #2000
 6849              	.LVL326:
 6850              	.LBE158:
 6851              	.LBB159:
  71:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     break;
  72:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   case 3:
  73:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++)
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = constrain(testCommand, 1000, 1200);
  75:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     break;
  76:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   case 5:
  77:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++)
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
  79:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     safetyCheck = ON;
  80:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     break;
  81:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   default:
  82:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++)
  83:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = MINCOMMAND;
 6852              		.loc 29 83 0
 6853 0016 4FF47A72 		movne	r2, #1000
 6854              	.LVL327:
 6855              	.L422:
 6856              		.loc 29 83 0 is_stmt 0 discriminator 1
 6857 001a 1A60     		str	r2, [r3, #0]
 6858              	.LVL328:
 6859 001c 5A60     		str	r2, [r3, #4]
 6860              	.LVL329:
 6861 001e 9A60     		str	r2, [r3, #8]
 6862              	.LVL330:
 6863 0020 DA60     		str	r2, [r3, #12]
 6864              	.LVL331:
 6865 0022 23E0     		b	.L414
 6866              	.LVL332:
 6867              	.L412:
 6868              	.LBE159:
 6869              	.LBB160:
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = constrain(testCommand, 1000, 1200);
 6870              		.loc 29 74 0 is_stmt 1
 6871 0024 1448     		ldr	r0, .L423+8
 6872 0026 0268     		ldr	r2, [r0, #0]
 6873 0028 B2F5966F 		cmp	r2, #1200
 6874 002c B4BF     		ite	lt
 6875 002e 1146     		movlt	r1, r2
 6876 0030 4FF49661 		movge	r1, #1200
 6877 0034 B2F57A7F 		cmp	r2, #1000
 6878 0038 ACBF     		ite	ge
 6879 003a 0A46     		movge	r2, r1
 6880 003c 4FF47A72 		movlt	r2, #1000
 6881 0040 EBE7     		b	.L422
 6882              	.L418:
 6883              	.LBE160:
 6884              	.LBE157:
  67:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   switch (calibrateESC) { // used for calibrating ESC's
 6885              		.loc 29 67 0
 6886 0042 0022     		movs	r2, #0
 6887              	.L413:
 6888              	.LBB162:
 6889              	.LBB161:
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
 6890              		.loc 29 78 0
 6891 0044 0D49     		ldr	r1, .L423+12
 6892 0046 5158     		ldr	r1, [r2, r1]
 6893 0048 B1F57A7F 		cmp	r1, #1000
 6894 004c 05DB     		blt	.L419
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
 6895              		.loc 29 78 0 is_stmt 0 discriminator 1
 6896 004e B1F5966F 		cmp	r1, #1200
 6897 0052 A8BF     		it	ge
 6898 0054 4FF49661 		movge	r1, #1200
 6899 0058 01E0     		b	.L417
 6900              	.L419:
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
 6901              		.loc 29 78 0
 6902 005a 4FF47A71 		mov	r1, #1000
 6903              	.L417:
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
 6904              		.loc 29 78 0 discriminator 3
 6905 005e 9950     		str	r1, [r3, r2]
 6906 0060 0432     		adds	r2, r2, #4
  77:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++)
 6907              		.loc 29 77 0 is_stmt 1 discriminator 3
 6908 0062 102A     		cmp	r2, #16
 6909 0064 EED1     		bne	.L413
 6910              	.LBE161:
  79:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     safetyCheck = ON;
 6911              		.loc 29 79 0
 6912 0066 064B     		ldr	r3, .L423+16
 6913 0068 0122     		movs	r2, #1
 6914 006a 1A70     		strb	r2, [r3, #0]
 6915              	.LVL333:
 6916              	.L414:
 6917              	.LBE162:
 6918              	.LBE156:
 6919              	.LBE155:
  84:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
  85:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // Send calibration commands to motors
  86:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   writeMotors(); // Defined in Motors.h
  87:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** }
 6920              		.loc 29 87 0
 6921              	.LBB163:
  86:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   writeMotors(); // Defined in Motors.h
 6922              		.loc 29 86 0
 6923 006c FFF7FEBF 		b	_Z11writeMotorsv
 6924              	.L424:
 6925              		.align	2
 6926              	.L423:
 6927 0070 00000000 		.word	.LANCHOR116
 6928 0074 00000000 		.word	.LANCHOR63
 6929 0078 00000000 		.word	.LANCHOR117
 6930 007c 00000000 		.word	.LANCHOR118
 6931 0080 00000000 		.word	.LANCHOR119
 6932              	.LBE163:
 6933              		.cfi_endproc
 6934              	.LFE215:
 6936              		.section	.text._Z25processThrottleCorrectionv,"ax",%progbits
 6937              		.align	1
 6938              		.global	_Z25processThrottleCorrectionv
 6939              		.thumb
 6940              		.thumb_func
 6942              	_Z25processThrottleCorrectionv:
 6943              	.LFB216:
  88:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
  89:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** /**
  90:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * processBatteryMonitorThrottleAdjustment
  91:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  *
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * Check battery alarm and if in alarm, increment a counter
  93:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * When this counter reach BATTERY_MONITOR_MAX_ALARM_COUNT, then
  94:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * we are now in auto-descent mode.
  95:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  *
  96:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * When in auto-descent mode, the user can pass throttle keep when the
  97:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * alarm was reach, and the throttle is slowly decrease for a minute til
  98:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * batteryMonitorThrottle that is configurable with the configurator
  99:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  */
 100:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** #if defined BattMonitor && defined BattMonitorAutoDescent
 101:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   void processBatteryMonitorThrottleAdjustment() {
 102:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     
 103:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     if (batteryMonitorAlarmCounter < BATTERY_MONITOR_MAX_ALARM_COUNT) {
 104:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       if (batteryAlarm) {
 105:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         batteryMonitorAlarmCounter++;
 106:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       }
 107:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
 108:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     else {
 109:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 110:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         if (altitudeHoldState == ON) {
 111:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           #if defined AltitudeHoldBaro
 112:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             baroAltitudeToHoldTarget -= 0.01;
 113:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           #endif
 114:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           #if defined AltitudeHoldRangeFinder
 115:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             if (sonarAltitudeToHoldTarget != INVALID_RANGE) {
 116:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****               sonarAltitudeToHoldTarget -= 0.01;
 117:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             }
 118:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           #endif
 119:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         }
 120:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         else {
 121:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       #endif
 122:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           if (batteryMonitorStartThrottle == 0) {  // init battery monitor throttle correction!
 123:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             batteryMonitorStartTime = millis();
 124:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             if (throttle < batteryMonitorThrottleTarget) {
 125:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****               batteryMonitorStartThrottle = batteryMonitorThrottleTarget;
 126:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             }
 127:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             else {
 128:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****               batteryMonitorStartThrottle = throttle; 
 129:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             }
 130:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           }
 131:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           int batteryMonitorThrottle = map(millis()-batteryMonitorStartTime, 0, batteryMonitorGoing
 132:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           if (batteryMonitorThrottle < batteryMonitorThrottleTarget) {
 133:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             batteryMonitorThrottle = batteryMonitorThrottleTarget;
 134:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           }
 135:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           if (throttle < batteryMonitorThrottle) {
 136:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             batteyMonitorThrottleCorrection = 0;
 137:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           }
 138:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           else {
 139:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             batteyMonitorThrottleCorrection = batteryMonitorThrottle - throttle;
 140:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           }
 141:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 142:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         }
 143:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       #endif
 144:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
 145:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 146:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** #endif  
 147:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 148:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 149:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** #if defined AutoLanding
 150:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #define BARO_AUTO_LANDING_DESCENT_SPEED 0.008
 151:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #define SONAR_AUTO_LANDING_DESCENT_SPEED 0.005
 152:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   void processAutoLandingAltitudeCorrection() {
 153:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     if (autoLandingState != OFF) {   
 154:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 155:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       if (autoLandingState == BARO_AUTO_DESCENT_STATE) {
 156:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         baroAltitudeToHoldTarget -= BARO_AUTO_LANDING_DESCENT_SPEED;
 157:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         if (isOnRangerRange(rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX])) { 
 158:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           autoLandingState = SONAR_AUTO_DESCENT_STATE;
 159:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         }
 160:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       }
 161:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       else if (autoLandingState == SONAR_AUTO_DESCENT_STATE) {
 162:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         baroAltitudeToHoldTarget -= BARO_AUTO_LANDING_DESCENT_SPEED;
 163:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         sonarAltitudeToHoldTarget -= SONAR_AUTO_LANDING_DESCENT_SPEED;
 164:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         if (rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX] < 0.5) {
 165:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           autoLandingState = MOTOR_AUTO_DESCENT_STATE;
 166:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         }
 167:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       }
 168:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       else {
 169:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         autoLandingThrottleCorrection -= 1;
 170:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         baroAltitudeToHoldTarget -= BARO_AUTO_LANDING_DESCENT_SPEED;
 171:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         sonarAltitudeToHoldTarget -= SONAR_AUTO_LANDING_DESCENT_SPEED;
 172:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 173:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         if (((throttle + autoLandingThrottleCorrection) < 1000) || (rangeFinderRange[ALTITUDE_RANGE
 174:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           commandAllMotors(MINCOMMAND);
 175:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           motorArmed = OFF;
 176:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         }
 177:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       }
 178:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
 179:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  }
 180:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** #endif
 181:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 182:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 183:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** /**
 184:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * processThrottleCorrection
 185:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * 
 186:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * This function will add some throttle imput if the craft is angled
 187:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * this prevent the craft to loose altitude when angled.
 188:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * it also add the battery throttle correction in case
 189:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * of we are in auto-descent.
 190:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * 
 191:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * Special thank to Ziojo for this.
 192:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  */
 193:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** void processThrottleCorrection() {
 6944              		.loc 29 193 0
 6945              		.cfi_startproc
 6946              		@ args = 0, pretend = 0, frame = 0
 6947              		@ frame_needed = 0, uses_anonymous_args = 0
 6948              		@ link register save eliminated.
 6949              	.LVL334:
 6950              	.LBB164:
 194:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  
 195:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   int throttleAdjust = 0;
 196:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #if defined UseGPSNavigator
 197:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     if (navigationState == ON || positionHoldState == ON) {
 198:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       throttleAdjust = throttle / (cos (kinematicsAngle[XAXIS]*0.55) * cos (kinematicsAngle[YAXIS]*
 199:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       throttleAdjust = constrain ((throttleAdjust - throttle), 0, 50); //compensate max  +/- 25 deg
 200:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
 201:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #endif
 202:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #if defined BattMonitorAutoDescent
 203:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     throttleAdjust += batteyMonitorThrottleCorrection;
 204:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #endif
 205:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #if defined (AutoLanding)
 206:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #if defined BattMonitorAutoDescent
 207:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       if (batteyMonitorThrottleCorrection != 0) { // don't auto land in the same time that the batt
 208:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         throttleAdjust += autoLandingThrottleCorrection;
 209:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       }
 210:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #else
 211:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       throttleAdjust += autoLandingThrottleCorrection;
 212:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #endif
 213:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #endif
 214:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   
 215:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   throttle = constrain((throttle + throttleAdjust),MINCOMMAND,MAXCOMMAND-150);  // limmit throttle 
 6951              		.loc 29 215 0
 6952 0000 074A     		ldr	r2, .L428
 6953 0002 1368     		ldr	r3, [r2, #0]
 6954 0004 B3F57A7F 		cmp	r3, #1000
 6955 0008 05DB     		blt	.L427
 6956              		.loc 29 215 0 is_stmt 0 discriminator 1
 6957 000a 40F23A71 		movw	r1, #1850
 6958 000e 8B42     		cmp	r3, r1
 6959 0010 A8BF     		it	ge
 6960 0012 0B46     		movge	r3, r1
 6961 0014 01E0     		b	.L426
 6962              	.L427:
 6963              		.loc 29 215 0
 6964 0016 4FF47A73 		mov	r3, #1000
 6965              	.L426:
 6966              		.loc 29 215 0 discriminator 3
 6967 001a 1360     		str	r3, [r2, #0]
 6968              	.LBE164:
 216:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** }
 6969              		.loc 29 216 0 is_stmt 1 discriminator 3
 6970 001c 7047     		bx	lr
 6971              	.L429:
 6972 001e 00BF     		.align	2
 6973              	.L428:
 6974 0020 00000000 		.word	.LANCHOR106
 6975              		.cfi_endproc
 6976              	.LFE216:
 6978              		.section	.text._Z20processHardManueversv,"ax",%progbits
 6979              		.align	1
 6980              		.global	_Z20processHardManueversv
 6981              		.thumb
 6982              		.thumb_func
 6984              	_Z20processHardManueversv:
 6985              	.LFB217:
 217:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 218:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 219:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** /**
 220:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * processHardManuevers
 221:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  *
 222:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * In case of a roll/pitch stick at one edge to do a loop, this function
 223:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * will prevent the lower throttle motor side to have too much low throtte.
 224:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  */
 225:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** void processHardManuevers() {
 6986              		.loc 29 225 0
 6987              		.cfi_startproc
 6988              		@ args = 0, pretend = 0, frame = 0
 6989              		@ frame_needed = 0, uses_anonymous_args = 0
 6990              		@ link register save eliminated.
 6991              	.LBB165:
 226:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   
 227:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if ((receiverCommand[XAXIS] < MINCHECK) ||
 6992              		.loc 29 227 0
 6993 0000 0F4A     		ldr	r2, .L436
 6994 0002 1068     		ldr	r0, [r2, #0]
 6995 0004 A0F58863 		sub	r3, r0, #1088
 6996 0008 0C3B     		subs	r3, r3, #12
 6997 000a B3F5487F 		cmp	r3, #800
 6998 000e 04D8     		bhi	.L431
 228:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       (receiverCommand[XAXIS] > MAXCHECK) ||
 229:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       (receiverCommand[YAXIS] < MINCHECK) ||
 6999              		.loc 29 229 0 discriminator 1
 7000 0010 5368     		ldr	r3, [r2, #4]
 227:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if ((receiverCommand[XAXIS] < MINCHECK) ||
 7001              		.loc 29 227 0 discriminator 1
 7002 0012 40F24B42 		movw	r2, #1099
 7003 0016 9342     		cmp	r3, r2
 7004 0018 03DC     		bgt	.L432
 7005              	.L431:
 7006              	.LBB166:
 230:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       (receiverCommand[YAXIS] > MAXCHECK)) {  
 231:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         
 232:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (int motor = 0; motor < LASTMOTOR; motor++) {
 233:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 7007              		.loc 29 233 0 discriminator 2
 7008 001a 0A49     		ldr	r1, .L436+4
 7009 001c 0023     		movs	r3, #0
 7010 001e 0A68     		ldr	r2, [r1, #0]
 7011 0020 04E0     		b	.L433
 7012              	.L432:
 7013              	.LBE166:
 227:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if ((receiverCommand[XAXIS] < MINCHECK) ||
 7014              		.loc 29 227 0 discriminator 2
 7015 0022 40F26C70 		movw	r0, #1900
 7016 0026 8342     		cmp	r3, r0
 7017 0028 F7DC     		bgt	.L431
 7018 002a 7047     		bx	lr
 7019              	.L433:
 7020              	.LBB167:
 7021              		.loc 29 233 0 discriminator 2
 7022 002c 0648     		ldr	r0, .L436+8
 234:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorMaxCommand[motor] = MAXCOMMAND;
 7023              		.loc 29 234 0 discriminator 2
 7024 002e 0749     		ldr	r1, .L436+12
 233:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 7025              		.loc 29 233 0 discriminator 2
 7026 0030 1A50     		str	r2, [r3, r0]
 7027              		.loc 29 234 0 discriminator 2
 7028 0032 4FF4FA60 		mov	r0, #2000
 7029 0036 5850     		str	r0, [r3, r1]
 7030 0038 0433     		adds	r3, r3, #4
 232:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (int motor = 0; motor < LASTMOTOR; motor++) {
 7031              		.loc 29 232 0 discriminator 2
 7032 003a 102B     		cmp	r3, #16
 7033 003c F6D1     		bne	.L433
 7034 003e 7047     		bx	lr
 7035              	.L437:
 7036              		.align	2
 7037              	.L436:
 7038 0040 00000000 		.word	.LANCHOR6
 7039 0044 00000000 		.word	.LANCHOR120
 7040 0048 00000000 		.word	.LANCHOR121
 7041 004c 00000000 		.word	.LANCHOR122
 7042              	.LBE167:
 7043              	.LBE165:
 7044              		.cfi_endproc
 7045              	.LFE217:
 7047              		.section	.text._Z20processMinMaxCommandv,"ax",%progbits
 7048              		.align	1
 7049              		.global	_Z20processMinMaxCommandv
 7050              		.thumb
 7051              		.thumb_func
 7053              	_Z20processMinMaxCommandv:
 7054              	.LFB218:
 235:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
 236:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 237:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** }
 238:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 239:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** /**
 240:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * processMinMaxCommand
 241:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  *
 242:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * This function correct too low/max throttle when manuevering
 243:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * preventing some wobbling behavior
 244:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  */
 245:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** void processMinMaxCommand()
 246:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** {
 7055              		.loc 29 246 0
 7056              		.cfi_startproc
 7057              		@ args = 0, pretend = 0, frame = 0
 7058              		@ frame_needed = 0, uses_anonymous_args = 0
 7059              	.LVL335:
 7060              	.LBB168:
 7061              	.LBB169:
 247:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   for (byte motor = 0; motor < LASTMOTOR; motor++)
 248:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   {
 249:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorMinCommand[motor] = minArmedThrottle;
 7062              		.loc 29 249 0
 7063 0000 154A     		ldr	r2, .L442
 250:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorMaxCommand[motor] = MAXCOMMAND;
 7064              		.loc 29 250 0
 7065 0002 164B     		ldr	r3, .L442+4
 249:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorMinCommand[motor] = minArmedThrottle;
 7066              		.loc 29 249 0
 7067 0004 1068     		ldr	r0, [r2, #0]
 7068 0006 1649     		ldr	r1, .L442+8
 7069              		.loc 29 250 0
 7070 0008 4FF4FA62 		mov	r2, #2000
 7071              	.LBE169:
 7072              	.LBE168:
 246:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** {
 7073              		.loc 29 246 0
 7074 000c 10B5     		push	{r4, lr}
 7075              	.LCFI76:
 7076              		.cfi_def_cfa_offset 8
 7077              		.cfi_offset 14, -4
 7078              		.cfi_offset 4, -8
 7079              	.LBB174:
 7080              	.LBB170:
 7081              		.loc 29 250 0
 7082 000e 9A60     		str	r2, [r3, #8]
 7083 0010 DA60     		str	r2, [r3, #12]
 7084 0012 1A60     		str	r2, [r3, #0]
 7085              	.LVL336:
 7086 0014 5A60     		str	r2, [r3, #4]
 7087              	.LVL337:
 7088              	.LBE170:
 251:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 252:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 253:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   int maxMotor = motorCommand[0];
 7089              		.loc 29 253 0
 7090 0016 134B     		ldr	r3, .L442+12
 7091              	.LBB171:
 249:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorMinCommand[motor] = minArmedThrottle;
 7092              		.loc 29 249 0
 7093 0018 0860     		str	r0, [r1, #0]
 7094 001a 4860     		str	r0, [r1, #4]
 7095 001c 8860     		str	r0, [r1, #8]
 7096 001e C860     		str	r0, [r1, #12]
 7097              	.LBE171:
 7098              		.loc 29 253 0
 7099 0020 93E80600 		ldmia	r3, {r1, r2}
 7100 0024 9868     		ldr	r0, [r3, #8]
 7101 0026 9142     		cmp	r1, r2
 7102 0028 B8BF     		it	lt
 7103 002a 1146     		movlt	r1, r2
 7104              	.LVL338:
 7105 002c DA68     		ldr	r2, [r3, #12]
 7106 002e 8142     		cmp	r1, r0
 7107 0030 B8BF     		it	lt
 7108 0032 0146     		movlt	r1, r0
 7109              	.LVL339:
 7110 0034 9142     		cmp	r1, r2
 7111 0036 B8BF     		it	lt
 7112 0038 1146     		movlt	r1, r2
 7113              	.LVL340:
 7114              	.LBB172:
 254:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   
 255:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   for (byte motor=1; motor < LASTMOTOR; motor++) {
 256:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     if (motorCommand[motor] > maxMotor) {
 7115              		.loc 29 256 0
 7116 003a 0022     		movs	r2, #0
 7117              	.LVL341:
 7118              	.L440:
 7119              	.LBE172:
 7120              	.LBB173:
 257:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       maxMotor = motorCommand[motor];
 258:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
 259:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 260:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     
 261:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   for (byte motor = 0; motor < LASTMOTOR; motor++) {
 262:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     if (maxMotor > MAXCOMMAND) {
 7121              		.loc 29 262 0
 7122 003c B1F5FA6F 		cmp	r1, #2000
 7123 0040 05DD     		ble	.L439
 263:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] =  motorCommand[motor] - (maxMotor - MAXCOMMAND);
 7124              		.loc 29 263 0
 7125 0042 9C58     		ldr	r4, [r3, r2]
 7126 0044 C1F5FA6C 		rsb	ip, r1, #2000
 7127 0048 04EB0C00 		add	r0, r4, ip
 7128 004c 9850     		str	r0, [r3, r2]
 7129              	.L439:
 7130 004e 0432     		adds	r2, r2, #4
 261:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   for (byte motor = 0; motor < LASTMOTOR; motor++) {
 7131              		.loc 29 261 0
 7132 0050 102A     		cmp	r2, #16
 7133 0052 F3D1     		bne	.L440
 7134              	.LBE173:
 7135              	.LBE174:
 264:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
 265:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 266:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** }
 7136              		.loc 29 266 0
 7137 0054 10BD     		pop	{r4, pc}
 7138              	.L443:
 7139 0056 00BF     		.align	2
 7140              	.L442:
 7141 0058 00000000 		.word	.LANCHOR120
 7142 005c 00000000 		.word	.LANCHOR122
 7143 0060 00000000 		.word	.LANCHOR121
 7144 0064 00000000 		.word	.LANCHOR63
 7145              		.cfi_endproc
 7146              	.LFE218:
 7148              		.section	.text._Z14processHeadingv,"ax",%progbits
 7149              		.align	1
 7150              		.global	_Z14processHeadingv
 7151              		.thumb
 7152              		.thumb_func
 7154              	_Z14processHeadingv:
 7155              	.LFB221:
 7156              		.file 30 "C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h"
   1:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** /*
   2:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   AeroQuad v3.0.1 - February 2012
   3:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   www.AeroQuad.com
   4:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   An Open Source Arduino based multicopter.
   6:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  
   7:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   This program is free software: you can redistribute it and/or modify 
   8:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   it under the terms of the GNU General Public License as published by 
   9:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   (at your option) any later version. 
  11:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  
  12:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   This program is distributed in the hope that it will be useful, 
  13:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   GNU General Public License for more details. 
  16:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  
  17:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   You should have received a copy of the GNU General Public License 
  18:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** */
  20:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  21:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  22:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** #ifndef _AQ_HEADING_CONTROL_PROCESSOR_H_
  23:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** #define _AQ_HEADING_CONTROL_PROCESSOR_H_
  24:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  25:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  26:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** float setHeading          = 0;
  27:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** unsigned long headingTime = micros();
  28:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  29:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  30:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** /**
  31:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  * processHeading
  32:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  *
  33:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  * This function will calculate the craft heading correction depending 
  34:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  * of the users command. Heading correction is process with the gyro
  35:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  * or a magnetometer
  36:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  */
  37:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** void processHeading()
  38:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** {
 7157              		.loc 30 38 0
 7158              		.cfi_startproc
 7159              		@ args = 0, pretend = 0, frame = 0
 7160              		@ frame_needed = 0, uses_anonymous_args = 0
 7161 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 7162              	.LCFI77:
 7163              		.cfi_def_cfa_offset 24
 7164              		.cfi_offset 14, -4
 7165              		.cfi_offset 7, -8
 7166              		.cfi_offset 6, -12
 7167              		.cfi_offset 5, -16
 7168              		.cfi_offset 4, -20
 7169              		.cfi_offset 3, -24
 7170              	.LBB175:
  39:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   if (headingHoldConfig == ON) {
 7171              		.loc 30 39 0
 7172 0002 5C48     		ldr	r0, .L465
 7173 0004 5C4E     		ldr	r6, .L465+4
 7174 0006 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 7175 0008 5C4C     		ldr	r4, .L465+8
 7176 000a 012B     		cmp	r3, #1
 7177 000c 7ED1     		bne	.L445
  40:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  41:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     #if defined(HeadingMagHold)
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       heading = degrees(trueNorthHeading);
 7178              		.loc 30 42 0
 7179 000e 5C4A     		ldr	r2, .L465+12
 7180 0010 5C49     		ldr	r1, .L465+16
  43:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     #else
  44:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       heading = degrees(gyroHeading);
  45:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     #endif
  46:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  47:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     // Always center relative heading around absolute heading chosen during yaw command
  48:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     // This assumes that an incorrect yaw can't be forced on the AeroQuad >180 or <-180 degrees
  49:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     // This is done so that AeroQuad does not accidentally hit transition between 0 and 360 or -180
  50:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     // AKA - THERE IS A BUG HERE - if relative heading is greater than 180 degrees, the PID will sw
  51:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     // Doubt that will happen as it would have to be uncommanded.
  52:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     relativeHeading = heading - setHeading;
 7181              		.loc 30 52 0
 7182 0012 5D4B     		ldr	r3, .L465+20
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       heading = degrees(trueNorthHeading);
 7183              		.loc 30 42 0
 7184 0014 92ED007A 		flds	s14, [r2, #0]
 7185 0018 DFED5C7A 		flds	s15, .L465+24
 7186              		.loc 30 52 0
 7187 001c 5C4A     		ldr	r2, .L465+28
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       heading = degrees(trueNorthHeading);
 7188              		.loc 30 42 0
 7189 001e 67EE277A 		fmuls	s15, s14, s15
  53:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     if (heading <= (setHeading - 180)) {
 7190              		.loc 30 53 0
 7191 0022 9FED5C6A 		flds	s12, .L465+32
  52:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     relativeHeading = heading - setHeading;
 7192              		.loc 30 52 0
 7193 0026 92ED007A 		flds	s14, [r2, #0]
 7194              		.loc 30 53 0
 7195 002a 77EE465A 		fsubs	s11, s14, s12
  52:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     relativeHeading = heading - setHeading;
 7196              		.loc 30 52 0
 7197 002e 77EEC76A 		fsubs	s13, s15, s14
 7198              		.loc 30 53 0
 7199 0032 F4EEE57A 		fcmpes	s15, s11
 7200 0036 F1EE10FA 		fmstat
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       heading = degrees(trueNorthHeading);
 7201              		.loc 30 42 0
 7202 003a C1ED007A 		fsts	s15, [r1, #0]
  52:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     relativeHeading = heading - setHeading;
 7203              		.loc 30 52 0
 7204 003e C3ED006A 		fsts	s13, [r3, #0]
 7205              		.loc 30 53 0
 7206 0042 05D8     		bhi	.L446
  54:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       relativeHeading += 360;
 7207              		.loc 30 54 0
 7208 0044 9FED540A 		flds	s0, .L465+36
 7209 0048 76EE806A 		fadds	s13, s13, s0
 7210 004c C3ED006A 		fsts	s13, [r3, #0]
 7211              	.L446:
  55:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     }
  56:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     if (heading >= (setHeading + 180)) {
 7212              		.loc 30 56 0
 7213 0050 77EE060A 		fadds	s1, s14, s12
 7214 0054 F4EEE07A 		fcmpes	s15, s1
 7215 0058 F1EE10FA 		fmstat
 7216 005c 07DB     		blt	.L448
  57:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       relativeHeading -= 360;
 7217              		.loc 30 57 0
 7218 005e 93ED002A 		flds	s4, [r3, #0]
 7219 0062 DFED4D1A 		flds	s3, .L465+36
 7220 0066 32EE611A 		fsubs	s2, s4, s3
 7221 006a 83ED001A 		fsts	s2, [r3, #0]
 7222              	.L448:
  58:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     }
  59:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  60:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     // Apply heading hold only when throttle high enough to start flight
  61:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     if (receiverCommand[THROTTLE] > MINCHECK ) { 
 7223              		.loc 30 61 0
 7224 006e F068     		ldr	r0, [r6, #12]
 7225 0070 40F24C4C 		movw	ip, #1100
 7226 0074 6045     		cmp	r0, ip
 7227 0076 42DD     		ble	.L450
  62:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       
  63:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       #if defined (UseGPSNavigator)
  64:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         if (( (receiverCommand[ZAXIS] + gpsYawAxisCorrection) > (MIDCOMMAND + 25)) || 
  65:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****             ( (receiverCommand[ZAXIS] + gpsYawAxisCorrection) < (MIDCOMMAND - 25))) {
  66:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       #else
  67:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         if ((receiverCommand[ZAXIS] > (MIDCOMMAND + 25)) || 
 7228              		.loc 30 67 0
 7229 0078 3F48     		ldr	r0, .L465+4
 7230 007a 8168     		ldr	r1, [r0, #8]
 7231 007c A1F5B860 		sub	r0, r1, #1472
 7232 0080 C11E     		subs	r1, r0, #3
 7233 0082 3229     		cmp	r1, #50
 7234 0084 0ED9     		bls	.L451
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****             (receiverCommand[ZAXIS] < (MIDCOMMAND - 25))) {
  69:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       #endif
  70:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       
  71:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         
  72:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         // If commanding yaw, turn off heading hold and store latest heading
  73:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         setHeading = heading;
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         headingHold = 0;
  75:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         PID[HEADING_HOLD_PID_IDX].integratedError = 0;
 7235              		.loc 30 75 0
 7236 0086 4549     		ldr	r1, .L465+40
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         headingHold = 0;
 7237              		.loc 30 74 0
 7238 0088 0023     		movs	r3, #0
  73:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         setHeading = heading;
 7239              		.loc 30 73 0
 7240 008a C2ED007A 		fsts	s15, [r2, #0]
 7241              		.loc 30 75 0
 7242 008e C1F8A030 		str	r3, [r1, #160]	@ float
  76:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         headingHoldState = OFF;
 7243              		.loc 30 76 0
 7244 0092 434A     		ldr	r2, .L465+44
  77:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         headingTime = currentTime;
 7245              		.loc 30 77 0
 7246 0094 4349     		ldr	r1, .L465+48
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         headingHold = 0;
 7247              		.loc 30 74 0
 7248 0096 2360     		str	r3, [r4, #0]	@ float
  76:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         headingHoldState = OFF;
 7249              		.loc 30 76 0
 7250 0098 0020     		movs	r0, #0
 7251 009a 1070     		strb	r0, [r2, #0]
 7252              		.loc 30 77 0
 7253 009c 424B     		ldr	r3, .L465+52
 7254 009e 0A68     		ldr	r2, [r1, #0]
 7255 00a0 1A60     		str	r2, [r3, #0]
 7256 00a2 33E0     		b	.L445
 7257              	.L451:
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       }
  79:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       else {
  80:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         if (relativeHeading < 0.25 && relativeHeading > -0.25) {
 7258              		.loc 30 80 0
 7259 00a4 93ED007A 		flds	s14, [r3, #0]
 7260 00a8 F5EE002A 		fconsts	s5, #80
 7261 00ac B4EEE27A 		fcmpes	s14, s5
 7262 00b0 F1EE10FA 		fmstat
 7263 00b4 06D5     		bpl	.L452
 7264              		.loc 30 80 0 is_stmt 0 discriminator 1
 7265 00b6 BDEE003A 		fconsts	s6, #208
 7266 00ba B4EEC37A 		fcmpes	s14, s6
 7267 00be F1EE10FA 		fmstat
 7268 00c2 1EDC     		bgt	.L464
 7269              	.L452:
  81:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****           headingHold = 0;
  82:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****           PID[HEADING_HOLD_PID_IDX].integratedError = 0;
  83:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         }
  84:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         else if (headingHoldState == OFF) { // quick fix to soften heading hold on new heading
 7270              		.loc 30 84 0 is_stmt 1
 7271 00c4 3649     		ldr	r1, .L465+44
 7272 00c6 384D     		ldr	r5, .L465+52
 7273 00c8 0878     		ldrb	r0, [r1, #0]	@ zero_extendqisi2
 7274 00ca 364F     		ldr	r7, .L465+48
 7275 00cc 68B9     		cbnz	r0, .L455
  85:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****           if ((currentTime - headingTime) > 500000) {
 7276              		.loc 30 85 0
 7277 00ce 3B68     		ldr	r3, [r7, #0]
 7278 00d0 2F68     		ldr	r7, [r5, #0]
 7279 00d2 3648     		ldr	r0, .L465+56
 7280 00d4 DF1B     		subs	r7, r3, r7
 7281 00d6 8742     		cmp	r7, r0
 7282 00d8 18D9     		bls	.L445
  86:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****             headingHoldState = ON;
 7283              		.loc 30 86 0
 7284 00da 0120     		movs	r0, #1
  87:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****             headingTime = currentTime;
  88:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****             setHeading = heading;
 7285              		.loc 30 88 0
 7286 00dc C2ED007A 		fsts	s15, [r2, #0]
  89:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****             headingHold = 0;
 7287              		.loc 30 89 0
 7288 00e0 0022     		movs	r2, #0
  86:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****             headingHoldState = ON;
 7289              		.loc 30 86 0
 7290 00e2 0870     		strb	r0, [r1, #0]
  87:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****             headingTime = currentTime;
 7291              		.loc 30 87 0
 7292 00e4 2B60     		str	r3, [r5, #0]
 7293              		.loc 30 89 0
 7294 00e6 2260     		str	r2, [r4, #0]	@ float
 7295 00e8 10E0     		b	.L445
 7296              	.L455:
  90:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****           }
  91:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         }
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         else {
  93:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         // No new yaw input, calculate current heading vs. desired heading heading hold
  94:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         // Relative heading is always centered around zero
  95:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****           headingHold = updatePID(0, relativeHeading, &PID[HEADING_HOLD_PID_IDX]);
 7297              		.loc 30 95 0
 7298 00ea 17EE101A 		fmrs	r1, s14
 7299 00ee 0020     		movs	r0, #0
 7300 00f0 2F4A     		ldr	r2, .L465+60
 7301 00f2 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
  96:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****           headingTime = currentTime; // quick fix to soften heading hold, wait 100ms before applyin
 7302              		.loc 30 96 0
 7303 00f6 3968     		ldr	r1, [r7, #0]
  95:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****           headingHold = updatePID(0, relativeHeading, &PID[HEADING_HOLD_PID_IDX]);
 7304              		.loc 30 95 0
 7305 00f8 2060     		str	r0, [r4, #0]	@ float
 7306              		.loc 30 96 0
 7307 00fa 2960     		str	r1, [r5, #0]
 7308 00fc 06E0     		b	.L445
 7309              	.L450:
  97:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         }
  98:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       }
  99:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     }
 100:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     else {
 101:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       // minimum throttle not reached, use off settings
 102:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       setHeading = heading;
 7310              		.loc 30 102 0
 7311 00fe C2ED007A 		fsts	s15, [r2, #0]
 7312              	.L464:
 103:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       headingHold = 0;
 104:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       PID[HEADING_HOLD_PID_IDX].integratedError = 0;
 7313              		.loc 30 104 0
 7314 0102 264A     		ldr	r2, .L465+40
 103:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       headingHold = 0;
 7315              		.loc 30 103 0
 7316 0104 0023     		movs	r3, #0
 7317 0106 2360     		str	r3, [r4, #0]	@ float
 7318              		.loc 30 104 0
 7319 0108 C2F8A030 		str	r3, [r2, #160]	@ float
 7320              	.L445:
 7321              	.LVL342:
 105:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     }
 106:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   }
 107:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   // NEW SI Version
 108:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   #if defined (UseGPSNavigator) 
 109:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     float receiverSiData = (receiverCommand[ZAXIS] - receiverZero[ZAXIS] + gpsYawAxisCorrection) * 
 110:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   #else
 111:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     float receiverSiData = (receiverCommand[ZAXIS] - receiverZero[ZAXIS]) * (2.5 * PWM2RAD);
 7322              		.loc 30 111 0
 7323 010c 294B     		ldr	r3, .L465+64
 7324 010e B268     		ldr	r2, [r6, #8]
 7325 0110 9968     		ldr	r1, [r3, #8]
 7326 0112 501A     		subs	r0, r2, r1
 7327 0114 07EE900A 		fmsr	s15, r0	@ int
 112:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   #endif
 113:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   
 114:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   const float commandedYaw = constrain(receiverSiData + radians(headingHold), -PI, PI);
 7328              		.loc 30 114 0
 7329 0118 D4ED004A 		flds	s9, [r4, #0]
 111:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     float receiverSiData = (receiverCommand[ZAXIS] - receiverZero[ZAXIS]) * (2.5 * PWM2RAD);
 7330              		.loc 30 111 0
 7331 011c F8EEE73A 		fsitos	s7, s15
 7332              		.loc 30 114 0
 7333 0120 DFED257A 		flds	s15, .L465+68
 7334 0124 9FED254A 		flds	s8, .L465+72
 7335 0128 64EEA77A 		fmuls	s15, s9, s15
 7336 012c 43EE847A 		fmacs	s15, s7, s8
 7337 0130 9FED237A 		flds	s14, .L465+76
 7338 0134 F4EEC77A 		fcmpes	s15, s14
 7339 0138 F1EE10FA 		fmstat
 7340 013c 0BD4     		bmi	.L458
 7341              		.loc 30 114 0 is_stmt 0 discriminator 2
 7342 013e 9FED215A 		flds	s10, .L465+80
 7343 0142 F4EE457A 		fcmps	s15, s10
 7344 0146 F1EE10FA 		fmstat
 7345 014a CCBF     		ite	gt
 7346 014c 15EE100A 		fmrsgt	r0, s10
 7347 0150 17EE900A 		fmrsle	r0, s15
 7348 0154 01E0     		b	.L456
 7349              	.L458:
 7350              		.loc 30 114 0
 7351 0156 17EE100A 		fmrs	r0, s14
 7352              	.L456:
 115:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   motorAxisCommandYaw = updatePID(commandedYaw, gyroRate[ZAXIS], &PID[ZAXIS_PID_IDX]);
 7353              		.loc 30 115 0 is_stmt 1 discriminator 6
 7354 015a 1B49     		ldr	r1, .L465+84
 7355 015c 1B4A     		ldr	r2, .L465+88
 7356 015e 8968     		ldr	r1, [r1, #8]	@ float
 7357 0160 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 7358              	.LVL343:
 7359 0164 05EE900A 		fmsr	s11, r0
 7360 0168 1948     		ldr	r0, .L465+92
 7361 016a BDEEE56A 		ftosizs	s12, s11
 7362 016e 80ED006A 		fsts	s12, [r0, #0]	@ int
 7363              	.LBE175:
 116:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** }
 7364              		.loc 30 116 0 discriminator 6
 7365 0172 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 7366              	.L466:
 7367              		.align	2
 7368              	.L465:
 7369 0174 00000000 		.word	.LANCHOR123
 7370 0178 00000000 		.word	.LANCHOR6
 7371 017c 00000000 		.word	.LANCHOR127
 7372 0180 00000000 		.word	.LANCHOR74
 7373 0184 00000000 		.word	.LANCHOR124
 7374 0188 00000000 		.word	.LANCHOR126
 7375 018c E12E6542 		.word	1113927393
 7376 0190 00000000 		.word	.LANCHOR125
 7377 0194 00003443 		.word	1127481344
 7378 0198 0000B443 		.word	1135869952
 7379 019c 00000000 		.word	.LANCHOR17
 7380 01a0 00000000 		.word	.LANCHOR128
 7381 01a4 00000000 		.word	.LANCHOR15
 7382 01a8 00000000 		.word	.LANCHOR129
 7383 01ac 20A10700 		.word	500000
 7384 01b0 8C000000 		.word	.LANCHOR17+140
 7385 01b4 00000000 		.word	.LANCHOR11
 7386 01b8 35FA8E3C 		.word	1016003125
 7387 01bc 0BD7A33B 		.word	1000593163
 7388 01c0 DB0F49C0 		.word	-1068953637
 7389 01c4 DB0F4940 		.word	1078530011
 7390 01c8 00000000 		.word	.LANCHOR27
 7391 01cc 38000000 		.word	.LANCHOR17+56
 7392 01d0 00000000 		.word	.LANCHOR109
 7393              		.cfi_endproc
 7394              	.LFE221:
 7396              		.section	.text._Z20processFlightControlv,"ax",%progbits
 7397              		.align	1
 7398              		.global	_Z20processFlightControlv
 7399              		.thumb
 7400              		.thumb_func
 7402              	_Z20processFlightControlv:
 7403              	.LFB219:
 267:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 268:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** /**
 269:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * processFlightControl
 270:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  *
 271:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * Main flight control processos function
 272:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  */
 273:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** void processFlightControl() {
 7404              		.loc 29 273 0
 7405              		.cfi_startproc
 7406              		@ args = 0, pretend = 0, frame = 0
 7407              		@ frame_needed = 0, uses_anonymous_args = 0
 7408 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 7409              	.LCFI78:
 7410              		.cfi_def_cfa_offset 24
 7411              		.cfi_offset 14, -4
 7412              		.cfi_offset 7, -8
 7413              		.cfi_offset 6, -12
 7414              		.cfi_offset 5, -16
 7415              		.cfi_offset 4, -20
 7416              		.cfi_offset 3, -24
 7417              	.LBB176:
 274:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   
 275:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // ********************** Calculate Flight Error ***************************
 276:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   calculateFlightError();
 7418              		.loc 29 276 0
 7419 0002 FFF7FEFF 		bl	_Z20calculateFlightErrorv
 277:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   
 278:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // ********************** Update Yaw ***************************************
 279:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   processHeading();
 7420              		.loc 29 279 0
 7421 0006 FFF7FEFF 		bl	_Z14processHeadingv
 280:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   
 281:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if (frameCounter % THROTTLE_ADJUST_TASK_SPEED == 0) {  // 50hz task
 7422              		.loc 29 281 0
 7423 000a 2848     		ldr	r0, .L482
 7424 000c 0368     		ldr	r3, [r0, #0]
 7425 000e DA07     		lsls	r2, r3, #31
 7426 0010 03D4     		bmi	.L468
 282:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     
 283:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     // ********************** Process position hold or navigation **************************
 284:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #if defined (UseGPS)
 285:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       #if defined (UseGPSNavigator)
 286:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         processGpsNavigation();
 287:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       #endif  
 288:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #endif
 289:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     
 290:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     // ********************** Process Altitude hold **************************
 291:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 292:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       processAltitudeHold();
 7427              		.loc 29 292 0
 7428 0012 FFF7FEFF 		bl	_Z19processAltitudeHoldv
 293:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #else
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       throttle = receiverCommand[THROTTLE];
 295:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #endif
 296:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     
 297:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     // ********************** Process Battery monitor hold **************************
 298:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #if defined BattMonitor && defined BattMonitorAutoDescent
 299:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       processBatteryMonitorThrottleAdjustment();
 300:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #endif
 301:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 302:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     // ********************** Process Auto-Descent  **************************
 303:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #if defined AutoLanding
 304:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       processAutoLandingAltitudeCorrection();
 305:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #endif
 306:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     
 307:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     // ********************** Process throttle correction ********************
 308:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     processThrottleCorrection();
 7429              		.loc 29 308 0
 7430 0016 FFF7FEFF 		bl	_Z25processThrottleCorrectionv
 7431              	.L468:
 309:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 310:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 311:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // ********************** Calculate Motor Commands *************************
 312:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if (motorArmed && safetyCheck) {
 7432              		.loc 29 312 0
 7433 001a 254C     		ldr	r4, .L482+4
 7434 001c 2178     		ldrb	r1, [r4, #0]	@ zero_extendqisi2
 7435 001e 21B1     		cbz	r1, .L469
 7436              		.loc 29 312 0 is_stmt 0 discriminator 1
 7437 0020 244D     		ldr	r5, .L482+8
 7438 0022 2A78     		ldrb	r2, [r5, #0]	@ zero_extendqisi2
 7439 0024 0AB1     		cbz	r2, .L469
 313:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     applyMotorCommand();
 7440              		.loc 29 313 0 is_stmt 1
 7441 0026 FFF7FEFF 		bl	_Z17applyMotorCommandv
 7442              	.L469:
 314:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   } 
 315:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 316:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // *********************** process min max motor command *******************
 317:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   processMinMaxCommand();
 7443              		.loc 29 317 0
 7444 002a FFF7FEFF 		bl	_Z20processMinMaxCommandv
 7445              	.LBB177:
 318:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 319:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // If throttle in minimum position, don't apply yaw
 320:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if (receiverCommand[THROTTLE] < MINCHECK) {
 7446              		.loc 29 320 0
 7447 002e 224B     		ldr	r3, .L482+12
 7448 0030 2249     		ldr	r1, .L482+16
 7449 0032 D868     		ldr	r0, [r3, #12]
 7450 0034 40F24B4C 		movw	ip, #1099
 7451 0038 6045     		cmp	r0, ip
 7452 003a 01DD     		ble	.L470
 7453              	.L474:
 7454              	.LVL344:
 7455              	.LBB178:
 321:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 322:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 323:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 324:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         motorMaxCommand[motor] = MAXCOMMAND;
 325:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       }
 326:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       else {
 327:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         motorMaxCommand[motor] = minArmedThrottle;
 7456              		.loc 29 327 0 discriminator 1
 7457 003c 0023     		movs	r3, #0
 7458 003e 15E0     		b	.L471
 7459              	.LVL345:
 7460              	.L470:
 322:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 7461              		.loc 29 322 0
 7462 0040 1F4A     		ldr	r2, .L482+20
 323:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 7463              		.loc 29 323 0
 7464 0042 204E     		ldr	r6, .L482+24
 7465 0044 204F     		ldr	r7, .L482+28
 322:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 7466              		.loc 29 322 0
 7467 0046 1268     		ldr	r2, [r2, #0]
 323:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 7468              		.loc 29 323 0
 7469 0048 3678     		ldrb	r6, [r6, #0]	@ zero_extendqisi2
 7470 004a 3D78     		ldrb	r5, [r7, #0]	@ zero_extendqisi2
 7471 004c 0023     		movs	r3, #0
 7472              	.L473:
 322:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 7473              		.loc 29 322 0
 7474 004e CA50     		str	r2, [r1, r3]
 323:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 7475              		.loc 29 323 0
 7476 0050 2EB1     		cbz	r6, .L478
 7477              		.loc 29 327 0 discriminator 1
 7478 0052 002D     		cmp	r5, #0
 7479 0054 14BF     		ite	ne
 7480 0056 1046     		movne	r0, r2
 7481 0058 4FF4FA60 		moveq	r0, #2000
 7482 005c 00E0     		b	.L472
 7483              	.L478:
 7484              		.loc 29 327 0 is_stmt 0
 7485 005e 1046     		mov	r0, r2
 7486              	.L472:
 323:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 7487              		.loc 29 323 0 is_stmt 1
 7488 0060 1A4F     		ldr	r7, .L482+32
 7489 0062 D851     		str	r0, [r3, r7]
 7490 0064 0433     		adds	r3, r3, #4
 321:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 7491              		.loc 29 321 0
 7492 0066 102B     		cmp	r3, #16
 7493 0068 F1D1     		bne	.L473
 7494 006a E7E7     		b	.L474
 7495              	.LVL346:
 7496              	.L471:
 7497              	.LBE178:
 7498              	.LBE177:
 7499              	.LBB179:
 328:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       }
 329:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
 330:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 331:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   
 332:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // Apply limits to motor commands
 333:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   for (byte motor = 0; motor < LASTMOTOR; motor++) {
 334:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorCommand[motor] = constrain(motorCommand[motor], motorMinCommand[motor], motorMaxCommand[mo
 7500              		.loc 29 334 0
 7501 006c 1848     		ldr	r0, .L482+36
 7502 006e CA58     		ldr	r2, [r1, r3]
 7503 0070 1D58     		ldr	r5, [r3, r0]
 7504 0072 9542     		cmp	r5, r2
 7505 0074 04DB     		blt	.L475
 7506              		.loc 29 334 0 is_stmt 0 discriminator 2
 7507 0076 154A     		ldr	r2, .L482+32
 7508 0078 9A58     		ldr	r2, [r3, r2]
 7509 007a 9542     		cmp	r5, r2
 7510 007c B8BF     		it	lt
 7511 007e 2A46     		movlt	r2, r5
 7512              	.L475:
 7513              		.loc 29 334 0 discriminator 6
 7514 0080 C250     		str	r2, [r0, r3]
 7515 0082 0433     		adds	r3, r3, #4
 333:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   for (byte motor = 0; motor < LASTMOTOR; motor++) {
 7516              		.loc 29 333 0 is_stmt 1 discriminator 6
 7517 0084 102B     		cmp	r3, #16
 7518 0086 F1D1     		bne	.L471
 7519              	.LBE179:
 335:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 336:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 337:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // ESC Calibration
 338:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if (motorArmed == OFF) {
 7520              		.loc 29 338 0
 7521 0088 2178     		ldrb	r1, [r4, #0]	@ zero_extendqisi2
 7522 008a 09B9     		cbnz	r1, .L476
 339:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     processCalibrateESC();
 7523              		.loc 29 339 0
 7524 008c FFF7FEFF 		bl	_Z19processCalibrateESCv
 7525              	.L476:
 340:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 341:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   
 342:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // *********************** Command Motors **********************
 343:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if (motorArmed == ON && safetyCheck == ON) {
 7526              		.loc 29 343 0
 7527 0090 2078     		ldrb	r0, [r4, #0]	@ zero_extendqisi2
 7528 0092 0128     		cmp	r0, #1
 7529 0094 09D1     		bne	.L467
 7530              		.loc 29 343 0 is_stmt 0 discriminator 1
 7531 0096 074B     		ldr	r3, .L482+8
 7532 0098 93F800E0 		ldrb	lr, [r3, #0]	@ zero_extendqisi2
 7533 009c BEF1010F 		cmp	lr, #1
 7534 00a0 03D1     		bne	.L467
 7535              	.LBE176:
 344:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     writeMotors();
 345:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 346:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** }
 7536              		.loc 29 346 0 is_stmt 1
 7537 00a2 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 7538              	.LBB180:
 344:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     writeMotors();
 7539              		.loc 29 344 0
 7540 00a6 FFF7FEBF 		b	_Z11writeMotorsv
 7541              	.L467:
 7542 00aa F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 7543              	.L483:
 7544              		.align	2
 7545              	.L482:
 7546 00ac 00000000 		.word	.LANCHOR41
 7547 00b0 00000000 		.word	.LANCHOR130
 7548 00b4 00000000 		.word	.LANCHOR119
 7549 00b8 00000000 		.word	.LANCHOR6
 7550 00bc 00000000 		.word	.LANCHOR121
 7551 00c0 00000000 		.word	.LANCHOR120
 7552 00c4 00000000 		.word	.LANCHOR16
 7553 00c8 00000000 		.word	.LANCHOR114
 7554 00cc 00000000 		.word	.LANCHOR122
 7555 00d0 00000000 		.word	.LANCHOR63
 7556              	.LBE180:
 7557              		.cfi_endproc
 7558              	.LFE219:
 7560              		.section	.text._Z12nvrReadFloati,"ax",%progbits
 7561              		.align	1
 7562              		.global	_Z12nvrReadFloati
 7563              		.thumb
 7564              		.thumb_func
 7566              	_Z12nvrReadFloati:
 7567              	.LFB222:
 7568              		.file 31 "C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad/DataStorage.h"
   1:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** /*
   2:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   AeroQuad v3.0.1 - February 2012
   3:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   www.AeroQuad.com
   4:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   An Open Source Arduino based multicopter.
   6:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
   7:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   This program is free software: you can redistribute it and/or modify
   8:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   it under the terms of the GNU General Public License as published by
   9:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   the Free Software Foundation, either version 3 of the License, or
  10:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   (at your option) any later version.
  11:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  12:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   This program is distributed in the hope that it will be useful,
  13:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   GNU General Public License for more details.
  16:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  17:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   You should have received a copy of the GNU General Public License
  18:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** */
  20:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  21:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** // Special thanks for 1k space optimization update from Ala42
  22:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** // http://aeroquad.com/showthread.php?1369-The-big-enhancement-addition-to-2.0-code&p=13359&viewful
  23:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  24:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #ifndef _AQ_DATA_STORAGE_H_
  25:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #define _AQ_DATA_STORAGE_H_
  26:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  27:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** // Utilities for writing and reading from the EEPROM
  28:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** float nvrReadFloat(int address) {
 7569              		.loc 31 28 0
 7570              		.cfi_startproc
 7571              		@ args = 0, pretend = 0, frame = 0
 7572              		@ frame_needed = 0, uses_anonymous_args = 0
 7573              	.LVL347:
 7574 0000 38B5     		push	{r3, r4, r5, lr}
 7575              	.LCFI79:
 7576              		.cfi_def_cfa_offset 16
 7577              		.cfi_offset 14, -4
 7578              		.cfi_offset 5, -8
 7579              		.cfi_offset 4, -12
 7580              		.cfi_offset 3, -16
 7581              	.LBB181:
 7582              	.LBB182:
  29:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   union floatStore {
  30:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     byte floatByte[4];
  31:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     unsigned short floatUShort[2];
  32:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     float floatVal;
  33:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   } floatOut;
  34:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  35:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #ifdef EEPROM_USES_16BIT_WORDS
  36:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for (int i = 0; i < 2; i++) {
  37:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     floatOut.floatUShort[i] = EEPROM.read(address + 2*i);
 7583              		.loc 31 37 0
 7584 0002 85B2     		uxth	r5, r0
 7585 0004 2946     		mov	r1, r5
 7586 0006 0748     		ldr	r0, .L485
 7587              	.LVL348:
 7588 0008 FFF7FEFF 		bl	_ZN11EEPROMClass4readEt
 7589 000c 0024     		movs	r4, #0
 7590              	.LVL349:
 7591 000e A91C     		adds	r1, r5, #2
 7592 0010 60F30F04 		bfi	r4, r0, #0, #16
 7593              	.LVL350:
 7594 0014 89B2     		uxth	r1, r1
 7595 0016 0348     		ldr	r0, .L485
 7596 0018 FFF7FEFF 		bl	_ZN11EEPROMClass4readEt
 7597 001c 60F31F44 		bfi	r4, r0, #16, #16
 7598              	.LVL351:
 7599              	.LBE182:
  38:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
  39:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #else
  40:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for (int i = 0; i < 4; i++) {
  41:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     floatOut.floatByte[i] = EEPROM.read(address + i);
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
  43:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #endif
  44:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  45:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   return floatOut.floatVal;
 7600              		.loc 31 45 0
 7601 0020 2046     		mov	r0, r4	@ float
 7602              	.LBE181:
  46:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** }
 7603              		.loc 31 46 0
 7604 0022 38BD     		pop	{r3, r4, r5, pc}
 7605              	.L486:
 7606              		.align	2
 7607              	.L485:
 7608 0024 00000000 		.word	EEPROM
 7609              		.cfi_endproc
 7610              	.LFE222:
 7612              		.section	.text._Z13nvrWriteFloatfi,"ax",%progbits
 7613              		.align	1
 7614              		.global	_Z13nvrWriteFloatfi
 7615              		.thumb
 7616              		.thumb_func
 7618              	_Z13nvrWriteFloatfi:
 7619              	.LFB223:
  47:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  48:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void nvrWriteFloat(float value, int address) {
 7620              		.loc 31 48 0
 7621              		.cfi_startproc
 7622              		@ args = 0, pretend = 0, frame = 0
 7623              		@ frame_needed = 0, uses_anonymous_args = 0
 7624              	.LVL352:
 7625 0000 38B5     		push	{r3, r4, r5, lr}
 7626              	.LCFI80:
 7627              		.cfi_def_cfa_offset 16
 7628              		.cfi_offset 14, -4
 7629              		.cfi_offset 5, -8
 7630              		.cfi_offset 4, -12
 7631              		.cfi_offset 3, -16
 7632              	.LBB183:
  49:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   union floatStore {
  50:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     byte floatByte[4];
  51:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     unsigned short floatUShort[2];
  52:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     float floatVal;
  53:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   } floatIn;
  54:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  55:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   floatIn.floatVal = value;
 7633              		.loc 31 55 0
 7634 0002 0446     		mov	r4, r0	@ float
 7635              	.LVL353:
 7636              	.LBB184:
  56:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #ifdef EEPROM_USES_16BIT_WORDS
  57:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for (int i = 0; i < 2; i++) {
  58:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     EEPROM.write(address + 2*i, floatIn.floatUShort[i]);
 7637              		.loc 31 58 0
 7638 0004 8DB2     		uxth	r5, r1
 7639 0006 2946     		mov	r1, r5
 7640              	.LVL354:
 7641 0008 A2B2     		uxth	r2, r4
 7642 000a 0548     		ldr	r0, .L488
 7643              	.LVL355:
 7644 000c FFF7FEFF 		bl	_ZN11EEPROMClass5writeEtt
 7645              	.LVL356:
 7646 0010 A91C     		adds	r1, r5, #2
 7647 0012 0348     		ldr	r0, .L488
 7648 0014 89B2     		uxth	r1, r1
 7649 0016 220C     		lsrs	r2, r4, #16
 7650              	.LBE184:
 7651              	.LBE183:
  59:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
  60:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #else
  61:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for (int i = 0; i < 4; i++) {
  62:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     EEPROM.write(address + i, floatIn.floatByte[i]);
  63:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
  64:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #endif
  65:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** }
 7652              		.loc 31 65 0
 7653 0018 BDE83840 		pop	{r3, r4, r5, lr}
 7654              	.LBB186:
 7655              	.LBB185:
  58:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     EEPROM.write(address + 2*i, floatIn.floatUShort[i]);
 7656              		.loc 31 58 0
 7657 001c FFF7FEBF 		b	_ZN11EEPROMClass5writeEtt
 7658              	.L489:
 7659              		.align	2
 7660              	.L488:
 7661 0020 00000000 		.word	EEPROM
 7662              	.LBE185:
 7663              	.LBE186:
 7664              		.cfi_endproc
 7665              	.LFE223:
 7667              		.section	.text._Z11nvrReadLongi,"ax",%progbits
 7668              		.align	1
 7669              		.global	_Z11nvrReadLongi
 7670              		.thumb
 7671              		.thumb_func
 7673              	_Z11nvrReadLongi:
 7674              	.LFB224:
  66:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  67:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** long nvrReadLong(int address) {
 7675              		.loc 31 67 0
 7676              		.cfi_startproc
 7677              		@ args = 0, pretend = 0, frame = 0
 7678              		@ frame_needed = 0, uses_anonymous_args = 0
 7679              	.LVL357:
 7680 0000 38B5     		push	{r3, r4, r5, lr}
 7681              	.LCFI81:
 7682              		.cfi_def_cfa_offset 16
 7683              		.cfi_offset 14, -4
 7684              		.cfi_offset 5, -8
 7685              		.cfi_offset 4, -12
 7686              		.cfi_offset 3, -16
 7687              	.LBB187:
 7688              	.LBB188:
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   union longStore {
  69:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     byte longByte[4];
  70:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     unsigned short longUShort[2];
  71:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     long longVal;
  72:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   } longOut;  
  73:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #ifdef EEPROM_USES_16BIT_WORDS
  75:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for (int i = 0; i < 2; i++) {
  76:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     longOut.longUShort[i] = EEPROM.read(address + 2*i);
 7689              		.loc 31 76 0
 7690 0002 85B2     		uxth	r5, r0
 7691 0004 2946     		mov	r1, r5
 7692 0006 0748     		ldr	r0, .L491
 7693              	.LVL358:
 7694 0008 FFF7FEFF 		bl	_ZN11EEPROMClass4readEt
 7695 000c 0024     		movs	r4, #0
 7696              	.LVL359:
 7697 000e A91C     		adds	r1, r5, #2
 7698 0010 60F30F04 		bfi	r4, r0, #0, #16
 7699              	.LVL360:
 7700 0014 89B2     		uxth	r1, r1
 7701 0016 0348     		ldr	r0, .L491
 7702 0018 FFF7FEFF 		bl	_ZN11EEPROMClass4readEt
 7703 001c 60F31F44 		bfi	r4, r0, #16, #16
 7704              	.LVL361:
 7705              	.LBE188:
 7706              	.LBE187:
  77:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #else
  79:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for (byte i = 0; i < 4; i++) {
  80:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     longOut.longByte[i] = EEPROM.read(address + i);
  81:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
  82:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #endif
  83:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     
  84:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   return longOut.longVal;
  85:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** }
 7707              		.loc 31 85 0
 7708 0020 2046     		mov	r0, r4
 7709 0022 38BD     		pop	{r3, r4, r5, pc}
 7710              	.L492:
 7711              		.align	2
 7712              	.L491:
 7713 0024 00000000 		.word	EEPROM
 7714              		.cfi_endproc
 7715              	.LFE224:
 7717              		.section	.text._Z12nvrWriteLongli,"ax",%progbits
 7718              		.align	1
 7719              		.global	_Z12nvrWriteLongli
 7720              		.thumb
 7721              		.thumb_func
 7723              	_Z12nvrWriteLongli:
 7724              	.LFB225:
  86:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  87:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void nvrWriteLong(long value, int address) {
 7725              		.loc 31 87 0
 7726              		.cfi_startproc
 7727              		@ args = 0, pretend = 0, frame = 0
 7728              		@ frame_needed = 0, uses_anonymous_args = 0
 7729              	.LVL362:
 7730 0000 38B5     		push	{r3, r4, r5, lr}
 7731              	.LCFI82:
 7732              		.cfi_def_cfa_offset 16
 7733              		.cfi_offset 14, -4
 7734              		.cfi_offset 5, -8
 7735              		.cfi_offset 4, -12
 7736              		.cfi_offset 3, -16
 7737              		.loc 31 87 0
 7738 0002 0446     		mov	r4, r0
 7739              	.LBB189:
 7740              	.LBB190:
  88:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   union longStore {
  89:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     byte longByte[4];
  90:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     unsigned short longUShort[2];
  91:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     long longVal;
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   } longIn;  
  93:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
  94:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   longIn.longVal = value;
  95:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
  96:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #ifdef EEPROM_USES_16BIT_WORDS
  97:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for (int i = 0; i < 2; i++) {
  98:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     EEPROM.write(address + 2*i, longIn.longUShort[i]);
 7741              		.loc 31 98 0
 7742 0004 8DB2     		uxth	r5, r1
 7743 0006 2946     		mov	r1, r5
 7744              	.LVL363:
 7745 0008 A2B2     		uxth	r2, r4
 7746 000a 0548     		ldr	r0, .L494
 7747              	.LVL364:
 7748 000c FFF7FEFF 		bl	_ZN11EEPROMClass5writeEtt
 7749              	.LVL365:
 7750 0010 A91C     		adds	r1, r5, #2
 7751 0012 0348     		ldr	r0, .L494
 7752 0014 89B2     		uxth	r1, r1
 7753 0016 220C     		lsrs	r2, r4, #16
 7754              	.LBE190:
 7755              	.LBE189:
  99:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
 100:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #else
 101:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for (int i = 0; i < 4; i++) {
 102:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     EEPROM.write(address + i, longIn.longByte[i]);
 103:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
 104:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** #endif
 105:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** }
 7756              		.loc 31 105 0
 7757 0018 BDE83840 		pop	{r3, r4, r5, lr}
 7758              	.LBB192:
 7759              	.LBB191:
  98:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     EEPROM.write(address + 2*i, longIn.longUShort[i]);
 7760              		.loc 31 98 0
 7761 001c FFF7FEBF 		b	_ZN11EEPROMClass5writeEtt
 7762              	.L495:
 7763              		.align	2
 7764              	.L494:
 7765 0020 00000000 		.word	EEPROM
 7766              	.LBE191:
 7767              	.LBE192:
 7768              		.cfi_endproc
 7769              	.LFE225:
 7771              		.section	.text._Z10nvrReadPIDhj,"ax",%progbits
 7772              		.align	1
 7773              		.global	_Z10nvrReadPIDhj
 7774              		.thumb
 7775              		.thumb_func
 7777              	_Z10nvrReadPIDhj:
 7778              	.LFB226:
 106:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 107:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void nvrReadPID(unsigned char IDPid, unsigned int IDEeprom) {
 7779              		.loc 31 107 0
 7780              		.cfi_startproc
 7781              		@ args = 0, pretend = 0, frame = 0
 7782              		@ frame_needed = 0, uses_anonymous_args = 0
 7783              	.LVL366:
 7784              	.LBB193:
 108:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   struct PIDdata* pid = &PID[IDPid];
 7785              		.loc 31 108 0
 7786 0000 0B4A     		ldr	r2, .L497
 7787              	.LBE193:
 107:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void nvrReadPID(unsigned char IDPid, unsigned int IDEeprom) {
 7788              		.loc 31 107 0
 7789 0002 38B5     		push	{r3, r4, r5, lr}
 7790              	.LCFI83:
 7791              		.cfi_def_cfa_offset 16
 7792              		.cfi_offset 14, -4
 7793              		.cfi_offset 5, -8
 7794              		.cfi_offset 4, -12
 7795              		.cfi_offset 3, -16
 7796              	.LBB194:
 7797              		.loc 31 108 0
 7798 0004 1C24     		movs	r4, #28
 7799 0006 04FB0024 		mla	r4, r4, r0, r2
 7800              	.LVL367:
 109:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   pid->P = nvrReadFloat(IDEeprom);
 7801              		.loc 31 109 0
 7802 000a 0846     		mov	r0, r1
 7803              	.LVL368:
 7804              	.LBE194:
 107:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void nvrReadPID(unsigned char IDPid, unsigned int IDEeprom) {
 7805              		.loc 31 107 0
 7806 000c 0D46     		mov	r5, r1
 7807              	.LBB195:
 7808              		.loc 31 109 0
 7809 000e FFF7FEFF 		bl	_Z12nvrReadFloati
 7810              	.LVL369:
 7811 0012 2060     		str	r0, [r4, #0]	@ float
 110:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   pid->I = nvrReadFloat(IDEeprom+4);
 7812              		.loc 31 110 0
 7813 0014 281D     		adds	r0, r5, #4
 7814 0016 FFF7FEFF 		bl	_Z12nvrReadFloati
 7815 001a 6060     		str	r0, [r4, #4]	@ float
 111:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   pid->D = nvrReadFloat(IDEeprom+8);
 7816              		.loc 31 111 0
 7817 001c 05F10800 		add	r0, r5, #8
 7818 0020 FFF7FEFF 		bl	_Z12nvrReadFloati
 112:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   pid->lastError = 0;
 7819              		.loc 31 112 0
 7820 0024 0023     		movs	r3, #0
 111:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   pid->D = nvrReadFloat(IDEeprom+8);
 7821              		.loc 31 111 0
 7822 0026 A060     		str	r0, [r4, #8]	@ float
 7823              		.loc 31 112 0
 7824 0028 E360     		str	r3, [r4, #12]	@ float
 113:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   pid->integratedError = 0;
 7825              		.loc 31 113 0
 7826 002a 6361     		str	r3, [r4, #20]	@ float
 7827              	.LBE195:
 114:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** }
 7828              		.loc 31 114 0
 7829 002c 38BD     		pop	{r3, r4, r5, pc}
 7830              	.L498:
 7831 002e 00BF     		.align	2
 7832              	.L497:
 7833 0030 00000000 		.word	.LANCHOR17
 7834              		.cfi_endproc
 7835              	.LFE226:
 7837              		.section	.text._Z11nvrWritePIDhj,"ax",%progbits
 7838              		.align	1
 7839              		.global	_Z11nvrWritePIDhj
 7840              		.thumb
 7841              		.thumb_func
 7843              	_Z11nvrWritePIDhj:
 7844              	.LFB227:
 115:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 116:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void nvrWritePID(unsigned char IDPid, unsigned int IDEeprom) {
 7845              		.loc 31 116 0
 7846              		.cfi_startproc
 7847              		@ args = 0, pretend = 0, frame = 0
 7848              		@ frame_needed = 0, uses_anonymous_args = 0
 7849              	.LVL370:
 7850 0000 38B5     		push	{r3, r4, r5, lr}
 7851              	.LCFI84:
 7852              		.cfi_def_cfa_offset 16
 7853              		.cfi_offset 14, -4
 7854              		.cfi_offset 5, -8
 7855              		.cfi_offset 4, -12
 7856              		.cfi_offset 3, -16
 7857              	.LBB196:
 117:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   struct PIDdata* pid = &PID[IDPid];
 7858              		.loc 31 117 0
 7859 0002 094B     		ldr	r3, .L500
 7860 0004 1C24     		movs	r4, #28
 7861 0006 04FB0034 		mla	r4, r4, r0, r3
 7862              	.LVL371:
 7863              	.LBE196:
 116:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void nvrWritePID(unsigned char IDPid, unsigned int IDEeprom) {
 7864              		.loc 31 116 0
 7865 000a 0D46     		mov	r5, r1
 7866              	.LBB197:
 118:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   nvrWriteFloat(pid->P, IDEeprom);
 7867              		.loc 31 118 0
 7868 000c 2068     		ldr	r0, [r4, #0]	@ float
 7869              	.LVL372:
 7870 000e FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 7871              	.LVL373:
 119:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   nvrWriteFloat(pid->I, IDEeprom+4);
 7872              		.loc 31 119 0
 7873 0012 6068     		ldr	r0, [r4, #4]	@ float
 7874 0014 291D     		adds	r1, r5, #4
 7875 0016 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 120:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   nvrWriteFloat(pid->D, IDEeprom+8);
 7876              		.loc 31 120 0
 7877 001a A068     		ldr	r0, [r4, #8]	@ float
 7878 001c 05F10801 		add	r1, r5, #8
 7879              	.LBE197:
 121:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** }
 7880              		.loc 31 121 0
 7881 0020 BDE83840 		pop	{r3, r4, r5, lr}
 7882              	.LBB198:
 120:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   nvrWriteFloat(pid->D, IDEeprom+8);
 7883              		.loc 31 120 0
 7884 0024 FFF7FEBF 		b	_Z13nvrWriteFloatfi
 7885              	.L501:
 7886              		.align	2
 7887              	.L500:
 7888 0028 00000000 		.word	.LANCHOR17
 7889              	.LBE198:
 7890              		.cfi_endproc
 7891              	.LFE227:
 7893              		.section	.text._Z16initializeEEPROMv,"ax",%progbits
 7894              		.align	1
 7895              		.global	_Z16initializeEEPROMv
 7896              		.thumb
 7897              		.thumb_func
 7899              	_Z16initializeEEPROMv:
 7900              	.LFB228:
 122:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 123:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** // contains all default values when re-writing EEPROM
 124:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void initializeEEPROM() {
 7901              		.loc 31 124 0
 7902              		.cfi_startproc
 7903              		@ args = 0, pretend = 0, frame = 0
 7904              		@ frame_needed = 0, uses_anonymous_args = 0
 7905              	.LBB199:
 125:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].P = 100.0;
 7906              		.loc 31 125 0
 7907 0000 514B     		ldr	r3, .L505
 7908 0002 5248     		ldr	r0, .L505+4
 126:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].I = 0.0;
 127:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].D = -300.0;
 128:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].P = 100.0;
 129:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].I = 0.0;
 130:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].D = -300.0;
 131:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].P = 4.0;
 7909              		.loc 31 131 0
 7910 0004 4FF08141 		mov	r1, #1082130432
 7911              	.LBE199:
 124:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void initializeEEPROM() {
 7912              		.loc 31 124 0
 7913 0008 70B5     		push	{r4, r5, r6, lr}
 7914              	.LCFI85:
 7915              		.cfi_def_cfa_offset 16
 7916              		.cfi_offset 14, -4
 7917              		.cfi_offset 6, -8
 7918              		.cfi_offset 5, -12
 7919              		.cfi_offset 4, -16
 7920              	.LBB202:
 7921              		.loc 31 131 0
 7922 000a 5965     		str	r1, [r3, #84]	@ float
 132:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].I = 0.0;
 133:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].D = 0.0;
 134:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].P = 4.0;
 7923              		.loc 31 134 0
 7924 000c 1967     		str	r1, [r3, #112]	@ float
 135:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].I = 0.0;
 136:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].D = 0.0;
 137:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ZAXIS_PID_IDX].P = 200.0;
 138:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ZAXIS_PID_IDX].I = 5.0;
 139:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ZAXIS_PID_IDX].D = 0.0;
 140:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].P = 3.0;
 141:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].I = 0.1;
 142:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].D = 0.0;
 143:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // AKA PID experiements
 144:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].P = 100.0;
 145:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].I = 0.0;
 146:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].D = -300.0;
 147:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].P = 100.0;
 148:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].I = 0.0;
 149:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].D = -300.0;
 150:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   rotationSpeedFactor = 1.0;
 7925              		.loc 31 150 0
 7926 000e 5049     		ldr	r1, .L505+8
 127:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].D = -300.0;
 7927              		.loc 31 127 0
 7928 0010 504E     		ldr	r6, .L505+12
 125:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].P = 100.0;
 7929              		.loc 31 125 0
 7930 0012 1860     		str	r0, [r3, #0]	@ float
 128:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].P = 100.0;
 7931              		.loc 31 128 0
 7932 0014 D861     		str	r0, [r3, #28]	@ float
 144:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].P = 100.0;
 7933              		.loc 31 144 0
 7934 0016 C3F8A800 		str	r0, [r3, #168]	@ float
 147:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].P = 100.0;
 7935              		.loc 31 147 0
 7936 001a C3F8C400 		str	r0, [r3, #196]	@ float
 7937              		.loc 31 150 0
 7938 001e 4FF07E50 		mov	r0, #1065353216
 137:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ZAXIS_PID_IDX].P = 200.0;
 7939              		.loc 31 137 0
 7940 0022 4D4D     		ldr	r5, .L505+16
 140:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].P = 3.0;
 7941              		.loc 31 140 0
 7942 0024 4D4C     		ldr	r4, .L505+20
 7943              		.loc 31 150 0
 7944 0026 0860     		str	r0, [r1, #0]	@ float
 151:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 152:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined (AltitudeHoldBaro)
 153:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].P = 25.0;
 7945              		.loc 31 153 0
 7946 0028 4D49     		ldr	r1, .L505+24
 127:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].D = -300.0;
 7947              		.loc 31 127 0
 7948 002a 9E60     		str	r6, [r3, #8]	@ float
 130:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].D = -300.0;
 7949              		.loc 31 130 0
 7950 002c 5E62     		str	r6, [r3, #36]	@ float
 146:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].D = -300.0;
 7951              		.loc 31 146 0
 7952 002e C3F8B060 		str	r6, [r3, #176]	@ float
 149:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].D = -300.0;
 7953              		.loc 31 149 0
 7954 0032 C3F8CC60 		str	r6, [r3, #204]	@ float
 154:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].I = 0.6;
 7955              		.loc 31 154 0
 7956 0036 4B4E     		ldr	r6, .L505+28
 137:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ZAXIS_PID_IDX].P = 200.0;
 7957              		.loc 31 137 0
 7958 0038 9D63     		str	r5, [r3, #56]	@ float
 140:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].P = 3.0;
 7959              		.loc 31 140 0
 7960 003a C3F88C40 		str	r4, [r3, #140]	@ float
 153:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].P = 25.0;
 7961              		.loc 31 153 0
 7962 003e C3F8E010 		str	r1, [r3, #224]	@ float
 141:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].I = 0.1;
 7963              		.loc 31 141 0
 7964 0042 494C     		ldr	r4, .L505+32
 155:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].D = 0.0;
 156:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard = 25.0; //this prevents the 0.1 I term to rise too 
 7965              		.loc 31 156 0
 7966 0044 C3F8F810 		str	r1, [r3, #248]	@ float
 138:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ZAXIS_PID_IDX].I = 5.0;
 7967              		.loc 31 138 0
 7968 0048 484D     		ldr	r5, .L505+36
 157:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[ZDAMPENING_PID_IDX].P = 0.0;
 158:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[ZDAMPENING_PID_IDX].I = 0.0;
 159:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[ZDAMPENING_PID_IDX].D = 0.0;
 160:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 161:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined (AltitudeHoldRangeFinder)
 162:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].P = 50.0;
 163:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].I = 0.6;
 164:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].D = 0.0;
 165:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].windupGuard = 25.0; //this prevents the 0.1 I term to rise too
 166:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 167:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 168:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 169:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 170:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     minThrottleAdjust = -50.0;
 7969              		.loc 31 170 0
 7970 004a 4949     		ldr	r1, .L505+40
 154:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].I = 0.6;
 7971              		.loc 31 154 0
 7972 004c C3F8E460 		str	r6, [r3, #228]	@ float
 126:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].I = 0.0;
 7973              		.loc 31 126 0
 7974 0050 0022     		movs	r2, #0
 7975              		.loc 31 170 0
 7976 0052 6FF03106 		mvn	r6, #49
 141:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].I = 0.1;
 7977              		.loc 31 141 0
 7978 0056 C3F89040 		str	r4, [r3, #144]	@ float
 126:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].I = 0.0;
 7979              		.loc 31 126 0
 7980 005a 5A60     		str	r2, [r3, #4]	@ float
 129:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].I = 0.0;
 7981              		.loc 31 129 0
 7982 005c 1A62     		str	r2, [r3, #32]	@ float
 132:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].I = 0.0;
 7983              		.loc 31 132 0
 7984 005e 9A65     		str	r2, [r3, #88]	@ float
 133:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].D = 0.0;
 7985              		.loc 31 133 0
 7986 0060 DA65     		str	r2, [r3, #92]	@ float
 135:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].I = 0.0;
 7987              		.loc 31 135 0
 7988 0062 5A67     		str	r2, [r3, #116]	@ float
 136:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].D = 0.0;
 7989              		.loc 31 136 0
 7990 0064 9A67     		str	r2, [r3, #120]	@ float
 138:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ZAXIS_PID_IDX].I = 5.0;
 7991              		.loc 31 138 0
 7992 0066 DD63     		str	r5, [r3, #60]	@ float
 139:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ZAXIS_PID_IDX].D = 0.0;
 7993              		.loc 31 139 0
 7994 0068 1A64     		str	r2, [r3, #64]	@ float
 142:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].D = 0.0;
 7995              		.loc 31 142 0
 7996 006a C3F89420 		str	r2, [r3, #148]	@ float
 145:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].I = 0.0;
 7997              		.loc 31 145 0
 7998 006e C3F8AC20 		str	r2, [r3, #172]	@ float
 148:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].I = 0.0;
 7999              		.loc 31 148 0
 8000 0072 C3F8C820 		str	r2, [r3, #200]	@ float
 155:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].D = 0.0;
 8001              		.loc 31 155 0
 8002 0076 C3F8E820 		str	r2, [r3, #232]	@ float
 157:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[ZDAMPENING_PID_IDX].P = 0.0;
 8003              		.loc 31 157 0
 8004 007a C3F8FC20 		str	r2, [r3, #252]	@ float
 158:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[ZDAMPENING_PID_IDX].I = 0.0;
 8005              		.loc 31 158 0
 8006 007e C3F80021 		str	r2, [r3, #256]	@ float
 159:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[ZDAMPENING_PID_IDX].D = 0.0;
 8007              		.loc 31 159 0
 8008 0082 C3F80421 		str	r2, [r3, #260]	@ float
 8009              		.loc 31 170 0
 8010 0086 0E60     		str	r6, [r1, #0]
 171:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     maxThrottleAdjust = 50.0; //we don't want it to be able to take over totally
 8011              		.loc 31 171 0
 8012 0088 3A49     		ldr	r1, .L505+44
 8013 008a 3226     		movs	r6, #50
 8014 008c 0E60     		str	r6, [r1, #0]
 172:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #if defined AltitudeHoldBaro
 173:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       baroSmoothFactor = 0.1;
 8015              		.loc 31 173 0
 8016 008e 3A49     		ldr	r1, .L505+48
 8017 0090 0C60     		str	r4, [r1, #0]	@ float
 174:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #endif
 175:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     altitudeHoldBump = 90;
 8018              		.loc 31 175 0
 8019 0092 3A49     		ldr	r1, .L505+52
 8020 0094 5A26     		movs	r6, #90
 8021 0096 0E60     		str	r6, [r1, #0]
 176:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     altitudeHoldPanicStickMovement = 250;
 8022              		.loc 31 176 0
 8023 0098 394E     		ldr	r6, .L505+56
 8024 009a FA24     		movs	r4, #250
 8025 009c 3460     		str	r4, [r6, #0]
 177:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 178:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 179:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Gyro Cal
 180:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[XAXIS] = 0.0;
 8026              		.loc 31 180 0
 8027 009e 394E     		ldr	r6, .L505+60
 181:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[YAXIS] = 0.0;
 182:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[ZAXIS] = 0.0;
 183:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** //  gyroTempBiasSlope[XAXIS] = 0.0;
 184:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** //  gyroTempBiasSlope[YAXIS] = 0.0;
 185:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** //  gyroTempBiasSlope[ZAXIS] = 0.0;
 186:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** //  gyroTempBiasIntercept[XAXIS] = 0.0;
 187:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** //  gyroTempBiasIntercept[YAXIS] = 0.0;
 188:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** //  gyroTempBiasIntercept[ZAXIS] = 0.0;
 189:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 190:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Accel Cal
 191:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[XAXIS] = 1.0;
 8028              		.loc 31 191 0
 8029 00a0 394C     		ldr	r4, .L505+64
 180:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[XAXIS] = 0.0;
 8030              		.loc 31 180 0
 8031 00a2 0021     		movs	r1, #0
 8032 00a4 3160     		str	r1, [r6, #0]
 181:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[YAXIS] = 0.0;
 8033              		.loc 31 181 0
 8034 00a6 7160     		str	r1, [r6, #4]
 182:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[ZAXIS] = 0.0;
 8035              		.loc 31 182 0
 8036 00a8 B160     		str	r1, [r6, #8]
 192:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[XAXIS] = 0.0;
 8037              		.loc 31 192 0
 8038 00aa 3849     		ldr	r1, .L505+68
 193:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[YAXIS] = 1.0;
 194:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[YAXIS] = 0.0;
 195:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[ZAXIS] = 1.0;
 196:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[ZAXIS] = 0.0;
 197:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 198:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef HeadingMagHold
 199:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magScale[XAXIS] = 1.0;
 8039              		.loc 31 199 0
 8040 00ac 384E     		ldr	r6, .L505+72
 192:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[XAXIS] = 0.0;
 8041              		.loc 31 192 0
 8042 00ae 0A60     		str	r2, [r1, #0]	@ float
 194:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[YAXIS] = 0.0;
 8043              		.loc 31 194 0
 8044 00b0 4A60     		str	r2, [r1, #4]	@ float
 196:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[ZAXIS] = 0.0;
 8045              		.loc 31 196 0
 8046 00b2 8A60     		str	r2, [r1, #8]	@ float
 200:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magBias[XAXIS] = 0.0;
 8047              		.loc 31 200 0
 8048 00b4 3749     		ldr	r1, .L505+76
 191:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[XAXIS] = 1.0;
 8049              		.loc 31 191 0
 8050 00b6 2060     		str	r0, [r4, #0]	@ float
 199:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magScale[XAXIS] = 1.0;
 8051              		.loc 31 199 0
 8052 00b8 3060     		str	r0, [r6, #0]	@ float
 8053              		.loc 31 200 0
 8054 00ba 0A60     		str	r2, [r1, #0]	@ float
 193:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[YAXIS] = 1.0;
 8055              		.loc 31 193 0
 8056 00bc 6060     		str	r0, [r4, #4]	@ float
 195:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[ZAXIS] = 1.0;
 8057              		.loc 31 195 0
 8058 00be A060     		str	r0, [r4, #8]	@ float
 201:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magScale[YAXIS] = 1.0;
 8059              		.loc 31 201 0
 8060 00c0 7060     		str	r0, [r6, #4]	@ float
 202:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magBias[YAXIS] = 0.0;
 203:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magScale[ZAXIS] = 1.0;
 204:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magBias[ZAXIS] = 0.0;
 205:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 206:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   windupGuard = 1000.0;
 8061              		.loc 31 206 0
 8062 00c2 354C     		ldr	r4, .L505+80
 202:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magBias[YAXIS] = 0.0;
 8063              		.loc 31 202 0
 8064 00c4 4A60     		str	r2, [r1, #4]	@ float
 203:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magScale[ZAXIS] = 1.0;
 8065              		.loc 31 203 0
 8066 00c6 B060     		str	r0, [r6, #8]	@ float
 204:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magBias[ZAXIS] = 0.0;
 8067              		.loc 31 204 0
 8068 00c8 8A60     		str	r2, [r1, #8]	@ float
 8069              		.loc 31 206 0
 8070 00ca 344E     		ldr	r6, .L505+84
 207:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 208:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // AKA - added so that each PID has its own windupGuard, will need to be removed once each PID's 
 209:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for (byte i = XAXIS; i < LAST_PID_IDX; i++ ) {
 210:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #if defined AltitudeHoldBaro
 211:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       if (i != BARO_ALTITUDE_HOLD_PID_IDX) {
 212:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****         PID[i].windupGuard = windupGuard;
 213:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       }
 214:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #else
 215:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       PID[i].windupGuard = windupGuard;
 216:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #endif
 217:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
 218:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     
 219:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   receiverXmitFactor = 1.0;
 8071              		.loc 31 219 0
 8072 00cc 3449     		ldr	r1, .L505+88
 206:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   windupGuard = 1000.0;
 8073              		.loc 31 206 0
 8074 00ce 2660     		str	r6, [r4, #0]	@ float
 8075              	.LVL374:
 8076              	.LBB200:
 212:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****         PID[i].windupGuard = windupGuard;
 8077              		.loc 31 212 0
 8078 00d0 9E61     		str	r6, [r3, #24]	@ float
 8079              	.LVL375:
 8080 00d2 5E63     		str	r6, [r3, #52]	@ float
 8081              	.LVL376:
 8082 00d4 1E65     		str	r6, [r3, #80]	@ float
 8083              	.LVL377:
 8084 00d6 DE66     		str	r6, [r3, #108]	@ float
 8085              	.LVL378:
 8086 00d8 C3F88860 		str	r6, [r3, #136]	@ float
 8087              	.LVL379:
 8088 00dc C3F8A460 		str	r6, [r3, #164]	@ float
 8089              	.LVL380:
 8090 00e0 C3F8C060 		str	r6, [r3, #192]	@ float
 8091              	.LVL381:
 8092 00e4 C3F8DC60 		str	r6, [r3, #220]	@ float
 8093              	.LVL382:
 8094 00e8 C3F81461 		str	r6, [r3, #276]	@ float
 8095              	.LVL383:
 8096              	.LBE200:
 8097              		.loc 31 219 0
 8098 00ec 0860     		str	r0, [r1, #0]	@ float
 220:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   minArmedThrottle = 1150;
 8099              		.loc 31 220 0
 8100 00ee 2D4E     		ldr	r6, .L505+92
 221:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // AKA - old setOneG not in SI - accel->setOneG(500);
 222:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelOneG = -9.80665; // AKA set one G to 9.8 m/s^2
 8101              		.loc 31 222 0
 8102 00f0 2D49     		ldr	r1, .L505+96
 8103 00f2 2E4B     		ldr	r3, .L505+100
 220:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   minArmedThrottle = 1150;
 8104              		.loc 31 220 0
 8105 00f4 40F27E44 		movw	r4, #1150
 8106 00f8 3460     		str	r4, [r6, #0]
 8107              		.loc 31 222 0
 8108 00fa 1960     		str	r1, [r3, #0]	@ float
 8109              	.LVL384:
 8110 00fc 2C4E     		ldr	r6, .L505+104
 8111 00fe 2D4C     		ldr	r4, .L505+108
 8112 0100 2D49     		ldr	r1, .L505+112
 8113 0102 0823     		movs	r3, #8
 8114              	.LVL385:
 8115              	.L503:
 8116              	.LBB201:
 223:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for (byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 224:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     receiverSlope[channel] = 1.0;
 225:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     receiverOffset[channel] = 0.0;
 226:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     receiverSmoothFactor[channel] = 1.0;
 8117              		.loc 31 226 0 discriminator 2
 8118 0104 013B     		subs	r3, r3, #1
 8119 0106 DBB2     		uxtb	r3, r3
 224:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     receiverSlope[channel] = 1.0;
 8120              		.loc 31 224 0 discriminator 2
 8121 0108 46F8040F 		str	r0, [r6, #4]!	@ float
 225:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     receiverOffset[channel] = 0.0;
 8122              		.loc 31 225 0 discriminator 2
 8123 010c 44F8042F 		str	r2, [r4, #4]!	@ float
 8124              		.loc 31 226 0 discriminator 2
 8125 0110 41F8040F 		str	r0, [r1, #4]!	@ float
 223:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for (byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 8126              		.loc 31 223 0 discriminator 2
 8127 0114 002B     		cmp	r3, #0
 8128 0116 F5D1     		bne	.L503
 8129              	.LBE201:
 227:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
 228:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   receiverSmoothFactor[ZAXIS] = 0.5;
 229:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 230:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   flightMode = RATE_FLIGHT_MODE;
 8130              		.loc 31 230 0
 8131 0118 2848     		ldr	r0, .L505+116
 228:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   receiverSmoothFactor[ZAXIS] = 0.5;
 8132              		.loc 31 228 0
 8133 011a 2949     		ldr	r1, .L505+120
 8134              		.loc 31 230 0
 8135 011c 0370     		strb	r3, [r0, #0]
 231:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   headingHoldConfig = ON;
 8136              		.loc 31 231 0
 8137 011e 294B     		ldr	r3, .L505+124
 232:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   aref = 5.0; // Use 3.0 if using a v1.7 shield or use 2.8 for an AeroQuad Shield < v1.7
 233:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 234:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Battery Monitor
 235:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef BattMonitor
 236:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     batteryMonitorAlarmVoltage = 3.33;
 8138              		.loc 31 236 0
 8139 0120 2948     		ldr	r0, .L505+128
 231:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   headingHoldConfig = ON;
 8140              		.loc 31 231 0
 8141 0122 0122     		movs	r2, #1
 8142 0124 1A70     		strb	r2, [r3, #0]
 228:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   receiverSmoothFactor[ZAXIS] = 0.5;
 8143              		.loc 31 228 0
 8144 0126 4FF07C5C 		mov	ip, #1056964608
 8145              		.loc 31 236 0
 8146 012a 284A     		ldr	r2, .L505+132
 228:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   receiverSmoothFactor[ZAXIS] = 0.5;
 8147              		.loc 31 228 0
 8148 012c C1F808C0 		str	ip, [r1, #8]	@ float
 232:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   aref = 5.0; // Use 3.0 if using a v1.7 shield or use 2.8 for an AeroQuad Shield < v1.7
 8149              		.loc 31 232 0
 8150 0130 2749     		ldr	r1, .L505+136
 8151              		.loc 31 236 0
 8152 0132 0260     		str	r2, [r0, #0]	@ float
 237:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     batteryMonitorThrottleTarget = 1450;
 8153              		.loc 31 237 0
 8154 0134 274B     		ldr	r3, .L505+140
 238:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     batteryMonitorGoingDownTime = 60000;
 8155              		.loc 31 238 0
 8156 0136 2848     		ldr	r0, .L505+144
 232:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   aref = 5.0; // Use 3.0 if using a v1.7 shield or use 2.8 for an AeroQuad Shield < v1.7
 8157              		.loc 31 232 0
 8158 0138 0D60     		str	r5, [r1, #0]	@ float
 8159              		.loc 31 238 0
 8160 013a 4EF66022 		movw	r2, #60000
 237:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     batteryMonitorThrottleTarget = 1450;
 8161              		.loc 31 237 0
 8162 013e 40F2AA51 		movw	r1, #1450
 8163 0142 1960     		str	r1, [r3, #0]
 8164              		.loc 31 238 0
 8165 0144 0260     		str	r2, [r0, #0]
 8166              	.LBE202:
 239:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 240:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 241:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Range Finder
 242:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined (AltitudeHoldRangeFinder)
 243:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     maxRangeFinderRange = 4.5;
 244:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     minRangeFinderRange = 0.0;
 245:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 246:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 247:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined (UseGPSNavigator)
 248:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     missionNbPoint = 0;
 249:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSROLL_PID_IDX].P = 0.8;
 250:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSROLL_PID_IDX].I = 0.0;
 251:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSROLL_PID_IDX].D = 0.0;
 252:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSPITCH_PID_IDX].P = 0.8;
 253:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSPITCH_PID_IDX].I = 0.0;
 254:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSPITCH_PID_IDX].D = 0.0;
 255:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSYAW_PID_IDX].P = 50.0;
 256:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSYAW_PID_IDX].I = 0.0;
 257:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSYAW_PID_IDX].D = 0.0;
 258:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 259:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     for (byte location = 0; location < MAX_WAYPOINTS; location++) {
 260:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       waypoint[location].longitude = GPS_INVALID_ANGLE;
 261:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       waypoint[location].latitude = GPS_INVALID_ANGLE;
 262:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       waypoint[location].altitude = GPS_INVALID_ALTITUDE;
 263:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     }
 264:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 265:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 266:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Camera Control
 267:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef CameraControl
 268:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     cameraMode = 1;
 269:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     mCameraPitch = 1273.2;    
 270:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     mCameraRoll = 636.6;    
 271:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     mCameraYaw = 318.3;
 272:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoCenterPitch = 1500;
 273:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoCenterRoll = 1500;
 274:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoCenterYaw = 1500;
 275:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMinPitch = 1000;
 276:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMinRoll = 1000;
 277:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMinYaw = 1000;
 278:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMaxPitch = 2000;
 279:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMaxRoll = 2000;
 280:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMaxYaw = 2000;
 281:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 282:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** }
 8167              		.loc 31 282 0
 8168 0146 70BD     		pop	{r4, r5, r6, pc}
 8169              	.L506:
 8170              		.align	2
 8171              	.L505:
 8172 0148 00000000 		.word	.LANCHOR17
 8173 014c 0000C842 		.word	1120403456
 8174 0150 00000000 		.word	.LANCHOR115
 8175 0154 000096C3 		.word	-1013579776
 8176 0158 00004843 		.word	1128792064
 8177 015c 00004040 		.word	1077936128
 8178 0160 0000C841 		.word	1103626240
 8179 0164 9A99193F 		.word	1058642330
 8180 0168 CDCCCC3D 		.word	1036831949
 8181 016c 0000A040 		.word	1084227584
 8182 0170 00000000 		.word	.LANCHOR111
 8183 0174 00000000 		.word	.LANCHOR112
 8184 0178 00000000 		.word	.LANCHOR97
 8185 017c 00000000 		.word	.LANCHOR8
 8186 0180 00000000 		.word	.LANCHOR113
 8187 0184 00000000 		.word	.LANCHOR31
 8188 0188 00000000 		.word	.LANCHOR35
 8189 018c 00000000 		.word	.LANCHOR36
 8190 0190 00000000 		.word	.LANCHOR75
 8191 0194 00000000 		.word	.LANCHOR76
 8192 0198 00000000 		.word	.LANCHOR131
 8193 019c 00007A44 		.word	1148846080
 8194 01a0 00000000 		.word	.LANCHOR61
 8195 01a4 00000000 		.word	.LANCHOR120
 8196 01a8 0AE81CC1 		.word	-1055070198
 8197 01ac 00000000 		.word	.LANCHOR39
 8198 01b0 FCFFFFFF 		.word	.LANCHOR12-4
 8199 01b4 FCFFFFFF 		.word	.LANCHOR13-4
 8200 01b8 FCFFFFFF 		.word	.LANCHOR14-4
 8201 01bc 00000000 		.word	.LANCHOR114
 8202 01c0 00000000 		.word	.LANCHOR14
 8203 01c4 00000000 		.word	.LANCHOR123
 8204 01c8 00000000 		.word	.LANCHOR133
 8205 01cc B81E5540 		.word	1079320248
 8206 01d0 00000000 		.word	.LANCHOR132
 8207 01d4 00000000 		.word	.LANCHOR134
 8208 01d8 00000000 		.word	.LANCHOR135
 8209              		.cfi_endproc
 8210              	.LFE228:
 8212              		.section	.text._Z10readEEPROMv,"ax",%progbits
 8213              		.align	1
 8214              		.global	_Z10readEEPROMv
 8215              		.thumb
 8216              		.thumb_func
 8218              	_Z10readEEPROMv:
 8219              	.LFB229:
 283:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 284:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void readEEPROM() {
 8220              		.loc 31 284 0
 8221              		.cfi_startproc
 8222              		@ args = 0, pretend = 0, frame = 0
 8223              		@ frame_needed = 0, uses_anonymous_args = 0
 8224              	.LBB203:
 285:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   readPID(XAXIS, ROLL_PID_GAIN_ADR);
 8225              		.loc 31 285 0
 8226 0000 0020     		movs	r0, #0
 8227              	.LBE203:
 284:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void readEEPROM() {
 8228              		.loc 31 284 0
 8229 0002 70B5     		push	{r4, r5, r6, lr}
 8230              	.LCFI86:
 8231              		.cfi_def_cfa_offset 16
 8232              		.cfi_offset 14, -4
 8233              		.cfi_offset 6, -8
 8234              		.cfi_offset 5, -12
 8235              		.cfi_offset 4, -16
 8236              	.LBB206:
 8237              		.loc 31 285 0
 8238 0004 0146     		mov	r1, r0
 8239 0006 FFF7FEFF 		bl	_Z10nvrReadPIDhj
 286:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   readPID(YAXIS, PITCH_PID_GAIN_ADR);
 8240              		.loc 31 286 0
 8241 000a 0120     		movs	r0, #1
 8242 000c 2421     		movs	r1, #36
 8243 000e FFF7FEFF 		bl	_Z10nvrReadPIDhj
 287:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   readPID(ZAXIS, YAW_PID_GAIN_ADR);
 8244              		.loc 31 287 0
 8245 0012 0220     		movs	r0, #2
 8246 0014 1821     		movs	r1, #24
 8247 0016 FFF7FEFF 		bl	_Z10nvrReadPIDhj
 288:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   readPID(ATTITUDE_XAXIS_PID_IDX, LEVELROLL_PID_GAIN_ADR);
 8248              		.loc 31 288 0
 8249 001a 0320     		movs	r0, #3
 8250 001c 0C21     		movs	r1, #12
 8251 001e FFF7FEFF 		bl	_Z10nvrReadPIDhj
 289:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   readPID(ATTITUDE_YAXIS_PID_IDX, LEVELPITCH_PID_GAIN_ADR);
 8252              		.loc 31 289 0
 8253 0022 0420     		movs	r0, #4
 8254 0024 3021     		movs	r1, #48
 8255 0026 FFF7FEFF 		bl	_Z10nvrReadPIDhj
 290:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   readPID(HEADING_HOLD_PID_IDX, HEADING_PID_GAIN_ADR);
 8256              		.loc 31 290 0
 8257 002a 0520     		movs	r0, #5
 8258 002c 3C21     		movs	r1, #60
 8259 002e FFF7FEFF 		bl	_Z10nvrReadPIDhj
 291:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   readPID(ATTITUDE_GYRO_XAXIS_PID_IDX, LEVEL_GYRO_ROLL_PID_GAIN_ADR);
 8260              		.loc 31 291 0
 8261 0032 0620     		movs	r0, #6
 8262 0034 4821     		movs	r1, #72
 8263 0036 FFF7FEFF 		bl	_Z10nvrReadPIDhj
 292:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   readPID(ATTITUDE_GYRO_YAXIS_PID_IDX, LEVEL_GYRO_PITCH_PID_GAIN_ADR);
 8264              		.loc 31 292 0
 8265 003a 5421     		movs	r1, #84
 8266 003c 0720     		movs	r0, #7
 8267 003e FFF7FEFF 		bl	_Z10nvrReadPIDhj
 293:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   rotationSpeedFactor = readFloat(ROTATION_SPEED_FACTOR_ARD);
 8268              		.loc 31 294 0
 8269 0042 4FF4A070 		mov	r0, #320
 8270 0046 FFF7FEFF 		bl	_Z12nvrReadFloati
 8271 004a 614C     		ldr	r4, .L508
 295:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 296:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Leaving separate PID reads as commented for now
 297:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Previously had issue where EEPROM was not reading right data
 298:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 299:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     readPID(BARO_ALTITUDE_HOLD_PID_IDX, ALTITUDE_PID_GAIN_ADR);
 300:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard = readFloat(ALTITUDE_WINDUP_ADR);
 301:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #if defined AltitudeHoldBaro
 302:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       baroSmoothFactor = readFloat(ALTITUDE_SMOOTH_ADR);
 303:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #endif  
 304:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     altitudeHoldBump = readFloat(ALTITUDE_BUMP_ADR);
 305:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     altitudeHoldPanicStickMovement = readFloat(ALTITUDE_PANIC_ADR);
 306:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     minThrottleAdjust = readFloat(ALTITUDE_MIN_THROTTLE_ADR);
 8272              		.loc 31 306 0
 8273 004c 614E     		ldr	r6, .L508+4
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   rotationSpeedFactor = readFloat(ROTATION_SPEED_FACTOR_ARD);
 8274              		.loc 31 294 0
 8275 004e 2060     		str	r0, [r4, #0]	@ float
 299:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     readPID(BARO_ALTITUDE_HOLD_PID_IDX, ALTITUDE_PID_GAIN_ADR);
 8276              		.loc 31 299 0
 8277 0050 6021     		movs	r1, #96
 8278 0052 0820     		movs	r0, #8
 8279 0054 FFF7FEFF 		bl	_Z10nvrReadPIDhj
 300:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard = readFloat(ALTITUDE_WINDUP_ADR);
 8280              		.loc 31 300 0
 8281 0058 4FF49470 		mov	r0, #296
 8282 005c FFF7FEFF 		bl	_Z12nvrReadFloati
 8283 0060 5D4C     		ldr	r4, .L508+8
 307:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     maxThrottleAdjust = readFloat(ALTITUDE_MAX_THROTTLE_ADR);
 8284              		.loc 31 307 0
 8285 0062 5E4D     		ldr	r5, .L508+12
 300:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard = readFloat(ALTITUDE_WINDUP_ADR);
 8286              		.loc 31 300 0
 8287 0064 C4F8F800 		str	r0, [r4, #248]	@ float
 302:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       baroSmoothFactor = readFloat(ALTITUDE_SMOOTH_ADR);
 8288              		.loc 31 302 0
 8289 0068 4FF49270 		mov	r0, #292
 8290 006c FFF7FEFF 		bl	_Z12nvrReadFloati
 8291 0070 5B4B     		ldr	r3, .L508+16
 8292 0072 1860     		str	r0, [r3, #0]	@ float
 304:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     altitudeHoldBump = readFloat(ALTITUDE_BUMP_ADR);
 8293              		.loc 31 304 0
 8294 0074 4FF49670 		mov	r0, #300
 8295 0078 FFF7FEFF 		bl	_Z12nvrReadFloati
 8296 007c 00EE100A 		fmsr	s0, r0
 8297 0080 5848     		ldr	r0, .L508+20
 8298 0082 FDEEC07A 		ftosizs	s15, s0
 8299 0086 C0ED007A 		fsts	s15, [r0, #0]	@ int
 305:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     altitudeHoldPanicStickMovement = readFloat(ALTITUDE_PANIC_ADR);
 8300              		.loc 31 305 0
 8301 008a 4FF49870 		mov	r0, #304
 8302 008e FFF7FEFF 		bl	_Z12nvrReadFloati
 8303 0092 07EE100A 		fmsr	s14, r0
 8304 0096 544A     		ldr	r2, .L508+24
 8305 0098 FDEEC76A 		ftosizs	s13, s14
 306:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     minThrottleAdjust = readFloat(ALTITUDE_MIN_THROTTLE_ADR);
 8306              		.loc 31 306 0
 8307 009c 4FF49070 		mov	r0, #288
 305:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     altitudeHoldPanicStickMovement = readFloat(ALTITUDE_PANIC_ADR);
 8308              		.loc 31 305 0
 8309 00a0 C2ED006A 		fsts	s13, [r2, #0]	@ int
 306:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     minThrottleAdjust = readFloat(ALTITUDE_MIN_THROTTLE_ADR);
 8310              		.loc 31 306 0
 8311 00a4 FFF7FEFF 		bl	_Z12nvrReadFloati
 8312 00a8 06EE100A 		fmsr	s12, r0
 8313 00ac FDEEC65A 		ftosizs	s11, s12
 8314              		.loc 31 307 0
 8315 00b0 4FF48E70 		mov	r0, #284
 306:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     minThrottleAdjust = readFloat(ALTITUDE_MIN_THROTTLE_ADR);
 8316              		.loc 31 306 0
 8317 00b4 C6ED005A 		fsts	s11, [r6, #0]	@ int
 8318              		.loc 31 307 0
 8319 00b8 FFF7FEFF 		bl	_Z12nvrReadFloati
 8320 00bc 05EE100A 		fmsr	s10, r0
 8321 00c0 FDEEC54A 		ftosizs	s9, s10
 308:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     readPID(ZDAMPENING_PID_IDX, ZDAMP_PID_GAIN_ADR);
 8322              		.loc 31 308 0
 8323 00c4 0920     		movs	r0, #9
 307:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     maxThrottleAdjust = readFloat(ALTITUDE_MAX_THROTTLE_ADR);
 8324              		.loc 31 307 0
 8325 00c6 C5ED004A 		fsts	s9, [r5, #0]	@ int
 8326              		.loc 31 308 0
 8327 00ca 6C21     		movs	r1, #108
 8328 00cc FFF7FEFF 		bl	_Z10nvrReadPIDhj
 309:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 310:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 311:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Mag calibration
 312:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef HeadingMagHold
 313:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magBias[XAXIS]  = readFloat(XAXIS_MAG_BIAS_ADR);
 8329              		.loc 31 313 0
 8330 00d0 4FF4AE70 		mov	r0, #348
 8331 00d4 FFF7FEFF 		bl	_Z12nvrReadFloati
 8332 00d8 444E     		ldr	r6, .L508+28
 314:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magScale[XAXIS] = readFloat(XAXIS_MAG_SCALE_FACTOR_ADR);
 8333              		.loc 31 314 0
 8334 00da 454D     		ldr	r5, .L508+32
 313:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magBias[XAXIS]  = readFloat(XAXIS_MAG_BIAS_ADR);
 8335              		.loc 31 313 0
 8336 00dc 3060     		str	r0, [r6, #0]	@ float
 8337              		.loc 31 314 0
 8338 00de 4FF4B070 		mov	r0, #352
 8339 00e2 FFF7FEFF 		bl	_Z12nvrReadFloati
 8340 00e6 2860     		str	r0, [r5, #0]	@ float
 315:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magBias[YAXIS]  = readFloat(YAXIS_MAG_BIAS_ADR);
 8341              		.loc 31 315 0
 8342 00e8 4FF4B270 		mov	r0, #356
 8343 00ec FFF7FEFF 		bl	_Z12nvrReadFloati
 8344 00f0 7060     		str	r0, [r6, #4]	@ float
 316:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magScale[YAXIS] = readFloat(YAXIS_MAG_SCALE_FACTOR_ADR);
 8345              		.loc 31 316 0
 8346 00f2 4FF4B470 		mov	r0, #360
 8347 00f6 FFF7FEFF 		bl	_Z12nvrReadFloati
 8348 00fa 6860     		str	r0, [r5, #4]	@ float
 317:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magBias[ZAXIS]  = readFloat(ZAXIS_MAG_BIAS_ADR);
 8349              		.loc 31 317 0
 8350 00fc 4FF4B670 		mov	r0, #364
 8351 0100 FFF7FEFF 		bl	_Z12nvrReadFloati
 8352 0104 B060     		str	r0, [r6, #8]	@ float
 318:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     magScale[ZAXIS] = readFloat(ZAXIS_MAG_SCALE_FACTOR_ADR);
 8353              		.loc 31 318 0
 8354 0106 4FF4B870 		mov	r0, #368
 8355 010a FFF7FEFF 		bl	_Z12nvrReadFloati
 8356 010e A860     		str	r0, [r5, #8]	@ float
 319:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 320:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 321:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Battery Monitor
 322:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef BattMonitor
 323:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     batteryMonitorAlarmVoltage = readFloat(BATT_ALARM_VOLTAGE_ADR);
 8357              		.loc 31 323 0
 8358 0110 4FF4BA70 		mov	r0, #372
 8359 0114 FFF7FEFF 		bl	_Z12nvrReadFloati
 8360 0118 3649     		ldr	r1, .L508+36
 8361 011a 0860     		str	r0, [r1, #0]	@ float
 324:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     batteryMonitorThrottleTarget = readFloat(BATT_THROTTLE_TARGET_ADR);
 8362              		.loc 31 324 0
 8363 011c 4FF4BC70 		mov	r0, #376
 8364 0120 FFF7FEFF 		bl	_Z12nvrReadFloati
 8365 0124 04EE100A 		fmsr	s8, r0
 8366 0128 334B     		ldr	r3, .L508+40
 8367 012a FDEEC43A 		ftosizs	s7, s8
 325:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     batteryMonitorGoingDownTime = readFloat(BATT_DOWN_TIME_ADR);
 8368              		.loc 31 325 0
 8369 012e 4FF4BE70 		mov	r0, #380
 324:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     batteryMonitorThrottleTarget = readFloat(BATT_THROTTLE_TARGET_ADR);
 8370              		.loc 31 324 0
 8371 0132 C3ED003A 		fsts	s7, [r3, #0]	@ int
 8372              		.loc 31 325 0
 8373 0136 FFF7FEFF 		bl	_Z12nvrReadFloati
 8374 013a 03EE100A 		fmsr	s6, r0
 8375 013e 2F48     		ldr	r0, .L508+44
 8376 0140 FCEEC32A 		ftouizs	s5, s6
 8377 0144 C0ED002A 		fsts	s5, [r0, #0]	@ int
 326:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 327:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 328:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   windupGuard = readFloat(WINDUPGUARD_ADR);
 8378              		.loc 31 328 0
 8379 0148 4FF48070 		mov	r0, #256
 8380 014c FFF7FEFF 		bl	_Z12nvrReadFloati
 8381 0150 2B4A     		ldr	r2, .L508+48
 8382              	.LBB204:
 329:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // AKA - added so that each PID has its own windupGuard, will need to be removed once each PID's 
 330:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for (byte i = XAXIS; i < LAST_PID_IDX; i++ ) {
 331:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #if defined AltitudeHoldBaro
 332:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       if (i != BARO_ALTITUDE_HOLD_PID_IDX) {
 333:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****         PID[i].windupGuard = windupGuard;
 8383              		.loc 31 333 0
 8384 0152 A061     		str	r0, [r4, #24]	@ float
 8385              	.LBE204:
 328:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   windupGuard = readFloat(WINDUPGUARD_ADR);
 8386              		.loc 31 328 0
 8387 0154 1060     		str	r0, [r2, #0]	@ float
 8388              	.LVL386:
 8389              	.LBB205:
 8390              		.loc 31 333 0
 8391 0156 6063     		str	r0, [r4, #52]	@ float
 8392              	.LVL387:
 8393 0158 2065     		str	r0, [r4, #80]	@ float
 8394              	.LVL388:
 8395 015a E066     		str	r0, [r4, #108]	@ float
 8396              	.LVL389:
 8397 015c C4F88800 		str	r0, [r4, #136]	@ float
 8398              	.LVL390:
 8399 0160 C4F8A400 		str	r0, [r4, #164]	@ float
 8400              	.LVL391:
 8401 0164 C4F8C000 		str	r0, [r4, #192]	@ float
 8402              	.LVL392:
 8403 0168 C4F8DC00 		str	r0, [r4, #220]	@ float
 8404              	.LVL393:
 8405 016c C4F81401 		str	r0, [r4, #276]	@ float
 8406              	.LVL394:
 8407              	.LBE205:
 334:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       }
 335:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #else
 336:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       PID[i].windupGuard = windupGuard;
 337:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #endif      
 338:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
 339:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     
 340:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   minArmedThrottle = readFloat(MINARMEDTHROTTLE_ADR);
 8408              		.loc 31 340 0
 8409 0170 4FF48470 		mov	r0, #264
 8410 0174 FFF7FEFF 		bl	_Z12nvrReadFloati
 8411 0178 02EE100A 		fmsr	s4, r0
 8412 017c 2149     		ldr	r1, .L508+52
 8413 017e FDEEC21A 		ftosizs	s3, s4
 341:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   aref = readFloat(AREF_ADR);
 8414              		.loc 31 341 0
 8415 0182 4FF48670 		mov	r0, #268
 340:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   minArmedThrottle = readFloat(MINARMEDTHROTTLE_ADR);
 8416              		.loc 31 340 0
 8417 0186 C1ED001A 		fsts	s3, [r1, #0]	@ int
 8418              		.loc 31 341 0
 8419 018a FFF7FEFF 		bl	_Z12nvrReadFloati
 8420 018e 1E4B     		ldr	r3, .L508+56
 8421 0190 1860     		str	r0, [r3, #0]	@ float
 342:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   flightMode = readFloat(FLIGHTMODE_ADR);
 8422              		.loc 31 342 0
 8423 0192 4FF48870 		mov	r0, #272
 8424 0196 FFF7FEFF 		bl	_Z12nvrReadFloati
 8425 019a 01EE100A 		fmsr	s2, r0
 8426 019e FCEEC10A 		ftouizs	s1, s2
 8427 01a2 1A48     		ldr	r0, .L508+60
 8428 01a4 10EE902A 		fmrs	r2, s1	@ int
 8429 01a8 0270     		strb	r2, [r0, #0]
 343:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelOneG = readFloat(ACCEL_1G_ADR);
 8430              		.loc 31 343 0
 8431 01aa 4FF48C70 		mov	r0, #280
 8432 01ae FFF7FEFF 		bl	_Z12nvrReadFloati
 8433 01b2 1749     		ldr	r1, .L508+64
 8434 01b4 0860     		str	r0, [r1, #0]	@ float
 344:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   headingHoldConfig = readFloat(HEADINGHOLD_ADR);
 8435              		.loc 31 344 0
 8436 01b6 4FF48A70 		mov	r0, #276
 8437 01ba FFF7FEFF 		bl	_Z12nvrReadFloati
 8438 01be 00EE100A 		fmsr	s0, r0
 8439 01c2 FCEEC07A 		ftouizs	s15, s0
 8440 01c6 134B     		ldr	r3, .L508+68
 8441 01c8 17EE900A 		fmrs	r0, s15	@ int
 8442 01cc 1870     		strb	r0, [r3, #0]
 8443              	.LBE206:
 345:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 346:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Range Finder
 347:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined (AltitudeHoldRangeFinder)
 348:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** //    maxRangeFinderRange = readFloat(RANGE_FINDER_MAX_ADR);  // @Kenny @todo, remove this!
 349:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** //    minRangeFinderRange = readFloat(RANGE_FINDER_MIN_ADR);
 350:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif     
 351:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 352:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined (UseGPSNavigator)
 353:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     missionNbPoint = readFloat(GPS_MISSION_NB_POINT_ADR);
 354:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     readPID(GPSROLL_PID_IDX, GPSROLL_PID_GAIN_ADR);
 355:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     readPID(GPSPITCH_PID_IDX, GPSPITCH_PID_GAIN_ADR);
 356:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     readPID(GPSYAW_PID_IDX, GPSYAW_PID_GAIN_ADR);
 357:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     
 358:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     for (byte location = 0; location < MAX_WAYPOINTS; location++) {
 359:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       waypoint[location].longitude = readLong(WAYPOINT_ADR[location].longitude);
 360:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       waypoint[location].latitude = readLong(WAYPOINT_ADR[location].latitude);
 361:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       waypoint[location].altitude = readLong(WAYPOINT_ADR[location].altitude);
 362:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     }    
 363:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 364:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 365:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Camera Control
 366:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef CameraControl
 367:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     cameraMode = readFloat(CAMERAMODE_ADR);
 368:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     mCameraPitch = readFloat(MCAMERAPITCH_ADR);
 369:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     mCameraRoll = readFloat(MCAMERAROLL_ADR);    
 370:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     mCameraYaw = readFloat(MCAMERAYAW_ADR);
 371:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoCenterPitch = readFloat(SERVOCENTERPITCH_ADR);
 372:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoCenterRoll = readFloat(SERVOCENTERROLL_ADR);
 373:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoCenterYaw = readFloat(SERVOCENTERYAW_ADR);
 374:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMinPitch = readFloat(SERVOMINPITCH_ADR);
 375:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMinRoll = readFloat(SERVOMINROLL_ADR);
 376:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMinYaw = readFloat(SERVOMINYAW_ADR);
 377:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMaxPitch = readFloat(SERVOMAXPITCH_ADR);
 378:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMaxRoll = readFloat(SERVOMAXROLL_ADR);
 379:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMaxYaw = readFloat(SERVOMAXYAW_ADR);
 380:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif   
 381:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** }
 8444              		.loc 31 381 0
 8445 01ce 70BD     		pop	{r4, r5, r6, pc}
 8446              	.L509:
 8447              		.align	2
 8448              	.L508:
 8449 01d0 00000000 		.word	.LANCHOR115
 8450 01d4 00000000 		.word	.LANCHOR111
 8451 01d8 00000000 		.word	.LANCHOR17
 8452 01dc 00000000 		.word	.LANCHOR112
 8453 01e0 00000000 		.word	.LANCHOR97
 8454 01e4 00000000 		.word	.LANCHOR8
 8455 01e8 00000000 		.word	.LANCHOR113
 8456 01ec 00000000 		.word	.LANCHOR76
 8457 01f0 00000000 		.word	.LANCHOR75
 8458 01f4 00000000 		.word	.LANCHOR133
 8459 01f8 00000000 		.word	.LANCHOR134
 8460 01fc 00000000 		.word	.LANCHOR135
 8461 0200 00000000 		.word	.LANCHOR131
 8462 0204 00000000 		.word	.LANCHOR120
 8463 0208 00000000 		.word	.LANCHOR132
 8464 020c 00000000 		.word	.LANCHOR114
 8465 0210 00000000 		.word	.LANCHOR39
 8466 0214 00000000 		.word	.LANCHOR123
 8467              		.cfi_endproc
 8468              	.LFE229:
 8470              		.section	.text._Z11writeEEPROMv,"ax",%progbits
 8471              		.align	1
 8472              		.global	_Z11writeEEPROMv
 8473              		.thumb
 8474              		.thumb_func
 8476              	_Z11writeEEPROMv:
 8477              	.LFB230:
 382:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 383:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void writeEEPROM(){
 8478              		.loc 31 383 0
 8479              		.cfi_startproc
 8480              		@ args = 0, pretend = 0, frame = 0
 8481              		@ frame_needed = 0, uses_anonymous_args = 0
 8482 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 8483              	.LCFI87:
 8484              		.cfi_def_cfa_offset 24
 8485              		.cfi_offset 14, -4
 8486              		.cfi_offset 7, -8
 8487              		.cfi_offset 6, -12
 8488              		.cfi_offset 5, -16
 8489              		.cfi_offset 4, -20
 8490              		.cfi_offset 3, -24
 8491              	.LBB213:
 8492              	.LBB214:
 8493              	.LBB215:
 8494              		.file 32 "../Libmaple/libmaple/libmaple/nvic.h"
   1:../Libmaple/libmaple/libmaple/nvic.h **** /******************************************************************************
   2:../Libmaple/libmaple/libmaple/nvic.h ****  * The MIT License
   3:../Libmaple/libmaple/libmaple/nvic.h ****  *
   4:../Libmaple/libmaple/libmaple/nvic.h ****  * Copyright (c) 2010 Perry Hung.
   5:../Libmaple/libmaple/libmaple/nvic.h ****  *
   6:../Libmaple/libmaple/libmaple/nvic.h ****  * Permission is hereby granted, free of charge, to any person
   7:../Libmaple/libmaple/libmaple/nvic.h ****  * obtaining a copy of this software and associated documentation
   8:../Libmaple/libmaple/libmaple/nvic.h ****  * files (the "Software"), to deal in the Software without
   9:../Libmaple/libmaple/libmaple/nvic.h ****  * restriction, including without limitation the rights to use, copy,
  10:../Libmaple/libmaple/libmaple/nvic.h ****  * modify, merge, publish, distribute, sublicense, and/or sell copies
  11:../Libmaple/libmaple/libmaple/nvic.h ****  * of the Software, and to permit persons to whom the Software is
  12:../Libmaple/libmaple/libmaple/nvic.h ****  * furnished to do so, subject to the following conditions:
  13:../Libmaple/libmaple/libmaple/nvic.h ****  *
  14:../Libmaple/libmaple/libmaple/nvic.h ****  * The above copyright notice and this permission notice shall be
  15:../Libmaple/libmaple/libmaple/nvic.h ****  * included in all copies or substantial portions of the Software.
  16:../Libmaple/libmaple/libmaple/nvic.h ****  *
  17:../Libmaple/libmaple/libmaple/nvic.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  18:../Libmaple/libmaple/libmaple/nvic.h ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  19:../Libmaple/libmaple/libmaple/nvic.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20:../Libmaple/libmaple/libmaple/nvic.h ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  21:../Libmaple/libmaple/libmaple/nvic.h ****  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  22:../Libmaple/libmaple/libmaple/nvic.h ****  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  23:../Libmaple/libmaple/libmaple/nvic.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  24:../Libmaple/libmaple/libmaple/nvic.h ****  * SOFTWARE.
  25:../Libmaple/libmaple/libmaple/nvic.h ****  *****************************************************************************/
  26:../Libmaple/libmaple/libmaple/nvic.h **** 
  27:../Libmaple/libmaple/libmaple/nvic.h **** /**
  28:../Libmaple/libmaple/libmaple/nvic.h ****  * @file nvic.h
  29:../Libmaple/libmaple/libmaple/nvic.h ****  * @brief Nested vector interrupt controller support.
  30:../Libmaple/libmaple/libmaple/nvic.h ****  *
  31:../Libmaple/libmaple/libmaple/nvic.h ****  * Basic usage:
  32:../Libmaple/libmaple/libmaple/nvic.h ****  *
  33:../Libmaple/libmaple/libmaple/nvic.h ****  * @code
  34:../Libmaple/libmaple/libmaple/nvic.h ****  *   // Initialise the interrupt controller and point to the vector
  35:../Libmaple/libmaple/libmaple/nvic.h ****  *   // table at the start of flash.
  36:../Libmaple/libmaple/libmaple/nvic.h ****  *   nvic_init(0x08000000, 0);
  37:../Libmaple/libmaple/libmaple/nvic.h ****  *   // Bind in a timer interrupt handler
  38:../Libmaple/libmaple/libmaple/nvic.h ****  *   timer_attach_interrupt(TIMER_CC1_INTERRUPT, handler);
  39:../Libmaple/libmaple/libmaple/nvic.h ****  *   // Optionally set the priority
  40:../Libmaple/libmaple/libmaple/nvic.h ****  *   nvic_irq_set_priority(NVIC_TIMER1_CC, 5);
  41:../Libmaple/libmaple/libmaple/nvic.h ****  *   // All done, enable all interrupts
  42:../Libmaple/libmaple/libmaple/nvic.h ****  *   nvic_globalirq_enable();
  43:../Libmaple/libmaple/libmaple/nvic.h ****  * @endcode
  44:../Libmaple/libmaple/libmaple/nvic.h ****  */
  45:../Libmaple/libmaple/libmaple/nvic.h **** 
  46:../Libmaple/libmaple/libmaple/nvic.h **** #ifndef _NVIC_H_
  47:../Libmaple/libmaple/libmaple/nvic.h **** #define _NVIC_H_
  48:../Libmaple/libmaple/libmaple/nvic.h **** 
  49:../Libmaple/libmaple/libmaple/nvic.h **** #include "libmaple_types.h"
  50:../Libmaple/libmaple/libmaple/nvic.h **** #include "util.h"
  51:../Libmaple/libmaple/libmaple/nvic.h **** 
  52:../Libmaple/libmaple/libmaple/nvic.h **** #ifdef __cplusplus
  53:../Libmaple/libmaple/libmaple/nvic.h **** extern "C"{
  54:../Libmaple/libmaple/libmaple/nvic.h **** #endif
  55:../Libmaple/libmaple/libmaple/nvic.h **** 
  56:../Libmaple/libmaple/libmaple/nvic.h **** /** NVIC register map type. */
  57:../Libmaple/libmaple/libmaple/nvic.h **** typedef struct nvic_reg_map {
  58:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 ISER[8];      /**< Interrupt Set Enable Registers */
  59:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RESERVED0[24];     /**< Reserved */
  60:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 ICER[8];      /**< Interrupt Clear Enable Registers */
  61:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RSERVED1[24];      /**< Reserved */
  62:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 ISPR[8];      /**< Interrupt Set Pending Registers */
  63:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RESERVED2[24];     /**< Reserved */
  64:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 ICPR[8];      /**< Interrupt Clear Pending Registers */
  65:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RESERVED3[24];     /**< Reserved */
  66:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 IABR[8];      /**< Interrupt Active bit Registers */
  67:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RESERVED4[56];     /**< Reserved */
  68:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint8  IP[240];      /**< Interrupt Priority Registers */
  69:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RESERVED5[644];    /**< Reserved */
  70:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 STIR;         /**< Software Trigger Interrupt Registers */
  71:../Libmaple/libmaple/libmaple/nvic.h **** } nvic_reg_map;
  72:../Libmaple/libmaple/libmaple/nvic.h **** 
  73:../Libmaple/libmaple/libmaple/nvic.h **** /** NVIC register map base pointer. */
  74:../Libmaple/libmaple/libmaple/nvic.h **** #define NVIC_BASE                       ((struct nvic_reg_map*)0xE000E100)
  75:../Libmaple/libmaple/libmaple/nvic.h **** 
  76:../Libmaple/libmaple/libmaple/nvic.h **** /**
  77:../Libmaple/libmaple/libmaple/nvic.h ****  * @brief Interrupt vector table interrupt numbers.
  78:../Libmaple/libmaple/libmaple/nvic.h ****  *
  79:../Libmaple/libmaple/libmaple/nvic.h ****  * Each positive-valued enumerator is the position of the
  80:../Libmaple/libmaple/libmaple/nvic.h ****  * corresponding interrupt in the vector table.  Negative-valued
  81:../Libmaple/libmaple/libmaple/nvic.h ****  * enumerators correspond to interrupts controlled by the system
  82:../Libmaple/libmaple/libmaple/nvic.h ****  * handler block.
  83:../Libmaple/libmaple/libmaple/nvic.h ****  *
  84:../Libmaple/libmaple/libmaple/nvic.h ****  * @see scb.h
  85:../Libmaple/libmaple/libmaple/nvic.h ****  */
  86:../Libmaple/libmaple/libmaple/nvic.h **** typedef enum nvic_irq_num {
  87:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_NMI            = -14,  /**< Non-maskable interrupt */
  88:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_HARDFAULT      = -13,  /**< Hard fault (all class of fault) */
  89:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_MEM_MANAGE     = -12,  /**< Memory management */
  90:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_BUS_FAULT      = -11,  /**< Bus fault: prefetch fault, memory
  91:../Libmaple/libmaple/libmaple/nvic.h ****                                      access fault. */
  92:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USAGE_FAULT    = -10,  /**< Usage fault: Undefined instruction or
  93:../Libmaple/libmaple/libmaple/nvic.h ****                                      illegal state. */
  94:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SVC            = -5,   /**< System service call via SWI insruction */
  95:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DEBUG_MON      = -4,   /**< Debug monitor */
  96:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_PEND_SVC       = -2,   /**< Pendable request for system service */
  97:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SYSTICK        = -1,   /**< System tick timer */
  98:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_WWDG           = 0,    /**< Window watchdog interrupt */
  99:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_PVD            = 1,    /**< PVD through EXTI line detection */
 100:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TAMPER         = 2,    /**< Tamper */
 101:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_RTC            = 3,    /**< Real-time clock */
 102:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_FLASH          = 4,    /**< Flash */
 103:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_RCC            = 5,    /**< Reset and clock control */
 104:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI0          = 6,    /**< EXTI line 0 */
 105:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI1          = 7,    /**< EXTI line 1 */
 106:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI2          = 8,    /**< EXTI line 2 */
 107:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI3          = 9,    /**< EXTI line 3 */
 108:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI4          = 10,   /**< EXTI line 4 */
 109:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH1        = 11,   /**< DMA1 channel 1 */
 110:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH2        = 12,   /**< DMA1 channel 2 */
 111:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH3        = 13,   /**< DMA1 channel 3 */
 112:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH4        = 14,   /**< DMA1 channel 4 */
 113:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH5        = 15,   /**< DMA1 channel 5 */
 114:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH6        = 16,   /**< DMA1 channel 6 */
 115:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH7        = 17,   /**< DMA1 channel 7 */
 116:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_ADC_1_2        = 18,   /**< ADC1 and ADC2 */
 117:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USB_HP_CAN_TX  = 19,   /**< USB high priority or CAN TX */
 118:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USB_LP_CAN_RX0 = 20,   /**< USB low priority or CAN RX0 */
 119:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_CAN_RX1        = 21,   /**< CAN RX1 */
 120:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_CAN_SCE        = 22,   /**< CAN SCE */
 121:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI_9_5       = 23,   /**< EXTI line [9:5] */
 122:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER1_BRK     = 24,   /**< Timer 1 break */
 123:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER1_UP      = 25,   /**< Timer 1 update */
 124:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER1_TRG_COM = 26,   /**< Timer 1 trigger and commutation */
 125:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER1_CC      = 27,   /**< Timer 1 capture/compare */
 126:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER2         = 28,   /**< Timer 2 */
 127:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER3         = 29,   /**< Timer 3 */
 128:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER4         = 30,   /**< Timer 4 */
 129:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_I2C1_EV        = 31,   /**< I2C1 event */
 130:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_I2C1_ER        = 32,   /**< I2C1 error */
 131:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_I2C2_EV        = 33,   /**< I2C2 event */
 132:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_I2C2_ER        = 34,   /**< I2C2 error */
 133:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SPI1           = 35,   /**< SPI1 */
 134:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SPI2           = 36,   /**< SPI2 */
 135:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USART1         = 37,   /**< USART1 */
 136:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USART2         = 38,   /**< USART2 */
 137:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USART3         = 39,   /**< USART3 */
 138:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI_15_10     = 40,   /**< EXTI line [15:10] */
 139:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_RTCALARM       = 41,   /**< RTC alarm through EXTI line */
 140:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USBWAKEUP      = 42,   /**< USB wakeup from suspend through
 141:../Libmaple/libmaple/libmaple/nvic.h ****                                      EXTI line */
 142:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER8_BRK     = 43,   /**< Timer 8 break */
 143:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER8_UP      = 44,   /**< Timer 8 update */
 144:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER8_TRG_COM = 45,   /**< Timer 8 trigger and commutation */
 145:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER8_CC      = 46,   /**< Timer 8 capture/compare */
 146:../Libmaple/libmaple/libmaple/nvic.h **** #ifdef STM32_HIGH_DENSITY
 147:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_ADC3           = 47,   /**< ADC3 */
 148:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_FSMC           = 48,   /**< FSMC */
 149:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SDIO           = 49,   /**< SDIO */
 150:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER5         = 50,   /**< Timer 5 */
 151:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SPI3           = 51,   /**< SPI3 */
 152:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_UART4          = 52,   /**< UART4 */
 153:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_UART5          = 53,   /**< UART5 */
 154:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER6         = 54,   /**< Timer 6 */
 155:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER7         = 55,   /**< Timer 7 */
 156:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA2_CH1       = 56,   /**< DMA2 channel 1 */
 157:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA2_CH2       = 57,   /**< DMA2 channel 2 */
 158:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA2_CH3       = 58,   /**< DMA2 channel 3 */
 159:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA2_CH_4_5    = 59,   /**< DMA2 channels 4 and 5 */
 160:../Libmaple/libmaple/libmaple/nvic.h **** #endif
 161:../Libmaple/libmaple/libmaple/nvic.h **** } nvic_irq_num;
 162:../Libmaple/libmaple/libmaple/nvic.h **** 
 163:../Libmaple/libmaple/libmaple/nvic.h **** /*
 164:../Libmaple/libmaple/libmaple/nvic.h ****  * Initialises the interrupt controller and sets all interrupts to the
 165:../Libmaple/libmaple/libmaple/nvic.h ****  * lowest priority.
 166:../Libmaple/libmaple/libmaple/nvic.h ****  *
 167:../Libmaple/libmaple/libmaple/nvic.h ****  * For stand-alone products, the base address is normally the start of
 168:../Libmaple/libmaple/libmaple/nvic.h ****  * flash (0x08000000).
 169:../Libmaple/libmaple/libmaple/nvic.h ****  *
 170:../Libmaple/libmaple/libmaple/nvic.h ****  * @param vector_table_address  base address of the vector table
 171:../Libmaple/libmaple/libmaple/nvic.h ****  */
 172:../Libmaple/libmaple/libmaple/nvic.h **** void nvic_init(uint32 vector_table_address, uint32 offset);
 173:../Libmaple/libmaple/libmaple/nvic.h **** 
 174:../Libmaple/libmaple/libmaple/nvic.h **** /**
 175:../Libmaple/libmaple/libmaple/nvic.h ****  * Sets the base address of the vector table.
 176:../Libmaple/libmaple/libmaple/nvic.h ****  */
 177:../Libmaple/libmaple/libmaple/nvic.h **** void nvic_set_vector_table(uint32 address, uint32 offset);
 178:../Libmaple/libmaple/libmaple/nvic.h **** 
 179:../Libmaple/libmaple/libmaple/nvic.h **** void nvic_irq_set_priority(nvic_irq_num irqn, uint8 priority);
 180:../Libmaple/libmaple/libmaple/nvic.h **** 
 181:../Libmaple/libmaple/libmaple/nvic.h **** /**
 182:../Libmaple/libmaple/libmaple/nvic.h ****  * Enables interrupts and configurable fault handlers (clear PRIMASK).
 183:../Libmaple/libmaple/libmaple/nvic.h ****  */
 184:../Libmaple/libmaple/libmaple/nvic.h **** static inline void nvic_globalirq_enable() {
 185:../Libmaple/libmaple/libmaple/nvic.h ****     asm volatile("cpsie i");
 186:../Libmaple/libmaple/libmaple/nvic.h **** }
 187:../Libmaple/libmaple/libmaple/nvic.h **** 
 188:../Libmaple/libmaple/libmaple/nvic.h **** /**
 189:../Libmaple/libmaple/libmaple/nvic.h ****  * Disable interrupts and configurable fault handlers (set PRIMASK).
 190:../Libmaple/libmaple/libmaple/nvic.h ****  */
 191:../Libmaple/libmaple/libmaple/nvic.h **** static inline void nvic_globalirq_disable() {
 192:../Libmaple/libmaple/libmaple/nvic.h ****     asm volatile("cpsid i");
 8495              		.loc 32 192 0
 8496              	@ 192 "../Libmaple/libmaple/libmaple/nvic.h" 1
 8497 0002 72B6     		cpsid i
 8498              	@ 0 "" 2
 8499              		.thumb
 8500              	.LBE215:
 8501              	.LBE214:
 384:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   cli(); // Needed so that APM sensor data does not overflow
 385:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(XAXIS, ROLL_PID_GAIN_ADR);
 8502              		.loc 31 385 0
 8503 0004 0020     		movs	r0, #0
 8504 0006 0146     		mov	r1, r0
 8505 0008 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 386:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(YAXIS, PITCH_PID_GAIN_ADR);
 8506              		.loc 31 386 0
 8507 000c 0120     		movs	r0, #1
 8508 000e 2421     		movs	r1, #36
 8509 0010 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 387:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(ATTITUDE_XAXIS_PID_IDX, LEVELROLL_PID_GAIN_ADR);
 8510              		.loc 31 387 0
 8511 0014 0320     		movs	r0, #3
 8512 0016 0C21     		movs	r1, #12
 8513 0018 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 388:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(ATTITUDE_YAXIS_PID_IDX, LEVELPITCH_PID_GAIN_ADR);
 8514              		.loc 31 388 0
 8515 001c 0420     		movs	r0, #4
 8516 001e 3021     		movs	r1, #48
 8517 0020 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 389:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(ZAXIS, YAW_PID_GAIN_ADR);
 8518              		.loc 31 389 0
 8519 0024 0220     		movs	r0, #2
 8520 0026 1821     		movs	r1, #24
 8521 0028 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 390:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(HEADING_HOLD_PID_IDX, HEADING_PID_GAIN_ADR);
 8522              		.loc 31 390 0
 8523 002c 0520     		movs	r0, #5
 8524 002e 3C21     		movs	r1, #60
 8525 0030 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 391:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(ATTITUDE_GYRO_XAXIS_PID_IDX, LEVEL_GYRO_ROLL_PID_GAIN_ADR);
 392:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(ATTITUDE_GYRO_YAXIS_PID_IDX, LEVEL_GYRO_PITCH_PID_GAIN_ADR);
 393:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 394:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(rotationSpeedFactor,ROTATION_SPEED_FACTOR_ARD);
 8526              		.loc 31 394 0
 8527 0034 7A4E     		ldr	r6, .L513
 395:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 396:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined AltitudeHoldBaro
 397:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writePID(BARO_ALTITUDE_HOLD_PID_IDX, ALTITUDE_PID_GAIN_ADR);
 398:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard, ALTITUDE_WINDUP_ADR);
 399:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 400:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 401:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 402:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #if defined AltitudeHoldBaro
 403:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       writeFloat(baroSmoothFactor, ALTITUDE_SMOOTH_ADR);
 404:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #else
 405:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       writeFloat(0.0, ALTITUDE_SMOOTH_ADR);
 406:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     #endif
 407:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(altitudeHoldBump, ALTITUDE_BUMP_ADR);
 8528              		.loc 31 407 0
 8529 0036 7B4D     		ldr	r5, .L513+4
 408:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(altitudeHoldPanicStickMovement, ALTITUDE_PANIC_ADR);
 409:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(minThrottleAdjust, ALTITUDE_MIN_THROTTLE_ADR);
 8530              		.loc 31 409 0
 8531 0038 7B4F     		ldr	r7, .L513+8
 391:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(ATTITUDE_GYRO_XAXIS_PID_IDX, LEVEL_GYRO_ROLL_PID_GAIN_ADR);
 8532              		.loc 31 391 0
 8533 003a 0620     		movs	r0, #6
 8534 003c 4821     		movs	r1, #72
 8535 003e FFF7FEFF 		bl	_Z11nvrWritePIDhj
 392:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(ATTITUDE_GYRO_YAXIS_PID_IDX, LEVEL_GYRO_PITCH_PID_GAIN_ADR);
 8536              		.loc 31 392 0
 8537 0042 0720     		movs	r0, #7
 8538 0044 5421     		movs	r1, #84
 8539 0046 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 394:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(rotationSpeedFactor,ROTATION_SPEED_FACTOR_ARD);
 8540              		.loc 31 394 0
 8541 004a 3068     		ldr	r0, [r6, #0]	@ float
 8542 004c 4FF4A071 		mov	r1, #320
 8543 0050 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 397:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writePID(BARO_ALTITUDE_HOLD_PID_IDX, ALTITUDE_PID_GAIN_ADR);
 8544              		.loc 31 397 0
 8545 0054 0820     		movs	r0, #8
 8546 0056 6021     		movs	r1, #96
 8547 0058 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 398:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard, ALTITUDE_WINDUP_ADR);
 8548              		.loc 31 398 0
 8549 005c 734A     		ldr	r2, .L513+12
 8550 005e 4FF49471 		mov	r1, #296
 8551 0062 D2F8F800 		ldr	r0, [r2, #248]	@ float
 8552 0066 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 403:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       writeFloat(baroSmoothFactor, ALTITUDE_SMOOTH_ADR);
 8553              		.loc 31 403 0
 8554 006a 7149     		ldr	r1, .L513+16
 8555 006c 0868     		ldr	r0, [r1, #0]	@ float
 8556 006e 4FF49271 		mov	r1, #292
 8557 0072 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 407:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(altitudeHoldBump, ALTITUDE_BUMP_ADR);
 8558              		.loc 31 407 0
 8559 0076 2C68     		ldr	r4, [r5, #0]
 410:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(maxThrottleAdjust, ALTITUDE_MAX_THROTTLE_ADR);
 411:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writePID(ZDAMPENING_PID_IDX, ZDAMP_PID_GAIN_ADR);
 412:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #else
 413:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(0.1, ALTITUDE_SMOOTH_ADR);
 414:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(90, ALTITUDE_BUMP_ADR);
 415:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(250, ALTITUDE_PANIC_ADR);
 416:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(-50, ALTITUDE_MIN_THROTTLE_ADR);
 417:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(50, ALTITUDE_MAX_THROTTLE_ADR);
 418:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(0.1, ALTITUDE_SMOOTH_ADR);
 419:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 420:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 421:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef HeadingMagHold
 422:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magBias[XAXIS], XAXIS_MAG_BIAS_ADR);
 8560              		.loc 31 422 0
 8561 0078 6E4D     		ldr	r5, .L513+20
 407:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(altitudeHoldBump, ALTITUDE_BUMP_ADR);
 8562              		.loc 31 407 0
 8563 007a 03EE104A 		fmsr	s6, r4	@ int
 8564 007e F8EEC32A 		fsitos	s5, s6
 8565 0082 4FF49671 		mov	r1, #300
 8566 0086 12EE900A 		fmrs	r0, s5
 8567 008a FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 408:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(altitudeHoldPanicStickMovement, ALTITUDE_PANIC_ADR);
 8568              		.loc 31 408 0
 8569 008e 6A48     		ldr	r0, .L513+24
 423:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magScale[XAXIS], XAXIS_MAG_SCALE_FACTOR_ADR);
 8570              		.loc 31 423 0
 8571 0090 6A4C     		ldr	r4, .L513+28
 408:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(altitudeHoldPanicStickMovement, ALTITUDE_PANIC_ADR);
 8572              		.loc 31 408 0
 8573 0092 0368     		ldr	r3, [r0, #0]
 8574 0094 02EE103A 		fmsr	s4, r3	@ int
 8575 0098 F8EEC21A 		fsitos	s3, s4
 8576 009c 4FF49871 		mov	r1, #304
 8577 00a0 11EE900A 		fmrs	r0, s3
 8578 00a4 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 409:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(minThrottleAdjust, ALTITUDE_MIN_THROTTLE_ADR);
 8579              		.loc 31 409 0
 8580 00a8 3E68     		ldr	r6, [r7, #0]
 424:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magBias[YAXIS], YAXIS_MAG_BIAS_ADR);
 425:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magScale[YAXIS], YAXIS_MAG_SCALE_FACTOR_ADR);
 426:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magBias[ZAXIS], ZAXIS_MAG_BIAS_ADR);
 427:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magScale[ZAXIS], ZAXIS_MAG_SCALE_FACTOR_ADR);
 428:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 429:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(windupGuard, WINDUPGUARD_ADR);
 430:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(receiverXmitFactor, XMITFACTOR_ADR);
 8581              		.loc 31 430 0
 8582 00aa 654F     		ldr	r7, .L513+32
 409:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(minThrottleAdjust, ALTITUDE_MIN_THROTTLE_ADR);
 8583              		.loc 31 409 0
 8584 00ac 01EE106A 		fmsr	s2, r6	@ int
 8585 00b0 F8EEC10A 		fsitos	s1, s2
 8586 00b4 4FF49071 		mov	r1, #288
 8587 00b8 10EE900A 		fmrs	r0, s1
 8588 00bc FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 410:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(maxThrottleAdjust, ALTITUDE_MAX_THROTTLE_ADR);
 8589              		.loc 31 410 0
 8590 00c0 604A     		ldr	r2, .L513+36
 8591              		.loc 31 430 0
 8592 00c2 614E     		ldr	r6, .L513+40
 410:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(maxThrottleAdjust, ALTITUDE_MAX_THROTTLE_ADR);
 8593              		.loc 31 410 0
 8594 00c4 1168     		ldr	r1, [r2, #0]
 8595 00c6 00EE101A 		fmsr	s0, r1	@ int
 8596 00ca F8EEC07A 		fsitos	s15, s0
 8597 00ce 4FF48E71 		mov	r1, #284
 8598 00d2 17EE900A 		fmrs	r0, s15
 8599 00d6 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 411:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writePID(ZDAMPENING_PID_IDX, ZDAMP_PID_GAIN_ADR);
 8600              		.loc 31 411 0
 8601 00da 0920     		movs	r0, #9
 8602 00dc 6C21     		movs	r1, #108
 8603 00de FFF7FEFF 		bl	_Z11nvrWritePIDhj
 422:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magBias[XAXIS], XAXIS_MAG_BIAS_ADR);
 8604              		.loc 31 422 0
 8605 00e2 2868     		ldr	r0, [r5, #0]	@ float
 8606 00e4 4FF4AE71 		mov	r1, #348
 8607 00e8 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 423:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magScale[XAXIS], XAXIS_MAG_SCALE_FACTOR_ADR);
 8608              		.loc 31 423 0
 8609 00ec 2068     		ldr	r0, [r4, #0]	@ float
 8610 00ee 4FF4B071 		mov	r1, #352
 8611 00f2 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 424:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magBias[YAXIS], YAXIS_MAG_BIAS_ADR);
 8612              		.loc 31 424 0
 8613 00f6 6868     		ldr	r0, [r5, #4]	@ float
 8614 00f8 4FF4B271 		mov	r1, #356
 8615 00fc FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 425:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magScale[YAXIS], YAXIS_MAG_SCALE_FACTOR_ADR);
 8616              		.loc 31 425 0
 8617 0100 6068     		ldr	r0, [r4, #4]	@ float
 8618 0102 4FF4B471 		mov	r1, #360
 8619 0106 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 426:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magBias[ZAXIS], ZAXIS_MAG_BIAS_ADR);
 8620              		.loc 31 426 0
 8621 010a A868     		ldr	r0, [r5, #8]	@ float
 8622              		.loc 31 430 0
 8623 010c 4F4D     		ldr	r5, .L513+44
 426:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magBias[ZAXIS], ZAXIS_MAG_BIAS_ADR);
 8624              		.loc 31 426 0
 8625 010e 4FF4B671 		mov	r1, #364
 8626 0112 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 427:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magScale[ZAXIS], ZAXIS_MAG_SCALE_FACTOR_ADR);
 8627              		.loc 31 427 0
 8628 0116 A068     		ldr	r0, [r4, #8]	@ float
 8629 0118 4FF4B871 		mov	r1, #368
 8630 011c FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 429:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(windupGuard, WINDUPGUARD_ADR);
 8631              		.loc 31 429 0
 8632 0120 4B48     		ldr	r0, .L513+48
 8633 0122 4FF48071 		mov	r1, #256
 8634 0126 0068     		ldr	r0, [r0, #0]	@ float
 8635 0128 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 8636              		.loc 31 430 0
 8637 012c 494B     		ldr	r3, .L513+52
 8638 012e 4FF48271 		mov	r1, #260
 8639 0132 1868     		ldr	r0, [r3, #0]	@ float
 8640 0134 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 8641              	.LVL395:
 8642 0138 0024     		movs	r4, #0
 8643              	.LVL396:
 8644              	.L511:
 8645              	.LBB216:
 431:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 432:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for(byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 433:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(receiverSlope[channel],  RECEIVER_DATA[channel].slope);
 8646              		.loc 31 433 0 discriminator 2
 8647 013a 04F19C01 		add	r1, r4, #156
 8648 013e 57F8040F 		ldr	r0, [r7, #4]!	@ float
 8649 0142 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 434:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(receiverOffset[channel], RECEIVER_DATA[channel].offset);
 8650              		.loc 31 434 0 discriminator 2
 8651 0146 04F1A001 		add	r1, r4, #160
 8652 014a 56F8040F 		ldr	r0, [r6, #4]!	@ float
 8653 014e FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 435:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(receiverSmoothFactor[channel], RECEIVER_DATA[channel].smooth_factor);
 8654              		.loc 31 435 0 discriminator 2
 8655 0152 04F1A401 		add	r1, r4, #164
 8656 0156 55F8040F 		ldr	r0, [r5, #4]!	@ float
 8657 015a 0C34     		adds	r4, r4, #12
 8658 015c FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 432:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for(byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 8659              		.loc 31 432 0 discriminator 2
 8660 0160 602C     		cmp	r4, #96
 8661 0162 EAD1     		bne	.L511
 8662              	.LBE216:
 436:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
 437:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 438:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(minArmedThrottle, MINARMEDTHROTTLE_ADR);
 8663              		.loc 31 438 0
 8664 0164 3C4B     		ldr	r3, .L513+56
 8665 0166 1A68     		ldr	r2, [r3, #0]
 8666 0168 00EE102A 		fmsr	s0, r2	@ int
 8667 016c F8EEC07A 		fsitos	s15, s0
 8668 0170 4FF48471 		mov	r1, #264
 8669 0174 17EE900A 		fmrs	r0, s15
 8670 0178 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 439:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(aref, AREF_ADR);
 8671              		.loc 31 439 0
 8672 017c 3749     		ldr	r1, .L513+60
 8673 017e 0868     		ldr	r0, [r1, #0]	@ float
 8674 0180 4FF48671 		mov	r1, #268
 8675 0184 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 440:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(flightMode, FLIGHTMODE_ADR);
 8676              		.loc 31 440 0
 8677 0188 3548     		ldr	r0, .L513+64
 8678 018a 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 8679 018c 07EE103A 		fmsr	s14, r3	@ int
 8680 0190 F8EE476A 		fuitos	s13, s14
 8681 0194 4FF48871 		mov	r1, #272
 8682 0198 16EE900A 		fmrs	r0, s13
 8683 019c FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 441:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(headingHoldConfig, HEADINGHOLD_ADR);
 8684              		.loc 31 441 0
 8685 01a0 304A     		ldr	r2, .L513+68
 8686 01a2 1178     		ldrb	r1, [r2, #0]	@ zero_extendqisi2
 8687 01a4 06EE101A 		fmsr	s12, r1	@ int
 8688 01a8 F8EE465A 		fuitos	s11, s12
 8689 01ac 4FF48A71 		mov	r1, #276
 8690 01b0 15EE900A 		fmrs	r0, s11
 8691 01b4 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 442:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(accelOneG, ACCEL_1G_ADR);
 8692              		.loc 31 442 0
 8693 01b8 2B48     		ldr	r0, .L513+72
 8694 01ba 4FF48C71 		mov	r1, #280
 8695 01be 0068     		ldr	r0, [r0, #0]	@ float
 8696 01c0 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 443:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(SOFTWARE_VERSION, SOFTWARE_VERSION_ADR);
 8697              		.loc 31 443 0
 8698 01c4 FC21     		movs	r1, #252
 8699 01c6 2948     		ldr	r0, .L513+76
 8700 01c8 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 444:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 445:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Battery Monitor
 446:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef BattMonitor
 447:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(batteryMonitorAlarmVoltage, BATT_ALARM_VOLTAGE_ADR);
 8701              		.loc 31 447 0
 8702 01cc 284B     		ldr	r3, .L513+80
 8703 01ce 4FF4BA71 		mov	r1, #372
 8704 01d2 1868     		ldr	r0, [r3, #0]	@ float
 8705 01d4 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 448:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(batteryMonitorThrottleTarget, BATT_THROTTLE_TARGET_ADR);
 8706              		.loc 31 448 0
 8707 01d8 264A     		ldr	r2, .L513+84
 8708 01da 1168     		ldr	r1, [r2, #0]
 8709 01dc 05EE101A 		fmsr	s10, r1	@ int
 8710 01e0 F8EEC54A 		fsitos	s9, s10
 8711 01e4 4FF4BC71 		mov	r1, #376
 8712 01e8 14EE900A 		fmrs	r0, s9
 8713 01ec FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 449:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(batteryMonitorGoingDownTime, BATT_DOWN_TIME_ADR);
 8714              		.loc 31 449 0
 8715 01f0 2148     		ldr	r0, .L513+88
 8716 01f2 0368     		ldr	r3, [r0, #0]
 8717 01f4 04EE103A 		fmsr	s8, r3	@ int
 8718 01f8 F8EE443A 		fuitos	s7, s8
 8719 01fc 4FF4BE71 		mov	r1, #380
 8720 0200 13EE900A 		fmrs	r0, s7
 8721 0204 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 450:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 451:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 452:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Range Finder
 453:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined (AltitudeHoldRangeFinder)
 454:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(maxRangeFinderRange, RANGE_FINDER_MAX_ADR);
 455:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(minRangeFinderRange, RANGE_FINDER_MIN_ADR);
 456:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #else
 457:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(0, RANGE_FINDER_MAX_ADR);
 8722              		.loc 31 457 0
 8723 0208 0020     		movs	r0, #0
 8724 020a 4FF4C071 		mov	r1, #384
 8725 020e FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 458:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(0, RANGE_FINDER_MIN_ADR);
 8726              		.loc 31 458 0
 8727 0212 0020     		movs	r0, #0
 8728 0214 4FF4C271 		mov	r1, #388
 8729 0218 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 8730              	.LBB217:
 8731              	.LBB218:
 185:../Libmaple/libmaple/libmaple/nvic.h ****     asm volatile("cpsie i");
 8732              		.loc 32 185 0
 8733              	@ 185 "../Libmaple/libmaple/libmaple/nvic.h" 1
 8734 021c 62B6     		cpsie i
 8735              	@ 0 "" 2
 8736              		.thumb
 8737              	.LBE218:
 8738              	.LBE217:
 8739              	.LBE213:
 459:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 460:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 461:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined (UseGPSNavigator)
 462:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(missionNbPoint, GPS_MISSION_NB_POINT_ADR);
 463:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writePID(GPSROLL_PID_IDX, GPSROLL_PID_GAIN_ADR);
 464:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writePID(GPSPITCH_PID_IDX, GPSPITCH_PID_GAIN_ADR);
 465:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writePID(GPSYAW_PID_IDX, GPSYAW_PID_GAIN_ADR);
 466:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     
 467:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     for (byte location = 0; location < MAX_WAYPOINTS; location++) {
 468:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       writeLong(waypoint[location].longitude, WAYPOINT_ADR[location].longitude);
 469:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       writeLong(waypoint[location].latitude, WAYPOINT_ADR[location].latitude);
 470:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****       writeLong(waypoint[location].altitude, WAYPOINT_ADR[location].altitude);
 471:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     }       
 472:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 473:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 474:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     // Camera Control
 475:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef CameraControl
 476:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(cameraMode, CAMERAMODE_ADR);
 477:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(mCameraPitch, MCAMERAPITCH_ADR);
 478:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(mCameraRoll, MCAMERAROLL_ADR);    
 479:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(mCameraYaw, MCAMERAYAW_ADR);
 480:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoCenterPitch, SERVOCENTERPITCH_ADR);
 481:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoCenterRoll, SERVOCENTERROLL_ADR);
 482:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoCenterYaw, SERVOCENTERYAW_ADR);
 483:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoMinPitch, SERVOMINPITCH_ADR);
 484:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoMinRoll, SERVOMINROLL_ADR);
 485:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoMinYaw, SERVOMINYAW_ADR);
 486:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoMaxPitch, SERVOMAXPITCH_ADR);
 487:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoMaxRoll, SERVOMAXROLL_ADR);
 488:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoMaxYaw, SERVOMAXYAW_ADR);
 489:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif 
 490:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   sei(); // Restart interrupts
 491:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** }
 8740              		.loc 31 491 0
 8741 021e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 8742              	.L514:
 8743              		.align	2
 8744              	.L513:
 8745 0220 00000000 		.word	.LANCHOR115
 8746 0224 00000000 		.word	.LANCHOR8
 8747 0228 00000000 		.word	.LANCHOR111
 8748 022c 00000000 		.word	.LANCHOR17
 8749 0230 00000000 		.word	.LANCHOR97
 8750 0234 00000000 		.word	.LANCHOR76
 8751 0238 00000000 		.word	.LANCHOR113
 8752 023c 00000000 		.word	.LANCHOR75
 8753 0240 FCFFFFFF 		.word	.LANCHOR12-4
 8754 0244 00000000 		.word	.LANCHOR112
 8755 0248 FCFFFFFF 		.word	.LANCHOR13-4
 8756 024c FCFFFFFF 		.word	.LANCHOR14-4
 8757 0250 00000000 		.word	.LANCHOR131
 8758 0254 00000000 		.word	.LANCHOR61
 8759 0258 00000000 		.word	.LANCHOR120
 8760 025c 00000000 		.word	.LANCHOR132
 8761 0260 00000000 		.word	.LANCHOR114
 8762 0264 00000000 		.word	.LANCHOR123
 8763 0268 00000000 		.word	.LANCHOR39
 8764 026c 66664640 		.word	1078355558
 8765 0270 00000000 		.word	.LANCHOR133
 8766 0274 00000000 		.word	.LANCHOR134
 8767 0278 00000000 		.word	.LANCHOR135
 8768              		.cfi_endproc
 8769              	.LFE230:
 8771              		.section	.text._Z25initSensorsZeroFromEEPROMv,"ax",%progbits
 8772              		.align	1
 8773              		.global	_Z25initSensorsZeroFromEEPROMv
 8774              		.thumb
 8775              		.thumb_func
 8777              	_Z25initSensorsZeroFromEEPROMv:
 8778              	.LFB231:
 492:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 493:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void initSensorsZeroFromEEPROM() {
 8779              		.loc 31 493 0
 8780              		.cfi_startproc
 8781              		@ args = 0, pretend = 0, frame = 0
 8782              		@ frame_needed = 0, uses_anonymous_args = 0
 8783 0000 38B5     		push	{r3, r4, r5, lr}
 8784              	.LCFI88:
 8785              		.cfi_def_cfa_offset 16
 8786              		.cfi_offset 14, -4
 8787              		.cfi_offset 5, -8
 8788              		.cfi_offset 4, -12
 8789              		.cfi_offset 3, -16
 494:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Gyro initialization from EEPROM
 495:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[XAXIS] = readFloat(GYRO_ROLL_ZERO_ADR);
 8790              		.loc 31 495 0
 8791 0002 4FF49A70 		mov	r0, #308
 8792 0006 FFF7FEFF 		bl	_Z12nvrReadFloati
 8793 000a 02EE100A 		fmsr	s4, r0
 8794 000e 204C     		ldr	r4, .L516
 496:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[YAXIS] = readFloat(GYRO_PITCH_ZERO_ADR);
 497:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[ZAXIS] = readFloat(GYRO_YAW_ZERO_ADR);
 498:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 499:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Accel initialization from EEPROM
 500:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelOneG = readFloat(ACCEL_1G_ADR);
 501:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Accel calibration
 502:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[XAXIS] = readFloat(XAXIS_ACCEL_SCALE_FACTOR_ADR);
 8795              		.loc 31 502 0
 8796 0010 204D     		ldr	r5, .L516+4
 495:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[XAXIS] = readFloat(GYRO_ROLL_ZERO_ADR);
 8797              		.loc 31 495 0
 8798 0012 FDEEC21A 		ftosizs	s3, s4
 496:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[YAXIS] = readFloat(GYRO_PITCH_ZERO_ADR);
 8799              		.loc 31 496 0
 8800 0016 4FF49C70 		mov	r0, #312
 495:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[XAXIS] = readFloat(GYRO_ROLL_ZERO_ADR);
 8801              		.loc 31 495 0
 8802 001a C4ED001A 		fsts	s3, [r4, #0]	@ int
 496:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[YAXIS] = readFloat(GYRO_PITCH_ZERO_ADR);
 8803              		.loc 31 496 0
 8804 001e FFF7FEFF 		bl	_Z12nvrReadFloati
 8805 0022 01EE100A 		fmsr	s2, r0
 8806 0026 FDEEC10A 		ftosizs	s1, s2
 497:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[ZAXIS] = readFloat(GYRO_YAW_ZERO_ADR);
 8807              		.loc 31 497 0
 8808 002a 4FF49E70 		mov	r0, #316
 496:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[YAXIS] = readFloat(GYRO_PITCH_ZERO_ADR);
 8809              		.loc 31 496 0
 8810 002e C4ED010A 		fsts	s1, [r4, #4]	@ int
 497:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[ZAXIS] = readFloat(GYRO_YAW_ZERO_ADR);
 8811              		.loc 31 497 0
 8812 0032 FFF7FEFF 		bl	_Z12nvrReadFloati
 8813 0036 00EE100A 		fmsr	s0, r0
 8814 003a FDEEC07A 		ftosizs	s15, s0
 500:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelOneG = readFloat(ACCEL_1G_ADR);
 8815              		.loc 31 500 0
 8816 003e 4FF48C70 		mov	r0, #280
 497:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   gyroZero[ZAXIS] = readFloat(GYRO_YAW_ZERO_ADR);
 8817              		.loc 31 497 0
 8818 0042 C4ED027A 		fsts	s15, [r4, #8]	@ int
 500:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelOneG = readFloat(ACCEL_1G_ADR);
 8819              		.loc 31 500 0
 8820 0046 FFF7FEFF 		bl	_Z12nvrReadFloati
 8821 004a 134B     		ldr	r3, .L516+8
 503:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[XAXIS] = readFloat(XAXIS_ACCEL_BIAS_ADR);
 8822              		.loc 31 503 0
 8823 004c 134C     		ldr	r4, .L516+12
 500:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelOneG = readFloat(ACCEL_1G_ADR);
 8824              		.loc 31 500 0
 8825 004e 1860     		str	r0, [r3, #0]	@ float
 502:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[XAXIS] = readFloat(XAXIS_ACCEL_SCALE_FACTOR_ADR);
 8826              		.loc 31 502 0
 8827 0050 4FF4A470 		mov	r0, #328
 8828 0054 FFF7FEFF 		bl	_Z12nvrReadFloati
 8829 0058 2860     		str	r0, [r5, #0]	@ float
 8830              		.loc 31 503 0
 8831 005a 4FF4A270 		mov	r0, #324
 8832 005e FFF7FEFF 		bl	_Z12nvrReadFloati
 8833 0062 2060     		str	r0, [r4, #0]	@ float
 504:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[YAXIS] = readFloat(YAXIS_ACCEL_SCALE_FACTOR_ADR);
 8834              		.loc 31 504 0
 8835 0064 4FF4A870 		mov	r0, #336
 8836 0068 FFF7FEFF 		bl	_Z12nvrReadFloati
 8837 006c 6860     		str	r0, [r5, #4]	@ float
 505:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[YAXIS] = readFloat(YAXIS_ACCEL_BIAS_ADR);
 8838              		.loc 31 505 0
 8839 006e 4FF4A670 		mov	r0, #332
 8840 0072 FFF7FEFF 		bl	_Z12nvrReadFloati
 8841 0076 6060     		str	r0, [r4, #4]	@ float
 506:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[ZAXIS] = readFloat(ZAXIS_ACCEL_SCALE_FACTOR_ADR);
 8842              		.loc 31 506 0
 8843 0078 4FF4AC70 		mov	r0, #344
 8844 007c FFF7FEFF 		bl	_Z12nvrReadFloati
 8845 0080 A860     		str	r0, [r5, #8]	@ float
 507:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[ZAXIS] = readFloat(ZAXIS_ACCEL_BIAS_ADR);
 8846              		.loc 31 507 0
 8847 0082 4FF4AA70 		mov	r0, #340
 8848 0086 FFF7FEFF 		bl	_Z12nvrReadFloati
 8849 008a A060     		str	r0, [r4, #8]	@ float
 508:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** }
 8850              		.loc 31 508 0
 8851 008c 38BD     		pop	{r3, r4, r5, pc}
 8852              	.L517:
 8853 008e 00BF     		.align	2
 8854              	.L516:
 8855 0090 00000000 		.word	.LANCHOR31
 8856 0094 00000000 		.word	.LANCHOR35
 8857 0098 00000000 		.word	.LANCHOR39
 8858 009c 00000000 		.word	.LANCHOR36
 8859              		.cfi_endproc
 8860              	.LFE231:
 8862              		.section	.text._Z24storeSensorsZeroToEEPROMv,"ax",%progbits
 8863              		.align	1
 8864              		.global	_Z24storeSensorsZeroToEEPROMv
 8865              		.thumb
 8866              		.thumb_func
 8868              	_Z24storeSensorsZeroToEEPROMv:
 8869              	.LFB232:
 509:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 510:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void storeSensorsZeroToEEPROM() {
 8870              		.loc 31 510 0
 8871              		.cfi_startproc
 8872              		@ args = 0, pretend = 0, frame = 0
 8873              		@ frame_needed = 0, uses_anonymous_args = 0
 8874 0000 38B5     		push	{r3, r4, r5, lr}
 8875              	.LCFI89:
 8876              		.cfi_def_cfa_offset 16
 8877              		.cfi_offset 14, -4
 8878              		.cfi_offset 5, -8
 8879              		.cfi_offset 4, -12
 8880              		.cfi_offset 3, -16
 511:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Store gyro data to EEPROM
 512:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(gyroZero[XAXIS], GYRO_ROLL_ZERO_ADR);
 8881              		.loc 31 512 0
 8882 0002 244C     		ldr	r4, .L519
 513:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(gyroZero[YAXIS], GYRO_PITCH_ZERO_ADR);
 514:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(gyroZero[ZAXIS], GYRO_YAW_ZERO_ADR);
 515:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 516:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Store accel data to EEPROM
 517:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(accelOneG, ACCEL_1G_ADR);
 518:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   // Accel Cal
 519:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(accelScaleFactor[XAXIS], XAXIS_ACCEL_SCALE_FACTOR_ADR);
 8883              		.loc 31 519 0
 8884 0004 244D     		ldr	r5, .L519+4
 512:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(gyroZero[XAXIS], GYRO_ROLL_ZERO_ADR);
 8885              		.loc 31 512 0
 8886 0006 94ED002A 		flds	s4, [r4, #0]	@ int
 8887 000a F8EEC21A 		fsitos	s3, s4
 8888 000e 4FF49A71 		mov	r1, #308
 8889 0012 11EE900A 		fmrs	r0, s3
 8890 0016 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 513:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(gyroZero[YAXIS], GYRO_PITCH_ZERO_ADR);
 8891              		.loc 31 513 0
 8892 001a 94ED011A 		flds	s2, [r4, #4]	@ int
 8893 001e F8EEC10A 		fsitos	s1, s2
 8894 0022 4FF49C71 		mov	r1, #312
 8895 0026 10EE900A 		fmrs	r0, s1
 8896 002a FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 514:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(gyroZero[ZAXIS], GYRO_YAW_ZERO_ADR);
 8897              		.loc 31 514 0
 8898 002e A068     		ldr	r0, [r4, #8]
 520:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(runTimeAccelBias[XAXIS], XAXIS_ACCEL_BIAS_ADR);
 8899              		.loc 31 520 0
 8900 0030 1A4C     		ldr	r4, .L519+8
 514:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(gyroZero[ZAXIS], GYRO_YAW_ZERO_ADR);
 8901              		.loc 31 514 0
 8902 0032 00EE100A 		fmsr	s0, r0	@ int
 8903 0036 F8EEC07A 		fsitos	s15, s0
 8904 003a 4FF49E71 		mov	r1, #316
 8905 003e 17EE900A 		fmrs	r0, s15
 8906 0042 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 517:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(accelOneG, ACCEL_1G_ADR);
 8907              		.loc 31 517 0
 8908 0046 164B     		ldr	r3, .L519+12
 8909 0048 4FF48C71 		mov	r1, #280
 8910 004c 1868     		ldr	r0, [r3, #0]	@ float
 8911 004e FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 519:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(accelScaleFactor[XAXIS], XAXIS_ACCEL_SCALE_FACTOR_ADR);
 8912              		.loc 31 519 0
 8913 0052 2868     		ldr	r0, [r5, #0]	@ float
 8914 0054 4FF4A471 		mov	r1, #328
 8915 0058 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 8916              		.loc 31 520 0
 8917 005c 2068     		ldr	r0, [r4, #0]	@ float
 8918 005e 4FF4A271 		mov	r1, #324
 8919 0062 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 521:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(accelScaleFactor[YAXIS], YAXIS_ACCEL_SCALE_FACTOR_ADR);
 8920              		.loc 31 521 0
 8921 0066 6868     		ldr	r0, [r5, #4]	@ float
 8922 0068 4FF4A871 		mov	r1, #336
 8923 006c FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 522:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(runTimeAccelBias[YAXIS], YAXIS_ACCEL_BIAS_ADR);
 8924              		.loc 31 522 0
 8925 0070 6068     		ldr	r0, [r4, #4]	@ float
 8926 0072 4FF4A671 		mov	r1, #332
 8927 0076 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 523:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(accelScaleFactor[ZAXIS], ZAXIS_ACCEL_SCALE_FACTOR_ADR);
 8928              		.loc 31 523 0
 8929 007a A868     		ldr	r0, [r5, #8]	@ float
 8930 007c 4FF4AC71 		mov	r1, #344
 8931 0080 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 524:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(runTimeAccelBias[ZAXIS], ZAXIS_ACCEL_BIAS_ADR);
 8932              		.loc 31 524 0
 8933 0084 A068     		ldr	r0, [r4, #8]	@ float
 8934 0086 4FF4AA71 		mov	r1, #340
 525:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** }
 8935              		.loc 31 525 0
 8936 008a BDE83840 		pop	{r3, r4, r5, lr}
 524:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(runTimeAccelBias[ZAXIS], ZAXIS_ACCEL_BIAS_ADR);
 8937              		.loc 31 524 0
 8938 008e FFF7FEBF 		b	_Z13nvrWriteFloatfi
 8939              	.L520:
 8940 0092 00BF     		.align	2
 8941              	.L519:
 8942 0094 00000000 		.word	.LANCHOR31
 8943 0098 00000000 		.word	.LANCHOR35
 8944 009c 00000000 		.word	.LANCHOR36
 8945 00a0 00000000 		.word	.LANCHOR39
 8946              		.cfi_endproc
 8947              	.LFE232:
 8949              		.section	.text._Z17readPilotCommandsv,"ax",%progbits
 8950              		.align	1
 8951              		.global	_Z17readPilotCommandsv
 8952              		.thumb
 8953              		.thumb_func
 8955              	_Z17readPilotCommandsv:
 8956              	.LFB220:
 8957              		.file 33 "C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad/FlightCommandProcessor.h"
   1:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** /*
   2:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   AeroQuad v3.0.1 - February 2012
   3:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   www.AeroQuad.com
   4:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   An Open Source Arduino based multicopter.
   6:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  
   7:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   This program is free software: you can redistribute it and/or modify 
   8:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   it under the terms of the GNU General Public License as published by 
   9:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   (at your option) any later version. 
  11:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  12:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   This program is distributed in the hope that it will be useful, 
  13:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   GNU General Public License for more details. 
  16:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  17:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   You should have received a copy of the GNU General Public License 
  18:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** */
  20:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  21:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** // FlightCommand.pde is responsible for decoding transmitter stick combinations
  22:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** // for setting up AeroQuad modes such as motor arming and disarming
  23:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  24:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** #ifndef _AQ_FLIGHT_COMMAND_READER_
  25:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** #define _AQ_FLIGHT_COMMAND_READER_
  26:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  27:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  28:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** /**
  29:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  * readPilotCommands
  30:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  * 
  31:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  * This function is responsible to read receiver
  32:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  * and process command from the users
  33:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  */
  34:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** void readPilotCommands() {
 8958              		.loc 33 34 0
 8959              		.cfi_startproc
 8960              		@ args = 0, pretend = 0, frame = 0
 8961              		@ frame_needed = 0, uses_anonymous_args = 0
 8962 0000 70B5     		push	{r4, r5, r6, lr}
 8963              	.LCFI90:
 8964              		.cfi_def_cfa_offset 16
 8965              		.cfi_offset 14, -4
 8966              		.cfi_offset 6, -8
 8967              		.cfi_offset 5, -12
 8968              		.cfi_offset 4, -16
 8969              	.LBB219:
 8970              	.LBB220:
  35:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   
  36:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   readReceiver(); 
  37:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   if (receiverCommand[THROTTLE] < MINCHECK) {
 8971              		.loc 33 37 0
 8972 0002 494C     		ldr	r4, .L530
 8973 0004 494D     		ldr	r5, .L530+4
 8974              	.LBE220:
  36:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   readReceiver(); 
 8975              		.loc 33 36 0
 8976 0006 FFF7FEFF 		bl	_Z12readReceiverv
 8977              	.LBB227:
 8978              		.loc 33 37 0
 8979 000a E268     		ldr	r2, [r4, #12]
 8980 000c 40F24B43 		movw	r3, #1099
 8981 0010 9A42     		cmp	r2, r3
 8982 0012 4DDC     		bgt	.L522
 8983              	.LBB221:
  38:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     // Disarm motors (left stick lower left corner)
  39:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     if (receiverCommand[ZAXIS] < MINCHECK && motorArmed == ON) {
 8984              		.loc 33 39 0
 8985 0014 A068     		ldr	r0, [r4, #8]
 8986 0016 9842     		cmp	r0, r3
 8987 0018 0DDC     		bgt	.L523
 8988              		.loc 33 39 0 is_stmt 0 discriminator 1
 8989 001a 454E     		ldr	r6, .L530+8
 8990 001c 3378     		ldrb	r3, [r6, #0]	@ zero_extendqisi2
 8991 001e 012B     		cmp	r3, #1
 8992 0020 09D1     		bne	.L523
  40:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       commandAllMotors(MINCOMMAND);
 8993              		.loc 33 40 0 is_stmt 1
 8994 0022 4FF47A70 		mov	r0, #1000
 8995 0026 FFF7FEFF 		bl	_Z16commandAllMotorsi
  41:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       motorArmed = OFF;
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       inFlight = false;
  43:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  44:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 	  #if defined GraupnerHoTTTelemetry
  45:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 	    SpeakHoTT = HoTTv4NotificationMicrocopterOff;
 8996              		.loc 33 45 0
 8997 002a 424A     		ldr	r2, .L530+12
  41:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       motorArmed = OFF;
 8998              		.loc 33 41 0
 8999 002c 0020     		movs	r0, #0
 9000              		.loc 33 45 0
 9001 002e 2621     		movs	r1, #38
  41:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       motorArmed = OFF;
 9002              		.loc 33 41 0
 9003 0030 3070     		strb	r0, [r6, #0]
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       inFlight = false;
 9004              		.loc 33 42 0
 9005 0032 2870     		strb	r0, [r5, #0]
 9006              		.loc 33 45 0
 9007 0034 1170     		strb	r1, [r2, #0]
 9008              	.L523:
  46:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 	  #endif
  47:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             
  48:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       #ifdef OSD
  49:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         notifyOSD(OSD_CENTER|OSD_WARN, "MOTORS UNARMED");
  50:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       #endif
  51:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       
  52:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       #if defined BattMonitorAutoDescent
  53:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         batteryMonitorAlarmCounter = 0;
  54:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         batteryMonitorStartThrottle = 0;
  55:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         batteyMonitorThrottleCorrection = 0.0;
  56:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       #endif
  57:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     }    
  58:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     
  59:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     // Zero Gyro and Accel sensors (left stick lower left, right stick lower right corner)
  60:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     if ((receiverCommand[ZAXIS] < MINCHECK) && (receiverCommand[XAXIS] > MAXCHECK) && (receiverComm
 9009              		.loc 33 60 0
 9010 0036 A168     		ldr	r1, [r4, #8]
 9011 0038 3B4A     		ldr	r2, .L530
 9012 003a 40F24B43 		movw	r3, #1099
 9013 003e 9942     		cmp	r1, r3
 9014 0040 15DC     		bgt	.L524
 9015              		.loc 33 60 0 is_stmt 0 discriminator 1
 9016 0042 1068     		ldr	r0, [r2, #0]
 9017 0044 40F26C7C 		movw	ip, #1900
 9018 0048 6045     		cmp	r0, ip
 9019 004a 10DD     		ble	.L524
 9020              		.loc 33 60 0 discriminator 2
 9021 004c 5268     		ldr	r2, [r2, #4]
 9022 004e 9A42     		cmp	r2, r3
 9023 0050 0DDC     		bgt	.L524
  61:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 	  #if defined GraupnerHoTTTelemetry
  62:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 	    SpeakHoTT = HoTTv4NotificationCalibrating;
 9024              		.loc 33 62 0 is_stmt 1
 9025 0052 384B     		ldr	r3, .L530+12
 9026 0054 1821     		movs	r1, #24
 9027 0056 1970     		strb	r1, [r3, #0]
  63:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 	  #endif
  64:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  65:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       calibrateGyro();
 9028              		.loc 33 65 0
 9029 0058 FFF7FEFF 		bl	_Z13calibrateGyrov
  66:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       computeAccelBias();
 9030              		.loc 33 66 0
 9031 005c FFF7FEFF 		bl	_Z16computeAccelBiasv
  67:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       storeSensorsZeroToEEPROM();
 9032              		.loc 33 67 0
 9033 0060 FFF7FEFF 		bl	_Z24storeSensorsZeroToEEPROMv
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       calibrateKinematics();
  69:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       zeroIntegralError();
 9034              		.loc 33 69 0
 9035 0064 FFF7FEFF 		bl	_Z17zeroIntegralErrorv
  70:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       pulseMotors(3);
 9036              		.loc 33 70 0
 9037 0068 0320     		movs	r0, #3
 9038 006a FFF7FEFF 		bl	_Z11pulseMotorsh
 9039              	.L524:
 9040              	.LBB222:
  71:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     }   
  72:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     
  73:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     // Arm motors (left stick lower right corner)
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     if (receiverCommand[ZAXIS] > MAXCHECK && motorArmed == OFF && safetyCheck == ON) {
 9041              		.loc 33 74 0
 9042 006e A068     		ldr	r0, [r4, #8]
 9043 0070 40F26C72 		movw	r2, #1900
 9044 0074 9042     		cmp	r0, r2
 9045 0076 13DD     		ble	.L525
 9046              		.loc 33 74 0 is_stmt 0 discriminator 1
 9047 0078 2D4B     		ldr	r3, .L530+8
 9048 007a 1978     		ldrb	r1, [r3, #0]	@ zero_extendqisi2
 9049 007c 81B9     		cbnz	r1, .L525
 9050              		.loc 33 74 0 discriminator 2
 9051 007e 2E48     		ldr	r0, .L530+16
 9052 0080 0278     		ldrb	r2, [r0, #0]	@ zero_extendqisi2
 9053 0082 012A     		cmp	r2, #1
 9054 0084 0CD1     		bne	.L525
 9055              	.LVL397:
 9056              	.LBB223:
 9057              	.LBB224:
  75:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  76:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       #ifdef OSD_SYSTEM_MENU
  77:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         if (menuOwnsSticks) {
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           return;
  79:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         }
  80:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       #endif
  81:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  82:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       for (byte motor = 0; motor < LASTMOTOR; motor++) {
  83:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         motorCommand[motor] = MINTHROTTLE;
 9058              		.loc 33 83 0 is_stmt 1 discriminator 1
 9059 0086 2D49     		ldr	r1, .L530+20
 9060              	.LBE224:
  84:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       }
  85:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       motorArmed = ON;
 9061              		.loc 33 85 0 discriminator 1
 9062 0088 1A70     		strb	r2, [r3, #0]
  86:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  87:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 	  #if defined GraupnerHoTTTelemetry
  88:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 	    SpeakHoTT = HoTTv4NotificationStarting;
 9063              		.loc 33 88 0 discriminator 1
 9064 008a 2A4B     		ldr	r3, .L530+12
 9065              	.LBB225:
  83:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         motorCommand[motor] = MINTHROTTLE;
 9066              		.loc 33 83 0 discriminator 1
 9067 008c 40F24C40 		movw	r0, #1100
 9068              	.LBE225:
 9069              		.loc 33 88 0 discriminator 1
 9070 0090 3422     		movs	r2, #52
 9071              	.LBB226:
  83:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         motorCommand[motor] = MINTHROTTLE;
 9072              		.loc 33 83 0 discriminator 1
 9073 0092 0860     		str	r0, [r1, #0]
 9074              	.LVL398:
 9075 0094 4860     		str	r0, [r1, #4]
 9076              	.LVL399:
 9077 0096 8860     		str	r0, [r1, #8]
 9078              	.LVL400:
 9079 0098 C860     		str	r0, [r1, #12]
 9080              	.LVL401:
 9081              	.LBE226:
 9082              		.loc 33 88 0 discriminator 1
 9083 009a 1A70     		strb	r2, [r3, #0]
  89:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       #endif
  90:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     
  91:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       #ifdef OSD
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         notifyOSD(OSD_CENTER|OSD_WARN, "!MOTORS ARMED!");
  93:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       #endif  
  94:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  95:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       zeroIntegralError();
 9084              		.loc 33 95 0 discriminator 1
 9085 009c FFF7FEFF 		bl	_Z17zeroIntegralErrorv
 9086              	.LVL402:
 9087              	.L525:
 9088              	.LBE223:
 9089              	.LBE222:
  96:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  97:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     }
  98:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     // Prevents accidental arming of motor output if no transmitter command received
  99:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     if (receiverCommand[ZAXIS] > MINCHECK) {
 9090              		.loc 33 99 0
 9091 00a0 A268     		ldr	r2, [r4, #8]
 9092 00a2 40F24C4E 		movw	lr, #1100
 9093 00a6 7245     		cmp	r2, lr
 9094 00a8 02DD     		ble	.L522
 100:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       safetyCheck = ON; 
 9095              		.loc 33 100 0
 9096 00aa 234B     		ldr	r3, .L530+16
 9097 00ac 0120     		movs	r0, #1
 9098 00ae 1870     		strb	r0, [r3, #0]
 9099              	.L522:
 9100              	.LBE221:
 9101              	.LBE227:
 101:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     }
 102:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   }
 103:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   
 104:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   if (!inFlight) {
 9102              		.loc 33 104 0
 9103 00b0 2978     		ldrb	r1, [r5, #0]	@ zero_extendqisi2
 9104 00b2 51B9     		cbnz	r1, .L526
 105:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     if (motorArmed == ON && receiverCommand[THROTTLE] > minArmedThrottle) {
 9105              		.loc 33 105 0
 9106 00b4 1E4A     		ldr	r2, .L530+8
 9107 00b6 1378     		ldrb	r3, [r2, #0]	@ zero_extendqisi2
 9108 00b8 012B     		cmp	r3, #1
 9109 00ba 06D1     		bne	.L526
 9110              		.loc 33 105 0 is_stmt 0 discriminator 1
 9111 00bc 204A     		ldr	r2, .L530+24
 9112 00be E168     		ldr	r1, [r4, #12]
 9113 00c0 1068     		ldr	r0, [r2, #0]
 9114 00c2 8142     		cmp	r1, r0
 106:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       inFlight = true;
 9115              		.loc 33 106 0 is_stmt 1 discriminator 1
 9116 00c4 C4BF     		itt	gt
 9117 00c6 1948     		ldrgt	r0, .L530+4
 9118 00c8 0370     		strbgt	r3, [r0, #0]
 9119              	.L526:
 107:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     }
 108:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   }
 109:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   
 110:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   // Check Mode switch for Acro or Stable
 111:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   if (receiverCommand[MODE] > 1500) {
 112:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     flightMode = ATTITUDE_FLIGHT_MODE;
 9120              		.loc 33 112 0
 9121 00ca 2069     		ldr	r0, [r4, #16]
 113:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   }
 114:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   else {
 115:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     flightMode = RATE_FLIGHT_MODE;
 116:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   }
 117:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 118:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   
 119:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 120:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****      if (receiverCommand[AUX1] < 1750) {
 9122              		.loc 33 120 0
 9123 00cc 6469     		ldr	r4, [r4, #20]
 112:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     flightMode = ATTITUDE_FLIGHT_MODE;
 9124              		.loc 33 112 0
 9125 00ce 1D4B     		ldr	r3, .L530+28
 9126 00d0 40F2DC51 		movw	r1, #1500
 9127 00d4 8842     		cmp	r0, r1
 9128              		.loc 33 120 0
 9129 00d6 40F2D56C 		movw	ip, #1749
 112:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     flightMode = ATTITUDE_FLIGHT_MODE;
 9130              		.loc 33 112 0
 9131 00da D4BF     		ite	le
 9132 00dc 0020     		movle	r0, #0
 9133 00de 0120     		movgt	r0, #1
 9134              		.loc 33 120 0
 9135 00e0 6445     		cmp	r4, ip
 112:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     flightMode = ATTITUDE_FLIGHT_MODE;
 9136              		.loc 33 112 0
 9137 00e2 1870     		strb	r0, [r3, #0]
 9138 00e4 184C     		ldr	r4, .L530+32
 9139              		.loc 33 120 0
 9140 00e6 18DC     		bgt	.L527
 121:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       if (altitudeHoldState != ALTPANIC ) {  // check for special condition with manditory override
 9141              		.loc 33 121 0
 9142 00e8 2278     		ldrb	r2, [r4, #0]	@ zero_extendqisi2
 9143 00ea 022A     		cmp	r2, #2
 9144 00ec 1AD0     		beq	.L521
 122:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         if (isStoreAltitudeNeeded) {
 9145              		.loc 33 122 0
 9146 00ee 174D     		ldr	r5, .L530+36
 9147 00f0 2878     		ldrb	r0, [r5, #0]	@ zero_extendqisi2
 9148 00f2 78B1     		cbz	r0, .L529
 123:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           #if defined AltitudeHoldBaro
 124:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             baroAltitudeToHoldTarget = getBaroAltitude();
 9149              		.loc 33 124 0
 9150 00f4 FFF7FEFF 		bl	_Z15getBaroAltitudev
 125:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             PID[BARO_ALTITUDE_HOLD_PID_IDX].integratedError = 0;
 9151              		.loc 33 125 0
 9152 00f8 154B     		ldr	r3, .L530+40
 124:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             baroAltitudeToHoldTarget = getBaroAltitude();
 9153              		.loc 33 124 0
 9154 00fa 164A     		ldr	r2, .L530+44
 126:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             PID[BARO_ALTITUDE_HOLD_PID_IDX].lastError = baroAltitudeToHoldTarget;
 9155              		.loc 33 126 0
 9156 00fc C3F8EC00 		str	r0, [r3, #236]	@ float
 124:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             baroAltitudeToHoldTarget = getBaroAltitude();
 9157              		.loc 33 124 0
 9158 0100 1060     		str	r0, [r2, #0]	@ float
 127:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           #endif
 128:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           #if defined AltitudeHoldRangeFinder
 129:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             sonarAltitudeToHoldTarget = rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX];
 130:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             PID[SONAR_ALTITUDE_HOLD_PID_IDX].integratedError = 0;
 131:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             PID[SONAR_ALTITUDE_HOLD_PID_IDX].lastError = sonarAltitudeToHoldTarget;
 132:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           #endif
 133:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           altitudeHoldThrottle = receiverCommand[THROTTLE];
 9159              		.loc 33 133 0
 9160 0102 0948     		ldr	r0, .L530
 9161 0104 144A     		ldr	r2, .L530+48
 125:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             PID[BARO_ALTITUDE_HOLD_PID_IDX].integratedError = 0;
 9162              		.loc 33 125 0
 9163 0106 0021     		movs	r1, #0
 9164 0108 C3F8F410 		str	r1, [r3, #244]	@ float
 9165              		.loc 33 133 0
 9166 010c C168     		ldr	r1, [r0, #12]
 134:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           isStoreAltitudeNeeded = false;
 9167              		.loc 33 134 0
 9168 010e 0023     		movs	r3, #0
 133:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           altitudeHoldThrottle = receiverCommand[THROTTLE];
 9169              		.loc 33 133 0
 9170 0110 1160     		str	r1, [r2, #0]
 9171              		.loc 33 134 0
 9172 0112 2B70     		strb	r3, [r5, #0]
 9173              	.L529:
 135:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         }
 136:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         altitudeHoldState = ON;
 9174              		.loc 33 136 0
 9175 0114 0120     		movs	r0, #1
 9176 0116 2070     		strb	r0, [r4, #0]
 9177 0118 70BD     		pop	{r4, r5, r6, pc}
 9178              	.L527:
 137:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       }
 138:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     } 
 139:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     else {
 140:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       isStoreAltitudeNeeded = true;
 9179              		.loc 33 140 0
 9180 011a 0C4A     		ldr	r2, .L530+36
 9181 011c 0121     		movs	r1, #1
 141:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       altitudeHoldState = OFF;
 9182              		.loc 33 141 0
 9183 011e 0023     		movs	r3, #0
 140:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       isStoreAltitudeNeeded = true;
 9184              		.loc 33 140 0
 9185 0120 1170     		strb	r1, [r2, #0]
 9186              		.loc 33 141 0
 9187 0122 2370     		strb	r3, [r4, #0]
 9188              	.L521:
 9189 0124 70BD     		pop	{r4, r5, r6, pc}
 9190              	.L531:
 9191 0126 00BF     		.align	2
 9192              	.L530:
 9193 0128 00000000 		.word	.LANCHOR6
 9194 012c 00000000 		.word	.LANCHOR16
 9195 0130 00000000 		.word	.LANCHOR130
 9196 0134 00000000 		.word	.LANCHOR136
 9197 0138 00000000 		.word	.LANCHOR119
 9198 013c 00000000 		.word	.LANCHOR63
 9199 0140 00000000 		.word	.LANCHOR120
 9200 0144 00000000 		.word	.LANCHOR114
 9201 0148 00000000 		.word	.LANCHOR5
 9202 014c 00000000 		.word	.LANCHOR137
 9203 0150 00000000 		.word	.LANCHOR17
 9204 0154 00000000 		.word	.LANCHOR110
 9205 0158 00000000 		.word	.LANCHOR7
 9206              	.LBE219:
 9207              		.cfi_endproc
 9208              	.LFE220:
 9210              		.section	.text._Z22initReceiverFromEEPROMv,"ax",%progbits
 9211              		.align	1
 9212              		.global	_Z22initReceiverFromEEPROMv
 9213              		.thumb
 9214              		.thumb_func
 9216              	_Z22initReceiverFromEEPROMv:
 9217              	.LFB233:
 526:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** 
 527:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** void initReceiverFromEEPROM() {
 9218              		.loc 31 527 0
 9219              		.cfi_startproc
 9220              		@ args = 0, pretend = 0, frame = 0
 9221              		@ frame_needed = 0, uses_anonymous_args = 0
 9222 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 9223              	.LCFI91:
 9224              		.cfi_def_cfa_offset 24
 9225              		.cfi_offset 14, -4
 9226              		.cfi_offset 7, -8
 9227              		.cfi_offset 6, -12
 9228              		.cfi_offset 5, -16
 9229              		.cfi_offset 4, -20
 9230              		.cfi_offset 3, -24
 9231              	.LBB228:
 528:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   receiverXmitFactor = readFloat(XMITFACTOR_ADR);
 9232              		.loc 31 528 0
 9233 0002 4FF48270 		mov	r0, #260
 9234 0006 FFF7FEFF 		bl	_Z12nvrReadFloati
 9235 000a 0E4B     		ldr	r3, .L535
 9236 000c 0E4F     		ldr	r7, .L535+4
 9237 000e 0F4E     		ldr	r6, .L535+8
 9238 0010 0F4D     		ldr	r5, .L535+12
 9239 0012 1860     		str	r0, [r3, #0]	@ float
 9240              	.LVL403:
 9241 0014 0024     		movs	r4, #0
 9242              	.LVL404:
 9243              	.L533:
 9244              	.LBB229:
 529:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   
 530:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for(byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 531:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     receiverSlope[channel] = readFloat(RECEIVER_DATA[channel].slope);
 9245              		.loc 31 531 0 discriminator 2
 9246 0016 04F19C00 		add	r0, r4, #156
 9247 001a FFF7FEFF 		bl	_Z12nvrReadFloati
 9248 001e 47F8040F 		str	r0, [r7, #4]!	@ float
 532:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     receiverOffset[channel] = readFloat(RECEIVER_DATA[channel].offset);
 9249              		.loc 31 532 0 discriminator 2
 9250 0022 04F1A000 		add	r0, r4, #160
 9251 0026 FFF7FEFF 		bl	_Z12nvrReadFloati
 9252 002a 46F8040F 		str	r0, [r6, #4]!	@ float
 533:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****     receiverSmoothFactor[channel] = readFloat(RECEIVER_DATA[channel].smooth_factor);
 9253              		.loc 31 533 0 discriminator 2
 9254 002e 04F1A400 		add	r0, r4, #164
 9255 0032 FFF7FEFF 		bl	_Z12nvrReadFloati
 9256 0036 0C34     		adds	r4, r4, #12
 530:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for(byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 9257              		.loc 31 530 0 discriminator 2
 9258 0038 602C     		cmp	r4, #96
 9259              		.loc 31 533 0 discriminator 2
 9260 003a 45F8040F 		str	r0, [r5, #4]!	@ float
 530:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   for(byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 9261              		.loc 31 530 0 discriminator 2
 9262 003e EAD1     		bne	.L533
 9263              	.LBE229:
 9264              	.LBE228:
 534:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h ****   }
 535:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\DataStorage.h **** }
 9265              		.loc 31 535 0
 9266 0040 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 9267              	.L536:
 9268 0042 00BF     		.align	2
 9269              	.L535:
 9270 0044 00000000 		.word	.LANCHOR61
 9271 0048 FCFFFFFF 		.word	.LANCHOR12-4
 9272 004c FCFFFFFF 		.word	.LANCHOR13-4
 9273 0050 FCFFFFFF 		.word	.LANCHOR14-4
 9274              		.cfi_endproc
 9275              	.LFE233:
 9277              		.section	.text._Z16processLedStatusv,"ax",%progbits
 9278              		.align	1
 9279              		.global	_Z16processLedStatusv
 9280              		.thumb
 9281              		.thumb_func
 9283              	_Z16processLedStatusv:
 9284              	.LFB234:
 9285              		.file 34 "C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad/LedStatusProcessor.h"
   1:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** /*
   2:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   AeroQuad v3.0 - Febuary 2012
   3:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   www.AeroQuad.com
   4:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   Copyright (c) 2011 Ted Carancho.  All rights reserved.
   5:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   An Open Source Arduino based multicopter.
   6:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****  
   7:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   This program is free software: you can redistribute it and/or modify 
   8:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   it under the terms of the GNU General Public License as published by 
   9:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   (at your option) any later version. 
  11:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****  
  12:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   This program is distributed in the hope that it will be useful, 
  13:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   GNU General Public License for more details. 
  16:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****  
  17:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   You should have received a copy of the GNU General Public License 
  18:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** */
  20:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 
  21:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** // Led Status Processor controls the LED:s on the shield according to vehicle status
  22:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 
  23:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 
  24:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** #ifndef _AQ_LedProcessor_H_
  25:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** #define _AQ_LedProcessor_H_
  26:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 
  27:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** byte flashingLedState = 0; // this counter increments by one at 10Hz
  28:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 
  29:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** void processLedStatus() {
 9286              		.loc 34 29 0
 9287              		.cfi_startproc
 9288              		@ args = 0, pretend = 0, frame = 0
 9289              		@ frame_needed = 0, uses_anonymous_args = 0
 9290 0000 10B5     		push	{r4, lr}
 9291              	.LCFI92:
 9292              		.cfi_def_cfa_offset 8
 9293              		.cfi_offset 14, -4
 9294              		.cfi_offset 4, -8
  30:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 
  31:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   
  32:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   //
  33:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   // process ready state light in case we use GPS
  34:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   //
  35:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   #if defined (UseGPS)
  36:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****     if (haveAGpsLock()) {
  37:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****       if (isHomeBaseInitialized()) {
  38:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****         digitalWrite(LED_Green, HIGH);
  39:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****       }
  40:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****       else {
  41:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****         digitalWrite(LED_Green, (flashingLedState & 4));
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****       }
  43:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****     }
  44:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****     else { 
  45:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****       digitalWrite(LED_Green, (flashingLedState & 2));
  46:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****     }
  47:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   #endif
  48:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   
  49:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   //
  50:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   // process ready state light in case we use Batt monitor
  51:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   //
  52:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** #if defined (BattMonitor)
  53:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 	if(motorArmed) {
 9295              		.loc 34 53 0
 9296 0002 124B     		ldr	r3, .L546
 9297 0004 124C     		ldr	r4, .L546+4
 9298 0006 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 9299 0008 88B1     		cbz	r0, .L538
  54:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 		if (batteryAlarm) {
 9300              		.loc 34 54 0
 9301 000a 1248     		ldr	r0, .L546+8
 9302 000c 0078     		ldrb	r0, [r0, #0]	@ zero_extendqisi2
 9303 000e 20B1     		cbz	r0, .L539
  55:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 			digitalWrite(BuzzerPin, (flashingLedState & 2));
 9304              		.loc 34 55 0
 9305 0010 2178     		ldrb	r1, [r4, #0]	@ zero_extendqisi2
 9306 0012 0020     		movs	r0, #0
 9307 0014 01F00201 		and	r1, r1, #2
 9308 0018 0AE0     		b	.L544
 9309              	.L539:
  56:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 			} else if (batteryWarning) {
 9310              		.loc 34 56 0
 9311 001a 0F4A     		ldr	r2, .L546+12
 9312 001c 1378     		ldrb	r3, [r2, #0]	@ zero_extendqisi2
 9313 001e 1BB1     		cbz	r3, .L541
  57:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 				digitalWrite(BuzzerPin, (flashingLedState & 6));
 9314              		.loc 34 57 0
 9315 0020 2378     		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 9316 0022 03F00601 		and	r1, r3, #6
 9317 0026 03E0     		b	.L544
 9318              	.L541:
  58:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 			} else {
  59:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 				digitalWrite(BuzzerPin, LOW);
 9319              		.loc 34 59 0
 9320 0028 1846     		mov	r0, r3
 9321 002a 1946     		mov	r1, r3
 9322 002c 00E0     		b	.L544
 9323              	.L538:
  60:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 				}
  61:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 		}
  62:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 	else {
  63:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 		digitalWrite(BuzzerPin, LOW);
 9324              		.loc 34 63 0
 9325 002e 0146     		mov	r1, r0
 9326              	.L544:
 9327 0030 FFF7FEFF 		bl	_Z12digitalWritehh
  64:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 		}
  65:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** #endif  
  66:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 
  67:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   //
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   // process mode light
  69:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   //
  70:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   if (flightMode == ATTITUDE_FLIGHT_MODE) {
 9328              		.loc 34 70 0
 9329 0034 094A     		ldr	r2, .L546+16
 9330 0036 1178     		ldrb	r1, [r2, #0]	@ zero_extendqisi2
  71:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****     digitalWrite(LED_Yellow, HIGH);
 9331              		.loc 34 71 0
 9332 0038 4520     		movs	r0, #69
  70:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   if (flightMode == ATTITUDE_FLIGHT_MODE) {
 9333              		.loc 34 70 0
 9334 003a 0129     		cmp	r1, #1
  72:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   }
  73:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   else {
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****     digitalWrite(LED_Yellow, LOW);
 9335              		.loc 34 74 0
 9336 003c 18BF     		it	ne
 9337 003e 0021     		movne	r1, #0
 9338 0040 FFF7FEFF 		bl	_Z12digitalWritehh
  75:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   }
  76:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 
  77:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h ****   flashingLedState++;
 9339              		.loc 34 77 0
 9340 0044 2178     		ldrb	r1, [r4, #0]	@ zero_extendqisi2
 9341 0046 481C     		adds	r0, r1, #1
 9342 0048 2070     		strb	r0, [r4, #0]
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** 
  79:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\LedStatusProcessor.h **** }
 9343              		.loc 34 79 0
 9344 004a 10BD     		pop	{r4, pc}
 9345              	.L547:
 9346              		.align	2
 9347              	.L546:
 9348 004c 00000000 		.word	.LANCHOR130
 9349 0050 00000000 		.word	.LANCHOR138
 9350 0054 00000000 		.word	.LANCHOR104
 9351 0058 00000000 		.word	.LANCHOR105
 9352 005c 00000000 		.word	.LANCHOR114
 9353              		.cfi_endproc
 9354              	.LFE234:
 9356              		.section	.text._Z17initCommunicationv,"ax",%progbits
 9357              		.align	1
 9358              		.global	_Z17initCommunicationv
 9359              		.thumb
 9360              		.thumb_func
 9362              	_Z17initCommunicationv:
 9363              	.LFB235:
 9364              		.file 35 "C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad/SerialCom.h"
   1:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** /*
   2:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   AeroQuad v3.0.1 - February 2012
   3:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   www.AeroQuad.com
   4:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   An Open Source Arduino based multicopter.
   6:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****  
   7:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   This program is free software: you can redistribute it and/or modify 
   8:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   it under the terms of the GNU General Public License as published by 
   9:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   (at your option) any later version. 
  11:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****  
  12:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   This program is distributed in the hope that it will be useful, 
  13:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   GNU General Public License for more details. 
  16:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****  
  17:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   You should have received a copy of the GNU General Public License 
  18:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** */
  20:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
  21:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** // SerialCom.pde is responsible for the serial communication for commands and telemetry from the Ae
  22:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** // This comtains readSerialCommand() which listens for a serial command and it's arguments
  23:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** // This also contains readSerialTelemetry() which listens for a telemetry request and responds with
  24:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** // For more information on each command/telemetry look at: http://aeroquad.com/content.php?117
  25:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
  26:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** // Includes re-write / fixes from Aadamson and ala42, special thanks to those guys!
  27:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** // http://aeroquad.com/showthread.php?1461-We-have-some-hidden-warnings&p=14618&viewfull=1#post1461
  28:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
  29:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** #ifndef _AQ_SERIAL_COMM_
  30:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** #define _AQ_SERIAL_COMM_
  31:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
  32:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** char queryType = 'X';
  33:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
  34:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void initCommunication() {
 9365              		.loc 35 34 0
 9366              		.cfi_startproc
 9367              		@ args = 0, pretend = 0, frame = 0
 9368              		@ frame_needed = 0, uses_anonymous_args = 0
 9369              		@ link register save eliminated.
  35:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // do nothing here for now
  36:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 9370              		.loc 35 36 0
 9371 0000 7047     		bx	lr
 9372              		.cfi_endproc
 9373              	.LFE235:
 9375              		.section	.text._Z15readValueSerialPch,"ax",%progbits
 9376              		.align	1
 9377              		.global	_Z15readValueSerialPch
 9378              		.thumb
 9379              		.thumb_func
 9381              	_Z15readValueSerialPch:
 9382              	.LFB248:
  37:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
  38:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** //*************************************************************************************************
  39:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** //********************************** Serial Commands **********************************************
  40:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** //*************************************************************************************************
  41:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** bool validateCalibrateCommand(byte command)
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
  43:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   if (readFloatSerial() == 123.45) {// use a specific float value to validate full throttle call is
  44:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     motorArmed = OFF;
  45:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     calibrateESC = command;
  46:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     return true;
  47:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   } 
  48:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   else {
  49:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     calibrateESC = 0;
  50:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     testCommand = 1000;
  51:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     return false;
  52:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   }
  53:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
  54:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
  55:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void readSerialPID(unsigned char PIDid) {
  56:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   struct PIDdata* pid = &PID[PIDid];
  57:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->P = readFloatSerial();
  58:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->I = readFloatSerial();
  59:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->D = readFloatSerial();
  60:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->lastError = 0;
  61:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->integratedError = 0;
  62:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
  63:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
  64:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void readSerialCommand() {
  65:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // Check for serial message
  66:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   if (SERIAL_AVAILABLE()) {
  67:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = SERIAL_READ();
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     switch (queryType) {
  69:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'A': // Receive roll and pitch rate mode PID
  70:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(RATE_XAXIS_PID_IDX);
  71:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(RATE_YAXIS_PID_IDX);
  72:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       rotationSpeedFactor = readFloatSerial();
  73:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
  75:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'B': // Receive roll/pitch attitude mode PID
  76:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ATTITUDE_XAXIS_PID_IDX);
  77:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ATTITUDE_YAXIS_PID_IDX);
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ATTITUDE_GYRO_XAXIS_PID_IDX);
  79:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ATTITUDE_GYRO_YAXIS_PID_IDX);
  80:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       windupGuard = readFloatSerial(); // defaults found in setup() of AeroQuad.pde
  81:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
  82:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
  83:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'C': // Receive yaw PID
  84:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ZAXIS_PID_IDX);
  85:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(HEADING_HOLD_PID_IDX);
  86:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readFloatSerial();
  87:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
  88:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
  89:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'D': // Altitude hold PID
  90:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
  91:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readSerialPID(BARO_ALTITUDE_HOLD_PID_IDX);
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard = readFloatSerial();
  93:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         altitudeHoldBump = readFloatSerial();
  94:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         altitudeHoldPanicStickMovement = readFloatSerial();
  95:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         minThrottleAdjust = readFloatSerial();
  96:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         maxThrottleAdjust = readFloatSerial();
  97:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         #if defined AltitudeHoldBaro
  98:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           baroSmoothFactor = readFloatSerial();
  99:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         #else
 100:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           readFloatSerial();
 101:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         #endif
 102:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readSerialPID(ZDAMPENING_PID_IDX);
 103:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 104:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 105:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 106:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'E': // Receive sensor filtering values
 107:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       aref = readFloatSerial();
 108:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       minArmedThrottle = readFloatSerial();
 109:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 110:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 111:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'F': // Receive transmitter smoothing values
 112:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       receiverXmitFactor = readFloatSerial();
 113:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       for(byte channel = XAXIS; channel<LASTCHANNEL; channel++) {
 114:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         receiverSmoothFactor[channel] = readFloatSerial();
 115:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       }
 116:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 117:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 118:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'G': // Receive transmitter calibration values
 119:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       channelCal = (int)readFloatSerial();
 120:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       receiverSlope[channelCal] = readFloatSerial();
 121:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 122:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 123:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'H': // Receive transmitter calibration values
 124:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       channelCal = (int)readFloatSerial();
 125:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       receiverOffset[channelCal] = readFloatSerial();
 126:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 127:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 128:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'I': // Initialize EEPROM with default values
 129:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       initializeEEPROM(); // defined in DataStorage.h
 130:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       writeEEPROM();
 131:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       storeSensorsZeroToEEPROM();
 132:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       calibrateGyro();
 133:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       computeAccelBias();
 134:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       zeroIntegralError();
 135:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #ifdef HeadingMagHold
 136:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         initializeMagnetometer();
 137:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 138:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #ifdef AltitudeHoldBaro
 139:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         initializeBaro();
 140:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 141:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 142:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 143:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'J': // calibrate gyros
 144:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       calibrateGyro();
 145:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       storeSensorsZeroToEEPROM();
 146:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 147:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 148:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'K': // Write accel calibration values
 149:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       accelScaleFactor[XAXIS] = readFloatSerial();
 150:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       runTimeAccelBias[XAXIS] = readFloatSerial();      
 151:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       accelScaleFactor[YAXIS] = readFloatSerial();
 152:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       runTimeAccelBias[YAXIS] = readFloatSerial();      
 153:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       accelScaleFactor[ZAXIS] = readFloatSerial();
 154:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       runTimeAccelBias[ZAXIS] = readFloatSerial();
 155:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       storeSensorsZeroToEEPROM();
 156:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 157:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 158:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'L': // generate accel bias
 159:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       computeAccelBias();
 160:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #if defined(AeroQuadMega_CHR6DM) || defined(APM_OP_CHR6DM)
 161:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         calibrateKinematics();
 162:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         accelOneG = meterPerSecSec[ZAXIS];
 163:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 164:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       storeSensorsZeroToEEPROM();
 165:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 166:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 167:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'M': // calibrate magnetometer
 168:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #ifdef HeadingMagHold
 169:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         magBias[XAXIS]  = readFloatSerial();      
 170:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         magBias[YAXIS]  = readFloatSerial();
 171:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         magBias[ZAXIS]  = readFloatSerial();
 172:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         writeEEPROM();
 173:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 174:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         for(int c=0;c<3;c++) {
 175:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           readFloatSerial();
 176:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         }
 177:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 178:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 179:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 180:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'N': // battery monitor
 181:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #ifdef BattMonitor
 182:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         batteryMonitorAlarmVoltage = readFloatSerial();
 183:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         batteryMonitorThrottleTarget = readFloatSerial();
 184:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         batteryMonitorGoingDownTime = readFloatSerial();
 185:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         setBatteryCellVoltageThreshold(batteryMonitorAlarmVoltage);
 186:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 187:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readFloatSerial();
 188:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readFloatSerial();
 189:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readFloatSerial();
 190:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 191:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 192:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 193:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'O': // define waypoints
 194:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #ifdef UseGPSNavigator
 195:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         missionNbPoint = readIntegerSerial();
 196:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         waypoint[missionNbPoint].latitude = readIntegerSerial();
 197:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         waypoint[missionNbPoint].longitude = readIntegerSerial();
 198:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         waypoint[missionNbPoint].altitude = readIntegerSerial();
 199:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 200:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readIntegerSerial();
 201:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readIntegerSerial();
 202:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readIntegerSerial();
 203:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readIntegerSerial();
 204:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 205:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 206:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'P': //  read Camera values
 207:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #ifdef CameraControl
 208:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         cameraMode = readFloatSerial();
 209:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         servoCenterPitch = readFloatSerial();
 210:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         servoCenterRoll = readFloatSerial();
 211:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         servoCenterYaw = readFloatSerial();
 212:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         mCameraPitch = readFloatSerial();
 213:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         mCameraRoll = readFloatSerial();
 214:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         mCameraYaw = readFloatSerial();
 215:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         servoMinPitch = readFloatSerial();
 216:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         servoMinRoll = readFloatSerial();
 217:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         servoMinYaw = readFloatSerial();
 218:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         servoMaxPitch = readFloatSerial();
 219:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         servoMaxRoll = readFloatSerial();
 220:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         servoMaxYaw = readFloatSerial();
 221:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 222:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         for (byte values = 0; values < 13; values++)
 223:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           readFloatSerial();
 224:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 225:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 226:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 227:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'U': // Range Finder
 228:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #if defined (AltitudeHoldRangeFinder)
 229:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         maxRangeFinderRange = readFloatSerial();
 230:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         minRangeFinderRange = readFloatSerial();
 231:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 232:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readFloatSerial();
 233:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readFloatSerial();
 234:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 235:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 236:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 237:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'V': // GPS
 238:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #if defined (UseGPS)
 239:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readSerialPID(GPSROLL_PID_IDX);
 240:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readSerialPID(GPSPITCH_PID_IDX);
 241:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readSerialPID(GPSYAW_PID_IDX);
 242:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         writeEEPROM();
 243:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 244:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         for (byte values = 0; values < 6; values++) {
 245:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           readFloatSerial();
 246:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         }
 247:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 248:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 249:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 250:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'W': // Write all user configurable values to EEPROM
 251:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       writeEEPROM(); // defined in DataStorage.h
 252:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       zeroIntegralError();
 253:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 254:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 255:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'X': // Stop sending messages
 256:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 257:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 258:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case '1': // Calibrate ESCS's by setting Throttle high on all channels
 259:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         validateCalibrateCommand(1);
 260:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 261:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 262:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case '2': // Calibrate ESC's by setting Throttle low on all channels
 263:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         validateCalibrateCommand(2);
 264:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 265:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 266:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case '3': // Test ESC calibration
 267:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       if (validateCalibrateCommand(3)) {
 268:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         testCommand = readFloatSerial();
 269:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       }
 270:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 271:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 272:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case '4': // Turn off ESC calibration
 273:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       if (validateCalibrateCommand(4)) {
 274:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         calibrateESC = 0;
 275:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         testCommand = 1000;
 276:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       }
 277:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 278:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 279:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case '5': // Send individual motor commands (motor, command)
 280:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       if (validateCalibrateCommand(5)) {
 281:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         for (byte motor = 0; motor < LASTMOTOR; motor++)
 282:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           motorConfiguratorCommand[motor] = (int)readFloatSerial();
 283:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       }
 284:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 285:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       
 286:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'Z': // fast telemetry transfer <--- get rid if this?
 287:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       if (readFloatSerial() == 1.0)
 288:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         fastTransfer = ON;
 289:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       else
 290:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         fastTransfer = OFF;
 291:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 292:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 293:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   }
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 295:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 296:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** //*************************************************************************************************
 297:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** //********************************* Serial Telemetry **********************************************
 298:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** //*************************************************************************************************
 299:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 300:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(float val) {
 301:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 302:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 303:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 304:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 305:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(double val) {
 306:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 307:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 308:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 309:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 310:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(char val) {
 311:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 312:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 313:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 314:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 315:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(int val) {
 316:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 317:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 318:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 319:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 320:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(unsigned long val)
 321:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 322:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 323:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 324:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 325:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 326:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(byte val)
 327:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 328:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 329:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 330:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 331:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 332:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(long int val)
 333:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 334:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 335:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 336:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 337:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 338:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintPID(unsigned char IDPid)
 339:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 340:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   PrintValueComma(PID[IDPid].P);
 341:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   PrintValueComma(PID[IDPid].I);
 342:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   PrintValueComma(PID[IDPid].D);
 343:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 344:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 345:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void sendSerialTelemetry() {
 346:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   switch (queryType) {
 347:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case '=': // Reserved debug command to view any variable from Serial Monitor
 348:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 349:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 350:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'a': // Send roll and pitch rate mode PID values
 351:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(RATE_XAXIS_PID_IDX);
 352:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(RATE_YAXIS_PID_IDX);
 353:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(rotationSpeedFactor);
 354:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 355:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 356:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 357:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 358:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'b': // Send roll and pitch attitude mode PID values
 359:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ATTITUDE_XAXIS_PID_IDX);
 360:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ATTITUDE_YAXIS_PID_IDX);
 361:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ATTITUDE_GYRO_XAXIS_PID_IDX);
 362:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ATTITUDE_GYRO_YAXIS_PID_IDX);
 363:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(windupGuard);
 364:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 365:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 366:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 367:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'c': // Send yaw PID values
 368:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ZAXIS_PID_IDX);
 369:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(HEADING_HOLD_PID_IDX);
 370:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN((int)headingHoldConfig);
 371:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 372:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 373:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 374:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'd': // Altitude Hold
 375:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 376:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintPID(BARO_ALTITUDE_HOLD_PID_IDX);
 377:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard);
 378:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(altitudeHoldBump);
 379:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(altitudeHoldPanicStickMovement);
 380:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(minThrottleAdjust);
 381:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(maxThrottleAdjust);
 382:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #if defined AltitudeHoldBaro
 383:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(baroSmoothFactor);
 384:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 385:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(0);
 386:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 387:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintPID(ZDAMPENING_PID_IDX);
 388:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 389:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       for(byte i=0; i<10; i++) {
 390:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(0);
 391:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       }
 392:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 393:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 394:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 395:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 396:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 397:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'e': // miscellaneous config values
 398:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(aref);
 399:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(minArmedThrottle);
 400:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 401:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 402:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 403:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'f': // Send transmitter smoothing values
 404:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(receiverXmitFactor);
 405:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 406:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(receiverSmoothFactor[axis]);
 407:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 408:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 409:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 410:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 411:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 412:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'g': // Send transmitter calibration data
 413:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 414:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(receiverSlope[axis], 6);
 415:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(',');
 416:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 417:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 418:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 419:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 420:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 421:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'h': // Send transmitter calibration data
 422:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 423:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(receiverOffset[axis], 6);
 424:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(',');
 425:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 426:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 427:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 428:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 429:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 430:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'i': // Send sensor data
 431:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 432:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(gyroRate[axis]);
 433:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 434:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 435:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(filteredAccel[axis]);
 436:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 437:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 438:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #if defined(HeadingMagHold)
 439:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(getMagnetometerData(axis));
 440:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 441:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(0);
 442:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 443:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 444:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 445:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 446:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 447:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'j': // Send raw mag values
 448:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #ifdef HeadingMagHold
 449:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(getMagnetometerRawData(XAXIS));
 450:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(getMagnetometerRawData(YAXIS));
 451:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(getMagnetometerRawData(ZAXIS));
 452:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 453:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 454:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 455:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'k': // Send accelerometer cal values
 456:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[XAXIS], 6);
 457:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 458:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(runTimeAccelBias[XAXIS], 6);
 459:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 460:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[YAXIS], 6);
 461:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 462:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(runTimeAccelBias[YAXIS], 6);
 463:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 464:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[ZAXIS], 6);
 465:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 466:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(runTimeAccelBias[ZAXIS], 6);
 467:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 468:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 469:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 470:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'l': // Send raw accel values
 471:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     measureAccelSum();
 472:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma((int)(accelSample[XAXIS]/accelSampleCount));
 473:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     accelSample[XAXIS] = 0;
 474:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma((int)(accelSample[YAXIS]/accelSampleCount));
 475:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     accelSample[YAXIS] = 0;
 476:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN ((int)(accelSample[ZAXIS]/accelSampleCount));
 477:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     accelSample[ZAXIS] = 0;
 478:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     accelSampleCount = 0;
 479:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 480:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 481:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'm': // Send magnetometer cal values
 482:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #ifdef HeadingMagHold
 483:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINT(magBias[XAXIS], 6);
 484:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       comma();
 485:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINT(magBias[YAXIS], 6);
 486:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       comma();
 487:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(magBias[ZAXIS], 6);
 488:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 489:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 490:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 491:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 492:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'n': // battery monitor
 493:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #ifdef BattMonitor
 494:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(batteryMonitorAlarmVoltage);
 495:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(batteryMonitorThrottleTarget);
 496:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(batteryMonitorGoingDownTime);
 497:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 498:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 499:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 500:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(0);
 501:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 502:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 503:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 504:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 505:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'o': // send waypoints
 506:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #ifdef UseGPSNavigator
 507:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       for (byte index = 0; index < MAX_WAYPOINTS; index++) {
 508:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(index);
 509:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(waypoint[index].latitude);
 510:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(waypoint[index].longitude);
 511:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(waypoint[index].altitude);
 512:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       }
 513:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN();
 514:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 515:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 516:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 517:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 518:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(0);
 519:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 520:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 521:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 522:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 523:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'p': // Send Camera values
 524:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #ifdef CameraControl
 525:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(cameraMode);
 526:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(servoCenterPitch);
 527:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(servoCenterRoll);
 528:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(servoCenterYaw);
 529:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(mCameraPitch);
 530:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(mCameraRoll);
 531:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(mCameraYaw);
 532:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(servoMinPitch);
 533:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(servoMinRoll);
 534:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(servoMinYaw);
 535:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(servoMaxPitch);
 536:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(servoMaxRoll);
 537:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(servoMaxYaw);
 538:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 539:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       for (byte index=0; index < 12; index++) {
 540:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(0);
 541:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       }
 542:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(0);
 543:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 544:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 545:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 546:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 547:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'q': // Send Vehicle State Value
 548:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(vehicleState);
 549:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 550:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 551:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 552:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'r': // Vehicle attitude
 553:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[XAXIS]);
 554:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[YAXIS]);
 555:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #if defined(HeadingMagHold) || defined(AeroQuadMega_CHR6DM) || defined(APM_OP_CHR6DM)
 556:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(trueNorthHeading);
 557:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 558:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(gyroHeading);
 559:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 560:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 561:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 562:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 's': // Send all flight data
 563:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(motorArmed);
 564:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[XAXIS]);
 565:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[YAXIS]);
 566:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #if defined(HeadingMagHold) || defined(AeroQuadMega_CHR6DM) || defined(APM_OP_CHR6DM)
 567:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(trueNorthHeading);
 568:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 569:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(gyroHeading);
 570:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 571:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 572:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #if defined AltitudeHoldBaro
 573:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(getBaroAltitude());
 574:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #elif defined AltitudeHoldRangeFinder
 575:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX] != INVALID_RANGE ? rangeFinde
 576:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif  
 577:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma((int)altitudeHoldState);
 578:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 579:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 580:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 581:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 582:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 583:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(receiverCommand[channel]);
 584:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 585:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte channel = 0; channel < (8 - LASTCHANNEL); channel++) {// max of 8 transmitter channel
 586:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0); // zero out unused transmitter channels
 587:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 588:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 589:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(motorCommand[motor]);
 590:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 591:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte motor = 0; motor < (8 - (LASTMOTOR)); motor++) {// max of 8 motor outputs supported
 592:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0); // zero out unused motor channels
 593:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 594:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #ifdef BattMonitor
 595:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma((float)batteryData[0].voltage/100.0); // voltage internally stored at 10mV:s
 596:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 597:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 598:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 599:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(flightMode);
 600:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 601:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 602:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 603:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 't': // Send processed transmitter values
 604:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = 0; axis < LASTCHANNEL; axis++) {
 605:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(receiverCommand[axis]);
 606:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 607:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 608:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 609:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 610:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'u': // Send range finder values
 611:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #if defined (AltitudeHoldRangeFinder)
 612:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(maxRangeFinderRange);
 613:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(minRangeFinderRange);
 614:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 615:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 616:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(0);
 617:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 618:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 619:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 620:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 621:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'v': // Send GPS PIDs
 622:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #if defined (UseGPS)
 623:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintPID(GPSROLL_PID_IDX);
 624:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintPID(GPSPITCH_PID_IDX);
 625:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintPID(GPSYAW_PID_IDX);
 626:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN();
 627:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       queryType = 'X';
 628:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 629:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       for (byte values=0; values < 5; values++)
 630:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(0);
 631:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(0);
 632:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 633:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 634:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 635:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 636:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'x': // Stop sending messages
 637:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 638:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 639:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case '!': // Send flight software version
 640:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(SOFTWARE_VERSION, 1);
 641:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 642:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 643:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 644:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case '#': // Send configuration
 645:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     reportVehicleState();
 646:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 647:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 648:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     
 649:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   case '6': // Report remote commands
 650:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 651:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(motorCommand[motor]);
 652:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 653:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 654:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 655:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 656:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   }
 657:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 658:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 659:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void readValueSerial(char *data, byte size) {
 9383              		.loc 35 659 0
 9384              		.cfi_startproc
 9385              		@ args = 0, pretend = 0, frame = 0
 9386              		@ frame_needed = 0, uses_anonymous_args = 0
 9387              	.LVL405:
 9388 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 9389              	.LCFI93:
 9390              		.cfi_def_cfa_offset 24
 9391              		.cfi_offset 14, -4
 9392              		.cfi_offset 7, -8
 9393              		.cfi_offset 6, -12
 9394              		.cfi_offset 5, -16
 9395              		.cfi_offset 4, -20
 9396              		.cfi_offset 3, -24
 9397              	.LBB230:
 660:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   byte index = 0;
 661:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   byte timeout = 0;
 662:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   data[0] = '\0';
 9398              		.loc 35 662 0
 9399 0002 0026     		movs	r6, #0
 9400              	.LBE230:
 659:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void readValueSerial(char *data, byte size) {
 9401              		.loc 35 659 0
 9402 0004 0446     		mov	r4, r0
 9403 0006 0F46     		mov	r7, r1
 9404              	.LBB231:
 9405              		.loc 35 662 0
 9406 0008 0670     		strb	r6, [r0, #0]
 660:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   byte index = 0;
 9407              		.loc 35 660 0
 9408 000a 3546     		mov	r5, r6
 9409              	.LVL406:
 9410              	.L554:
 663:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 664:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   do {
 665:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     if (SERIAL_AVAILABLE() == 0) {
 9411              		.loc 35 665 0
 9412 000c 0F48     		ldr	r0, .L556
 9413 000e FFF7FEFF 		bl	_ZN9USBSerial9availableEv
 9414 0012 28B9     		cbnz	r0, .L550
 666:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       delay(1);
 9415              		.loc 35 666 0
 9416 0014 0120     		movs	r0, #1
 667:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       timeout++;
 9417              		.loc 35 667 0
 9418 0016 0136     		adds	r6, r6, #1
 9419              	.LVL407:
 666:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       delay(1);
 9420              		.loc 35 666 0
 9421 0018 FFF7FEFF 		bl	_Z5delaym
 9422              		.loc 35 667 0
 9423 001c F6B2     		uxtb	r6, r6
 9424              	.LVL408:
 9425 001e 06E0     		b	.L551
 9426              	.L550:
 668:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     } else {
 669:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       data[index] = SERIAL_READ();
 9427              		.loc 35 669 0
 9428 0020 0A48     		ldr	r0, .L556
 9429 0022 FFF7FEFF 		bl	_ZN9USBSerial4readEv
 9430 0026 6055     		strb	r0, [r4, r5]
 9431              	.LVL409:
 670:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       timeout = 0;
 671:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       index++;
 9432              		.loc 35 671 0
 9433 0028 0135     		adds	r5, r5, #1
 9434              	.LVL410:
 9435 002a EDB2     		uxtb	r5, r5
 9436              	.LVL411:
 670:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       timeout = 0;
 9437              		.loc 35 670 0
 9438 002c 0026     		movs	r6, #0
 9439              	.LVL412:
 9440              	.L551:
 664:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   do {
 9441              		.loc 35 664 0
 9442 002e 25B1     		cbz	r5, .L552
 664:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   do {
 9443              		.loc 35 664 0 is_stmt 0 discriminator 2
 9444 0030 6019     		adds	r0, r4, r5
 9445 0032 10F8013C 		ldrb	r3, [r0, #-1]	@ zero_extendqisi2
 9446 0036 3B2B     		cmp	r3, #59
 9447 0038 04D0     		beq	.L553
 9448              	.L552:
 664:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   do {
 9449              		.loc 35 664 0 discriminator 1
 9450 003a 092E     		cmp	r6, #9
 9451 003c 02D8     		bhi	.L553
 664:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   do {
 9452              		.loc 35 664 0 discriminator 4
 9453 003e 791E     		subs	r1, r7, #1
 9454 0040 8D42     		cmp	r5, r1
 9455 0042 E3DB     		blt	.L554
 9456              	.L553:
 672:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 673:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   } while ((index == 0 || data[index-1] != ';') && (timeout < 10) && (index < size-1));
 674:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 675:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   data[index] = '\0';
 9457              		.loc 35 675 0 is_stmt 1
 9458 0044 0022     		movs	r2, #0
 9459 0046 6255     		strb	r2, [r4, r5]
 9460              	.LBE231:
 676:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 9461              		.loc 35 676 0
 9462 0048 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 9463              	.L557:
 9464 004a 00BF     		.align	2
 9465              	.L556:
 9466 004c 00000000 		.word	SerialUSB
 9467              		.cfi_endproc
 9468              	.LFE248:
 9470              		.section	.text._Z15readFloatSerialv,"ax",%progbits
 9471              		.align	1
 9472              		.global	_Z15readFloatSerialv
 9473              		.thumb
 9474              		.thumb_func
 9476              	_Z15readFloatSerialv:
 9477              	.LFB249:
 677:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 678:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 679:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** // Used to read floating point values from the serial port
 680:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** float readFloatSerial() {
 9478              		.loc 35 680 0
 9479              		.cfi_startproc
 9480              		@ args = 0, pretend = 0, frame = 16
 9481              		@ frame_needed = 0, uses_anonymous_args = 0
 9482 0000 1FB5     		push	{r0, r1, r2, r3, r4, lr}
 9483              	.LCFI94:
 9484              		.cfi_def_cfa_offset 24
 9485              		.cfi_offset 14, -4
 9486              		.cfi_offset 4, -8
 9487              		.cfi_offset 3, -12
 9488              		.cfi_offset 2, -16
 9489              		.cfi_offset 1, -20
 9490              		.cfi_offset 0, -24
 9491              	.LBB232:
 681:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   char data[15] = "";
 9492              		.loc 35 681 0
 9493 0002 0021     		movs	r1, #0
 9494 0004 0B22     		movs	r2, #11
 9495 0006 01A8     		add	r0, sp, #4
 9496 0008 0091     		str	r1, [sp, #0]
 9497 000a FFF7FEFF 		bl	memset
 682:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 683:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   readValueSerial(data, sizeof(data));
 9498              		.loc 35 683 0
 9499 000e 6846     		mov	r0, sp
 9500 0010 0F21     		movs	r1, #15
 9501 0012 FFF7FEFF 		bl	_Z15readValueSerialPch
 684:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   return atof(data);
 9502              		.loc 35 684 0
 9503 0016 6846     		mov	r0, sp
 9504 0018 FFF7FEFF 		bl	atof
 9505 001c FFF7FEFF 		bl	__aeabi_d2f
 9506              	.LBE232:
 685:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 9507              		.loc 35 685 0
 9508 0020 05B0     		add	sp, sp, #20
 9509 0022 00BD     		pop	{pc}
 9510              		.cfi_endproc
 9511              	.LFE249:
 9513              		.section	.text._Z13readSerialPIDh,"ax",%progbits
 9514              		.align	1
 9515              		.global	_Z13readSerialPIDh
 9516              		.thumb
 9517              		.thumb_func
 9519              	_Z13readSerialPIDh:
 9520              	.LFB237:
  55:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void readSerialPID(unsigned char PIDid) {
 9521              		.loc 35 55 0
 9522              		.cfi_startproc
 9523              		@ args = 0, pretend = 0, frame = 0
 9524              		@ frame_needed = 0, uses_anonymous_args = 0
 9525              	.LVL413:
 9526              	.LBB233:
  56:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   struct PIDdata* pid = &PID[PIDid];
 9527              		.loc 35 56 0
 9528 0000 0849     		ldr	r1, .L560
 9529              	.LBE233:
  55:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void readSerialPID(unsigned char PIDid) {
 9530              		.loc 35 55 0
 9531 0002 10B5     		push	{r4, lr}
 9532              	.LCFI95:
 9533              		.cfi_def_cfa_offset 8
 9534              		.cfi_offset 14, -4
 9535              		.cfi_offset 4, -8
 9536              	.LBB234:
  56:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   struct PIDdata* pid = &PID[PIDid];
 9537              		.loc 35 56 0
 9538 0004 1C24     		movs	r4, #28
 9539 0006 04FB0014 		mla	r4, r4, r0, r1
 9540              	.LVL414:
  57:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->P = readFloatSerial();
 9541              		.loc 35 57 0
 9542 000a FFF7FEFF 		bl	_Z15readFloatSerialv
 9543              	.LVL415:
 9544 000e 2060     		str	r0, [r4, #0]	@ float
  58:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->I = readFloatSerial();
 9545              		.loc 35 58 0
 9546 0010 FFF7FEFF 		bl	_Z15readFloatSerialv
 9547 0014 6060     		str	r0, [r4, #4]	@ float
  59:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->D = readFloatSerial();
 9548              		.loc 35 59 0
 9549 0016 FFF7FEFF 		bl	_Z15readFloatSerialv
  60:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->lastError = 0;
 9550              		.loc 35 60 0
 9551 001a 0023     		movs	r3, #0
  59:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->D = readFloatSerial();
 9552              		.loc 35 59 0
 9553 001c A060     		str	r0, [r4, #8]	@ float
  60:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->lastError = 0;
 9554              		.loc 35 60 0
 9555 001e E360     		str	r3, [r4, #12]	@ float
  61:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->integratedError = 0;
 9556              		.loc 35 61 0
 9557 0020 6361     		str	r3, [r4, #20]	@ float
 9558              	.LBE234:
  62:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 9559              		.loc 35 62 0
 9560 0022 10BD     		pop	{r4, pc}
 9561              	.L561:
 9562              		.align	2
 9563              	.L560:
 9564 0024 00000000 		.word	.LANCHOR17
 9565              		.cfi_endproc
 9566              	.LFE237:
 9568              		.section	.text._Z24validateCalibrateCommandh,"ax",%progbits
 9569              		.align	1
 9570              		.global	_Z24validateCalibrateCommandh
 9571              		.thumb
 9572              		.thumb_func
 9574              	_Z24validateCalibrateCommandh:
 9575              	.LFB236:
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 9576              		.loc 35 42 0
 9577              		.cfi_startproc
 9578              		@ args = 0, pretend = 0, frame = 0
 9579              		@ frame_needed = 0, uses_anonymous_args = 0
 9580              	.LVL416:
 9581 0000 10B5     		push	{r4, lr}
 9582              	.LCFI96:
 9583              		.cfi_def_cfa_offset 8
 9584              		.cfi_offset 14, -4
 9585              		.cfi_offset 4, -8
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 9586              		.loc 35 42 0
 9587 0002 0446     		mov	r4, r0
  43:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   if (readFloatSerial() == 123.45) {// use a specific float value to validate full throttle call is
 9588              		.loc 35 43 0
 9589 0004 FFF7FEFF 		bl	_Z15readFloatSerialv
 9590              	.LVL417:
 9591 0008 DFED0B7A 		flds	s15, .L565
 9592 000c 07EE100A 		fmsr	s14, r0
 9593 0010 B4EE677A 		fcmps	s14, s15
 9594 0014 F1EE10FA 		fmstat
 9595 0018 4FF00000 		mov	r0, #0
 9596 001c 074B     		ldr	r3, .L565+4
 9597 001e 04D1     		bne	.L563
  44:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     motorArmed = OFF;
 9598              		.loc 35 44 0
 9599 0020 074A     		ldr	r2, .L565+8
  45:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     calibrateESC = command;
 9600              		.loc 35 45 0
 9601 0022 1C70     		strb	r4, [r3, #0]
  44:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     motorArmed = OFF;
 9602              		.loc 35 44 0
 9603 0024 1070     		strb	r0, [r2, #0]
  46:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     return true;
 9604              		.loc 35 46 0
 9605 0026 0120     		movs	r0, #1
 9606 0028 10BD     		pop	{r4, pc}
 9607              	.L563:
  49:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     calibrateESC = 0;
 9608              		.loc 35 49 0
 9609 002a 1870     		strb	r0, [r3, #0]
  50:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     testCommand = 1000;
 9610              		.loc 35 50 0
 9611 002c 054B     		ldr	r3, .L565+12
 9612 002e 4FF47A71 		mov	r1, #1000
 9613 0032 1960     		str	r1, [r3, #0]
  53:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 9614              		.loc 35 53 0
 9615 0034 10BD     		pop	{r4, pc}
 9616              	.L566:
 9617 0036 00BF     		.align	2
 9618              	.L565:
 9619 0038 66E6F642 		.word	1123477094
 9620 003c 00000000 		.word	.LANCHOR116
 9621 0040 00000000 		.word	.LANCHOR130
 9622 0044 00000000 		.word	.LANCHOR117
 9623              		.cfi_endproc
 9624              	.LFE236:
 9626              		.section	.text._Z17readIntegerSerialv,"ax",%progbits
 9627              		.align	1
 9628              		.global	_Z17readIntegerSerialv
 9629              		.thumb
 9630              		.thumb_func
 9632              	_Z17readIntegerSerialv:
 9633              	.LFB250:
 686:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 687:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** // Used to read integer values from the serial port
 688:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** long readIntegerSerial() {
 9634              		.loc 35 688 0
 9635              		.cfi_startproc
 9636              		@ args = 0, pretend = 0, frame = 16
 9637              		@ frame_needed = 0, uses_anonymous_args = 0
 9638 0000 1FB5     		push	{r0, r1, r2, r3, r4, lr}
 9639              	.LCFI97:
 9640              		.cfi_def_cfa_offset 24
 9641              		.cfi_offset 14, -4
 9642              		.cfi_offset 4, -8
 9643              		.cfi_offset 3, -12
 9644              		.cfi_offset 2, -16
 9645              		.cfi_offset 1, -20
 9646              		.cfi_offset 0, -24
 9647              	.LBB235:
 689:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   char data[16] = "";
 9648              		.loc 35 689 0
 9649 0002 0021     		movs	r1, #0
 9650 0004 0C22     		movs	r2, #12
 9651 0006 01A8     		add	r0, sp, #4
 9652 0008 0091     		str	r1, [sp, #0]
 9653 000a FFF7FEFF 		bl	memset
 690:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 691:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   readValueSerial(data, sizeof(data));
 9654              		.loc 35 691 0
 9655 000e 6846     		mov	r0, sp
 9656 0010 1021     		movs	r1, #16
 9657 0012 FFF7FEFF 		bl	_Z15readValueSerialPch
 692:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   return atol(data);
 9658              		.loc 35 692 0
 9659 0016 6846     		mov	r0, sp
 9660 0018 FFF7FEFF 		bl	atol
 9661              	.LBE235:
 693:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 9662              		.loc 35 693 0
 9663 001c 05B0     		add	sp, sp, #20
 9664 001e 00BD     		pop	{pc}
 9665              		.cfi_endproc
 9666              	.LFE250:
 9668              		.section	.text._Z17readSerialCommandv,"ax",%progbits
 9669              		.align	1
 9670              		.global	_Z17readSerialCommandv
 9671              		.thumb
 9672              		.thumb_func
 9674              	_Z17readSerialCommandv:
 9675              	.LFB238:
  64:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void readSerialCommand() {
 9676              		.loc 35 64 0
 9677              		.cfi_startproc
 9678              		@ args = 0, pretend = 0, frame = 0
 9679              		@ frame_needed = 0, uses_anonymous_args = 0
 9680 0000 38B5     		push	{r3, r4, r5, lr}
 9681              	.LCFI98:
 9682              		.cfi_def_cfa_offset 16
 9683              		.cfi_offset 14, -4
 9684              		.cfi_offset 5, -8
 9685              		.cfi_offset 4, -12
 9686              		.cfi_offset 3, -16
 9687              	.LBB236:
  66:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   if (SERIAL_AVAILABLE()) {
 9688              		.loc 35 66 0
 9689 0002 8648     		ldr	r0, .L610
 9690 0004 FFF7FEFF 		bl	_ZN9USBSerial9availableEv
 9691 0008 0028     		cmp	r0, #0
 9692 000a 00F0B781 		beq	.L568
 9693              	.LBB237:
  67:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = SERIAL_READ();
 9694              		.loc 35 67 0
 9695 000e 8348     		ldr	r0, .L610
 9696 0010 FFF7FEFF 		bl	_ZN9USBSerial4readEv
 9697 0014 824B     		ldr	r3, .L610+4
 9698 0016 1870     		strb	r0, [r3, #0]
 9699              	.LBB238:
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     switch (queryType) {
 9700              		.loc 35 68 0
 9701 0018 3138     		subs	r0, r0, #49
 9702 001a 2928     		cmp	r0, #41
 9703 001c 00F2AE81 		bhi	.L568
 9704 0020 DFE810F0 		tbh	[pc, r0, lsl #1]
 9705              	.L595:
 9706 0024 6501     		.2byte	(.L570-.L595)/2
 9707 0026 6701     		.2byte	(.L571-.L595)/2
 9708 0028 6C01     		.2byte	(.L572-.L595)/2
 9709 002a 7B01     		.2byte	(.L573-.L595)/2
 9710 002c 8801     		.2byte	(.L574-.L595)/2
 9711 002e AC01     		.2byte	(.L568-.L595)/2
 9712 0030 AC01     		.2byte	(.L568-.L595)/2
 9713 0032 AC01     		.2byte	(.L568-.L595)/2
 9714 0034 AC01     		.2byte	(.L568-.L595)/2
 9715 0036 AC01     		.2byte	(.L568-.L595)/2
 9716 0038 AC01     		.2byte	(.L568-.L595)/2
 9717 003a AC01     		.2byte	(.L568-.L595)/2
 9718 003c AC01     		.2byte	(.L568-.L595)/2
 9719 003e AC01     		.2byte	(.L568-.L595)/2
 9720 0040 AC01     		.2byte	(.L568-.L595)/2
 9721 0042 AC01     		.2byte	(.L568-.L595)/2
 9722 0044 2A00     		.2byte	(.L575-.L595)/2
 9723 0046 3400     		.2byte	(.L576-.L595)/2
 9724 0048 4500     		.2byte	(.L577-.L595)/2
 9725 004a 4C00     		.2byte	(.L578-.L595)/2
 9726 004c 8100     		.2byte	(.L579-.L595)/2
 9727 004e 8F00     		.2byte	(.L580-.L595)/2
 9728 0050 9D00     		.2byte	(.L581-.L595)/2
 9729 0052 AC00     		.2byte	(.L582-.L595)/2
 9730 0054 BE00     		.2byte	(.L583-.L595)/2
 9731 0056 D000     		.2byte	(.L584-.L595)/2
 9732 0058 D300     		.2byte	(.L585-.L595)/2
 9733 005a EB00     		.2byte	(.L586-.L595)/2
 9734 005c EE00     		.2byte	(.L587-.L595)/2
 9735 005e 2401     		.2byte	(.L588-.L595)/2
 9736 0060 3F01     		.2byte	(.L589-.L595)/2
 9737 0062 4901     		.2byte	(.L599-.L595)/2
 9738 0064 AC01     		.2byte	(.L568-.L595)/2
 9739 0066 AC01     		.2byte	(.L568-.L595)/2
 9740 0068 AC01     		.2byte	(.L568-.L595)/2
 9741 006a AC01     		.2byte	(.L568-.L595)/2
 9742 006c 5101     		.2byte	(.L591-.L595)/2
 9743 006e 5701     		.2byte	(.L600-.L595)/2
 9744 0070 5F01     		.2byte	(.L593-.L595)/2
 9745 0072 AC01     		.2byte	(.L568-.L595)/2
 9746 0074 AC01     		.2byte	(.L568-.L595)/2
 9747 0076 9B01     		.2byte	(.L594-.L595)/2
 9748              	.L575:
 9749              	.LBB239:
  70:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(RATE_XAXIS_PID_IDX);
 9750              		.loc 35 70 0
 9751 0078 0020     		movs	r0, #0
 9752 007a FFF7FEFF 		bl	_Z13readSerialPIDh
  71:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(RATE_YAXIS_PID_IDX);
 9753              		.loc 35 71 0
 9754 007e 0120     		movs	r0, #1
 9755 0080 FFF7FEFF 		bl	_Z13readSerialPIDh
  72:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       rotationSpeedFactor = readFloatSerial();
 9756              		.loc 35 72 0
 9757 0084 FFF7FEFF 		bl	_Z15readFloatSerialv
 9758 0088 664B     		ldr	r3, .L610+8
 9759 008a 0EE0     		b	.L608
 9760              	.L576:
  76:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ATTITUDE_XAXIS_PID_IDX);
 9761              		.loc 35 76 0
 9762 008c 0320     		movs	r0, #3
 9763 008e FFF7FEFF 		bl	_Z13readSerialPIDh
  77:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ATTITUDE_YAXIS_PID_IDX);
 9764              		.loc 35 77 0
 9765 0092 0420     		movs	r0, #4
 9766 0094 FFF7FEFF 		bl	_Z13readSerialPIDh
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ATTITUDE_GYRO_XAXIS_PID_IDX);
 9767              		.loc 35 78 0
 9768 0098 0620     		movs	r0, #6
 9769 009a FFF7FEFF 		bl	_Z13readSerialPIDh
  79:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ATTITUDE_GYRO_YAXIS_PID_IDX);
 9770              		.loc 35 79 0
 9771 009e 0720     		movs	r0, #7
 9772 00a0 FFF7FEFF 		bl	_Z13readSerialPIDh
  80:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       windupGuard = readFloatSerial(); // defaults found in setup() of AeroQuad.pde
 9773              		.loc 35 80 0
 9774 00a4 FFF7FEFF 		bl	_Z15readFloatSerialv
 9775 00a8 5F4B     		ldr	r3, .L610+12
 9776              	.L608:
 9777 00aa 1860     		str	r0, [r3, #0]	@ float
  81:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 9778              		.loc 35 81 0
 9779 00ac 38BD     		pop	{r3, r4, r5, pc}
 9780              	.L577:
  84:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ZAXIS_PID_IDX);
 9781              		.loc 35 84 0
 9782 00ae 0220     		movs	r0, #2
 9783 00b0 FFF7FEFF 		bl	_Z13readSerialPIDh
  85:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(HEADING_HOLD_PID_IDX);
 9784              		.loc 35 85 0
 9785 00b4 0520     		movs	r0, #5
 9786 00b6 FFF7FEFF 		bl	_Z13readSerialPIDh
 9787 00ba 06E1     		b	.L605
 9788              	.L578:
  91:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readSerialPID(BARO_ALTITUDE_HOLD_PID_IDX);
 9789              		.loc 35 91 0
 9790 00bc 0820     		movs	r0, #8
 9791 00be FFF7FEFF 		bl	_Z13readSerialPIDh
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard = readFloatSerial();
 9792              		.loc 35 92 0
 9793 00c2 FFF7FEFF 		bl	_Z15readFloatSerialv
 9794 00c6 594A     		ldr	r2, .L610+16
 9795 00c8 C2F8F800 		str	r0, [r2, #248]	@ float
  93:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         altitudeHoldBump = readFloatSerial();
 9796              		.loc 35 93 0
 9797 00cc FFF7FEFF 		bl	_Z15readFloatSerialv
 9798 00d0 02EE900A 		fmsr	s5, r0
 9799 00d4 5649     		ldr	r1, .L610+20
 9800 00d6 BDEEE22A 		ftosizs	s4, s5
 9801 00da 81ED002A 		fsts	s4, [r1, #0]	@ int
  94:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         altitudeHoldPanicStickMovement = readFloatSerial();
 9802              		.loc 35 94 0
 9803 00de FFF7FEFF 		bl	_Z15readFloatSerialv
 9804 00e2 01EE900A 		fmsr	s3, r0
 9805 00e6 534B     		ldr	r3, .L610+24
 9806 00e8 BDEEE11A 		ftosizs	s2, s3
 9807 00ec 83ED001A 		fsts	s2, [r3, #0]	@ int
  95:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         minThrottleAdjust = readFloatSerial();
 9808              		.loc 35 95 0
 9809 00f0 FFF7FEFF 		bl	_Z15readFloatSerialv
 9810 00f4 00EE900A 		fmsr	s1, r0
 9811 00f8 4F4A     		ldr	r2, .L610+28
 9812 00fa BDEEE07A 		ftosizs	s14, s1
 9813 00fe 82ED007A 		fsts	s14, [r2, #0]	@ int
  96:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         maxThrottleAdjust = readFloatSerial();
 9814              		.loc 35 96 0
 9815 0102 FFF7FEFF 		bl	_Z15readFloatSerialv
 9816 0106 00EE100A 		fmsr	s0, r0
 9817 010a 4C48     		ldr	r0, .L610+32
 9818 010c FDEEC07A 		ftosizs	s15, s0
 9819 0110 C0ED007A 		fsts	s15, [r0, #0]	@ int
  98:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           baroSmoothFactor = readFloatSerial();
 9820              		.loc 35 98 0
 9821 0114 FFF7FEFF 		bl	_Z15readFloatSerialv
 9822 0118 4949     		ldr	r1, .L610+36
 9823 011a 0860     		str	r0, [r1, #0]	@ float
 102:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readSerialPID(ZDAMPENING_PID_IDX);
 9824              		.loc 35 102 0
 9825 011c 0920     		movs	r0, #9
 9826              	.LBE239:
 9827              	.LBE238:
 9828              	.LBE237:
 9829              	.LBE236:
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 9830              		.loc 35 294 0
 9831 011e BDE83840 		pop	{r3, r4, r5, lr}
 9832              	.LBB274:
 9833              	.LBB265:
 9834              	.LBB256:
 9835              	.LBB245:
 102:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readSerialPID(ZDAMPENING_PID_IDX);
 9836              		.loc 35 102 0
 9837 0122 FFF7FEBF 		b	_Z13readSerialPIDh
 9838              	.L579:
 107:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       aref = readFloatSerial();
 9839              		.loc 35 107 0
 9840 0126 FFF7FEFF 		bl	_Z15readFloatSerialv
 9841 012a 464B     		ldr	r3, .L610+40
 9842 012c 1860     		str	r0, [r3, #0]	@ float
 108:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       minArmedThrottle = readFloatSerial();
 9843              		.loc 35 108 0
 9844 012e FFF7FEFF 		bl	_Z15readFloatSerialv
 9845 0132 03EE900A 		fmsr	s7, r0
 9846 0136 4448     		ldr	r0, .L610+44
 9847 0138 BDEEE33A 		ftosizs	s6, s7
 9848 013c 80ED003A 		fsts	s6, [r0, #0]	@ int
 109:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 9849              		.loc 35 109 0
 9850 0140 38BD     		pop	{r3, r4, r5, pc}
 9851              	.L580:
 112:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       receiverXmitFactor = readFloatSerial();
 9852              		.loc 35 112 0
 9853 0142 FFF7FEFF 		bl	_Z15readFloatSerialv
 9854 0146 414C     		ldr	r4, .L610+48
 9855 0148 2060     		str	r0, [r4, #0]	@ float
 9856              	.LVL418:
 9857 014a 414C     		ldr	r4, .L610+52
  64:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void readSerialCommand() {
 9858              		.loc 35 64 0
 9859 014c 04F12005 		add	r5, r4, #32
 9860              	.LVL419:
 9861              	.L596:
 9862              	.LBB240:
 114:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         receiverSmoothFactor[channel] = readFloatSerial();
 9863              		.loc 35 114 0 discriminator 2
 9864 0150 FFF7FEFF 		bl	_Z15readFloatSerialv
 9865 0154 44F8040F 		str	r0, [r4, #4]!	@ float
 113:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       for(byte channel = XAXIS; channel<LASTCHANNEL; channel++) {
 9866              		.loc 35 113 0 discriminator 2
 9867 0158 AC42     		cmp	r4, r5
 9868 015a F9D1     		bne	.L596
 9869 015c 38BD     		pop	{r3, r4, r5, pc}
 9870              	.L581:
 9871              	.LBE240:
 119:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       channelCal = (int)readFloatSerial();
 9872              		.loc 35 119 0
 9873 015e FFF7FEFF 		bl	_Z15readFloatSerialv
 9874 0162 04EE900A 		fmsr	s9, r0
 9875 0166 3B49     		ldr	r1, .L610+56
 9876 0168 BDEEE44A 		ftosizs	s8, s9
 9877 016c 81ED004A 		fsts	s8, [r1, #0]	@ int
 9878 0170 14EE104A 		fmrs	r4, s8	@ int
 120:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       receiverSlope[channelCal] = readFloatSerial();
 9879              		.loc 35 120 0
 9880 0174 FFF7FEFF 		bl	_Z15readFloatSerialv
 9881 0178 374B     		ldr	r3, .L610+60
 9882 017a 0DE0     		b	.L609
 9883              	.L582:
 124:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       channelCal = (int)readFloatSerial();
 9884              		.loc 35 124 0
 9885 017c FFF7FEFF 		bl	_Z15readFloatSerialv
 9886 0180 05EE900A 		fmsr	s11, r0
 9887 0184 334A     		ldr	r2, .L610+56
 9888 0186 BDEEE55A 		ftosizs	s10, s11
 9889 018a 82ED005A 		fsts	s10, [r2, #0]	@ int
 9890 018e 15EE104A 		fmrs	r4, s10	@ int
 125:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       receiverOffset[channelCal] = readFloatSerial();
 9891              		.loc 35 125 0
 9892 0192 FFF7FEFF 		bl	_Z15readFloatSerialv
 9893 0196 314B     		ldr	r3, .L610+64
 9894              	.L609:
 9895 0198 03EB8404 		add	r4, r3, r4, lsl #2
 9896 019c 2060     		str	r0, [r4, #0]	@ float
 126:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 9897              		.loc 35 126 0
 9898 019e 38BD     		pop	{r3, r4, r5, pc}
 9899              	.L583:
 129:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       initializeEEPROM(); // defined in DataStorage.h
 9900              		.loc 35 129 0
 9901 01a0 FFF7FEFF 		bl	_Z16initializeEEPROMv
 130:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       writeEEPROM();
 9902              		.loc 35 130 0
 9903 01a4 FFF7FEFF 		bl	_Z11writeEEPROMv
 131:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       storeSensorsZeroToEEPROM();
 9904              		.loc 35 131 0
 9905 01a8 FFF7FEFF 		bl	_Z24storeSensorsZeroToEEPROMv
 132:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       calibrateGyro();
 9906              		.loc 35 132 0
 9907 01ac FFF7FEFF 		bl	_Z13calibrateGyrov
 133:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       computeAccelBias();
 9908              		.loc 35 133 0
 9909 01b0 FFF7FEFF 		bl	_Z16computeAccelBiasv
 134:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       zeroIntegralError();
 9910              		.loc 35 134 0
 9911 01b4 FFF7FEFF 		bl	_Z17zeroIntegralErrorv
 136:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         initializeMagnetometer();
 9912              		.loc 35 136 0
 9913 01b8 FFF7FEFF 		bl	_Z22initializeMagnetometerv
 9914              	.LBE245:
 9915              	.LBE256:
 9916              	.LBE265:
 9917              	.LBE274:
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 9918              		.loc 35 294 0
 9919 01bc BDE83840 		pop	{r3, r4, r5, lr}
 9920              	.LBB275:
 9921              	.LBB266:
 9922              	.LBB257:
 9923              	.LBB246:
 139:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         initializeBaro();
 9924              		.loc 35 139 0
 9925 01c0 FFF7FEBF 		b	_Z14initializeBarov
 9926              	.L584:
 144:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       calibrateGyro();
 9927              		.loc 35 144 0
 9928 01c4 FFF7FEFF 		bl	_Z13calibrateGyrov
 9929 01c8 13E0     		b	.L606
 9930              	.L585:
 149:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       accelScaleFactor[XAXIS] = readFloatSerial();
 9931              		.loc 35 149 0
 9932 01ca FFF7FEFF 		bl	_Z15readFloatSerialv
 9933 01ce 244D     		ldr	r5, .L610+68
 150:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       runTimeAccelBias[XAXIS] = readFloatSerial();      
 9934              		.loc 35 150 0
 9935 01d0 244C     		ldr	r4, .L610+72
 149:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       accelScaleFactor[XAXIS] = readFloatSerial();
 9936              		.loc 35 149 0
 9937 01d2 2860     		str	r0, [r5, #0]	@ float
 150:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       runTimeAccelBias[XAXIS] = readFloatSerial();      
 9938              		.loc 35 150 0
 9939 01d4 FFF7FEFF 		bl	_Z15readFloatSerialv
 9940 01d8 2060     		str	r0, [r4, #0]	@ float
 151:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       accelScaleFactor[YAXIS] = readFloatSerial();
 9941              		.loc 35 151 0
 9942 01da FFF7FEFF 		bl	_Z15readFloatSerialv
 9943 01de 6860     		str	r0, [r5, #4]	@ float
 152:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       runTimeAccelBias[YAXIS] = readFloatSerial();      
 9944              		.loc 35 152 0
 9945 01e0 FFF7FEFF 		bl	_Z15readFloatSerialv
 9946 01e4 6060     		str	r0, [r4, #4]	@ float
 153:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       accelScaleFactor[ZAXIS] = readFloatSerial();
 9947              		.loc 35 153 0
 9948 01e6 FFF7FEFF 		bl	_Z15readFloatSerialv
 9949 01ea A860     		str	r0, [r5, #8]	@ float
 154:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       runTimeAccelBias[ZAXIS] = readFloatSerial();
 9950              		.loc 35 154 0
 9951 01ec FFF7FEFF 		bl	_Z15readFloatSerialv
 9952 01f0 A060     		str	r0, [r4, #8]	@ float
 9953              	.L606:
 9954              	.LBE246:
 9955              	.LBE257:
 9956              	.LBE266:
 9957              	.LBE275:
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 9958              		.loc 35 294 0
 9959 01f2 BDE83840 		pop	{r3, r4, r5, lr}
 9960              	.LBB276:
 9961              	.LBB267:
 9962              	.LBB258:
 9963              	.LBB247:
 155:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       storeSensorsZeroToEEPROM();
 9964              		.loc 35 155 0
 9965 01f6 FFF7FEBF 		b	_Z24storeSensorsZeroToEEPROMv
 9966              	.L586:
 159:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       computeAccelBias();
 9967              		.loc 35 159 0
 9968 01fa FFF7FEFF 		bl	_Z16computeAccelBiasv
 9969 01fe F8E7     		b	.L606
 9970              	.L587:
 169:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         magBias[XAXIS]  = readFloatSerial();      
 9971              		.loc 35 169 0
 9972 0200 FFF7FEFF 		bl	_Z15readFloatSerialv
 9973 0204 184C     		ldr	r4, .L610+76
 9974 0206 2060     		str	r0, [r4, #0]	@ float
 170:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         magBias[YAXIS]  = readFloatSerial();
 9975              		.loc 35 170 0
 9976 0208 FFF7FEFF 		bl	_Z15readFloatSerialv
 9977 020c 6060     		str	r0, [r4, #4]	@ float
 171:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         magBias[ZAXIS]  = readFloatSerial();
 9978              		.loc 35 171 0
 9979 020e FFF7FEFF 		bl	_Z15readFloatSerialv
 9980 0212 A060     		str	r0, [r4, #8]	@ float
 9981              	.LBE247:
 9982              	.LBE258:
 9983              	.LBE267:
 9984              	.LBE276:
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 9985              		.loc 35 294 0
 9986 0214 BDE83840 		pop	{r3, r4, r5, lr}
 9987              	.LBB277:
 9988              	.LBB268:
 9989              	.LBB259:
 9990              	.LBB248:
 172:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         writeEEPROM();
 9991              		.loc 35 172 0
 9992 0218 FFF7FEBF 		b	_Z11writeEEPROMv
 9993              	.L611:
 9994              		.align	2
 9995              	.L610:
 9996 021c 00000000 		.word	SerialUSB
 9997 0220 00000000 		.word	.LANCHOR139
 9998 0224 00000000 		.word	.LANCHOR115
 9999 0228 00000000 		.word	.LANCHOR131
 10000 022c 00000000 		.word	.LANCHOR17
 10001 0230 00000000 		.word	.LANCHOR8
 10002 0234 00000000 		.word	.LANCHOR113
 10003 0238 00000000 		.word	.LANCHOR111
 10004 023c 00000000 		.word	.LANCHOR112
 10005 0240 00000000 		.word	.LANCHOR97
 10006 0244 00000000 		.word	.LANCHOR132
 10007 0248 00000000 		.word	.LANCHOR120
 10008 024c 00000000 		.word	.LANCHOR61
 10009 0250 FCFFFFFF 		.word	.LANCHOR14-4
 10010 0254 00000000 		.word	.LANCHOR140
 10011 0258 00000000 		.word	.LANCHOR12
 10012 025c 00000000 		.word	.LANCHOR13
 10013 0260 00000000 		.word	.LANCHOR35
 10014 0264 00000000 		.word	.LANCHOR36
 10015 0268 00000000 		.word	.LANCHOR76
 10016              	.L588:
 182:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         batteryMonitorAlarmVoltage = readFloatSerial();
 10017              		.loc 35 182 0
 10018 026c FFF7FEFF 		bl	_Z15readFloatSerialv
 10019 0270 434C     		ldr	r4, .L612
 10020 0272 2060     		str	r0, [r4, #0]	@ float
 183:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         batteryMonitorThrottleTarget = readFloatSerial();
 10021              		.loc 35 183 0
 10022 0274 FFF7FEFF 		bl	_Z15readFloatSerialv
 10023 0278 00EE100A 		fmsr	s0, r0
 10024 027c 414B     		ldr	r3, .L612+4
 10025 027e FDEEC07A 		ftosizs	s15, s0
 10026 0282 C3ED007A 		fsts	s15, [r3, #0]	@ int
 184:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         batteryMonitorGoingDownTime = readFloatSerial();
 10027              		.loc 35 184 0
 10028 0286 FFF7FEFF 		bl	_Z15readFloatSerialv
 10029 028a 06EE900A 		fmsr	s13, r0
 10030 028e 3E48     		ldr	r0, .L612+8
 10031 0290 BCEEE66A 		ftouizs	s12, s13
 10032 0294 80ED006A 		fsts	s12, [r0, #0]	@ int
 185:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         setBatteryCellVoltageThreshold(batteryMonitorAlarmVoltage);
 10033              		.loc 35 185 0
 10034 0298 2068     		ldr	r0, [r4, #0]	@ float
 10035              	.LBE248:
 10036              	.LBE259:
 10037              	.LBE268:
 10038              	.LBE277:
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10039              		.loc 35 294 0
 10040 029a BDE83840 		pop	{r3, r4, r5, lr}
 10041              	.LBB278:
 10042              	.LBB269:
 10043              	.LBB260:
 10044              	.LBB249:
 185:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         setBatteryCellVoltageThreshold(batteryMonitorAlarmVoltage);
 10045              		.loc 35 185 0
 10046 029e FFF7FEBF 		b	_Z30setBatteryCellVoltageThresholdf
 10047              	.L589:
 200:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readIntegerSerial();
 10048              		.loc 35 200 0
 10049 02a2 FFF7FEFF 		bl	_Z17readIntegerSerialv
 201:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readIntegerSerial();
 10050              		.loc 35 201 0
 10051 02a6 FFF7FEFF 		bl	_Z17readIntegerSerialv
 202:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readIntegerSerial();
 10052              		.loc 35 202 0
 10053 02aa FFF7FEFF 		bl	_Z17readIntegerSerialv
 10054              	.LBE249:
 10055              	.LBE260:
 10056              	.LBE269:
 10057              	.LBE278:
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10058              		.loc 35 294 0
 10059 02ae BDE83840 		pop	{r3, r4, r5, lr}
 10060              	.LBB279:
 10061              	.LBB270:
 10062              	.LBB261:
 10063              	.LBB250:
 203:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readIntegerSerial();
 10064              		.loc 35 203 0
 10065 02b2 FFF7FEBF 		b	_Z17readIntegerSerialv
 10066              	.L599:
 10067              	.LBE250:
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     switch (queryType) {
 10068              		.loc 35 68 0
 10069 02b6 0D24     		movs	r4, #13
 10070              	.L590:
 10071              	.LBB251:
 10072              	.LBB241:
 223:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           readFloatSerial();
 10073              		.loc 35 223 0 discriminator 2
 10074 02b8 013C     		subs	r4, r4, #1
 10075 02ba E4B2     		uxtb	r4, r4
 10076 02bc FFF7FEFF 		bl	_Z15readFloatSerialv
 222:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         for (byte values = 0; values < 13; values++)
 10077              		.loc 35 222 0 discriminator 2
 10078 02c0 002C     		cmp	r4, #0
 10079 02c2 F9D1     		bne	.L590
 10080 02c4 38BD     		pop	{r3, r4, r5, pc}
 10081              	.LVL420:
 10082              	.L591:
 10083              	.LBE241:
 232:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readFloatSerial();
 10084              		.loc 35 232 0
 10085 02c6 FFF7FEFF 		bl	_Z15readFloatSerialv
 10086              	.L605:
 10087              	.LBE251:
 10088              	.LBE261:
 10089              	.LBE270:
 10090              	.LBE279:
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10091              		.loc 35 294 0
 10092 02ca BDE83840 		pop	{r3, r4, r5, lr}
 10093              	.LBB280:
 10094              	.LBB271:
 10095              	.LBB262:
 10096              	.LBB252:
 233:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         readFloatSerial();
 10097              		.loc 35 233 0
 10098 02ce FFF7FEBF 		b	_Z15readFloatSerialv
 10099              	.L600:
 10100              	.LBE252:
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     switch (queryType) {
 10101              		.loc 35 68 0
 10102 02d2 0624     		movs	r4, #6
 10103              	.L592:
 10104              	.LBB253:
 10105              	.LBB242:
 245:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           readFloatSerial();
 10106              		.loc 35 245 0 discriminator 2
 10107 02d4 FFF7FEFF 		bl	_Z15readFloatSerialv
 10108 02d8 611E     		subs	r1, r4, #1
 10109 02da CCB2     		uxtb	r4, r1
 244:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         for (byte values = 0; values < 6; values++) {
 10110              		.loc 35 244 0 discriminator 2
 10111 02dc 002C     		cmp	r4, #0
 10112 02de F9D1     		bne	.L592
 10113 02e0 38BD     		pop	{r3, r4, r5, pc}
 10114              	.LVL421:
 10115              	.L593:
 10116              	.LBE242:
 251:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       writeEEPROM(); // defined in DataStorage.h
 10117              		.loc 35 251 0
 10118 02e2 FFF7FEFF 		bl	_Z11writeEEPROMv
 10119              	.LBE253:
 10120              	.LBE262:
 10121              	.LBE271:
 10122              	.LBE280:
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10123              		.loc 35 294 0
 10124 02e6 BDE83840 		pop	{r3, r4, r5, lr}
 10125              	.LBB281:
 10126              	.LBB272:
 10127              	.LBB263:
 10128              	.LBB254:
 252:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       zeroIntegralError();
 10129              		.loc 35 252 0
 10130 02ea FFF7FEBF 		b	_Z17zeroIntegralErrorv
 10131              	.L570:
 259:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         validateCalibrateCommand(1);
 10132              		.loc 35 259 0
 10133 02ee 0120     		movs	r0, #1
 10134 02f0 00E0     		b	.L607
 10135              	.L571:
 263:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         validateCalibrateCommand(2);
 10136              		.loc 35 263 0
 10137 02f2 0220     		movs	r0, #2
 10138              	.L607:
 10139              	.LBE254:
 10140              	.LBE263:
 10141              	.LBE272:
 10142              	.LBE281:
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10143              		.loc 35 294 0
 10144 02f4 BDE83840 		pop	{r3, r4, r5, lr}
 10145              	.LBB282:
 10146              	.LBB273:
 10147              	.LBB264:
 10148              	.LBB255:
 263:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         validateCalibrateCommand(2);
 10149              		.loc 35 263 0
 10150 02f8 FFF7FEBF 		b	_Z24validateCalibrateCommandh
 10151              	.L572:
 267:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       if (validateCalibrateCommand(3)) {
 10152              		.loc 35 267 0
 10153 02fc 0320     		movs	r0, #3
 10154 02fe FFF7FEFF 		bl	_Z24validateCalibrateCommandh
 10155 0302 0028     		cmp	r0, #0
 10156 0304 3AD0     		beq	.L568
 268:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         testCommand = readFloatSerial();
 10157              		.loc 35 268 0
 10158 0306 FFF7FEFF 		bl	_Z15readFloatSerialv
 10159 030a 00EE900A 		fmsr	s1, r0
 10160 030e 1F4A     		ldr	r2, .L612+12
 10161 0310 BDEEE07A 		ftosizs	s14, s1
 10162 0314 82ED007A 		fsts	s14, [r2, #0]	@ int
 10163 0318 38BD     		pop	{r3, r4, r5, pc}
 10164              	.L573:
 273:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       if (validateCalibrateCommand(4)) {
 10165              		.loc 35 273 0
 10166 031a 0420     		movs	r0, #4
 10167 031c FFF7FEFF 		bl	_Z24validateCalibrateCommandh
 10168 0320 0028     		cmp	r0, #0
 10169 0322 2BD0     		beq	.L568
 274:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         calibrateESC = 0;
 10170              		.loc 35 274 0
 10171 0324 1A4A     		ldr	r2, .L612+16
 275:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         testCommand = 1000;
 10172              		.loc 35 275 0
 10173 0326 194B     		ldr	r3, .L612+12
 274:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         calibrateESC = 0;
 10174              		.loc 35 274 0
 10175 0328 0021     		movs	r1, #0
 275:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         testCommand = 1000;
 10176              		.loc 35 275 0
 10177 032a 4FF47A70 		mov	r0, #1000
 274:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         calibrateESC = 0;
 10178              		.loc 35 274 0
 10179 032e 1170     		strb	r1, [r2, #0]
 275:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         testCommand = 1000;
 10180              		.loc 35 275 0
 10181 0330 1860     		str	r0, [r3, #0]
 10182 0332 38BD     		pop	{r3, r4, r5, pc}
 10183              	.L574:
 10184              	.LBB243:
 280:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       if (validateCalibrateCommand(5)) {
 10185              		.loc 35 280 0
 10186 0334 0520     		movs	r0, #5
 10187 0336 FFF7FEFF 		bl	_Z24validateCalibrateCommandh
 10188 033a F8B1     		cbz	r0, .L568
 10189 033c 0024     		movs	r4, #0
 10190              	.L597:
 10191              	.LBB244:
 282:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           motorConfiguratorCommand[motor] = (int)readFloatSerial();
 10192              		.loc 35 282 0 discriminator 2
 10193 033e FFF7FEFF 		bl	_Z15readFloatSerialv
 10194 0342 01EE900A 		fmsr	s3, r0
 10195 0346 BDEEE11A 		ftosizs	s2, s3
 10196 034a 124B     		ldr	r3, .L612+20
 10197 034c 11EE100A 		fmrs	r0, s2	@ int
 10198 0350 E050     		str	r0, [r4, r3]
 10199 0352 0434     		adds	r4, r4, #4
 281:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         for (byte motor = 0; motor < LASTMOTOR; motor++)
 10200              		.loc 35 281 0 discriminator 2
 10201 0354 102C     		cmp	r4, #16
 10202 0356 F2D1     		bne	.L597
 10203 0358 38BD     		pop	{r3, r4, r5, pc}
 10204              	.LVL422:
 10205              	.L594:
 10206              	.LBE244:
 10207              	.LBE243:
 287:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       if (readFloatSerial() == 1.0)
 10208              		.loc 35 287 0
 10209 035a FFF7FEFF 		bl	_Z15readFloatSerialv
 10210 035e 02EE100A 		fmsr	s4, r0
 10211 0362 F7EE002A 		fconsts	s5, #112
 10212 0366 B4EE622A 		fcmps	s4, s5
 10213 036a F1EE10FA 		fmstat
 10214 036e 0A4B     		ldr	r3, .L612+24
 10215 0370 02D1     		bne	.L598
 288:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         fastTransfer = ON;
 10216              		.loc 35 288 0
 10217 0372 0121     		movs	r1, #1
 10218 0374 1970     		strb	r1, [r3, #0]
 10219 0376 38BD     		pop	{r3, r4, r5, pc}
 10220              	.L598:
 290:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         fastTransfer = OFF;
 10221              		.loc 35 290 0
 10222 0378 0022     		movs	r2, #0
 10223 037a 1A70     		strb	r2, [r3, #0]
 10224              	.L568:
 10225 037c 38BD     		pop	{r3, r4, r5, pc}
 10226              	.L613:
 10227 037e 00BF     		.align	2
 10228              	.L612:
 10229 0380 00000000 		.word	.LANCHOR133
 10230 0384 00000000 		.word	.LANCHOR134
 10231 0388 00000000 		.word	.LANCHOR135
 10232 038c 00000000 		.word	.LANCHOR117
 10233 0390 00000000 		.word	.LANCHOR116
 10234 0394 00000000 		.word	.LANCHOR118
 10235 0398 00000000 		.word	.LANCHOR141
 10236              	.LBE255:
 10237              	.LBE264:
 10238              	.LBE273:
 10239              	.LBE282:
 10240              		.cfi_endproc
 10241              	.LFE238:
 10243              		.section	.text._Z5commav,"ax",%progbits
 10244              		.align	1
 10245              		.global	_Z5commav
 10246              		.thumb
 10247              		.thumb_func
 10249              	_Z5commav:
 10250              	.LFB251:
 694:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 695:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void comma() {
 10251              		.loc 35 695 0
 10252              		.cfi_startproc
 10253              		@ args = 0, pretend = 0, frame = 0
 10254              		@ frame_needed = 0, uses_anonymous_args = 0
 10255              		@ link register save eliminated.
 696:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(',');
 10256              		.loc 35 696 0
 10257 0000 0148     		ldr	r0, .L615
 10258 0002 2C21     		movs	r1, #44
 697:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10259              		.loc 35 697 0
 696:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(',');
 10260              		.loc 35 696 0
 10261 0004 FFF7FEBF 		b	_ZN5Print5printEc
 10262              	.L616:
 10263              		.align	2
 10264              	.L615:
 10265 0008 00000000 		.word	SerialUSB
 10266              		.cfi_endproc
 10267              	.LFE251:
 10269              		.section	.text._Z15PrintValueCommal,"ax",%progbits
 10270              		.align	1
 10271              		.global	_Z15PrintValueCommal
 10272              		.thumb
 10273              		.thumb_func
 10275              	_Z15PrintValueCommal:
 10276              	.LFB245:
 333:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 10277              		.loc 35 333 0
 10278              		.cfi_startproc
 10279              		@ args = 0, pretend = 0, frame = 0
 10280              		@ frame_needed = 0, uses_anonymous_args = 0
 10281              	.LVL423:
 10282 0000 08B5     		push	{r3, lr}
 10283              	.LCFI99:
 10284              		.cfi_def_cfa_offset 8
 10285              		.cfi_offset 14, -4
 10286              		.cfi_offset 3, -8
 333:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 10287              		.loc 35 333 0
 10288 0002 0146     		mov	r1, r0
 334:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 10289              		.loc 35 334 0
 10290 0004 0A22     		movs	r2, #10
 10291 0006 0348     		ldr	r0, .L618
 10292              	.LVL424:
 10293 0008 FFF7FEFF 		bl	_ZN5Print5printEli
 10294              	.LVL425:
 336:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10295              		.loc 35 336 0
 10296 000c BDE80840 		pop	{r3, lr}
 335:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 10297              		.loc 35 335 0
 10298 0010 FFF7FEBF 		b	_Z5commav
 10299              	.L619:
 10300              		.align	2
 10301              	.L618:
 10302 0014 00000000 		.word	SerialUSB
 10303              		.cfi_endproc
 10304              	.LFE245:
 10306              		.section	.text._Z15PrintValueCommah,"ax",%progbits
 10307              		.align	1
 10308              		.global	_Z15PrintValueCommah
 10309              		.thumb
 10310              		.thumb_func
 10312              	_Z15PrintValueCommah:
 10313              	.LFB244:
 327:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 10314              		.loc 35 327 0
 10315              		.cfi_startproc
 10316              		@ args = 0, pretend = 0, frame = 0
 10317              		@ frame_needed = 0, uses_anonymous_args = 0
 10318              	.LVL426:
 10319 0000 08B5     		push	{r3, lr}
 10320              	.LCFI100:
 10321              		.cfi_def_cfa_offset 8
 10322              		.cfi_offset 14, -4
 10323              		.cfi_offset 3, -8
 327:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 10324              		.loc 35 327 0
 10325 0002 0146     		mov	r1, r0
 328:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 10326              		.loc 35 328 0
 10327 0004 0A22     		movs	r2, #10
 10328 0006 0348     		ldr	r0, .L621
 10329              	.LVL427:
 10330 0008 FFF7FEFF 		bl	_ZN5Print5printEhi
 330:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10331              		.loc 35 330 0
 10332 000c BDE80840 		pop	{r3, lr}
 329:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 10333              		.loc 35 329 0
 10334 0010 FFF7FEBF 		b	_Z5commav
 10335              	.L622:
 10336              		.align	2
 10337              	.L621:
 10338 0014 00000000 		.word	SerialUSB
 10339              		.cfi_endproc
 10340              	.LFE244:
 10342              		.section	.text._Z15PrintValueCommam,"ax",%progbits
 10343              		.align	1
 10344              		.global	_Z15PrintValueCommam
 10345              		.thumb
 10346              		.thumb_func
 10348              	_Z15PrintValueCommam:
 10349              	.LFB243:
 321:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 10350              		.loc 35 321 0
 10351              		.cfi_startproc
 10352              		@ args = 0, pretend = 0, frame = 0
 10353              		@ frame_needed = 0, uses_anonymous_args = 0
 10354              	.LVL428:
 10355 0000 08B5     		push	{r3, lr}
 10356              	.LCFI101:
 10357              		.cfi_def_cfa_offset 8
 10358              		.cfi_offset 14, -4
 10359              		.cfi_offset 3, -8
 321:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 10360              		.loc 35 321 0
 10361 0002 0146     		mov	r1, r0
 322:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 10362              		.loc 35 322 0
 10363 0004 0A22     		movs	r2, #10
 10364 0006 0348     		ldr	r0, .L624
 10365              	.LVL429:
 10366 0008 FFF7FEFF 		bl	_ZN5Print5printEmi
 10367              	.LVL430:
 324:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10368              		.loc 35 324 0
 10369 000c BDE80840 		pop	{r3, lr}
 323:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 10370              		.loc 35 323 0
 10371 0010 FFF7FEBF 		b	_Z5commav
 10372              	.L625:
 10373              		.align	2
 10374              	.L624:
 10375 0014 00000000 		.word	SerialUSB
 10376              		.cfi_endproc
 10377              	.LFE243:
 10379              		.section	.text._Z15PrintValueCommai,"ax",%progbits
 10380              		.align	1
 10381              		.global	_Z15PrintValueCommai
 10382              		.thumb
 10383              		.thumb_func
 10385              	_Z15PrintValueCommai:
 10386              	.LFB242:
 315:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(int val) {
 10387              		.loc 35 315 0
 10388              		.cfi_startproc
 10389              		@ args = 0, pretend = 0, frame = 0
 10390              		@ frame_needed = 0, uses_anonymous_args = 0
 10391              	.LVL431:
 10392 0000 08B5     		push	{r3, lr}
 10393              	.LCFI102:
 10394              		.cfi_def_cfa_offset 8
 10395              		.cfi_offset 14, -4
 10396              		.cfi_offset 3, -8
 315:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(int val) {
 10397              		.loc 35 315 0
 10398 0002 0146     		mov	r1, r0
 316:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 10399              		.loc 35 316 0
 10400 0004 0A22     		movs	r2, #10
 10401 0006 0348     		ldr	r0, .L627
 10402              	.LVL432:
 10403 0008 FFF7FEFF 		bl	_ZN5Print5printEii
 10404              	.LVL433:
 318:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10405              		.loc 35 318 0
 10406 000c BDE80840 		pop	{r3, lr}
 317:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 10407              		.loc 35 317 0
 10408 0010 FFF7FEBF 		b	_Z5commav
 10409              	.L628:
 10410              		.align	2
 10411              	.L627:
 10412 0014 00000000 		.word	SerialUSB
 10413              		.cfi_endproc
 10414              	.LFE242:
 10416              		.section	.text._Z15PrintValueCommac,"ax",%progbits
 10417              		.align	1
 10418              		.global	_Z15PrintValueCommac
 10419              		.thumb
 10420              		.thumb_func
 10422              	_Z15PrintValueCommac:
 10423              	.LFB241:
 310:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(char val) {
 10424              		.loc 35 310 0
 10425              		.cfi_startproc
 10426              		@ args = 0, pretend = 0, frame = 0
 10427              		@ frame_needed = 0, uses_anonymous_args = 0
 10428              	.LVL434:
 10429 0000 08B5     		push	{r3, lr}
 10430              	.LCFI103:
 10431              		.cfi_def_cfa_offset 8
 10432              		.cfi_offset 14, -4
 10433              		.cfi_offset 3, -8
 310:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(char val) {
 10434              		.loc 35 310 0
 10435 0002 0146     		mov	r1, r0
 311:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 10436              		.loc 35 311 0
 10437 0004 0348     		ldr	r0, .L630
 10438              	.LVL435:
 10439 0006 FFF7FEFF 		bl	_ZN5Print5printEc
 313:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10440              		.loc 35 313 0
 10441 000a BDE80840 		pop	{r3, lr}
 312:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 10442              		.loc 35 312 0
 10443 000e FFF7FEBF 		b	_Z5commav
 10444              	.L631:
 10445 0012 00BF     		.align	2
 10446              	.L630:
 10447 0014 00000000 		.word	SerialUSB
 10448              		.cfi_endproc
 10449              	.LFE241:
 10451              		.section	.text._Z15PrintValueCommad,"ax",%progbits
 10452              		.align	1
 10453              		.global	_Z15PrintValueCommad
 10454              		.thumb
 10455              		.thumb_func
 10457              	_Z15PrintValueCommad:
 10458              	.LFB240:
 305:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(double val) {
 10459              		.loc 35 305 0
 10460              		.cfi_startproc
 10461              		@ args = 0, pretend = 0, frame = 0
 10462              		@ frame_needed = 0, uses_anonymous_args = 0
 10463              	.LVL436:
 10464 0000 07B5     		push	{r0, r1, r2, lr}
 10465              	.LCFI104:
 10466              		.cfi_def_cfa_offset 16
 10467              		.cfi_offset 14, -4
 10468              		.cfi_offset 2, -8
 10469              		.cfi_offset 1, -12
 10470              		.cfi_offset 0, -16
 305:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(double val) {
 10471              		.loc 35 305 0
 10472 0002 0B46     		mov	r3, r1
 10473 0004 0246     		mov	r2, r0
 306:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 10474              		.loc 35 306 0
 10475 0006 0221     		movs	r1, #2
 10476 0008 0448     		ldr	r0, .L633
 10477              	.LVL437:
 10478 000a 0091     		str	r1, [sp, #0]
 10479 000c FFF7FEFF 		bl	_ZN5Print5printEdi
 308:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10480              		.loc 35 308 0
 10481 0010 03B0     		add	sp, sp, #12
 10482 0012 5DF804EB 		pop	{lr}
 307:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 10483              		.loc 35 307 0
 10484 0016 FFF7FEBF 		b	_Z5commav
 10485              	.L634:
 10486 001a 00BF     		.align	2
 10487              	.L633:
 10488 001c 00000000 		.word	SerialUSB
 10489              		.cfi_endproc
 10490              	.LFE240:
 10492              		.section	.text._Z15PrintValueCommaf,"ax",%progbits
 10493              		.align	1
 10494              		.global	_Z15PrintValueCommaf
 10495              		.thumb
 10496              		.thumb_func
 10498              	_Z15PrintValueCommaf:
 10499              	.LFB239:
 300:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(float val) {
 10500              		.loc 35 300 0
 10501              		.cfi_startproc
 10502              		@ args = 0, pretend = 0, frame = 0
 10503              		@ frame_needed = 0, uses_anonymous_args = 0
 10504              	.LVL438:
 10505 0000 07B5     		push	{r0, r1, r2, lr}
 10506              	.LCFI105:
 10507              		.cfi_def_cfa_offset 16
 10508              		.cfi_offset 14, -4
 10509              		.cfi_offset 2, -8
 10510              		.cfi_offset 1, -12
 10511              		.cfi_offset 0, -16
 301:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 10512              		.loc 35 301 0
 10513 0002 FFF7FEFF 		bl	__aeabi_f2d
 10514              	.LVL439:
 10515 0006 0246     		mov	r2, r0
 10516 0008 0B46     		mov	r3, r1
 10517 000a 0548     		ldr	r0, .L636
 10518 000c 0221     		movs	r1, #2
 10519 000e 0091     		str	r1, [sp, #0]
 10520 0010 FFF7FEFF 		bl	_ZN5Print5printEdi
 303:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10521              		.loc 35 303 0
 10522 0014 03B0     		add	sp, sp, #12
 10523 0016 5DF804EB 		pop	{lr}
 302:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 10524              		.loc 35 302 0
 10525 001a FFF7FEBF 		b	_Z5commav
 10526              	.L637:
 10527 001e 00BF     		.align	2
 10528              	.L636:
 10529 0020 00000000 		.word	SerialUSB
 10530              		.cfi_endproc
 10531              	.LFE239:
 10533              		.section	.text._Z8PrintPIDh,"ax",%progbits
 10534              		.align	1
 10535              		.global	_Z8PrintPIDh
 10536              		.thumb
 10537              		.thumb_func
 10539              	_Z8PrintPIDh:
 10540              	.LFB246:
 339:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 10541              		.loc 35 339 0
 10542              		.cfi_startproc
 10543              		@ args = 0, pretend = 0, frame = 0
 10544              		@ frame_needed = 0, uses_anonymous_args = 0
 10545              	.LVL440:
 340:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   PrintValueComma(PID[IDPid].P);
 10546              		.loc 35 340 0
 10547 0000 074B     		ldr	r3, .L639
 339:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 10548              		.loc 35 339 0
 10549 0002 10B5     		push	{r4, lr}
 10550              	.LCFI106:
 10551              		.cfi_def_cfa_offset 8
 10552              		.cfi_offset 14, -4
 10553              		.cfi_offset 4, -8
 340:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   PrintValueComma(PID[IDPid].P);
 10554              		.loc 35 340 0
 10555 0004 1C24     		movs	r4, #28
 10556 0006 04FB0034 		mla	r4, r4, r0, r3
 10557 000a 2068     		ldr	r0, [r4, #0]	@ float
 10558              	.LVL441:
 10559 000c FFF7FEFF 		bl	_Z15PrintValueCommaf
 341:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   PrintValueComma(PID[IDPid].I);
 10560              		.loc 35 341 0
 10561 0010 6068     		ldr	r0, [r4, #4]	@ float
 10562 0012 FFF7FEFF 		bl	_Z15PrintValueCommaf
 342:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   PrintValueComma(PID[IDPid].D);
 10563              		.loc 35 342 0
 10564 0016 A068     		ldr	r0, [r4, #8]	@ float
 343:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10565              		.loc 35 343 0
 10566 0018 BDE81040 		pop	{r4, lr}
 342:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   PrintValueComma(PID[IDPid].D);
 10567              		.loc 35 342 0
 10568 001c FFF7FEBF 		b	_Z15PrintValueCommaf
 10569              	.L640:
 10570              		.align	2
 10571              	.L639:
 10572 0020 00000000 		.word	.LANCHOR17
 10573              		.cfi_endproc
 10574              	.LFE246:
 10576              		.section	.text._Z17printVehicleStatePKcmS0_,"ax",%progbits
 10577              		.align	1
 10578              		.global	_Z17printVehicleStatePKcmS0_
 10579              		.thumb
 10580              		.thumb_func
 10582              	_Z17printVehicleStatePKcmS0_:
 10583              	.LFB252:
 698:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 699:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 700:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** #ifdef BinaryWrite
 701:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void printInt(int data) {
 702:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   byte msb, lsb;
 703:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 704:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   msb = data >> 8;
 705:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   lsb = data & 0xff;
 706:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 707:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(msb);
 708:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(lsb);
 709:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 710:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 711:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void sendBinaryFloat(float data) {
 712:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   union binaryFloatType {
 713:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     byte floatByte[4];
 714:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     float floatVal;
 715:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   } binaryFloat;
 716:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 717:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryFloat.floatVal = data;
 718:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(binaryFloat.floatByte[3]);
 719:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(binaryFloat.floatByte[2]);
 720:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(binaryFloat.floatByte[1]);
 721:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(binaryFloat.floatByte[0]);
 722:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 723:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 724:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void sendBinaryuslong(unsigned long data) {
 725:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   union binaryuslongType {
 726:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     byte uslongByte[4];
 727:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     unsigned long uslongVal;
 728:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   } binaryuslong;
 729:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 730:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryuslong.uslongVal = data;
 731:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(binaryuslong.uslongByte[3]);
 732:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(binaryuslong.uslongByte[2]);
 733:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(binaryuslong.uslongByte[1]);
 734:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(binaryuslong.uslongByte[0]);
 735:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 736:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 737:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 738:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void fastTelemetry()
 739:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** {
 740:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // **************************************************************
 741:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // ***************** Fast Transfer Of Sensor Data ***************
 742:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // **************************************************************
 743:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // AeroQuad.h defines the output rate to be 10ms
 744:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // Since writing to UART is done by hardware, unable to measure data rate directly
 745:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // Through analysis:  115200 baud = 115200 bits/second = 14400 bytes/second
 746:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // If float = 4 bytes, then 3600 floats/second
 747:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // If 10 ms output rate, then 36 floats/10ms
 748:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // Number of floats written using sendBinaryFloat is 15
 749:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 750:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   if (motorArmed == ON) {
 751:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #ifdef OpenlogBinaryWrite
 752:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        printInt(21845); // Start word of 0x5555
 753:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        sendBinaryuslong(currentTime);
 754:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         printInt((int)flightMode);
 755:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 756:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(gyroRate[axis]);
 757:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        }
 758:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 759:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(meterPerSecSec[axis]);
 760:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        }
 761:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        sendBinaryFloat(accelOneG);
 762:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        #ifdef HeadingMagHold
 763:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           sendBinaryFloat(hdgX);
 764:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           sendBinaryFloat(hdgY);
 765:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 		  for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 766:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 		       #if defined(HeadingMagHold)
 767:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 			      sendBinaryFloat(getMagnetometerData(axis));
 768:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 		       #endif
 769:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           }  
 770:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        #else
 771:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(0.0);
 772:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(0.0);
 773:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(0.0);
 774:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        #endif
 775:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 776:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****           sendBinaryFloat(kinematicsAngle[axis]);
 777:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         }
 778:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         printInt(32767); // Stop word of 0x7FFF
 779:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 780:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        printInt(21845); // Start word of 0x5555
 781:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 782:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(gyroRate[axis]);
 783:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        }
 784:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 785:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(meterPerSecSec[axis]);
 786:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        }
 787:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++)
 788:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        #if defined(HeadingMagHold)
 789:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(getMagnetometerData(axis));
 790:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        #else
 791:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(0);
 792:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        #endif
 793:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 794:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(getGyroUnbias(axis));
 795:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        }
 796:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 797:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(kinematicsAngle[axis]);
 798:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        }
 799:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****        printInt(32767); // Stop word of 0x7FFF
 800:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 801:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   }
 802:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 803:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** #endif // BinaryWrite
 804:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 805:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void printVehicleState(const char *sensorName, unsigned long state, const char *message) {
 10584              		.loc 35 805 0
 10585              		.cfi_startproc
 10586              		@ args = 0, pretend = 0, frame = 0
 10587              		@ frame_needed = 0, uses_anonymous_args = 0
 10588              	.LVL442:
 10589 0000 8446     		mov	ip, r0
 10590 0002 38B5     		push	{r3, r4, r5, lr}
 10591              	.LCFI107:
 10592              		.cfi_def_cfa_offset 16
 10593              		.cfi_offset 14, -4
 10594              		.cfi_offset 5, -8
 10595              		.cfi_offset 4, -12
 10596              		.cfi_offset 3, -16
 806:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(sensorName);
 10597              		.loc 35 806 0
 10598 0004 0B48     		ldr	r0, .L643
 10599              	.LVL443:
 805:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void printVehicleState(const char *sensorName, unsigned long state, const char *message) {
 10600              		.loc 35 805 0
 10601 0006 0C46     		mov	r4, r1
 10602              		.loc 35 806 0
 10603 0008 6146     		mov	r1, ip
 10604              	.LVL444:
 805:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void printVehicleState(const char *sensorName, unsigned long state, const char *message) {
 10605              		.loc 35 805 0
 10606 000a 1546     		mov	r5, r2
 10607              		.loc 35 806 0
 10608 000c FFF7FEFF 		bl	_ZN5Print5printEPKc
 10609              	.LVL445:
 807:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(": ");
 10610              		.loc 35 807 0
 10611 0010 0848     		ldr	r0, .L643
 10612 0012 0949     		ldr	r1, .L643+4
 10613 0014 FFF7FEFF 		bl	_ZN5Print5printEPKc
 808:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   if (!(vehicleState & state))
 10614              		.loc 35 808 0
 10615 0018 0848     		ldr	r0, .L643+8
 10616 001a 0368     		ldr	r3, [r0, #0]
 10617 001c 1C42     		tst	r4, r3
 10618 001e 03D1     		bne	.L642
 809:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT("Not ");
 10619              		.loc 35 809 0
 10620 0020 0448     		ldr	r0, .L643
 10621 0022 0749     		ldr	r1, .L643+12
 10622 0024 FFF7FEFF 		bl	_ZN5Print5printEPKc
 10623              	.L642:
 810:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN(message);
 10624              		.loc 35 810 0
 10625 0028 0248     		ldr	r0, .L643
 10626 002a 2946     		mov	r1, r5
 811:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10627              		.loc 35 811 0
 10628 002c BDE83840 		pop	{r3, r4, r5, lr}
 810:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN(message);
 10629              		.loc 35 810 0
 10630 0030 FFF7FEBF 		b	_ZN5Print7printlnEPKc
 10631              	.L644:
 10632              		.align	2
 10633              	.L643:
 10634 0034 00000000 		.word	SerialUSB
 10635 0038 94000000 		.word	.LC6
 10636 003c 00000000 		.word	.LANCHOR21
 10637 0040 97000000 		.word	.LC7
 10638              		.cfi_endproc
 10639              	.LFE252:
 10641              		.section	.text._Z18reportVehicleStatev,"ax",%progbits
 10642              		.align	1
 10643              		.global	_Z18reportVehicleStatev
 10644              		.thumb
 10645              		.thumb_func
 10647              	_Z18reportVehicleStatev:
 10648              	.LFB253:
 812:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** 
 813:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void reportVehicleState() {
 10649              		.loc 35 813 0
 10650              		.cfi_startproc
 10651              		@ args = 0, pretend = 0, frame = 0
 10652              		@ frame_needed = 0, uses_anonymous_args = 0
 10653 0000 13B5     		push	{r0, r1, r4, lr}
 10654              	.LCFI108:
 10655              		.cfi_def_cfa_offset 16
 10656              		.cfi_offset 14, -4
 10657              		.cfi_offset 4, -8
 10658              		.cfi_offset 1, -12
 10659              		.cfi_offset 0, -16
 814:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // Tell Configurator how many vehicle state values to expect
 815:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN(14);
 10660              		.loc 35 815 0
 10661 0002 0A22     		movs	r2, #10
 10662 0004 0E21     		movs	r1, #14
 10663 0006 3448     		ldr	r0, .L646+8
 10664 0008 FFF7FEFF 		bl	_ZN5Print7printlnEii
 816:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT("Software Version: ");
 10665              		.loc 35 816 0
 10666 000c 3349     		ldr	r1, .L646+12
 10667 000e 3248     		ldr	r0, .L646+8
 10668 0010 FFF7FEFF 		bl	_ZN5Print5printEPKc
 817:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN(SOFTWARE_VERSION, 1);
 10669              		.loc 35 817 0
 10670 0014 0124     		movs	r4, #1
 10671 0016 2EA3     		adr	r3, .L646
 10672 0018 D3E90023 		ldrd	r2, [r3]
 10673 001c 2E48     		ldr	r0, .L646+8
 10674 001e 0094     		str	r4, [sp, #0]
 10675 0020 FFF7FEFF 		bl	_ZN5Print7printlnEdi
 818:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT("Board Type: ");
 10676              		.loc 35 818 0
 10677 0024 2C48     		ldr	r0, .L646+8
 10678 0026 2E49     		ldr	r1, .L646+16
 10679 0028 FFF7FEFF 		bl	_ZN5Print5printEPKc
 819:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #if defined(AeroQuad_v1)
 820:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("v1.x");
 821:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuad_v1_IDG)
 822:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("v1.x IDG");
 823:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuadMega_v1)
 824:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Mega v1.x");
 825:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuad_v18)
 826:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("v1.8 and greater");
 827:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuadMega_v2)
 828:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Mega v2");
 829:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuadMega_v21)
 830:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Mega v21");
 831:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuadMega_v21)
 832:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("AutoNav");
 833:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AutonavShield)
 834:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("AutonavShield");
 835:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuad_Wii)
 836:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Wii");
 837:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuadMega_Wii)
 838:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Mega Wii");
 839:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(ArduCopter)
 840:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("ArduCopter");
 841:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuadMega_CHR6DM)
 842:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("CHR6DM");
 843:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(APM_OP_CHR6DM)
 844:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("APM w/ CHR6DM");
 845:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuad_Mini)
 846:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Mini");
 847:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuadSTM32)
 848:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("STM32");    
 10680              		.loc 35 848 0
 10681 002c 2A48     		ldr	r0, .L646+8
 10682 002e 2D49     		ldr	r1, .L646+20
 10683 0030 FFF7FEFF 		bl	_ZN5Print7printlnEPKc
 849:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #endif
 850:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT("Flight Config: ");
 10684              		.loc 35 850 0
 10685 0034 2848     		ldr	r0, .L646+8
 10686 0036 2C49     		ldr	r1, .L646+24
 10687 0038 FFF7FEFF 		bl	_ZN5Print5printEPKc
 851:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #if defined(quadPlusConfig)
 852:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Quad +");
 853:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(quadXConfig) 
 854:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Quad X");
 10688              		.loc 35 854 0
 10689 003c 2648     		ldr	r0, .L646+8
 10690 003e 2B49     		ldr	r1, .L646+28
 10691 0040 FFF7FEFF 		bl	_ZN5Print7printlnEPKc
 855:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined (quadY4Config)
 856:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Quad Y4");
 857:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined (triConfig)
 858:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Tri");
 859:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(hexPlusConfig)
 860:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Hex +");
 861:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(hexXConfig)
 862:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Hex X");
 863:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(hexY6Config)
 864:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Hex Y6");
 865:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(octoX8Config)
 866:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Octo X8");
 867:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(octoXConfig)
 868:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Octo X");
 869:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   // *** For next rev, updat OctoPlus config name here and in Configurator
 870:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(octoPlusConfig)
 871:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Octo X+");
 872:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   #endif
 873:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT("Receiver Channels: ");
 10692              		.loc 35 873 0
 10693 0044 2448     		ldr	r0, .L646+8
 10694 0046 2A49     		ldr	r1, .L646+32
 10695 0048 FFF7FEFF 		bl	_ZN5Print5printEPKc
 874:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN(LASTCHANNEL);
 10696              		.loc 35 874 0
 10697 004c 0A22     		movs	r2, #10
 10698 004e 0821     		movs	r1, #8
 10699 0050 2148     		ldr	r0, .L646+8
 10700 0052 FFF7FEFF 		bl	_ZN5Print7printlnEii
 875:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT("Motors: ");
 10701              		.loc 35 875 0
 10702 0056 2048     		ldr	r0, .L646+8
 10703 0058 2649     		ldr	r1, .L646+36
 10704 005a FFF7FEFF 		bl	_ZN5Print5printEPKc
 876:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN(LASTMOTOR);
 10705              		.loc 35 876 0
 10706 005e 0421     		movs	r1, #4
 10707 0060 0A22     		movs	r2, #10
 10708 0062 1D48     		ldr	r0, .L646+8
 10709 0064 FFF7FEFF 		bl	_ZN5Print7printlnEii
 877:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Gyroscope", GYRO_DETECTED, "Detected");
 10710              		.loc 35 877 0
 10711 0068 2146     		mov	r1, r4
 10712 006a 2348     		ldr	r0, .L646+40
 10713 006c 234A     		ldr	r2, .L646+44
 10714 006e FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 878:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Accelerometer", ACCEL_DETECTED, "Detected");
 10715              		.loc 35 878 0
 10716 0072 0221     		movs	r1, #2
 10717 0074 2248     		ldr	r0, .L646+48
 10718 0076 214A     		ldr	r2, .L646+44
 10719 0078 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 879:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Barometer", BARO_DETECTED, "Detected");
 10720              		.loc 35 879 0
 10721 007c 0821     		movs	r1, #8
 10722 007e 2148     		ldr	r0, .L646+52
 10723 0080 1E4A     		ldr	r2, .L646+44
 10724 0082 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 880:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Magnetometer", MAG_DETECTED, "Detected");
 10725              		.loc 35 880 0
 10726 0086 0421     		movs	r1, #4
 10727 0088 1F48     		ldr	r0, .L646+56
 10728 008a 1C4A     		ldr	r2, .L646+44
 10729 008c FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 881:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Heading Hold", HEADINGHOLD_ENABLED, "Enabled");
 10730              		.loc 35 881 0
 10731 0090 1021     		movs	r1, #16
 10732 0092 1E48     		ldr	r0, .L646+60
 10733 0094 1E4A     		ldr	r2, .L646+64
 10734 0096 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 882:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Altitude Hold", ALTITUDEHOLD_ENABLED, "Enabled");
 10735              		.loc 35 882 0
 10736 009a 2021     		movs	r1, #32
 10737 009c 1D48     		ldr	r0, .L646+68
 10738 009e 1C4A     		ldr	r2, .L646+64
 10739 00a0 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 883:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Battery Monitor", BATTMONITOR_ENABLED, "Enabled");
 10740              		.loc 35 883 0
 10741 00a4 4021     		movs	r1, #64
 10742 00a6 1C48     		ldr	r0, .L646+72
 10743 00a8 194A     		ldr	r2, .L646+64
 10744 00aa FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 884:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Camera Stability", CAMERASTABLE_ENABLED, "Enabled");
 10745              		.loc 35 884 0
 10746 00ae 8021     		movs	r1, #128
 10747 00b0 1A48     		ldr	r0, .L646+76
 10748 00b2 174A     		ldr	r2, .L646+64
 10749 00b4 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 885:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Range Detection", RANGE_ENABLED, "Enabled");
 10750              		.loc 35 885 0
 10751 00b8 1948     		ldr	r0, .L646+80
 10752 00ba 154A     		ldr	r2, .L646+64
 10753 00bc 4FF48071 		mov	r1, #256
 886:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 10754              		.loc 35 886 0
 10755 00c0 02B0     		add	sp, sp, #8
 10756 00c2 BDE81040 		pop	{r4, lr}
 885:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Range Detection", RANGE_ENABLED, "Enabled");
 10757              		.loc 35 885 0
 10758 00c6 FFF7FEBF 		b	_Z17printVehicleStatePKcmS0_
 10759              	.L647:
 10760 00ca 00BFAFF3 		.align	3
 10760      0080
 10761              	.L646:
 10762 00d0 000000C0 		.word	-1073741824
 10763 00d4 CCCC0840 		.word	1074318540
 10764 00d8 00000000 		.word	SerialUSB
 10765 00dc 9C000000 		.word	.LC8
 10766 00e0 AF000000 		.word	.LC9
 10767 00e4 BC000000 		.word	.LC10
 10768 00e8 C2000000 		.word	.LC11
 10769 00ec D2000000 		.word	.LC12
 10770 00f0 D9000000 		.word	.LC13
 10771 00f4 ED000000 		.word	.LC14
 10772 00f8 F6000000 		.word	.LC15
 10773 00fc 00010000 		.word	.LC16
 10774 0100 09010000 		.word	.LC17
 10775 0104 17010000 		.word	.LC18
 10776 0108 21010000 		.word	.LC19
 10777 010c 2E010000 		.word	.LC20
 10778 0110 3B010000 		.word	.LC21
 10779 0114 43010000 		.word	.LC22
 10780 0118 51010000 		.word	.LC23
 10781 011c 61010000 		.word	.LC24
 10782 0120 72010000 		.word	.LC25
 10783              		.cfi_endproc
 10784              	.LFE253:
 10786 0124 AFF30080 		.section	.text._Z19sendSerialTelemetryv,"ax",%progbits
 10787              		.align	1
 10788              		.global	_Z19sendSerialTelemetryv
 10789              		.thumb
 10790              		.thumb_func
 10792              	_Z19sendSerialTelemetryv:
 10793              	.LFB247:
 345:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void sendSerialTelemetry() {
 10794              		.loc 35 345 0
 10795              		.cfi_startproc
 10796              		@ args = 0, pretend = 0, frame = 0
 10797              		@ frame_needed = 0, uses_anonymous_args = 0
 10798 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 10799              	.LCFI109:
 10800              		.cfi_def_cfa_offset 32
 10801              		.cfi_offset 14, -4
 10802              		.cfi_offset 7, -8
 10803              		.cfi_offset 6, -12
 10804              		.cfi_offset 5, -16
 10805              		.cfi_offset 4, -20
 10806              		.cfi_offset 2, -24
 10807              		.cfi_offset 1, -28
 10808              		.cfi_offset 0, -32
 10809              	.LBB283:
 346:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   switch (queryType) {
 10810              		.loc 35 346 0
 10811 0002 8E4C     		ldr	r4, .L718
 10812 0004 2378     		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 10813 0006 6A2B     		cmp	r3, #106
 10814 0008 2646     		mov	r6, r4
 10815 000a 00F00181 		beq	.L662
 10816 000e 28D8     		bhi	.L675
 10817 0010 642B     		cmp	r3, #100
 10818 0012 00F09080 		beq	.L656
 10819 0016 12D8     		bhi	.L676
 10820 0018 612B     		cmp	r3, #97
 10821 001a 62D0     		beq	.L653
 10822 001c 09D8     		bhi	.L677
 10823 001e 232B     		cmp	r3, #35
 10824 0020 00F05782 		beq	.L651
 10825 0024 362B     		cmp	r3, #54
 10826 0026 00F05982 		beq	.L688
 10827 002a 212B     		cmp	r3, #33
 10828 002c 40F06382 		bne	.L648
 10829 0030 46E2     		b	.L711
 10830              	.L677:
 10831 0032 622B     		cmp	r3, #98
 10832 0034 60D0     		beq	.L654
 10833 0036 632B     		cmp	r3, #99
 10834 0038 40F05D82 		bne	.L648
 10835 003c 71E0     		b	.L712
 10836              	.L676:
 10837 003e 672B     		cmp	r3, #103
 10838 0040 00F0B280 		beq	.L659
 10839 0044 06D8     		bhi	.L678
 10840 0046 652B     		cmp	r3, #101
 10841 0048 00F09880 		beq	.L657
 10842 004c 662B     		cmp	r3, #102
 10843 004e 40F05282 		bne	.L648
 10844 0052 9BE0     		b	.L713
 10845              	.L678:
 10846 0054 682B     		cmp	r3, #104
 10847 0056 00F0BC80 		beq	.L660
 10848 005a 692B     		cmp	r3, #105
 10849 005c 40F04B82 		bne	.L648
 10850 0060 29E0     		b	.L714
 10851              	.L675:
 10852 0062 702B     		cmp	r3, #112
 10853 0064 00F09B81 		beq	.L689
 10854 0068 11D8     		bhi	.L679
 10855 006a 6D2B     		cmp	r3, #109
 10856 006c 00F06C81 		beq	.L665
 10857 0070 06D8     		bhi	.L680
 10858 0072 6B2B     		cmp	r3, #107
 10859 0074 00F00881 		beq	.L663
 10860 0078 6C2B     		cmp	r3, #108
 10861 007a 40F03C82 		bne	.L648
 10862 007e 44E1     		b	.L715
 10863              	.L680:
 10864 0080 6E2B     		cmp	r3, #110
 10865 0082 00F08181 		beq	.L666
 10866 0086 6F2B     		cmp	r3, #111
 10867 0088 40F03582 		bne	.L648
 10868 008c 09E2     		b	.L710
 10869              	.L679:
 10870 008e 732B     		cmp	r3, #115
 10871 0090 00F0AD81 		beq	.L671
 10872 0094 06D8     		bhi	.L681
 10873 0096 712B     		cmp	r3, #113
 10874 0098 00F08F81 		beq	.L669
 10875 009c 722B     		cmp	r3, #114
 10876 009e 40F02A82 		bne	.L648
 10877 00a2 91E1     		b	.L716
 10878              	.L681:
 10879 00a4 752B     		cmp	r3, #117
 10880 00a6 00F00282 		beq	.L704
 10881 00aa C0F0E681 		bcc	.L690
 10882 00ae 762B     		cmp	r3, #118
 10883 00b0 40F02182 		bne	.L648
 10884 00b4 EFE1     		b	.L717
 10885              	.L714:
 10886              	.LVL446:
 10887              	.LBB284:
 10888              	.LBB285:
 432:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(gyroRate[axis]);
 10889              		.loc 35 432 0 discriminator 1
 10890 00b6 624C     		ldr	r4, .L718+4
 10891 00b8 2068     		ldr	r0, [r4, #0]	@ float
 10892 00ba FFF7FEFF 		bl	_Z15PrintValueCommaf
 10893              	.LVL447:
 10894 00be 6068     		ldr	r0, [r4, #4]	@ float
 10895 00c0 FFF7FEFF 		bl	_Z15PrintValueCommaf
 10896              	.LVL448:
 10897 00c4 A068     		ldr	r0, [r4, #8]	@ float
 10898              	.LBE285:
 10899              	.LBB286:
 435:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(filteredAccel[axis]);
 10900              		.loc 35 435 0 discriminator 1
 10901 00c6 5F4C     		ldr	r4, .L718+8
 10902              	.LBE286:
 10903              	.LBB287:
 432:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(gyroRate[axis]);
 10904              		.loc 35 432 0 discriminator 1
 10905 00c8 FFF7FEFF 		bl	_Z15PrintValueCommaf
 10906              	.LVL449:
 10907              	.LBE287:
 10908              	.LBB288:
 435:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(filteredAccel[axis]);
 10909              		.loc 35 435 0 discriminator 1
 10910 00cc 2068     		ldr	r0, [r4, #0]	@ float
 10911 00ce FFF7FEFF 		bl	_Z15PrintValueCommaf
 10912              	.LVL450:
 10913 00d2 6068     		ldr	r0, [r4, #4]	@ float
 10914 00d4 FFF7FEFF 		bl	_Z15PrintValueCommaf
 10915              	.LVL451:
 10916 00d8 A068     		ldr	r0, [r4, #8]	@ float
 10917 00da FFF7FEFF 		bl	_Z15PrintValueCommaf
 10918              	.LVL452:
 10919 00de 0024     		movs	r4, #0
 10920 00e0 8CE0     		b	.L682
 10921              	.LVL453:
 10922              	.L653:
 10923              	.LBE288:
 351:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(RATE_XAXIS_PID_IDX);
 10924              		.loc 35 351 0
 10925 00e2 0020     		movs	r0, #0
 10926 00e4 FFF7FEFF 		bl	_Z8PrintPIDh
 352:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(RATE_YAXIS_PID_IDX);
 10927              		.loc 35 352 0
 10928 00e8 0120     		movs	r0, #1
 10929 00ea FFF7FEFF 		bl	_Z8PrintPIDh
 353:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(rotationSpeedFactor);
 10930              		.loc 35 353 0
 10931 00ee 564B     		ldr	r3, .L718+12
 10932 00f0 1868     		ldr	r0, [r3, #0]	@ float
 10933 00f2 FFF7FEFF 		bl	_Z15PrintValueCommaf
 10934 00f6 3DE0     		b	.L703
 10935              	.L654:
 359:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ATTITUDE_XAXIS_PID_IDX);
 10936              		.loc 35 359 0
 10937 00f8 0320     		movs	r0, #3
 10938 00fa FFF7FEFF 		bl	_Z8PrintPIDh
 360:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ATTITUDE_YAXIS_PID_IDX);
 10939              		.loc 35 360 0
 10940 00fe 0420     		movs	r0, #4
 10941 0100 FFF7FEFF 		bl	_Z8PrintPIDh
 361:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ATTITUDE_GYRO_XAXIS_PID_IDX);
 10942              		.loc 35 361 0
 10943 0104 0620     		movs	r0, #6
 10944 0106 FFF7FEFF 		bl	_Z8PrintPIDh
 362:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ATTITUDE_GYRO_YAXIS_PID_IDX);
 10945              		.loc 35 362 0
 10946 010a 0720     		movs	r0, #7
 10947 010c FFF7FEFF 		bl	_Z8PrintPIDh
 363:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(windupGuard);
 10948              		.loc 35 363 0
 10949 0110 4E48     		ldr	r0, .L718+16
 10950 0112 0068     		ldr	r0, [r0, #0]	@ float
 10951 0114 FFF7FEFF 		bl	__aeabi_f2d
 10952 0118 0B46     		mov	r3, r1
 10953 011a 0221     		movs	r1, #2
 10954 011c 0246     		mov	r2, r0
 10955 011e 0091     		str	r1, [sp, #0]
 10956 0120 30E1     		b	.L709
 10957              	.L712:
 368:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ZAXIS_PID_IDX);
 10958              		.loc 35 368 0
 10959 0122 0220     		movs	r0, #2
 10960 0124 FFF7FEFF 		bl	_Z8PrintPIDh
 369:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(HEADING_HOLD_PID_IDX);
 10961              		.loc 35 369 0
 10962 0128 0520     		movs	r0, #5
 10963 012a FFF7FEFF 		bl	_Z8PrintPIDh
 370:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN((int)headingHoldConfig);
 10964              		.loc 35 370 0
 10965 012e 484A     		ldr	r2, .L718+20
 10966 0130 4848     		ldr	r0, .L718+24
 10967 0132 1178     		ldrb	r1, [r2, #0]	@ zero_extendqisi2
 10968 0134 C0E1     		b	.L705
 10969              	.L656:
 376:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintPID(BARO_ALTITUDE_HOLD_PID_IDX);
 10970              		.loc 35 376 0
 10971 0136 0820     		movs	r0, #8
 10972 0138 FFF7FEFF 		bl	_Z8PrintPIDh
 377:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard);
 10973              		.loc 35 377 0
 10974 013c 4649     		ldr	r1, .L718+28
 10975 013e D1F8F800 		ldr	r0, [r1, #248]	@ float
 10976 0142 FFF7FEFF 		bl	_Z15PrintValueCommaf
 378:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(altitudeHoldBump);
 10977              		.loc 35 378 0
 10978 0146 454B     		ldr	r3, .L718+32
 10979 0148 1868     		ldr	r0, [r3, #0]
 10980 014a FFF7FEFF 		bl	_Z15PrintValueCommai
 379:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(altitudeHoldPanicStickMovement);
 10981              		.loc 35 379 0
 10982 014e 444A     		ldr	r2, .L718+36
 10983 0150 1068     		ldr	r0, [r2, #0]
 10984 0152 FFF7FEFF 		bl	_Z15PrintValueCommai
 380:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(minThrottleAdjust);
 10985              		.loc 35 380 0
 10986 0156 4348     		ldr	r0, .L718+40
 10987 0158 0068     		ldr	r0, [r0, #0]
 10988 015a FFF7FEFF 		bl	_Z15PrintValueCommai
 381:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(maxThrottleAdjust);
 10989              		.loc 35 381 0
 10990 015e 4249     		ldr	r1, .L718+44
 10991 0160 0868     		ldr	r0, [r1, #0]
 10992 0162 FFF7FEFF 		bl	_Z15PrintValueCommai
 383:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(baroSmoothFactor);
 10993              		.loc 35 383 0
 10994 0166 414B     		ldr	r3, .L718+48
 10995 0168 1868     		ldr	r0, [r3, #0]	@ float
 10996 016a FFF7FEFF 		bl	_Z15PrintValueCommaf
 387:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintPID(ZDAMPENING_PID_IDX);
 10997              		.loc 35 387 0
 10998 016e 0920     		movs	r0, #9
 10999 0170 FFF7FEFF 		bl	_Z8PrintPIDh
 11000              	.L703:
 393:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 11001              		.loc 35 393 0
 11002 0174 3748     		ldr	r0, .L718+24
 11003 0176 FFF7FEFF 		bl	_ZN5Print7printlnEv
 11004 017a ACE1     		b	.L700
 11005              	.L657:
 398:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(aref);
 11006              		.loc 35 398 0
 11007 017c 3C48     		ldr	r0, .L718+52
 11008 017e 0068     		ldr	r0, [r0, #0]	@ float
 11009 0180 FFF7FEFF 		bl	_Z15PrintValueCommaf
 399:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(minArmedThrottle);
 11010              		.loc 35 399 0
 11011 0184 3B4A     		ldr	r2, .L718+56
 11012 0186 3348     		ldr	r0, .L718+24
 11013 0188 1168     		ldr	r1, [r2, #0]
 11014 018a 95E1     		b	.L705
 11015              	.L713:
 404:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(receiverXmitFactor);
 11016              		.loc 35 404 0
 11017 018c 3A4D     		ldr	r5, .L718+60
 11018 018e 3B4C     		ldr	r4, .L718+64
 11019 0190 2868     		ldr	r0, [r5, #0]	@ float
 11020 0192 FFF7FEFF 		bl	_Z15PrintValueCommaf
 11021              	.LVL454:
 345:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void sendSerialTelemetry() {
 11022              		.loc 35 345 0
 11023 0196 04F12005 		add	r5, r4, #32
 11024              	.LVL455:
 11025              	.L683:
 11026              	.LBB289:
 406:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(receiverSmoothFactor[axis]);
 11027              		.loc 35 406 0 discriminator 2
 11028 019a 54F8040F 		ldr	r0, [r4, #4]!	@ float
 11029 019e FFF7FEFF 		bl	_Z15PrintValueCommaf
 405:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 11030              		.loc 35 405 0 discriminator 2
 11031 01a2 AC42     		cmp	r4, r5
 11032 01a4 F9D1     		bne	.L683
 11033 01a6 A1E1     		b	.L708
 11034              	.L659:
 11035              	.LBE289:
 410:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 11036              		.loc 35 410 0
 11037 01a8 354C     		ldr	r4, .L718+68
 345:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void sendSerialTelemetry() {
 11038              		.loc 35 345 0
 11039 01aa 04F12005 		add	r5, r4, #32
 11040              	.L684:
 11041              	.LBB290:
 414:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(receiverSlope[axis], 6);
 11042              		.loc 35 414 0 discriminator 2
 11043 01ae 54F8040F 		ldr	r0, [r4, #4]!	@ float
 11044 01b2 FFF7FEFF 		bl	__aeabi_f2d
 11045 01b6 0246     		mov	r2, r0
 11046 01b8 0B46     		mov	r3, r1
 11047 01ba 2648     		ldr	r0, .L718+24
 11048 01bc 0621     		movs	r1, #6
 11049 01be 0091     		str	r1, [sp, #0]
 11050 01c0 FFF7FEFF 		bl	_ZN5Print5printEdi
 415:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(',');
 11051              		.loc 35 415 0 discriminator 2
 11052 01c4 2C21     		movs	r1, #44
 11053 01c6 2348     		ldr	r0, .L718+24
 11054 01c8 FFF7FEFF 		bl	_ZN5Print5printEc
 413:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 11055              		.loc 35 413 0 discriminator 2
 11056 01cc AC42     		cmp	r4, r5
 11057 01ce EED1     		bne	.L684
 11058 01d0 8CE1     		b	.L708
 11059              	.LVL456:
 11060              	.L660:
 11061              	.LBE290:
 419:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 11062              		.loc 35 419 0
 11063 01d2 2C4C     		ldr	r4, .L718+72
 345:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** void sendSerialTelemetry() {
 11064              		.loc 35 345 0
 11065 01d4 04F12005 		add	r5, r4, #32
 11066              	.L685:
 11067              	.LBB291:
 423:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(receiverOffset[axis], 6);
 11068              		.loc 35 423 0 discriminator 2
 11069 01d8 54F8040F 		ldr	r0, [r4, #4]!	@ float
 11070 01dc FFF7FEFF 		bl	__aeabi_f2d
 11071 01e0 0246     		mov	r2, r0
 11072 01e2 0620     		movs	r0, #6
 11073 01e4 0B46     		mov	r3, r1
 11074 01e6 0090     		str	r0, [sp, #0]
 11075 01e8 1A48     		ldr	r0, .L718+24
 11076 01ea FFF7FEFF 		bl	_ZN5Print5printEdi
 424:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(',');
 11077              		.loc 35 424 0 discriminator 2
 11078 01ee 2C21     		movs	r1, #44
 11079 01f0 1848     		ldr	r0, .L718+24
 11080 01f2 FFF7FEFF 		bl	_ZN5Print5printEc
 422:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 11081              		.loc 35 422 0 discriminator 2
 11082 01f6 AC42     		cmp	r4, r5
 11083 01f8 EED1     		bne	.L685
 11084 01fa 77E1     		b	.L708
 11085              	.LVL457:
 11086              	.L682:
 11087              	.LBE291:
 11088              	.LBB292:
 439:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(getMagnetometerData(axis));
 11089              		.loc 35 439 0 discriminator 2
 11090 01fc 2046     		mov	r0, r4
 437:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 11091              		.loc 35 437 0 discriminator 2
 11092 01fe 0134     		adds	r4, r4, #1
 439:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(getMagnetometerData(axis));
 11093              		.loc 35 439 0 discriminator 2
 11094 0200 FFF7FEFF 		bl	_Z19getMagnetometerDatah
 437:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 11095              		.loc 35 437 0 discriminator 2
 11096 0204 E4B2     		uxtb	r4, r4
 439:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(getMagnetometerData(axis));
 11097              		.loc 35 439 0 discriminator 2
 11098 0206 FFF7FEFF 		bl	_Z15PrintValueCommai
 11099              	.LVL458:
 437:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 11100              		.loc 35 437 0 discriminator 2
 11101 020a 032C     		cmp	r4, #3
 11102 020c F6D1     		bne	.L682
 11103 020e 3CE1     		b	.L702
 11104              	.LVL459:
 11105              	.L662:
 11106              	.LBE292:
 449:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(getMagnetometerRawData(XAXIS));
 11107              		.loc 35 449 0
 11108 0210 0020     		movs	r0, #0
 11109 0212 FFF7FEFF 		bl	_Z22getMagnetometerRawDatah
 11110 0216 FFF7FEFF 		bl	_Z15PrintValueCommai
 450:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(getMagnetometerRawData(YAXIS));
 11111              		.loc 35 450 0
 11112 021a 0120     		movs	r0, #1
 11113 021c FFF7FEFF 		bl	_Z22getMagnetometerRawDatah
 11114 0220 FFF7FEFF 		bl	_Z15PrintValueCommai
 451:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(getMagnetometerRawData(ZAXIS));
 11115              		.loc 35 451 0
 11116 0224 0220     		movs	r0, #2
 11117 0226 FFF7FEFF 		bl	_Z22getMagnetometerRawDatah
 11118 022a 0146     		mov	r1, r0
 11119 022c 0948     		ldr	r0, .L718+24
 11120 022e 0A22     		movs	r2, #10
 11121              	.LBE284:
 11122              	.LBE283:
 657:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 11123              		.loc 35 657 0
 11124 0230 03B0     		add	sp, sp, #12
 11125 0232 BDE8F040 		pop	{r4, r5, r6, r7, lr}
 11126              	.LBB305:
 11127              	.LBB300:
 451:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(getMagnetometerRawData(ZAXIS));
 11128              		.loc 35 451 0
 11129 0236 FFF7FEBF 		b	_ZN5Print7printlnEii
 11130              	.L719:
 11131 023a 00BF     		.align	2
 11132              	.L718:
 11133 023c 00000000 		.word	.LANCHOR139
 11134 0240 00000000 		.word	.LANCHOR27
 11135 0244 00000000 		.word	.LANCHOR142
 11136 0248 00000000 		.word	.LANCHOR115
 11137 024c 00000000 		.word	.LANCHOR131
 11138 0250 00000000 		.word	.LANCHOR123
 11139 0254 00000000 		.word	SerialUSB
 11140 0258 00000000 		.word	.LANCHOR17
 11141 025c 00000000 		.word	.LANCHOR8
 11142 0260 00000000 		.word	.LANCHOR113
 11143 0264 00000000 		.word	.LANCHOR111
 11144 0268 00000000 		.word	.LANCHOR112
 11145 026c 00000000 		.word	.LANCHOR97
 11146 0270 00000000 		.word	.LANCHOR132
 11147 0274 00000000 		.word	.LANCHOR120
 11148 0278 00000000 		.word	.LANCHOR61
 11149 027c FCFFFFFF 		.word	.LANCHOR14-4
 11150 0280 FCFFFFFF 		.word	.LANCHOR12-4
 11151 0284 FCFFFFFF 		.word	.LANCHOR13-4
 11152              	.L663:
 456:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[XAXIS], 6);
 11153              		.loc 35 456 0
 11154 0288 9F4E     		ldr	r6, .L720+8
 458:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(runTimeAccelBias[XAXIS], 6);
 11155              		.loc 35 458 0
 11156 028a A04F     		ldr	r7, .L720+12
 456:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[XAXIS], 6);
 11157              		.loc 35 456 0
 11158 028c 3068     		ldr	r0, [r6, #0]	@ float
 11159 028e FFF7FEFF 		bl	__aeabi_f2d
 11160 0292 0625     		movs	r5, #6
 11161 0294 0246     		mov	r2, r0
 11162 0296 0B46     		mov	r3, r1
 11163 0298 9D48     		ldr	r0, .L720+16
 11164 029a 0095     		str	r5, [sp, #0]
 11165 029c FFF7FEFF 		bl	_ZN5Print5printEdi
 457:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 11166              		.loc 35 457 0
 11167 02a0 FFF7FEFF 		bl	_Z5commav
 458:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(runTimeAccelBias[XAXIS], 6);
 11168              		.loc 35 458 0
 11169 02a4 3868     		ldr	r0, [r7, #0]	@ float
 11170 02a6 FFF7FEFF 		bl	__aeabi_f2d
 11171 02aa 0246     		mov	r2, r0
 11172 02ac 0B46     		mov	r3, r1
 11173 02ae 9848     		ldr	r0, .L720+16
 11174 02b0 0095     		str	r5, [sp, #0]
 11175 02b2 FFF7FEFF 		bl	_ZN5Print5printEdi
 459:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 11176              		.loc 35 459 0
 11177 02b6 FFF7FEFF 		bl	_Z5commav
 460:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[YAXIS], 6);
 11178              		.loc 35 460 0
 11179 02ba 7068     		ldr	r0, [r6, #4]	@ float
 11180 02bc FFF7FEFF 		bl	__aeabi_f2d
 11181 02c0 0246     		mov	r2, r0
 11182 02c2 0B46     		mov	r3, r1
 11183 02c4 9248     		ldr	r0, .L720+16
 11184 02c6 0095     		str	r5, [sp, #0]
 11185 02c8 FFF7FEFF 		bl	_ZN5Print5printEdi
 461:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 11186              		.loc 35 461 0
 11187 02cc FFF7FEFF 		bl	_Z5commav
 462:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(runTimeAccelBias[YAXIS], 6);
 11188              		.loc 35 462 0
 11189 02d0 7868     		ldr	r0, [r7, #4]	@ float
 11190 02d2 FFF7FEFF 		bl	__aeabi_f2d
 11191 02d6 0246     		mov	r2, r0
 11192 02d8 0B46     		mov	r3, r1
 11193 02da 8D48     		ldr	r0, .L720+16
 11194 02dc 0095     		str	r5, [sp, #0]
 11195 02de FFF7FEFF 		bl	_ZN5Print5printEdi
 463:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 11196              		.loc 35 463 0
 11197 02e2 FFF7FEFF 		bl	_Z5commav
 464:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[ZAXIS], 6);
 11198              		.loc 35 464 0
 11199 02e6 B068     		ldr	r0, [r6, #8]	@ float
 11200 02e8 FFF7FEFF 		bl	__aeabi_f2d
 11201 02ec 0246     		mov	r2, r0
 11202 02ee 0B46     		mov	r3, r1
 11203 02f0 8748     		ldr	r0, .L720+16
 11204 02f2 0095     		str	r5, [sp, #0]
 11205 02f4 FFF7FEFF 		bl	_ZN5Print5printEdi
 465:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 11206              		.loc 35 465 0
 11207 02f8 FFF7FEFF 		bl	_Z5commav
 466:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(runTimeAccelBias[ZAXIS], 6);
 11208              		.loc 35 466 0
 11209 02fc B868     		ldr	r0, [r7, #8]	@ float
 11210 02fe FFF7FEFF 		bl	__aeabi_f2d
 11211 0302 0095     		str	r5, [sp, #0]
 11212 0304 0246     		mov	r2, r0
 11213 0306 0B46     		mov	r3, r1
 11214 0308 3CE0     		b	.L709
 11215              	.L715:
 472:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma((int)(accelSample[XAXIS]/accelSampleCount));
 11216              		.loc 35 472 0
 11217 030a 824C     		ldr	r4, .L720+20
 11218 030c 824D     		ldr	r5, .L720+24
 471:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     measureAccelSum();
 11219              		.loc 35 471 0
 11220 030e FFF7FEFF 		bl	_Z15measureAccelSumv
 472:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma((int)(accelSample[XAXIS]/accelSampleCount));
 11221              		.loc 35 472 0
 11222 0312 2668     		ldr	r6, [r4, #0]
 11223 0314 2878     		ldrb	r0, [r5, #0]	@ zero_extendqisi2
 11224 0316 96FBF0F0 		sdiv	r0, r6, r0
 11225 031a FFF7FEFF 		bl	_Z15PrintValueCommai
 474:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma((int)(accelSample[YAXIS]/accelSampleCount));
 11226              		.loc 35 474 0
 11227 031e 2B78     		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 11228 0320 6168     		ldr	r1, [r4, #4]
 473:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     accelSample[XAXIS] = 0;
 11229              		.loc 35 473 0
 11230 0322 0026     		movs	r6, #0
 474:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma((int)(accelSample[YAXIS]/accelSampleCount));
 11231              		.loc 35 474 0
 11232 0324 91FBF3F0 		sdiv	r0, r1, r3
 473:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     accelSample[XAXIS] = 0;
 11233              		.loc 35 473 0
 11234 0328 2660     		str	r6, [r4, #0]
 474:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma((int)(accelSample[YAXIS]/accelSampleCount));
 11235              		.loc 35 474 0
 11236 032a FFF7FEFF 		bl	_Z15PrintValueCommai
 476:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN ((int)(accelSample[ZAXIS]/accelSampleCount));
 11237              		.loc 35 476 0
 11238 032e A268     		ldr	r2, [r4, #8]
 11239 0330 95F800C0 		ldrb	ip, [r5, #0]	@ zero_extendqisi2
 475:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     accelSample[YAXIS] = 0;
 11240              		.loc 35 475 0
 11241 0334 6660     		str	r6, [r4, #4]
 476:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN ((int)(accelSample[ZAXIS]/accelSampleCount));
 11242              		.loc 35 476 0
 11243 0336 92FBFCF1 		sdiv	r1, r2, ip
 11244 033a 7548     		ldr	r0, .L720+16
 11245 033c 0A22     		movs	r2, #10
 11246 033e FFF7FEFF 		bl	_ZN5Print7printlnEii
 477:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     accelSample[ZAXIS] = 0;
 11247              		.loc 35 477 0
 11248 0342 A660     		str	r6, [r4, #8]
 478:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     accelSampleCount = 0;
 11249              		.loc 35 478 0
 11250 0344 2E70     		strb	r6, [r5, #0]
 479:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 11251              		.loc 35 479 0
 11252 0346 D6E0     		b	.L648
 11253              	.L665:
 483:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINT(magBias[XAXIS], 6);
 11254              		.loc 35 483 0
 11255 0348 744D     		ldr	r5, .L720+28
 11256 034a 2868     		ldr	r0, [r5, #0]	@ float
 11257 034c FFF7FEFF 		bl	__aeabi_f2d
 11258 0350 0626     		movs	r6, #6
 11259 0352 0246     		mov	r2, r0
 11260 0354 0B46     		mov	r3, r1
 11261 0356 6E48     		ldr	r0, .L720+16
 11262 0358 0096     		str	r6, [sp, #0]
 11263 035a FFF7FEFF 		bl	_ZN5Print5printEdi
 484:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       comma();
 11264              		.loc 35 484 0
 11265 035e FFF7FEFF 		bl	_Z5commav
 485:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINT(magBias[YAXIS], 6);
 11266              		.loc 35 485 0
 11267 0362 6868     		ldr	r0, [r5, #4]	@ float
 11268 0364 FFF7FEFF 		bl	__aeabi_f2d
 11269 0368 0246     		mov	r2, r0
 11270 036a 0B46     		mov	r3, r1
 11271 036c 6848     		ldr	r0, .L720+16
 11272 036e 0096     		str	r6, [sp, #0]
 11273 0370 FFF7FEFF 		bl	_ZN5Print5printEdi
 486:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       comma();
 11274              		.loc 35 486 0
 11275 0374 FFF7FEFF 		bl	_Z5commav
 487:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(magBias[ZAXIS], 6);
 11276              		.loc 35 487 0
 11277 0378 A868     		ldr	r0, [r5, #8]	@ float
 11278 037a FFF7FEFF 		bl	__aeabi_f2d
 11279 037e 0096     		str	r6, [sp, #0]
 11280 0380 0246     		mov	r2, r0
 11281 0382 0B46     		mov	r3, r1
 11282              	.L709:
 11283 0384 6248     		ldr	r0, .L720+16
 11284 0386 A1E0     		b	.L706
 11285              	.L666:
 494:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(batteryMonitorAlarmVoltage);
 11286              		.loc 35 494 0
 11287 0388 6549     		ldr	r1, .L720+32
 11288 038a 0868     		ldr	r0, [r1, #0]	@ float
 11289 038c FFF7FEFF 		bl	_Z15PrintValueCommaf
 495:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(batteryMonitorThrottleTarget);
 11290              		.loc 35 495 0
 11291 0390 644A     		ldr	r2, .L720+36
 11292 0392 1068     		ldr	r0, [r2, #0]
 11293 0394 FFF7FEFF 		bl	_Z15PrintValueCommai
 496:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(batteryMonitorGoingDownTime);
 11294              		.loc 35 496 0
 11295 0398 5D48     		ldr	r0, .L720+16
 11296 039a 634B     		ldr	r3, .L720+40
 11297 039c 0FE0     		b	.L707
 11298              	.L689:
 11299              	.LBE300:
 346:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   switch (queryType) {
 11300              		.loc 35 346 0
 11301 039e 0C24     		movs	r4, #12
 11302              	.L668:
 11303              	.LBB301:
 11304              	.LBB293:
 540:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(0);
 11305              		.loc 35 540 0 discriminator 2
 11306 03a0 013C     		subs	r4, r4, #1
 11307 03a2 0020     		movs	r0, #0
 11308 03a4 E4B2     		uxtb	r4, r4
 11309 03a6 FFF7FEFF 		bl	_Z15PrintValueCommai
 539:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       for (byte index=0; index < 12; index++) {
 11310              		.loc 35 539 0 discriminator 2
 11311 03aa 002C     		cmp	r4, #0
 11312 03ac F8D1     		bne	.L668
 11313              	.LBE293:
 542:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(0);
 11314              		.loc 35 542 0
 11315 03ae 5848     		ldr	r0, .L720+16
 11316 03b0 2146     		mov	r1, r4
 11317 03b2 0A22     		movs	r2, #10
 11318 03b4 FFF7FEFF 		bl	_ZN5Print7printlnEii
 11319 03b8 9BE0     		b	.L701
 11320              	.LVL460:
 11321              	.L669:
 548:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(vehicleState);
 11322              		.loc 35 548 0
 11323 03ba 5548     		ldr	r0, .L720+16
 11324 03bc 5B4B     		ldr	r3, .L720+44
 11325              	.L707:
 11326 03be 1968     		ldr	r1, [r3, #0]
 11327 03c0 0A22     		movs	r2, #10
 11328 03c2 FFF7FEFF 		bl	_ZN5Print7printlnEmi
 11329 03c6 86E0     		b	.L700
 11330              	.L716:
 553:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[XAXIS]);
 11331              		.loc 35 553 0
 11332 03c8 594C     		ldr	r4, .L720+48
 11333 03ca 2068     		ldr	r0, [r4, #0]	@ float
 11334 03cc FFF7FEFF 		bl	_Z15PrintValueCommaf
 554:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[YAXIS]);
 11335              		.loc 35 554 0
 11336 03d0 6068     		ldr	r0, [r4, #4]	@ float
 11337 03d2 FFF7FEFF 		bl	_Z15PrintValueCommaf
 556:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(trueNorthHeading);
 11338              		.loc 35 556 0
 11339 03d6 574B     		ldr	r3, .L720+52
 11340 03d8 1868     		ldr	r0, [r3, #0]	@ float
 11341 03da FFF7FEFF 		bl	__aeabi_f2d
 11342 03de 0246     		mov	r2, r0
 11343 03e0 0220     		movs	r0, #2
 11344 03e2 0090     		str	r0, [sp, #0]
 11345 03e4 0B46     		mov	r3, r1
 11346 03e6 4A48     		ldr	r0, .L720+16
 11347 03e8 FFF7FEFF 		bl	_ZN5Print7printlnEdi
 560:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 11348              		.loc 35 560 0
 11349 03ec 83E0     		b	.L648
 11350              	.L671:
 563:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(motorArmed);
 11351              		.loc 35 563 0
 11352 03ee 5248     		ldr	r0, .L720+56
 564:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[XAXIS]);
 11353              		.loc 35 564 0
 11354 03f0 4F4C     		ldr	r4, .L720+48
 563:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(motorArmed);
 11355              		.loc 35 563 0
 11356 03f2 0078     		ldrb	r0, [r0, #0]	@ zero_extendqisi2
 11357 03f4 FFF7FEFF 		bl	_Z15PrintValueCommah
 564:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[XAXIS]);
 11358              		.loc 35 564 0
 11359 03f8 2068     		ldr	r0, [r4, #0]	@ float
 11360 03fa FFF7FEFF 		bl	_Z15PrintValueCommaf
 565:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[YAXIS]);
 11361              		.loc 35 565 0
 11362 03fe 6068     		ldr	r0, [r4, #4]	@ float
 11363 0400 FFF7FEFF 		bl	_Z15PrintValueCommaf
 567:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(trueNorthHeading);
 11364              		.loc 35 567 0
 11365 0404 4B49     		ldr	r1, .L720+52
 11366 0406 0868     		ldr	r0, [r1, #0]	@ float
 11367 0408 FFF7FEFF 		bl	_Z15PrintValueCommaf
 573:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(getBaroAltitude());
 11368              		.loc 35 573 0
 11369 040c FFF7FEFF 		bl	_Z15getBaroAltitudev
 11370 0410 FFF7FEFF 		bl	_Z15PrintValueCommaf
 577:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma((int)altitudeHoldState);
 11371              		.loc 35 577 0
 11372 0414 494A     		ldr	r2, .L720+60
 11373 0416 1078     		ldrb	r0, [r2, #0]	@ zero_extendqisi2
 11374 0418 FFF7FEFF 		bl	_Z15PrintValueCommai
 11375              	.LVL461:
 11376 041c 0024     		movs	r4, #0
 11377              	.LVL462:
 11378              	.L686:
 11379              	.LBB294:
 583:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(receiverCommand[channel]);
 11380              		.loc 35 583 0 discriminator 2
 11381 041e 484B     		ldr	r3, .L720+64
 11382 0420 E058     		ldr	r0, [r4, r3]
 11383 0422 0434     		adds	r4, r4, #4
 11384 0424 FFF7FEFF 		bl	_Z15PrintValueCommai
 582:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 11385              		.loc 35 582 0 discriminator 2
 11386 0428 202C     		cmp	r4, #32
 11387 042a F8D1     		bne	.L686
 582:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 11388              		.loc 35 582 0 is_stmt 0
 11389 042c 0024     		movs	r4, #0
 11390              	.L687:
 11391              	.LBE294:
 11392              	.LBB295:
 589:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(motorCommand[motor]);
 11393              		.loc 35 589 0 is_stmt 1 discriminator 2
 11394 042e 454A     		ldr	r2, .L720+68
 11395 0430 A058     		ldr	r0, [r4, r2]
 11396 0432 0434     		adds	r4, r4, #4
 11397 0434 FFF7FEFF 		bl	_Z15PrintValueCommai
 588:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 11398              		.loc 35 588 0 discriminator 2
 11399 0438 102C     		cmp	r4, #16
 11400 043a F8D1     		bne	.L687
 11401              	.LVL463:
 11402              	.LBE295:
 11403              	.LBB296:
 592:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0); // zero out unused motor channels
 11404              		.loc 35 592 0 discriminator 1
 11405 043c 0020     		movs	r0, #0
 11406 043e FFF7FEFF 		bl	_Z15PrintValueCommai
 11407              	.LVL464:
 11408 0442 0020     		movs	r0, #0
 11409 0444 FFF7FEFF 		bl	_Z15PrintValueCommai
 11410              	.LVL465:
 11411 0448 0020     		movs	r0, #0
 11412 044a FFF7FEFF 		bl	_Z15PrintValueCommai
 11413              	.LVL466:
 11414 044e 0020     		movs	r0, #0
 11415 0450 FFF7FEFF 		bl	_Z15PrintValueCommai
 11416              	.LVL467:
 11417              	.LBE296:
 595:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma((float)batteryData[0].voltage/100.0); // voltage internally stored at 10mV:s
 11418              		.loc 35 595 0 discriminator 1
 11419 0454 3C4B     		ldr	r3, .L720+72
 11420 0456 D888     		ldrh	r0, [r3, #6]
 11421 0458 00EE100A 		fmsr	s0, r0	@ int
 11422 045c DFED3B7A 		flds	s15, .L720+76
 11423 0460 B8EE407A 		fuitos	s14, s0
 11424 0464 C7EE276A 		fdivs	s13, s14, s15
 11425 0468 16EE900A 		fmrs	r0, s13
 11426 046c FFF7FEFF 		bl	_Z15PrintValueCommaf
 599:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(flightMode);
 11427              		.loc 35 599 0 discriminator 1
 11428 0470 3749     		ldr	r1, .L720+80
 11429 0472 0878     		ldrb	r0, [r1, #0]	@ zero_extendqisi2
 11430 0474 FFF7FEFF 		bl	_Z15PrintValueCommah
 11431 0478 07E0     		b	.L702
 11432              	.LVL468:
 11433              	.L690:
 11434              	.LBE301:
 346:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   switch (queryType) {
 11435              		.loc 35 346 0
 11436 047a 0024     		movs	r4, #0
 11437              	.L672:
 11438              	.LBB302:
 11439              	.LBB297:
 605:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(receiverCommand[axis]);
 11440              		.loc 35 605 0 discriminator 2
 11441 047c 304A     		ldr	r2, .L720+64
 11442 047e A058     		ldr	r0, [r4, r2]
 11443 0480 0434     		adds	r4, r4, #4
 11444 0482 FFF7FEFF 		bl	_Z15PrintValueCommai
 604:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = 0; axis < LASTCHANNEL; axis++) {
 11445              		.loc 35 604 0 discriminator 2
 11446 0486 202C     		cmp	r4, #32
 11447 0488 F8D1     		bne	.L672
 11448              	.LVL469:
 11449              	.L702:
 11450              	.LBE297:
 607:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 11451              		.loc 35 607 0
 11452 048a 2148     		ldr	r0, .L720+16
 11453              	.LBE302:
 11454              	.LBE305:
 657:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 11455              		.loc 35 657 0
 11456 048c 03B0     		add	sp, sp, #12
 11457 048e BDE8F040 		pop	{r4, r5, r6, r7, lr}
 11458              	.LBB306:
 11459              	.LBB303:
 607:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 11460              		.loc 35 607 0
 11461 0492 FFF7FEBF 		b	_ZN5Print7printlnEv
 11462              	.L717:
 11463              	.LBB298:
 630:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(0);
 11464              		.loc 35 630 0
 11465 0496 0020     		movs	r0, #0
 11466 0498 FFF7FEFF 		bl	_Z15PrintValueCommai
 11467              	.LVL470:
 11468 049c 0020     		movs	r0, #0
 11469 049e FFF7FEFF 		bl	_Z15PrintValueCommai
 11470              	.LVL471:
 11471              	.L710:
 11472 04a2 0020     		movs	r0, #0
 11473 04a4 FFF7FEFF 		bl	_Z15PrintValueCommai
 11474 04a8 0020     		movs	r0, #0
 11475 04aa FFF7FEFF 		bl	_Z15PrintValueCommai
 11476              	.L704:
 11477              	.LVL472:
 11478 04ae 0020     		movs	r0, #0
 11479 04b0 FFF7FEFF 		bl	_Z15PrintValueCommai
 11480              	.LVL473:
 11481              	.LBE298:
 631:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(0);
 11482              		.loc 35 631 0
 11483 04b4 1648     		ldr	r0, .L720+16
 11484 04b6 0021     		movs	r1, #0
 11485              	.LVL474:
 11486              	.L705:
 11487 04b8 0A22     		movs	r2, #10
 11488 04ba FFF7FEFF 		bl	_ZN5Print7printlnEii
 11489 04be 0AE0     		b	.L700
 11490              	.L711:
 640:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(SOFTWARE_VERSION, 1);
 11491              		.loc 35 640 0
 11492 04c0 0FA3     		adr	r3, .L720
 11493 04c2 D3E90023 		ldrd	r2, [r3]
 11494 04c6 0121     		movs	r1, #1
 11495 04c8 1148     		ldr	r0, .L720+16
 11496 04ca 0091     		str	r1, [sp, #0]
 11497              	.L706:
 11498 04cc FFF7FEFF 		bl	_ZN5Print7printlnEdi
 11499 04d0 01E0     		b	.L700
 11500              	.L651:
 645:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     reportVehicleState();
 11501              		.loc 35 645 0
 11502 04d2 FFF7FEFF 		bl	_Z18reportVehicleStatev
 11503              	.L700:
 646:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 11504              		.loc 35 646 0
 11505 04d6 5820     		movs	r0, #88
 11506 04d8 2070     		strb	r0, [r4, #0]
 647:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 11507              		.loc 35 647 0
 11508 04da 0CE0     		b	.L648
 11509              	.L688:
 11510              	.LBE303:
 346:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****   switch (queryType) {
 11511              		.loc 35 346 0
 11512 04dc 0024     		movs	r4, #0
 11513              	.L652:
 11514              	.LBB304:
 11515              	.LBB299:
 651:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(motorCommand[motor]);
 11516              		.loc 35 651 0 discriminator 2
 11517 04de 194B     		ldr	r3, .L720+68
 11518 04e0 E058     		ldr	r0, [r4, r3]
 11519 04e2 0434     		adds	r4, r4, #4
 11520 04e4 FFF7FEFF 		bl	_Z15PrintValueCommai
 650:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 11521              		.loc 35 650 0 discriminator 2
 11522 04e8 102C     		cmp	r4, #16
 11523 04ea F8D1     		bne	.L652
 11524              	.LVL475:
 11525              	.L708:
 11526              	.LBE299:
 653:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 11527              		.loc 35 653 0
 11528 04ec 0848     		ldr	r0, .L720+16
 11529 04ee FFF7FEFF 		bl	_ZN5Print7printlnEv
 11530              	.L701:
 654:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 11531              		.loc 35 654 0
 11532 04f2 5822     		movs	r2, #88
 11533 04f4 3270     		strb	r2, [r6, #0]
 11534              	.L648:
 11535              	.LBE304:
 11536              	.LBE306:
 657:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\SerialCom.h **** }
 11537              		.loc 35 657 0
 11538 04f6 03B0     		add	sp, sp, #12
 11539 04f8 F0BD     		pop	{r4, r5, r6, r7, pc}
 11540              	.L721:
 11541 04fa 00BFAFF3 		.align	3
 11541      0080
 11542              	.L720:
 11543 0500 000000C0 		.word	-1073741824
 11544 0504 CCCC0840 		.word	1074318540
 11545 0508 00000000 		.word	.LANCHOR35
 11546 050c 00000000 		.word	.LANCHOR36
 11547 0510 00000000 		.word	SerialUSB
 11548 0514 00000000 		.word	.LANCHOR37
 11549 0518 00000000 		.word	.LANCHOR38
 11550 051c 00000000 		.word	.LANCHOR76
 11551 0520 00000000 		.word	.LANCHOR133
 11552 0524 00000000 		.word	.LANCHOR134
 11553 0528 00000000 		.word	.LANCHOR135
 11554 052c 00000000 		.word	.LANCHOR21
 11555 0530 00000000 		.word	.LANCHOR42
 11556 0534 00000000 		.word	.LANCHOR74
 11557 0538 00000000 		.word	.LANCHOR130
 11558 053c 00000000 		.word	.LANCHOR5
 11559 0540 00000000 		.word	.LANCHOR6
 11560 0544 00000000 		.word	.LANCHOR63
 11561 0548 00000000 		.word	.LANCHOR103
 11562 054c 0000C842 		.word	1120403456
 11563 0550 00000000 		.word	.LANCHOR114
 11564              		.cfi_endproc
 11565              	.LFE247:
 11567 0554 AFF30080 		.section	.text._Z22hottV4SerialClearInputv,"ax",%progbits
 11568              		.align	1
 11569              		.global	_Z22hottV4SerialClearInputv
 11570              		.thumb
 11571              		.thumb_func
 11573              	_Z22hottV4SerialClearInputv:
 11574              	.LFB255:
  51:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** void hottV4SerialClearInput() {
 11575              		.loc 5 51 0
 11576              		.cfi_startproc
 11577              		@ args = 0, pretend = 0, frame = 0
 11578              		@ frame_needed = 0, uses_anonymous_args = 0
 11579 0000 10B5     		push	{r4, lr}
 11580              	.LCFI110:
 11581              		.cfi_def_cfa_offset 8
 11582              		.cfi_offset 14, -4
 11583              		.cfi_offset 4, -8
  52:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	while(hottV4Serial->available() > 0) {
 11584              		.loc 5 52 0
 11585 0002 02E0     		b	.L723
 11586              	.L724:
  53:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		hottV4Serial->read();
 11587              		.loc 5 53 0
 11588 0004 2068     		ldr	r0, [r4, #0]
 11589 0006 FFF7FEFF 		bl	_ZN14HardwareSerial4readEv
 11590              	.L723:
  52:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	while(hottV4Serial->available() > 0) {
 11591              		.loc 5 52 0 discriminator 1
 11592 000a 034C     		ldr	r4, .L725
 11593 000c 2068     		ldr	r0, [r4, #0]
 11594 000e FFF7FEFF 		bl	_ZN14HardwareSerial9availableEv
 11595 0012 0028     		cmp	r0, #0
 11596 0014 F6D1     		bne	.L724
  55:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 11597              		.loc 5 55 0
 11598 0016 10BD     		pop	{r4, pc}
 11599              	.L726:
 11600              		.align	2
 11601              	.L725:
 11602 0018 00000000 		.word	.LANCHOR143
 11603              		.cfi_endproc
 11604              	.LFE255:
 11606              		.section	.text._Z16hottV4SerialReadv,"ax",%progbits
 11607              		.align	1
 11608              		.global	_Z16hottV4SerialReadv
 11609              		.thumb
 11610              		.thumb_func
 11612              	_Z16hottV4SerialReadv:
 11613              	.LFB256:
  60:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** int hottV4SerialRead() {
 11614              		.loc 5 60 0
 11615              		.cfi_startproc
 11616              		@ args = 0, pretend = 0, frame = 0
 11617              		@ frame_needed = 0, uses_anonymous_args = 0
 11618 0000 10B5     		push	{r4, lr}
 11619              	.LCFI111:
 11620              		.cfi_def_cfa_offset 8
 11621              		.cfi_offset 14, -4
 11622              		.cfi_offset 4, -8
  61:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	while(hottV4Serial->available() > 1) {
 11623              		.loc 5 61 0
 11624 0002 01E0     		b	.L728
 11625              	.L729:
  62:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		hottV4Serial->read();
 11626              		.loc 5 62 0
 11627 0004 FFF7FEFF 		bl	_ZN14HardwareSerial4readEv
 11628              	.L728:
  61:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	while(hottV4Serial->available() > 1) {
 11629              		.loc 5 61 0 discriminator 1
 11630 0008 084C     		ldr	r4, .L731
 11631 000a 2068     		ldr	r0, [r4, #0]
 11632 000c FFF7FEFF 		bl	_ZN14HardwareSerial9availableEv
 11633 0010 0128     		cmp	r0, #1
  62:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		hottV4Serial->read();
 11634              		.loc 5 62 0 discriminator 1
 11635 0012 2068     		ldr	r0, [r4, #0]
  61:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	while(hottV4Serial->available() > 1) {
 11636              		.loc 5 61 0 discriminator 1
 11637 0014 F6D8     		bhi	.L729
  64:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     if(hottV4Serial->available()) {
 11638              		.loc 5 64 0
 11639 0016 FFF7FEFF 		bl	_ZN14HardwareSerial9availableEv
 11640 001a 20B1     		cbz	r0, .L730
  65:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     	return hottV4Serial->read();
 11641              		.loc 5 65 0
 11642 001c 2068     		ldr	r0, [r4, #0]
  69:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 11643              		.loc 5 69 0
 11644 001e BDE81040 		pop	{r4, lr}
  65:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     	return hottV4Serial->read();
 11645              		.loc 5 65 0
 11646 0022 FFF7FEBF 		b	_ZN14HardwareSerial4readEv
 11647              	.L730:
  69:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 11648              		.loc 5 69 0
 11649 0026 FF20     		movs	r0, #255
 11650 0028 10BD     		pop	{r4, pc}
 11651              	.L732:
 11652 002a 00BF     		.align	2
 11653              	.L731:
 11654 002c 00000000 		.word	.LANCHOR143
 11655              		.cfi_endproc
 11656              	.LFE256:
 11658              		.section	.text._Z8SetDelayj,"ax",%progbits
 11659              		.align	1
 11660              		.global	_Z8SetDelayj
 11661              		.thumb
 11662              		.thumb_func
 11664              	_Z8SetDelayj:
 11665              	.LFB265:
 179:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #endif
 180:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 181:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** unsigned int SetDelay (unsigned int t) {
 11666              		.loc 5 181 0
 11667              		.cfi_startproc
 11668              		@ args = 0, pretend = 0, frame = 0
 11669              		@ frame_needed = 0, uses_anonymous_args = 0
 11670              		@ link register save eliminated.
 11671              	.LVL476:
 182:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	return(CountMilliseconds + t + 1);
 11672              		.loc 5 182 0
 11673 0000 024A     		ldr	r2, .L734
 11674 0002 1168     		ldr	r1, [r2, #0]
 11675 0004 4B1C     		adds	r3, r1, #1
 183:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 11676              		.loc 5 183 0
 11677 0006 1818     		adds	r0, r3, r0
 11678              	.LVL477:
 11679 0008 7047     		bx	lr
 11680              	.L735:
 11681 000a 00BF     		.align	2
 11682              	.L734:
 11683 000c 00000000 		.word	.LANCHOR144
 11684              		.cfi_endproc
 11685              	.LFE265:
 11687              		.section	.text._Z10CheckDelayj,"ax",%progbits
 11688              		.align	1
 11689              		.global	_Z10CheckDelayj
 11690              		.thumb
 11691              		.thumb_func
 11693              	_Z10CheckDelayj:
 11694              	.LFB266:
 184:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 185:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** char CheckDelay(unsigned int t)	{
 11695              		.loc 5 185 0
 11696              		.cfi_startproc
 11697              		@ args = 0, pretend = 0, frame = 0
 11698              		@ frame_needed = 0, uses_anonymous_args = 0
 11699              		@ link register save eliminated.
 11700              	.LVL478:
 186:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	return(((t - CountMilliseconds) & 0x8000) >> 9);
 11701              		.loc 5 186 0
 11702 0000 0449     		ldr	r1, .L737
 11703 0002 0B68     		ldr	r3, [r1, #0]
 11704 0004 C21A     		subs	r2, r0, r3
 11705 0006 02F40041 		and	r1, r2, #32768
 11706 000a 480A     		lsrs	r0, r1, #9
 11707              	.LVL479:
 187:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 11708              		.loc 5 187 0
 11709 000c 00F04000 		and	r0, r0, #64
 11710 0010 7047     		bx	lr
 11711              	.L738:
 11712 0012 00BF     		.align	2
 11713              	.L737:
 11714 0014 00000000 		.word	.LANCHOR144
 11715              		.cfi_endproc
 11716              	.LFE266:
 11718              		.section	.text._Z10hottv4InitP14HardwareSerial,"ax",%progbits
 11719              		.align	1
 11720              		.global	_Z10hottv4InitP14HardwareSerial
 11721              		.thumb
 11722              		.thumb_func
 11724              	_Z10hottv4InitP14HardwareSerial:
 11725              	.LFB269:
 188:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 189:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static unsigned char hottVoiceOutput()
 190:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	{
 191:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	unsigned char status = 0;
 192:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	static char oldStatus = 0;
 193:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	static int repeat;
 194:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 195:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 196:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #if defined(HOTTV4BATT)
 197:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryAlarm) {
 198:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		status = HoTTv4NotificationUndervoltage;
 199:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	}
 200:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #endif
 201:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 202:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if(!SpeakHoTT) {
 203:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #if defined(AltitudeHoldBaro) || defined(AltitudeHoldRangeFinder)
 204:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		if(altitudeHoldState == ON)  isAHOn = true;
 205:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		else if(altitudeHoldState == ALTPANIC || altitudeHoldState == OFF) isAHOff = true;
 206:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 207:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		 if(isAHOn) {
 208:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 			 if (altitudeHoldState == ALTPANIC || altitudeHoldState == OFF) {
 209:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 				isAHOn = false;
 210:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 				SpeakHoTT = HoTTv4NotificationAltitudeOff;
 211:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 			 }
 212:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		 }
 213:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		 if(isAHOff) {
 214:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 			 if(altitudeHoldState == ON) {
 215:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 				 isAHOff = false;
 216:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 				 SpeakHoTT = HoTTv4NotificationAltitudeOn;
 217:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 			 }
 218:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		 }
 219:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #endif
 220:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 221:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #if defined(UseGPSNavigator)
 222:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		 if(navigationState == ON)  isNavOn = true;
 223:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		 else if(positionHoldState == ON) isHoldOn = true;
 224:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		 else if(positionHoldState == OFF && navigationState == OFF) isGPSOff = true;
 225:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 226:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		 if(isNavOn) {
 227:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 			 if (positionHoldState == ON) {
 228:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 				 isNavOn = false;
 229:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 				 SpeakHoTT = HoTTv4NotificationGPSHold;
 230:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 			 }
 231:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 			 if (positionHoldState == OFF && navigationState == OFF) {
 232:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 				 isNavOn = false;
 233:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 				 SpeakHoTT = HoTTv4NotificationGPSOff;
 234:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 			 }
 235:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		 }
 236:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		 if(isHoldOn) {
 237:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 			 if(navigationState == ON) {
 238:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 				 isHoldOn = false;
 239:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 				 SpeakHoTT = HoTTv4NotificationGPSHome;
 240:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 				 }
 241:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 			 if (positionHoldState == OFF && navigationState == OFF) {
 242:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 				 isHoldOn = false;
 243:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 				 SpeakHoTT = HoTTv4NotificationGPSOff;
 244:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 				 }
 245:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		 }
 246:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		 if(isGPSOff) {
 247:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 			 if (positionHoldState == ON) {
 248:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 				 isGPSOff = false;
 249:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 				 SpeakHoTT = HoTTv4NotificationGPSHold;
 250:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 			 }
 251:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 			 if(navigationState == ON) {
 252:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 				 isGPSOff = false;
 253:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 				 SpeakHoTT = HoTTv4NotificationGPSHome;
 254:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 			}
 255:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		 }
 256:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #endif
 257:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	}
 258:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	
 259:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if(!status) {
 260:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		status = SpeakHoTT; 
 261:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	}
 262:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 263:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if(oldStatus == status) {
 264:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		if(!CheckDelay(repeat)) return 0;
 265:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		repeat = SetDelay(5000);
 266:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	}
 267:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	else repeat = SetDelay(2000);
 268:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 269:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if(status) 	{
 270:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		if(status == SpeakHoTT) SpeakHoTT = 0;
 271:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	}   
 272:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 273:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	oldStatus = status;
 274:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 275:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	return status;
 276:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 277:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 278:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 279:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
 280:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Updates current flight time (with motors armed) by counting the seconds 
 281:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * from the moment power was applied.
 282:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
 283:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static void hottv4UpdateFlightTime(uint8_t *data) {
 284:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   static uint32_t previousEAMUpdate = 0;
 285:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   
 286:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint16_t timeDiff = millis() - previousEAMUpdate;
 287:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   previousEAMUpdate += timeDiff;
 288:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   
 289:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   CountMilliseconds += timeDiff;
 290:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 291:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if (motorArmed) {
 292:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     milliseconds += timeDiff;
 293:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	
 294:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     if (milliseconds >= 60000) {
 295:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       milliseconds -= 60000;
 296:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       minutes += 1;
 297:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     }
 298:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   }
 299:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   
 300:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   data[39] = minutes;
 301:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   // Enough accuracy and faster than divide by 1000
 302:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   data[40] = (milliseconds >> 10) ;
 303:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 304:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 305:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
 306:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Call to initialize HOTTV4
 307:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
 308:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** void hottv4Init(HardwareSerial *serial) {
 11726              		.loc 5 308 0
 11727              		.cfi_startproc
 11728              		@ args = 0, pretend = 0, frame = 0
 11729              		@ frame_needed = 0, uses_anonymous_args = 0
 11730              		@ link register save eliminated.
 11731              	.LVL480:
 309:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4Serial = serial;
 11732              		.loc 5 309 0
 11733 0000 024B     		ldr	r3, .L740
 310:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     
 311:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   #if defined (__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
 312:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     /* Enable PullUps on RX3
 313:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****      * without signal is to weak to be recognized
 314:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****      */
 315:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     DDRJ &= ~(1 << 0);
 316:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     PORTJ |= (1 << 0);
 317:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   #endif
 318:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4Serial->begin(19200);
 11734              		.loc 5 318 0
 11735 0002 4FF49641 		mov	r1, #19200
 309:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4Serial = serial;
 11736              		.loc 5 309 0
 11737 0006 1860     		str	r0, [r3, #0]
 319:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 11738              		.loc 5 319 0
 318:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4Serial->begin(19200);
 11739              		.loc 5 318 0
 11740 0008 FFF7FEBF 		b	_ZN14HardwareSerial5beginEj
 11741              	.LVL481:
 11742              	.L741:
 11743              		.align	2
 11744              	.L740:
 11745 000c 00000000 		.word	.LANCHOR143
 11746              		.cfi_endproc
 11747              	.LFE269:
 11749              		.section	.text._Z10hottV4Hookh,"ax",%progbits
 11750              		.align	1
 11751              		.global	_Z10hottV4Hookh
 11752              		.thumb
 11753              		.thumb_func
 11755              	_Z10hottV4Hookh:
 11756              	.LFB273:
 320:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 321:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /* ##################################################################### *
 322:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  *                HoTTv4 EAM Module                                      *
 323:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * ##################################################################### */
 324:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 325:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
 326:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Main method to send EAM telemetry data
 327:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
 328:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static void hottV4SendEAMTelemetry() {  
 329:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint8_t telemetry_data[] = { 
 330:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x7C,
 331:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               HOTTV4_ELECTRICAL_AIR_MODULE, 
 332:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Alarm */
 333:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               HOTTV4_ELECTRICAL_AIR_SENSOR_ID,
 334:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, /* Alarm Value 1 and 2 */
 335:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* Low Voltage Cell 1-7 in 2mV steps */
 336:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* High Voltage Cell 1-7 in 2mV steps */
 337:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, /* Battetry 1 LSB/MSB in 100mv steps, 50 == 5V */
 338:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, /* Battetry 2 LSB/MSB in 100mv steps, 50 == 5V */
 339:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x14, /* Temp 1, Offset of 20. 20 == 0C */ 
 340:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x14, /* Temp 2, Offset of 20. 20 == 0C */
 341:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0xF4, 0x01, /* Height. Offset -500. 500 == 0 */
 342:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, /* Current LSB, MSB 1 = 0.1A */
 343:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, /* Drive Voltage */
 344:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00,  /* mAh */
 345:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x48, 0x00, /* m2s */ 
 346:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x78, /* m3s */
 347:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, /* RPM. 10er steps, 300 == 3000rpm */
 348:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Electric minutes */
 349:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Electric seconds */
 350:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Speed */
 351:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Version Number */
 352:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x7D, /* End sign */
 353:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00 /* Checksum */
 354:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****             };
 355:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   
 356:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   #if defined(HOTTV4BATT)
 357:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     short voltage = hottv4UpdateBattery(telemetry_data);
 358:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[20] = telemetry_data[22] = telemetry_data[30] = voltage;
 359:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[21] = telemetry_data[23] = telemetry_data[31] = (voltage >> 8) & 0xFF;
 360:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 361:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	short current = hottv4UpdateCurrent();
 362:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[28] = current;
 363:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[29] = (current >> 8) & 0xFF;
 364:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 365:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	long capacity = hottv4UpdateCapacity();
 366:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[32] = capacity;
 367:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[33] = (capacity >> 8) & 0xFF;
 368:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   #endif
 369:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   
 370:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   #if defined(HOTTV4ALTITUDE)
 371:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     int32_t altitude = hottv4UpdateAlt();
 372:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[26] = altitude;
 373:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[27] = (altitude >> 8) & 0xFF;
 374:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 375:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	unsigned int varioSound = hottv4UpdateAltVario();
 376:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     telemetry_data[11] = telemetry_data[13] = varioSound;
 377:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     telemetry_data[12] = telemetry_data[14] = (varioSound >> 8) & 0xFF;
 378:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   #endif
 379:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 380:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottv4UpdateFlightTime(telemetry_data);
 381:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 382:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   // Write out telemetry data as Electric Air Module to serial           
 383:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4SendBinary(telemetry_data);
 384:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 385:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 386:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /* ##################################################################### *
 387:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  *                HoTTv4 GPS Module                                      *
 388:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * ##################################################################### */
 389:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 390:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #if defined(UseGPS)
 391:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
 392:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Converts unsigned long representation of GPS coordinate back to
 393:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * N Deg MM.SSSS representation and puts it into GPS data frame.
 394:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
 395:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static void updatePosition(uint8_t *data, uint32_t value, uint8_t index) {
 396:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   data[index] = (value < 0); 
 397:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 398:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint8_t deg = value / 100000;
 399:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint32_t sec = (value - (deg * 100000)) * 6;
 400:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint8_t min = sec / 10000;
 401:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   sec = sec % 10000;
 402:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   
 403:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint16_t degMin = (deg * 100) + min;
 404:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 405:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   data[index+1] = degMin;
 406:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   data[index+2] = degMin >> 8; 
 407:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   data[index+3] = sec; 
 408:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   data[index+4] = sec >> 8;
 409:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 410:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #endif
 411:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 412:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
 413:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Main method to send GPS telemetry data
 414:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
 415:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static void hottV4SendGPSTelemetry() {
 416:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint8_t telemetry_data[] = { 
 417:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x7C,
 418:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               HOTTV4_GPS_MODULE, 
 419:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Alarm */
 420:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               HOTTV4_GPS_SENSOR_ID,
 421:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, /* Alarm Value 1 and 2 */
 422:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Flight direction */ 
 423:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, /* Velocity */ 
 424:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, 0x00, 0x00, 0x00, /* Latitude */
 425:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, 0x00, 0x00, 0x00, /* Longitude */
 426:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, /* Distance */
 427:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0xF4, 0x01, /* Altitude, 500 = 0m */
 428:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x78, 0x00, /* m/s, 1 = 0.01m/s */ 
 429:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x78, /* m/3s, 120 = 0 */
 430:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Number of satelites */ 
 431:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* GPS fix character */
 432:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Home direction */
 433:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* angle x-direction */
 434:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* angle y-direction */
 435:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* angle z-direction */
 436:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00,  /* gyro x */
 437:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, /* gyro y */ 
 438:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, /* gyro z */
 439:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Vibrations */
 440:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* ASCII Free Character 4 */
 441:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* ASCII Free Character 5 */
 442:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* ASCII Free Character 6 */
 443:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Version Number */
 444:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x7D, /* End sign */
 445:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00 /* Checksum */
 446:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****             };
 447:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 448:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 449:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 450:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #if defined(UseGPS)
 451:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 452:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[26] = nbSatelitesInUse;
 453:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 454:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     if (haveAGpsLock()) {
 455:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       updatePosition(telemetry_data, currentPosition.latitude, 9);
 456:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       updatePosition(telemetry_data, currentPosition.longitude, 14);
 457:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 458:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       telemetry_data[27] = telemetry_data[41] = 'f'; // Displays a 'f' for fix
 459:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 460:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       /** GPS Speed in km/h */
 461:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       telemetry_data[7] = getGpsSpeed()*36/1000;
 462:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 463:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       /** Distance to home */
 464:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  if(isHomeBaseInitialized()) {
 465:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		  computeDistanceAndBearing(currentPosition, homePosition);
 466:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		  telemetry_data[19] = (int)getDistanceMeter();
 467:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		  telemetry_data[20] = (int)getDistanceMeter() >> 8;
 468:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		  telemetry_data[28] = (gpsBearing - (int)(trueNorthHeading * RAD2DEG)) * 50;
 469:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		  }
 470:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 471:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  if (navigationState == ON) { 
 472:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		  telemetry_data[39] = HoTTGPSWaypoint; // Displays a 'W' for Waypoint
 473:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		  }
 474:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  else if(positionHoldState == ON) {
 475:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		  telemetry_data[39] = HoTTGPSPositionHold; //Displays a 'P' for Position Hold
 476:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		  }
 477:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  else {
 478:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		  telemetry_data[39] = HoTTGPSFree; //Displays a '/' for GPS Mode off 
 479:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		  }
 480:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     }
 481:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #endif
 482:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****           
 483:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #if defined(HOTTV4ALTITUDE)
 484:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	int32_t altitude = hottv4UpdateAlt();
 485:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[21] = altitude;
 486:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[22] = (altitude >> 8) & 0xFF;
 487:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 488:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	unsigned int varioSound = hottv4UpdateAltVario();
 489:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[11] = varioSound;
 490:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[13] = 120;
 491:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #endif
 492:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 493:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 494:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #if defined(HOTTV4DIR) 
 495:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     telemetry_data[6] = hottV4UpdateDirection();
 496:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #endif
 497:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 498:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   // Triggers voice alarm if necessary
 499:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[2] = hottVoiceOutput();
 500:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   
 501:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   // Write out telemetry data as GPS Module to serial           
 502:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4SendBinary(telemetry_data);
 503:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 504:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 505:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /* ##################################################################### *
 506:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  *                HoTTv4 Vario Module                                    *
 507:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * ##################################################################### */
 508:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 509:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
 510:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Main method to send Vario telemetry data
 511:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
 512:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** static void hottV4SendVarioTelemetry() {
 513:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint8_t telemetry_data[] = { 
 514:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x7C,
 515:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               HOTTV4_VARIO_MODULE, 
 516:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Alarm */
 517:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               HOTTV4_VARIO_SENSOR_ID,
 518:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Inverse status */
 519:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0xF4, 0x01, /* Current altitude */ 
 520:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0xF4, 0x01, /* Max. altitude */ 
 521:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0xF4, 0x01, /* Min. altitude */
 522:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x30, 0x75, /* m/s */
 523:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x30, 0x75, /* m/3s  */
 524:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x30, 0x75, /* m/10s */
 525:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, 0x00, 0x00, /* ASCII */
 526:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, 0x00, 0x00, /* ASCII */
 527:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, 0x00, 0x00, /* ASCII */
 528:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, 0x00, 0x00, /* ASCII */
 529:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, 0x00, 0x00, /* ASCII */
 530:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00,                   /* ASCII */
 531:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, 0x00, 0x00, 0x00, /* free */
 532:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00, /* Version Number */
 533:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x7D, /* End sign */
 534:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****               0x00  /* Checksum */
 535:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****             };
 536:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 537:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #if defined(HOTTV4ALTITUDE)
 538:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   int32_t altitude = hottv4UpdateAlt();
 539:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[5] = altitude;
 540:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[6] = (altitude >> 8) & 0xFF;
 541:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 542:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[7] = maxAltitude;
 543:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[9] = minAltitude;
 544:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 545:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   unsigned int varioSound = hottv4UpdateAltVario();
 546:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[11] = telemetry_data[13] = telemetry_data[15] = varioSound;
 547:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[12] = telemetry_data[14] = telemetry_data[16] = (varioSound >> 8) & 0xFF;
 548:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 549:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(altitudeHoldState == ON) {
 550:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  if((receiverCommand[THROTTLE] > (altitudeHoldThrottle + altitudeHoldBump))) telemetry_data[38] =
 551:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  else if((receiverCommand[THROTTLE] < (altitudeHoldThrottle - altitudeHoldBump))) telemetry_data[
 552:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  else telemetry_data[38] = '=';
 553:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  }
 554:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   else if (altitudeHoldState == ALTPANIC) {
 555:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  telemetry_data[38] = '!';
 556:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  }
 557:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** #endif
 558:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 559:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   // Buffer for the available 21 ASCII + \0 chars
 560:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   char text[VARIO_ASCIIS+1];
 561:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   
 562:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(flightMode == ATTITUDE_FLIGHT_MODE) snprintf(text, VARIO_ASCIIS+1, HOTTV4_VARIO_ATTITUDE);
 563:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   else snprintf(text, VARIO_ASCIIS+1, HOTTV4_VARIO_RATE);
 564:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 565:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint8_t offset = (VARIO_ASCIIS - strlen(text)) / 2;
 566:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 567:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   for(uint8_t index = 0; (index + offset) < VARIO_ASCIIS; index++) {
 568:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     if (text[index] != 0x0) {
 569:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       // 17 == start byte for ASCII
 570:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       telemetry_data[17+index+offset] = text[index];
 571:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     } else {
 572:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       break;
 573:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     }
 574:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   }  
 575:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****             
 576:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   // Write out telemetry data as Vario Module to serial           
 577:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4SendBinary(telemetry_data);
 578:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 579:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 580:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /* ##################################################################### *
 581:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  *                HoTTv4 Text Mode                                       *
 582:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * ##################################################################### */
 583:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 584:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** /**
 585:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  * Main entry point for HoTTv4 telemetry
 586:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****  */
 587:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** bool hottV4Hook(uint8_t serialData) {
 11757              		.loc 5 587 0
 11758              		.cfi_startproc
 11759              		@ args = 0, pretend = 0, frame = 72
 11760              		@ frame_needed = 0, uses_anonymous_args = 0
 11761              	.LVL482:
 11762 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 11763              	.LCFI112:
 11764              		.cfi_def_cfa_offset 20
 11765              		.cfi_offset 14, -4
 11766              		.cfi_offset 7, -8
 11767              		.cfi_offset 6, -12
 11768              		.cfi_offset 5, -16
 11769              		.cfi_offset 4, -20
 588:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   switch (serialData) {
 11770              		.loc 5 588 0
 11771 0002 3328     		cmp	r0, #51
 587:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** bool hottV4Hook(uint8_t serialData) {
 11772              		.loc 5 587 0
 11773 0004 93B0     		sub	sp, sp, #76
 11774              	.LCFI113:
 11775              		.cfi_def_cfa_offset 96
 11776              		.loc 5 588 0
 11777 0006 00F03981 		beq	.L746
 11778 000a 05D8     		bhi	.L747
 11779 000c 3128     		cmp	r0, #49
 11780 000e 0CD0     		beq	.L744
 11781 0010 3228     		cmp	r0, #50
 11782 0012 40F0D781 		bne	.L775
 11783 0016 96E0     		b	.L745
 11784              	.L747:
 11785 0018 8A28     		cmp	r0, #138
 11786 001a 06D0     		beq	.L744
 11787 001c 8E28     		cmp	r0, #142
 11788 001e 00F09280 		beq	.L745
 11789 0022 8928     		cmp	r0, #137
 11790 0024 40F0CE81 		bne	.L775
 11791 0028 28E1     		b	.L746
 11792              	.L744:
 11793              	.LBB334:
 11794              	.LBB335:
 446:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****             };
 11795              		.loc 5 446 0
 11796 002a 0021     		movs	r1, #0
 11797 002c 2D22     		movs	r2, #45
 11798 002e 6846     		mov	r0, sp
 11799              	.LVL483:
 11800 0030 FFF7FEFF 		bl	memset
 11801 0034 7824     		movs	r4, #120
 11802 0036 7C23     		movs	r3, #124
 11803 0038 A022     		movs	r2, #160
 11804 003a 7D21     		movs	r1, #125
 11805 003c 8A27     		movs	r7, #138
 11806 003e F426     		movs	r6, #244
 11807 0040 0125     		movs	r5, #1
 11808 0042 8DF80030 		strb	r3, [sp, #0]
 11809 0046 8DF80320 		strb	r2, [sp, #3]
 11810 004a 8DF82B10 		strb	r1, [sp, #43]
 11811 004e 8DF80170 		strb	r7, [sp, #1]
 11812 0052 8DF81560 		strb	r6, [sp, #21]
 11813 0056 8DF81650 		strb	r5, [sp, #22]
 11814 005a 8DF81740 		strb	r4, [sp, #23]
 11815 005e 8DF81940 		strb	r4, [sp, #25]
 484:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	int32_t altitude = hottv4UpdateAlt();
 11816              		.loc 5 484 0
 11817 0062 FFF7FEFF 		bl	_ZL15hottv4UpdateAltv
 11818              	.LVL484:
 485:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[21] = altitude;
 11819              		.loc 5 485 0
 11820 0066 8DF81500 		strb	r0, [sp, #21]
 486:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[22] = (altitude >> 8) & 0xFF;
 11821              		.loc 5 486 0
 11822 006a 0012     		asrs	r0, r0, #8
 11823              	.LVL485:
 11824 006c 8DF81600 		strb	r0, [sp, #22]
 488:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	unsigned int varioSound = hottv4UpdateAltVario();
 11825              		.loc 5 488 0
 11826 0070 FFF7FEFF 		bl	_ZL20hottv4UpdateAltVariov
 11827              	.LVL486:
 11828              	.LBB336:
 11829              	.LBB337:
 104:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	return ((int)(trueNorthHeading / M_PI * 180.0) + 360) % 360;
 11830              		.loc 5 104 0
 11831 0074 A44B     		ldr	r3, .L784
 11832              	.LBE337:
 11833              	.LBE336:
 489:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[11] = varioSound;
 11834              		.loc 5 489 0
 11835 0076 8DF80B00 		strb	r0, [sp, #11]
 11836              	.LBB340:
 11837              	.LBB338:
 104:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	return ((int)(trueNorthHeading / M_PI * 180.0) + 360) % 360;
 11838              		.loc 5 104 0
 11839 007a 93ED007A 		flds	s14, [r3, #0]
 11840 007e DFEDA30A 		flds	s1, .L784+4
 11841 0082 87EE207A 		fdivs	s14, s14, s1
 11842 0086 4FF4B475 		mov	r5, #360
 11843              	.LBE338:
 11844              	.LBE340:
 11845              	.LBB341:
 11846              	.LBB342:
 197:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryAlarm) {
 11847              		.loc 5 197 0
 11848 008a A148     		ldr	r0, .L784+8
 11849              	.LVL487:
 11850              	.LBE342:
 11851              	.LBE341:
 490:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[13] = 120;
 11852              		.loc 5 490 0
 11853 008c 8DF80D40 		strb	r4, [sp, #13]
 11854              	.LBB346:
 11855              	.LBB343:
 197:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryAlarm) {
 11856              		.loc 5 197 0
 11857 0090 0478     		ldrb	r4, [r0, #0]	@ zero_extendqisi2
 191:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	unsigned char status = 0;
 11858              		.loc 5 191 0
 11859 0092 002C     		cmp	r4, #0
 11860 0094 14BF     		ite	ne
 11861 0096 1024     		movne	r4, #16
 11862 0098 0024     		moveq	r4, #0
 11863              	.LBE343:
 11864              	.LBE346:
 11865              	.LBB347:
 11866              	.LBB339:
 104:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	return ((int)(trueNorthHeading / M_PI * 180.0) + 360) % 360;
 11867              		.loc 5 104 0
 11868 009a 9FED9E0A 		flds	s0, .L784+12
 11869 009e 27EE000A 		fmuls	s0, s14, s0
 11870 00a2 FDEEC07A 		ftosizs	s15, s0
 11871 00a6 17EE907A 		fmrs	r7, s15	@ int
 11872 00aa 07F5B472 		add	r2, r7, #360
 11873 00ae 92FBF5F6 		sdiv	r6, r2, r5
 11874 00b2 05FB1621 		mls	r1, r5, r6, r2
 11875              	.LBE339:
 11876              	.LBE347:
 11877              	.LBB348:
 11878              	.LBB344:
 202:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if(!SpeakHoTT) {
 11879              		.loc 5 202 0
 11880 00b6 984D     		ldr	r5, .L784+16
 11881              	.LBE344:
 11882              	.LBE348:
 495:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     telemetry_data[6] = hottV4UpdateDirection();
 11883              		.loc 5 495 0
 11884 00b8 8DF80610 		strb	r1, [sp, #6]
 11885              	.LVL488:
 11886              	.LBB349:
 11887              	.LBB345:
 202:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if(!SpeakHoTT) {
 11888              		.loc 5 202 0
 11889 00bc 2B78     		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 11890 00be 03BB     		cbnz	r3, .L749
 204:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		if(altitudeHoldState == ON)  isAHOn = true;
 11891              		.loc 5 204 0
 11892 00c0 9649     		ldr	r1, .L784+20
 11893 00c2 974A     		ldr	r2, .L784+24
 11894 00c4 0B78     		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 11895 00c6 9748     		ldr	r0, .L784+28
 11896 00c8 012B     		cmp	r3, #1
 11897 00ca 01D1     		bne	.L750
 11898 00cc 1370     		strb	r3, [r2, #0]
 11899 00ce 04E0     		b	.L751
 11900              	.L750:
 205:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		else if(altitudeHoldState == ALTPANIC || altitudeHoldState == OFF) isAHOff = true;
 11901              		.loc 5 205 0
 11902 00d0 022B     		cmp	r3, #2
 11903 00d2 00D0     		beq	.L752
 11904 00d4 0BB9     		cbnz	r3, .L751
 11905              	.L752:
 11906 00d6 0126     		movs	r6, #1
 11907 00d8 0670     		strb	r6, [r0, #0]
 11908              	.L751:
 207:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		 if(isAHOn) {
 11909              		.loc 5 207 0
 11910 00da 1778     		ldrb	r7, [r2, #0]	@ zero_extendqisi2
 11911 00dc 3FB1     		cbz	r7, .L753
 208:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 			 if (altitudeHoldState == ALTPANIC || altitudeHoldState == OFF) {
 11912              		.loc 5 208 0
 11913 00de 0B78     		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 11914 00e0 022B     		cmp	r3, #2
 11915 00e2 00D0     		beq	.L754
 11916 00e4 1BB9     		cbnz	r3, .L753
 11917              	.L754:
 209:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 				isAHOn = false;
 11918              		.loc 5 209 0
 11919 00e6 0023     		movs	r3, #0
 11920 00e8 1370     		strb	r3, [r2, #0]
 210:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 				SpeakHoTT = HoTTv4NotificationAltitudeOff;
 11921              		.loc 5 210 0
 11922 00ea 2822     		movs	r2, #40
 11923 00ec 2A70     		strb	r2, [r5, #0]
 11924              	.L753:
 213:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		 if(isAHOff) {
 11925              		.loc 5 213 0
 11926 00ee 0078     		ldrb	r0, [r0, #0]	@ zero_extendqisi2
 11927 00f0 38B1     		cbz	r0, .L749
 214:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 			 if(altitudeHoldState == ON) {
 11928              		.loc 5 214 0
 11929 00f2 0978     		ldrb	r1, [r1, #0]	@ zero_extendqisi2
 11930 00f4 0129     		cmp	r1, #1
 11931 00f6 04D1     		bne	.L749
 215:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 				 isAHOff = false;
 11932              		.loc 5 215 0
 11933 00f8 8A4A     		ldr	r2, .L784+28
 11934 00fa 0027     		movs	r7, #0
 216:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 				 SpeakHoTT = HoTTv4NotificationAltitudeOn;
 11935              		.loc 5 216 0
 11936 00fc 2726     		movs	r6, #39
 215:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 				 isAHOff = false;
 11937              		.loc 5 215 0
 11938 00fe 1770     		strb	r7, [r2, #0]
 216:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 				 SpeakHoTT = HoTTv4NotificationAltitudeOn;
 11939              		.loc 5 216 0
 11940 0100 2E70     		strb	r6, [r5, #0]
 11941              	.L749:
 259:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if(!status) {
 11942              		.loc 5 259 0
 11943 0102 04B9     		cbnz	r4, .L755
 260:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		status = SpeakHoTT; 
 11944              		.loc 5 260 0
 11945 0104 2C78     		ldrb	r4, [r5, #0]	@ zero_extendqisi2
 11946              	.LVL489:
 11947              	.L755:
 263:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if(oldStatus == status) {
 11948              		.loc 5 263 0
 11949 0106 884F     		ldr	r7, .L784+32
 11950 0108 884E     		ldr	r6, .L784+36
 11951 010a 97F800C0 		ldrb	ip, [r7, #0]	@ zero_extendqisi2
 11952 010e A445     		cmp	ip, r4
 11953 0110 06D1     		bne	.L756
 264:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		if(!CheckDelay(repeat)) return 0;
 11954              		.loc 5 264 0
 11955 0112 3068     		ldr	r0, [r6, #0]
 11956 0114 FFF7FEFF 		bl	_Z10CheckDelayj
 11957 0118 88B1     		cbz	r0, .L777
 265:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		repeat = SetDelay(5000);
 11958              		.loc 5 265 0
 11959 011a 41F28830 		movw	r0, #5000
 11960 011e 01E0     		b	.L781
 11961              	.L756:
 267:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	else repeat = SetDelay(2000);
 11962              		.loc 5 267 0
 11963 0120 4FF4FA60 		mov	r0, #2000
 11964              	.L781:
 11965 0124 FFF7FEFF 		bl	_Z8SetDelayj
 11966 0128 3060     		str	r0, [r6, #0]
 269:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if(status) 	{
 11967              		.loc 5 269 0
 11968 012a 34B1     		cbz	r4, .L759
 270:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		if(status == SpeakHoTT) SpeakHoTT = 0;
 11969              		.loc 5 270 0
 11970 012c 95F800E0 		ldrb	lr, [r5, #0]	@ zero_extendqisi2
 11971 0130 A645     		cmp	lr, r4
 11972 0132 02D1     		bne	.L759
 11973 0134 784B     		ldr	r3, .L784+16
 11974 0136 0020     		movs	r0, #0
 11975 0138 1870     		strb	r0, [r3, #0]
 11976              	.L759:
 273:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	oldStatus = status;
 11977              		.loc 5 273 0
 11978 013a 3C70     		strb	r4, [r7, #0]
 11979 013c 00E0     		b	.L757
 11980              	.L777:
 264:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		if(!CheckDelay(repeat)) return 0;
 11981              		.loc 5 264 0
 11982 013e 0446     		mov	r4, r0
 11983              	.LVL490:
 11984              	.L757:
 11985              	.LBE345:
 11986              	.LBE349:
 499:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[2] = hottVoiceOutput();
 11987              		.loc 5 499 0
 11988 0140 8DF80240 		strb	r4, [sp, #2]
 11989 0144 39E1     		b	.L773
 11990              	.LVL491:
 11991              	.L745:
 11992              	.LBE335:
 11993              	.LBE334:
 11994              	.LBB350:
 11995              	.LBB351:
 354:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****             };
 11996              		.loc 5 354 0
 11997 0146 0021     		movs	r1, #0
 11998 0148 2D22     		movs	r2, #45
 11999 014a 6846     		mov	r0, sp
 12000              	.LVL492:
 12001 014c FFF7FEFF 		bl	memset
 12002 0150 7C22     		movs	r2, #124
 12003 0152 E020     		movs	r0, #224
 12004 0154 8DF80020 		strb	r2, [sp, #0]
 12005 0158 F422     		movs	r2, #244
 12006 015a 8DF80300 		strb	r0, [sp, #3]
 12007 015e 8DF81A20 		strb	r2, [sp, #26]
 12008 0162 4820     		movs	r0, #72
 12009 0164 7D22     		movs	r2, #125
 12010 0166 1421     		movs	r1, #20
 12011 0168 8DF82200 		strb	r0, [sp, #34]
 12012 016c 8DF82B20 		strb	r2, [sp, #43]
 12013              	.LVL493:
 12014              	.LBB352:
 12015              	.LBB353:
 121:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryWarning || batteryAlarm) {
 12016              		.loc 5 121 0
 12017 0170 6F48     		ldr	r0, .L784+40
 119:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	short voltage = batteryData[0].voltage/10;
 12018              		.loc 5 119 0
 12019 0172 704A     		ldr	r2, .L784+44
 12020              	.LBE353:
 12021              	.LBE352:
 354:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****             };
 12022              		.loc 5 354 0
 12023 0174 8DF81810 		strb	r1, [sp, #24]
 12024 0178 8E23     		movs	r3, #142
 12025 017a 8DF81910 		strb	r1, [sp, #25]
 12026 017e 7821     		movs	r1, #120
 12027 0180 8DF80130 		strb	r3, [sp, #1]
 12028 0184 8DF82410 		strb	r1, [sp, #36]
 12029 0188 0123     		movs	r3, #1
 12030              	.LBB358:
 12031              	.LBB356:
 119:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	short voltage = batteryData[0].voltage/10;
 12032              		.loc 5 119 0
 12033 018a B2F806C0 		ldrh	ip, [r2, #6]
 121:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryWarning || batteryAlarm) {
 12034              		.loc 5 121 0
 12035 018e 0178     		ldrb	r1, [r0, #0]	@ zero_extendqisi2
 12036              	.LBE356:
 12037              	.LBE358:
 354:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****             };
 12038              		.loc 5 354 0
 12039 0190 8DF81B30 		strb	r3, [sp, #27]
 12040              	.LBB359:
 12041              	.LBB357:
 119:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	short voltage = batteryData[0].voltage/10;
 12042              		.loc 5 119 0
 12043 0194 0A23     		movs	r3, #10
 12044 0196 BCFBF3F3 		udiv	r3, ip, r3
 12045              	.LVL494:
 121:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryWarning || batteryAlarm) {
 12046              		.loc 5 121 0
 12047 019a 11B9     		cbnz	r1, .L760
 12048 019c 5C48     		ldr	r0, .L784+8
 12049 019e 0178     		ldrb	r1, [r0, #0]	@ zero_extendqisi2
 12050 01a0 11B1     		cbz	r1, .L761
 12051              	.L760:
 12052              	.LVL495:
 12053              	.LBB354:
 12054              	.LBB355:
 109:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     data[4] = 0x80; // Inverts MikroKopter Telemetry Display for Voltage
 12055              		.loc 5 109 0
 12056 01a2 8021     		movs	r1, #128
 12057 01a4 8DF80410 		strb	r1, [sp, #4]
 12058              	.LVL496:
 12059              	.L761:
 12060              	.LBE355:
 12061              	.LBE354:
 12062              	.LBE357:
 12063              	.LBE359:
 12064              	.LBB360:
 12065              	.LBB361:
 129:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryData[0].cPin != BM_NOPIN) return batteryData[0].current/100;
 12066              		.loc 5 129 0
 12067 01a8 917A     		ldrb	r1, [r2, #10]	@ zero_extendqisi2
 12068              	.LBE361:
 12069              	.LBE360:
 358:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[20] = telemetry_data[22] = telemetry_data[30] = voltage;
 12070              		.loc 5 358 0
 12071 01aa 8DF81E30 		strb	r3, [sp, #30]
 12072 01ae 8DF81630 		strb	r3, [sp, #22]
 12073 01b2 8DF81430 		strb	r3, [sp, #20]
 359:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[21] = telemetry_data[23] = telemetry_data[31] = (voltage >> 8) & 0xFF;
 12074              		.loc 5 359 0
 12075 01b6 1B0A     		lsrs	r3, r3, #8
 12076              	.LVL497:
 12077              	.LBB364:
 12078              	.LBB362:
 129:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryData[0].cPin != BM_NOPIN) return batteryData[0].current/100;
 12079              		.loc 5 129 0
 12080 01b8 FF29     		cmp	r1, #255
 12081              	.LBE362:
 12082              	.LBE364:
 359:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[21] = telemetry_data[23] = telemetry_data[31] = (voltage >> 8) & 0xFF;
 12083              		.loc 5 359 0
 12084 01ba 8DF81F30 		strb	r3, [sp, #31]
 12085 01be 8DF81730 		strb	r3, [sp, #23]
 12086 01c2 8DF81530 		strb	r3, [sp, #21]
 12087              	.LBB365:
 12088              	.LBB363:
 129:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryData[0].cPin != BM_NOPIN) return batteryData[0].current/100;
 12089              		.loc 5 129 0
 12090 01c6 07D0     		beq	.L778
 12091 01c8 5A48     		ldr	r0, .L784+44
 12092 01ca B0F910E0 		ldrsh	lr, [r0, #16]
 12093 01ce 6423     		movs	r3, #100
 12094 01d0 9EFBF3F0 		sdiv	r0, lr, r3
 12095 01d4 83B2     		uxth	r3, r0
 12096 01d6 00E0     		b	.L762
 12097              	.L778:
 130:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	return 0;
 12098              		.loc 5 130 0
 12099 01d8 0023     		movs	r3, #0
 12100              	.L762:
 12101              	.LBE363:
 12102              	.LBE365:
 363:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[29] = (current >> 8) & 0xFF;
 12103              		.loc 5 363 0
 12104 01da 180A     		lsrs	r0, r3, #8
 12105              	.LBB366:
 12106              	.LBB367:
 134:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryData[0].cPin != BM_NOPIN) return batteryData[0].usedCapacity/1000;
 12107              		.loc 5 134 0
 12108 01dc FF29     		cmp	r1, #255
 12109 01de 18BF     		it	ne
 12110 01e0 5269     		ldrne	r2, [r2, #20]
 12111              	.LBE367:
 12112              	.LBE366:
 363:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[29] = (current >> 8) & 0xFF;
 12113              		.loc 5 363 0
 12114 01e2 8DF81D00 		strb	r0, [sp, #29]
 12115              	.LBB369:
 12116              	.LBB368:
 134:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	if (batteryData[0].cPin != BM_NOPIN) return batteryData[0].usedCapacity/1000;
 12117              		.loc 5 134 0
 12118 01e6 1ABF     		itte	ne
 12119 01e8 4FF47A70 		movne	r0, #1000
 12120 01ec 92FBF0F0 		sdivne	r0, r2, r0
 135:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	return 0;
 12121              		.loc 5 135 0
 12122 01f0 0020     		moveq	r0, #0
 12123              	.LBE368:
 12124              	.LBE369:
 362:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[28] = current;
 12125              		.loc 5 362 0
 12126 01f2 8DF81C30 		strb	r3, [sp, #28]
 367:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[33] = (capacity >> 8) & 0xFF;
 12127              		.loc 5 367 0
 12128 01f6 0312     		asrs	r3, r0, #8
 12129 01f8 8DF82130 		strb	r3, [sp, #33]
 366:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[32] = capacity;
 12130              		.loc 5 366 0
 12131 01fc 8DF82000 		strb	r0, [sp, #32]
 371:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     int32_t altitude = hottv4UpdateAlt();
 12132              		.loc 5 371 0
 12133 0200 FFF7FEFF 		bl	_ZL15hottv4UpdateAltv
 12134              	.LVL498:
 372:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[26] = altitude;
 12135              		.loc 5 372 0
 12136 0204 8DF81A00 		strb	r0, [sp, #26]
 373:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	telemetry_data[27] = (altitude >> 8) & 0xFF;
 12137              		.loc 5 373 0
 12138 0208 0012     		asrs	r0, r0, #8
 12139              	.LVL499:
 12140 020a 8DF81B00 		strb	r0, [sp, #27]
 375:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	unsigned int varioSound = hottv4UpdateAltVario();
 12141              		.loc 5 375 0
 12142 020e FFF7FEFF 		bl	_ZL20hottv4UpdateAltVariov
 12143              	.LVL500:
 377:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     telemetry_data[12] = telemetry_data[14] = (varioSound >> 8) & 0xFF;
 12144              		.loc 5 377 0
 12145 0212 010A     		lsrs	r1, r0, #8
 12146 0214 8DF80E10 		strb	r1, [sp, #14]
 12147 0218 8DF80C10 		strb	r1, [sp, #12]
 12148              	.LVL501:
 376:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     telemetry_data[11] = telemetry_data[13] = varioSound;
 12149              		.loc 5 376 0
 12150 021c 8DF80D00 		strb	r0, [sp, #13]
 12151 0220 8DF80B00 		strb	r0, [sp, #11]
 12152              	.LBB370:
 12153              	.LBB371:
 286:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint16_t timeDiff = millis() - previousEAMUpdate;
 12154              		.loc 5 286 0
 12155 0224 FFF7FEFF 		bl	_ZL6millisv
 12156              	.LVL502:
 12157 0228 434B     		ldr	r3, .L784+48
 12158 022a 1A68     		ldr	r2, [r3, #0]
 12159 022c C2EB000C 		rsb	ip, r2, r0
 12160 0230 1FFA8CF1 		uxth	r1, ip
 12161              	.LVL503:
 287:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   previousEAMUpdate += timeDiff;
 12162              		.loc 5 287 0
 12163 0234 8818     		adds	r0, r1, r2
 12164 0236 1860     		str	r0, [r3, #0]
 289:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   CountMilliseconds += timeDiff;
 12165              		.loc 5 289 0
 12166 0238 404B     		ldr	r3, .L784+52
 12167 023a 1A68     		ldr	r2, [r3, #0]
 12168 023c 8818     		adds	r0, r1, r2
 291:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if (motorArmed) {
 12169              		.loc 5 291 0
 12170 023e 404A     		ldr	r2, .L784+56
 289:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   CountMilliseconds += timeDiff;
 12171              		.loc 5 289 0
 12172 0240 1860     		str	r0, [r3, #0]
 291:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if (motorArmed) {
 12173              		.loc 5 291 0
 12174 0242 1078     		ldrb	r0, [r2, #0]	@ zero_extendqisi2
 12175 0244 3F4B     		ldr	r3, .L784+60
 12176 0246 404A     		ldr	r2, .L784+64
 12177 0248 80B1     		cbz	r0, .L764
 292:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     milliseconds += timeDiff;
 12178              		.loc 5 292 0
 12179 024a 1888     		ldrh	r0, [r3, #0]
 12180 024c 01EB000C 		add	ip, r1, r0
 12181 0250 1FFA8CF1 		uxth	r1, ip
 12182              	.LVL504:
 294:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     if (milliseconds >= 60000) {
 12183              		.loc 5 294 0
 12184 0254 4EF65F2E 		movw	lr, #59999
 12185 0258 7145     		cmp	r1, lr
 292:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     milliseconds += timeDiff;
 12186              		.loc 5 292 0
 12187 025a 1980     		strh	r1, [r3, #0]	@ movhi
 294:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     if (milliseconds >= 60000) {
 12188              		.loc 5 294 0
 12189 025c 06D9     		bls	.L764
 296:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       minutes += 1;
 12190              		.loc 5 296 0
 12191 025e 1078     		ldrb	r0, [r2, #0]	@ zero_extendqisi2
 295:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       milliseconds -= 60000;
 12192              		.loc 5 295 0
 12193 0260 01F5AD5E 		add	lr, r1, #5536
 296:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       minutes += 1;
 12194              		.loc 5 296 0
 12195 0264 411C     		adds	r1, r0, #1
 295:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       milliseconds -= 60000;
 12196              		.loc 5 295 0
 12197 0266 A3F800E0 		strh	lr, [r3, #0]	@ movhi
 296:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       minutes += 1;
 12198              		.loc 5 296 0
 12199 026a 1170     		strb	r1, [r2, #0]
 12200              	.L764:
 302:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   data[40] = (milliseconds >> 10) ;
 12201              		.loc 5 302 0
 12202 026c 1B88     		ldrh	r3, [r3, #0]
 300:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   data[39] = minutes;
 12203              		.loc 5 300 0
 12204 026e 1178     		ldrb	r1, [r2, #0]	@ zero_extendqisi2
 302:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   data[40] = (milliseconds >> 10) ;
 12205              		.loc 5 302 0
 12206 0270 9A12     		asrs	r2, r3, #10
 300:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   data[39] = minutes;
 12207              		.loc 5 300 0
 12208 0272 8DF82710 		strb	r1, [sp, #39]
 302:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   data[40] = (milliseconds >> 10) ;
 12209              		.loc 5 302 0
 12210 0276 8DF82820 		strb	r2, [sp, #40]
 12211 027a 9EE0     		b	.L773
 12212              	.LVL505:
 12213              	.L746:
 12214              	.LBE371:
 12215              	.LBE370:
 12216              	.LBE351:
 12217              	.LBE350:
 12218              	.LBB372:
 12219              	.LBB373:
 535:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****             };
 12220              		.loc 5 535 0
 12221 027c 334B     		ldr	r3, .L784+68
 12222 027e 6A46     		mov	r2, sp
 12223 0280 03F12805 		add	r5, r3, #40
 12224              	.LVL506:
 12225              	.L765:
 12226 0284 1868     		ldr	r0, [r3, #0]	@ unaligned
 12227 0286 5968     		ldr	r1, [r3, #4]	@ unaligned
 12228 0288 1446     		mov	r4, r2
 12229 028a 03C4     		stmia	r4!, {r0, r1}
 12230 028c 0833     		adds	r3, r3, #8
 12231 028e AB42     		cmp	r3, r5
 12232 0290 2246     		mov	r2, r4
 12233 0292 F7D1     		bne	.L765
 12234 0294 1868     		ldr	r0, [r3, #0]	@ unaligned
 12235 0296 2060     		str	r0, [r4, #0]	@ unaligned
 12236 0298 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 12237 029a 2171     		strb	r1, [r4, #4]
 538:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   int32_t altitude = hottv4UpdateAlt();
 12238              		.loc 5 538 0
 12239 029c FFF7FEFF 		bl	_ZL15hottv4UpdateAltv
 12240              	.LVL507:
 542:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[7] = maxAltitude;
 12241              		.loc 5 542 0
 12242 02a0 2B4A     		ldr	r2, .L784+72
 543:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[9] = minAltitude;
 12243              		.loc 5 543 0
 12244 02a2 2C49     		ldr	r1, .L784+76
 539:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[5] = altitude;
 12245              		.loc 5 539 0
 12246 02a4 8DF80500 		strb	r0, [sp, #5]
 540:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[6] = (altitude >> 8) & 0xFF;
 12247              		.loc 5 540 0
 12248 02a8 0312     		asrs	r3, r0, #8
 12249 02aa 8DF80630 		strb	r3, [sp, #6]
 542:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[7] = maxAltitude;
 12250              		.loc 5 542 0
 12251 02ae 1068     		ldr	r0, [r2, #0]
 12252              	.LVL508:
 543:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[9] = minAltitude;
 12253              		.loc 5 543 0
 12254 02b0 0B68     		ldr	r3, [r1, #0]
 542:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[7] = maxAltitude;
 12255              		.loc 5 542 0
 12256 02b2 8DF80700 		strb	r0, [sp, #7]
 543:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[9] = minAltitude;
 12257              		.loc 5 543 0
 12258 02b6 8DF80930 		strb	r3, [sp, #9]
 545:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   unsigned int varioSound = hottv4UpdateAltVario();
 12259              		.loc 5 545 0
 12260 02ba FFF7FEFF 		bl	_ZL20hottv4UpdateAltVariov
 12261              	.LVL509:
 547:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[12] = telemetry_data[14] = telemetry_data[16] = (varioSound >> 8) & 0xFF;
 12262              		.loc 5 547 0
 12263 02be 020A     		lsrs	r2, r0, #8
 546:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[11] = telemetry_data[13] = telemetry_data[15] = varioSound;
 12264              		.loc 5 546 0
 12265 02c0 8DF80F00 		strb	r0, [sp, #15]
 12266 02c4 8DF80D00 		strb	r0, [sp, #13]
 12267 02c8 8DF80B00 		strb	r0, [sp, #11]
 549:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(altitudeHoldState == ON) {
 12268              		.loc 5 549 0
 12269 02cc 1348     		ldr	r0, .L784+20
 12270              	.LVL510:
 547:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[12] = telemetry_data[14] = telemetry_data[16] = (varioSound >> 8) & 0xFF;
 12271              		.loc 5 547 0
 12272 02ce 8DF81020 		strb	r2, [sp, #16]
 549:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(altitudeHoldState == ON) {
 12273              		.loc 5 549 0
 12274 02d2 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 547:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[12] = telemetry_data[14] = telemetry_data[16] = (varioSound >> 8) & 0xFF;
 12275              		.loc 5 547 0
 12276 02d4 8DF80E20 		strb	r2, [sp, #14]
 549:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(altitudeHoldState == ON) {
 12277              		.loc 5 549 0
 12278 02d8 012B     		cmp	r3, #1
 547:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   telemetry_data[12] = telemetry_data[14] = telemetry_data[16] = (varioSound >> 8) & 0xFF;
 12279              		.loc 5 547 0
 12280 02da 8DF80C20 		strb	r2, [sp, #12]
 549:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(altitudeHoldState == ON) {
 12281              		.loc 5 549 0
 12282 02de 41D1     		bne	.L766
 550:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  if((receiverCommand[THROTTLE] > (altitudeHoldThrottle + altitudeHoldBump))) telemetry_data[38] =
 12283              		.loc 5 550 0
 12284 02e0 1D49     		ldr	r1, .L784+80
 12285 02e2 1E4A     		ldr	r2, .L784+84
 12286 02e4 1E4B     		ldr	r3, .L784+88
 12287 02e6 0968     		ldr	r1, [r1, #0]
 12288 02e8 1268     		ldr	r2, [r2, #0]
 12289 02ea DB68     		ldr	r3, [r3, #12]
 12290 02ec 01EB020C 		add	ip, r1, r2
 12291 02f0 6345     		cmp	r3, ip
 12292 02f2 01DD     		ble	.L767
 12293 02f4 2B23     		movs	r3, #43
 12294 02f6 38E0     		b	.L782
 12295              	.L767:
 551:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  else if((receiverCommand[THROTTLE] < (altitudeHoldThrottle - altitudeHoldBump))) telemetry_data[
 12296              		.loc 5 551 0
 12297 02f8 8A1A     		subs	r2, r1, r2
 12298 02fa 9342     		cmp	r3, r2
 12299 02fc 01DA     		bge	.L769
 12300 02fe 2D23     		movs	r3, #45
 12301 0300 33E0     		b	.L782
 12302              	.L769:
 552:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  else telemetry_data[38] = '=';
 12303              		.loc 5 552 0
 12304 0302 3D23     		movs	r3, #61
 12305 0304 31E0     		b	.L782
 12306              	.L785:
 12307 0306 00BF     		.align	2
 12308              	.L784:
 12309 0308 00000000 		.word	.LANCHOR74
 12310 030c DB0F4940 		.word	1078530011
 12311 0310 00000000 		.word	.LANCHOR104
 12312 0314 00003443 		.word	1127481344
 12313 0318 00000000 		.word	.LANCHOR136
 12314 031c 00000000 		.word	.LANCHOR5
 12315 0320 00000000 		.word	.LANCHOR145
 12316 0324 00000000 		.word	.LANCHOR146
 12317 0328 00000000 		.word	.LANCHOR147
 12318 032c 00000000 		.word	.LANCHOR148
 12319 0330 00000000 		.word	.LANCHOR105
 12320 0334 00000000 		.word	.LANCHOR103
 12321 0338 00000000 		.word	.LANCHOR149
 12322 033c 00000000 		.word	.LANCHOR144
 12323 0340 00000000 		.word	.LANCHOR130
 12324 0344 00000000 		.word	.LANCHOR150
 12325 0348 00000000 		.word	.LANCHOR151
 12326 034c 00000000 		.word	.LANCHOR152
 12327 0350 00000000 		.word	.LANCHOR82
 12328 0354 00000000 		.word	.LANCHOR83
 12329 0358 00000000 		.word	.LANCHOR7
 12330 035c 00000000 		.word	.LANCHOR8
 12331 0360 00000000 		.word	.LANCHOR6
 12332              	.L766:
 554:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   else if (altitudeHoldState == ALTPANIC) {
 12333              		.loc 5 554 0
 12334 0364 022B     		cmp	r3, #2
 12335 0366 02D1     		bne	.L768
 555:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	  telemetry_data[38] = '!';
 12336              		.loc 5 555 0
 12337 0368 2123     		movs	r3, #33
 12338              	.L782:
 12339 036a 8DF82630 		strb	r3, [sp, #38]
 12340              	.L768:
 562:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(flightMode == ATTITUDE_FLIGHT_MODE) snprintf(text, VARIO_ASCIIS+1, HOTTV4_VARIO_ATTITUDE);
 12341              		.loc 5 562 0
 12342 036e 1749     		ldr	r1, .L786
 12343 0370 91F800E0 		ldrb	lr, [r1, #0]	@ zero_extendqisi2
 12344 0374 1621     		movs	r1, #22
 12345 0376 BEF1010F 		cmp	lr, #1
 12346 037a 0CBF     		ite	eq
 12347 037c 144A     		ldreq	r2, .L786+4
 563:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   else snprintf(text, VARIO_ASCIIS+1, HOTTV4_VARIO_RATE);
 12348              		.loc 5 563 0
 12349 037e 154A     		ldrne	r2, .L786+8
 562:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   if(flightMode == ATTITUDE_FLIGHT_MODE) snprintf(text, VARIO_ASCIIS+1, HOTTV4_VARIO_ATTITUDE);
 12350              		.loc 5 562 0
 12351 0380 0CA8     		add	r0, sp, #48
 563:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   else snprintf(text, VARIO_ASCIIS+1, HOTTV4_VARIO_RATE);
 12352              		.loc 5 563 0
 12353 0382 FFF7FEFF 		bl	snprintf
 565:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   uint8_t offset = (VARIO_ASCIIS - strlen(text)) / 2;
 12354              		.loc 5 565 0
 12355 0386 0CA8     		add	r0, sp, #48
 12356 0388 FFF7FEFF 		bl	strlen
 12357 038c C0F11502 		rsb	r2, r0, #21
 12358 0390 5008     		lsrs	r0, r2, #1
 12359 0392 C2B2     		uxtb	r2, r0
 12360              	.LVL511:
 567:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   for(uint8_t index = 0; (index + offset) < VARIO_ASCIIS; index++) {
 12361              		.loc 5 567 0
 12362 0394 0023     		movs	r3, #0
 12363 0396 0BE0     		b	.L772
 12364              	.LVL512:
 12365              	.L774:
 12366              	.LBB374:
 568:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     if (text[index] != 0x0) {
 12367              		.loc 5 568 0
 12368 0398 0DF1480C 		add	ip, sp, #72
 12369 039c 0CEB0300 		add	r0, ip, r3
 12370 03a0 10F8181C 		ldrb	r1, [r0, #-24]	@ zero_extendqisi2
 12371 03a4 49B1     		cbz	r1, .L773
 570:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       telemetry_data[17+index+offset] = text[index];
 12372              		.loc 5 570 0
 12373 03a6 8018     		adds	r0, r0, r2
 567:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   for(uint8_t index = 0; (index + offset) < VARIO_ASCIIS; index++) {
 12374              		.loc 5 567 0
 12375 03a8 0133     		adds	r3, r3, #1
 12376              	.LVL513:
 570:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       telemetry_data[17+index+offset] = text[index];
 12377              		.loc 5 570 0
 12378 03aa 00F8371C 		strb	r1, [r0, #-55]
 567:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   for(uint8_t index = 0; (index + offset) < VARIO_ASCIIS; index++) {
 12379              		.loc 5 567 0
 12380 03ae DBB2     		uxtb	r3, r3
 12381              	.LVL514:
 12382              	.L772:
 12383 03b0 03EB020E 		add	lr, r3, r2
 12384 03b4 BEF1140F 		cmp	lr, #20
 12385 03b8 EEDD     		ble	.L774
 12386              	.LVL515:
 12387              	.L773:
 12388              	.LBE374:
 577:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4SendBinary(telemetry_data);
 12389              		.loc 5 577 0
 12390 03ba 6846     		mov	r0, sp
 12391 03bc FFF7FEFF 		bl	_ZL16hottV4SendBinaryPh
 589:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     case HOTTV4_GPS_MODULE:
 590:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     case '1':
 591:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       hottV4SendGPSTelemetry();
 592:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       return true;
 593:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       break;
 594:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     
 595:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     case HOTTV4_ELECTRICAL_AIR_MODULE:
 596:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     case '2':
 597:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       hottV4SendEAMTelemetry();
 598:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       return true;
 599:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       break;
 600:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****          
 601:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     case HOTTV4_VARIO_MODULE:
 602:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****     case '3':
 603:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       hottV4SendVarioTelemetry();
 604:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       return true;
 12392              		.loc 5 604 0
 12393 03c0 0120     		movs	r0, #1
 12394 03c2 00E0     		b	.L743
 12395              	.LVL516:
 12396              	.L775:
 12397              	.LBE373:
 12398              	.LBE372:
 605:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****       break;
 606:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   }
 607:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 608:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   return false;
 12399              		.loc 5 608 0
 12400 03c4 0020     		movs	r0, #0
 12401              	.LVL517:
 12402              	.L743:
 609:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** }
 12403              		.loc 5 609 0
 12404 03c6 13B0     		add	sp, sp, #76
 12405 03c8 F0BD     		pop	{r4, r5, r6, r7, pc}
 12406              	.L787:
 12407 03ca 00BF     		.align	2
 12408              	.L786:
 12409 03cc 00000000 		.word	.LANCHOR114
 12410 03d0 82010000 		.word	.LC26
 12411 03d4 96010000 		.word	.LC27
 12412              		.cfi_endproc
 12413              	.LFE273:
 12415              		.section	.text._Z11hottHandlerv,"ax",%progbits
 12416              		.align	1
 12417              		.global	_Z11hottHandlerv
 12418              		.thumb
 12419              		.thumb_func
 12421              	_Z11hottHandlerv:
 12422              	.LFB274:
 610:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 611:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** enum HottStateMachine {
 612:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	eHottReadCmd,
 613:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	eHottSendStartDelay,
 614:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	eHottSendByte,
 615:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	eHottCleanUp
 616:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** } ;
 617:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 618:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 619:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** HottStateMachine hottState = eHottReadCmd;
 620:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** uint32 hottTime;
 621:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** void hottHandler()
 622:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** {
 12423              		.loc 5 622 0
 12424              		.cfi_startproc
 12425              		@ args = 0, pretend = 0, frame = 0
 12426              		@ frame_needed = 0, uses_anonymous_args = 0
 12427 0000 70B5     		push	{r4, r5, r6, lr}
 12428              	.LCFI114:
 12429              		.cfi_def_cfa_offset 16
 12430              		.cfi_offset 14, -4
 12431              		.cfi_offset 6, -8
 12432              		.cfi_offset 5, -12
 12433              		.cfi_offset 4, -16
 12434              	.LBB380:
 623:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	switch(hottState) {
 12435              		.loc 5 623 0
 12436 0002 2A4C     		ldr	r4, .L796
 12437 0004 2378     		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 12438 0006 032B     		cmp	r3, #3
 12439 0008 4ED8     		bhi	.L788
 12440 000a DFE803F0 		tbb	[pc, r3]
 12441              	.L794:
 12442 000e 02       		.byte	(.L790-.L794)/2
 12443 000f 11       		.byte	(.L791-.L794)/2
 12444 0010 1F       		.byte	(.L792-.L794)/2
 12445 0011 3D       		.byte	(.L793-.L794)/2
 12446              		.align	1
 12447              	.L790:
 12448              	.LBB381:
 12449              	.LBB382:
 624:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	case eHottReadCmd:
 625:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		{
 626:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		  byte cmd = hottV4SerialRead();
 12450              		.loc 5 626 0
 12451 0012 FFF7FEFF 		bl	_Z16hottV4SerialReadv
 12452 0016 C0B2     		uxtb	r0, r0
 12453              	.LVL518:
 627:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	      if(cmd != 0xff && hottV4Hook(cmd)) {
 12454              		.loc 5 627 0
 12455 0018 FF28     		cmp	r0, #255
 12456 001a 45D0     		beq	.L788
 12457              		.loc 5 627 0 is_stmt 0 discriminator 1
 12458 001c FFF7FEFF 		bl	_Z10hottV4Hookh
 12459              	.LVL519:
 12460 0020 0028     		cmp	r0, #0
 12461 0022 41D0     		beq	.L788
 628:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   	        hottTime = micros();
 12462              		.loc 5 628 0 is_stmt 1 discriminator 4
 12463 0024 FFF7FEFF 		bl	_ZL6microsv
 12464 0028 2149     		ldr	r1, .L796+4
 629:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   	        hottState = eHottSendStartDelay;
 12465              		.loc 5 629 0 discriminator 4
 12466 002a 0123     		movs	r3, #1
 628:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   	        hottTime = micros();
 12467              		.loc 5 628 0 discriminator 4
 12468 002c 0860     		str	r0, [r1, #0]
 12469 002e 0BE0     		b	.L795
 12470              	.L791:
 12471              	.LBE382:
 630:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	      }
 631:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		}
 632:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		break;
 633:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 634:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	case eHottSendStartDelay:
 635:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		if(micros() - hottTime > 2000) {
 12472              		.loc 5 635 0
 12473 0030 1F4D     		ldr	r5, .L796+4
 12474 0032 FFF7FEFF 		bl	_ZL6microsv
 12475 0036 2A68     		ldr	r2, [r5, #0]
 12476 0038 801A     		subs	r0, r0, r2
 12477 003a B0F5FA6F 		cmp	r0, #2000
 12478 003e 33D9     		bls	.L788
 636:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		    hottTime = micros();
 12479              		.loc 5 636 0
 12480 0040 FFF7FEFF 		bl	_ZL6microsv
 637:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		    hottState = eHottSendByte;
 12481              		.loc 5 637 0
 12482 0044 0223     		movs	r3, #2
 636:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		    hottTime = micros();
 12483              		.loc 5 636 0
 12484 0046 2860     		str	r0, [r5, #0]
 12485              	.L795:
 12486              		.loc 5 637 0
 12487 0048 2370     		strb	r3, [r4, #0]
 12488 004a 70BD     		pop	{r4, r5, r6, pc}
 12489              	.L792:
 638:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		}
 639:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		break;
 640:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 641:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	case eHottSendByte:
 642:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		if(micros() - hottTime > 1000) {
 12490              		.loc 5 642 0
 12491 004c 184E     		ldr	r6, .L796+4
 12492 004e FFF7FEFF 		bl	_ZL6microsv
 12493 0052 3368     		ldr	r3, [r6, #0]
 12494 0054 C3EB000C 		rsb	ip, r3, r0
 12495 0058 BCF57A7F 		cmp	ip, #1000
 12496 005c 24D9     		bls	.L788
 643:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 			hottV4SerialWrite(hottV4TelemetryBuffer[hottV4TelemetryBufferIndex++]);
 12497              		.loc 5 643 0
 12498 005e 154D     		ldr	r5, .L796+8
 12499              	.LBB383:
 12500              	.LBB384:
  45:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4Serial->write(data);
 12501              		.loc 5 45 0
 12502 0060 1548     		ldr	r0, .L796+12
 12503              	.LBE384:
 12504              	.LBE383:
 12505              		.loc 5 643 0
 12506 0062 2B78     		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 12507              	.LBB388:
 12508              	.LBB385:
  45:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4Serial->write(data);
 12509              		.loc 5 45 0
 12510 0064 0068     		ldr	r0, [r0, #0]
 12511              	.LBE385:
 12512              	.LBE388:
 12513              		.loc 5 643 0
 12514 0066 1549     		ldr	r1, .L796+16
 12515 0068 5A1C     		adds	r2, r3, #1
 12516 006a C95C     		ldrb	r1, [r1, r3]	@ zero_extendqisi2
 12517              	.LBB389:
 12518              	.LBB386:
  45:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4Serial->write(data);
 12519              		.loc 5 45 0
 12520 006c 0368     		ldr	r3, [r0, #0]
 12521              	.LBE386:
 12522              	.LBE389:
 12523              		.loc 5 643 0
 12524 006e 2A70     		strb	r2, [r5, #0]
 12525              	.LVL520:
 12526              	.LBB390:
 12527              	.LBB387:
  45:../Libraries/AQ_HoTT/HoTT_Telemetry.h ****   hottV4Serial->write(data);
 12528              		.loc 5 45 0
 12529 0070 1A68     		ldr	r2, [r3, #0]
 12530 0072 9047     		blx	r2
 12531              	.LVL521:
 12532              	.LBE387:
 12533              	.LBE390:
 644:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 			hottV4SerialClearInput();
 12534              		.loc 5 644 0
 12535 0074 FFF7FEFF 		bl	_Z22hottV4SerialClearInputv
 645:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 646:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 			hottTime = micros();
 12536              		.loc 5 646 0
 12537 0078 FFF7FEFF 		bl	_ZL6microsv
 647:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		    if(hottV4TelemetryBufferIndex >= hottV4TelemetryBufferSize) {
 12538              		.loc 5 647 0
 12539 007c 2978     		ldrb	r1, [r5, #0]	@ zero_extendqisi2
 646:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 			hottTime = micros();
 12540              		.loc 5 646 0
 12541 007e 3060     		str	r0, [r6, #0]
 12542              		.loc 5 647 0
 12543 0080 2C29     		cmp	r1, #44
 12544 0082 11D9     		bls	.L788
 648:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		    	hottState = eHottCleanUp;
 12545              		.loc 5 648 0
 12546 0084 0323     		movs	r3, #3
 12547 0086 DFE7     		b	.L795
 12548              	.L793:
 649:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		    }
 650:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		}
 651:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		break;
 652:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 653:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 	case eHottCleanUp:
 654:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		hottV4SerialClearInput();
 655:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 
 656:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		if(micros() - hottTime > 5000) {
 12549              		.loc 5 656 0
 12550 0088 094D     		ldr	r5, .L796+4
 654:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		hottV4SerialClearInput();
 12551              		.loc 5 654 0
 12552 008a FFF7FEFF 		bl	_Z22hottV4SerialClearInputv
 12553              		.loc 5 656 0
 12554 008e FFF7FEFF 		bl	_ZL6microsv
 12555 0092 2B68     		ldr	r3, [r5, #0]
 12556 0094 C21A     		subs	r2, r0, r3
 12557 0096 41F28830 		movw	r0, #5000
 12558 009a 8242     		cmp	r2, r0
 12559 009c 04D9     		bls	.L788
 657:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		    hottTime = micros();
 12560              		.loc 5 657 0
 12561 009e FFF7FEFF 		bl	_ZL6microsv
 658:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		    hottState = eHottReadCmd;
 12562              		.loc 5 658 0
 12563 00a2 0021     		movs	r1, #0
 657:../Libraries/AQ_HoTT/HoTT_Telemetry.h **** 		    hottTime = micros();
 12564              		.loc 5 657 0
 12565 00a4 2860     		str	r0, [r5, #0]
 12566              		.loc 5 658 0
 12567 00a6 2170     		strb	r1, [r4, #0]
 12568              	.L788:
 12569 00a8 70BD     		pop	{r4, r5, r6, pc}
 12570              	.L797:
 12571 00aa 00BF     		.align	2
 12572              	.L796:
 12573 00ac 00000000 		.word	.LANCHOR153
 12574 00b0 00000000 		.word	.LANCHOR154
 12575 00b4 00000000 		.word	.LANCHOR4
 12576 00b8 00000000 		.word	.LANCHOR143
 12577 00bc 00000000 		.word	.LANCHOR3
 12578              	.LBE381:
 12579              	.LBE380:
 12580              		.cfi_endproc
 12581              	.LFE274:
 12583              		.section	.text._Z5setupv,"ax",%progbits
 12584              		.align	1
 12585              		.global	_Z5setupv
 12586              		.thumb
 12587              		.thumb_func
 12589              	_Z5setupv:
 12590              	.LFB275:
 12591              		.file 36 "C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad/AeroQuad.ino"
   1:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** /*
   2:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   AeroQuad v3.0.1 - February 2012
   3:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   www.AeroQuad.com
   4:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   An Open Source Arduino based multicopter.
   6:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
   7:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   This program is free software: you can redistribute it and/or modify
   8:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   it under the terms of the GNU General Public License as published by
   9:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   the Free Software Foundation, either version 3 of the License, or
  10:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   (at your option) any later version.
  11:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  12:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   This program is distributed in the hope that it will be useful,
  13:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   GNU General Public License for more details.
  16:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  17:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   You should have received a copy of the GNU General Public License
  18:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** */
  20:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  21:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** /****************************************************************************
  22:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    Before flight, select the different user options for your AeroQuad by
  23:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    editing UserConfiguration.h.
  24:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  25:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    If you need additional assistance go to http://www.aeroquad.com/forum.php
  26:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    or talk to us live on IRC #aeroquad
  27:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** *****************************************************************************/
  28:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  29:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "UserConfiguration.h" // Edit this file first before uploading to the AeroQuad
  30:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  31:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //
  32:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** // Define Security Checks
  33:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //
  34:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  35:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(UseGPS_NMEA) || defined(UseGPS_UBLOX) || defined(UseGPS_MTK) || defined(UseGPS_406)
  36:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****  #define UseGPS
  37:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif 
  38:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  39:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(UseGPSNavigator) && !defined(AltitudeHoldBaro)
  40:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #error "GpsNavigation NEED AltitudeHoldBaro defined"
  41:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
  42:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  43:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(AutoLanding) && (!defined(AltitudeHoldBaro) || !defined(AltitudeHoldRangeFinder))
  44:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #error "AutoLanding NEED AltitudeHoldBaro and AltitudeHoldRangeFinder defined"
  45:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
  46:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  47:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(ReceiverSBUS) && defined(SlowTelemetry)
  48:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #error "Receiver SWBUS and SlowTelemetry are in conflict for Seria2, they can't be used together"
  49:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
  50:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  51:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** // Special motor config additionnal variable
  52:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(quadXHT_FPVConfig)
  53:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****  #define quadXConfig
  54:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****  #define FRONT_YAW_CORRECTION 0.95
  55:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****  #define REAR_YAW_CORRECTION 1.17
  56:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
  57:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  58:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //
  59:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** // In order to use the DIYDrone libraries, this have to be declared here this way
  60:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** // @see Kenny9999 for details
  61:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //
  62:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(UseGPS)
  63:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // needed here to use DIYDrone GPS libraries
  64:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <FastSerial.h>
  65:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <AP_Common.h>
  66:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <AP_GPS.h>
  67:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
  68:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   FastSerialPort0(Serial);
  69:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   FastSerialPort1(Serial1);
  70:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   FastSerialPort2(Serial2);
  71:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   FastSerialPort3(Serial3);
  72:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
  73:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  74:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  75:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include <EEPROM.h>
  76:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include <Wire.h>
  77:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include <GlobalDefined.h>
  78:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "AeroQuad.h"
  79:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "PID.h"
  80:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include <AQMath.h>
  81:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include <FourtOrderFilter.h>
  82:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef BattMonitor
  83:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <BatteryMonitorTypes.h>
  84:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
  85:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  86:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
  87:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
  88:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********* PLATFORM SPECIFIC SECTION ********************
  89:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
  90:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
  91:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuad_v1
  92:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
  93:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 12
  94:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 12
  95:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  96:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
  97:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_IDG_IDZ500.h>
  98:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  99:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 100:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_ADXL500.h>
 101:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 102:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver declaration
 103:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_328P
 104:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 105:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 106:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_PWM
 107:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 108:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // unsupported in v1
 109:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldBaro
 110:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldRangeFinder
 111:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef HeadingMagHold
 112:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef BattMonitor
 113:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef BattMonitorAutoDescent
 114:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef POWERED_BY_VIN        
 115:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef CameraControl
 116:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef OSD
 117:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPS
 118:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPSNavigator
 119:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 120:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 121:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 122:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuad_v1 specific initialization need here
 123:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 124:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 125:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     setGyroAref(aref);
 126:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 127:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 128:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 129:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 130:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 131:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 132:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureGyro();
 133:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureAccel();
 134:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 135:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 136:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 137:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuad_v1_IDG
 138:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
 139:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 12
 140:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 12
 141:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 142:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 143:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_IDG_IDZ500.h>
 144:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 145:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 146:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_ADXL500.h>
 147:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 148:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver declaration
 149:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_328P
 150:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 151:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 152:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_PWM
 153:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 154:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // unsupported in v1
 155:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldBaro
 156:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldRangeFinder
 157:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef HeadingMagHold
 158:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef BattMonitor
 159:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef BattMonitorAutoDescent
 160:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef POWERED_BY_VIN        
 161:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef CameraControl
 162:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef OSD
 163:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPS
 164:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPSNavigator
 165:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 166:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 167:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuad_v1_IDG specific initialization need here
 168:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 169:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 170:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     setGyroAref(aref);
 171:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 172:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 173:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 174:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 175:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 176:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 177:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureGyro();
 178:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureAccel();
 179:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 180:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 181:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 182:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuad_v18
 183:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
 184:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 12
 185:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 12
 186:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 187:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_I2C.h>
 188:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 189:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 190:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_ITG3200.h>
 191:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 192:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 193:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_BMA180.h>
 194:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 195:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver declaration
 196:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_328P
 197:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 198:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 199:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_PWM_Timer
 200:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 201:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // heading mag hold declaration
 202:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef HeadingMagHold
 203:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define HMC5843
 204:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 205:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 206:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Battery Monitor declaration
 207:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef BattMonitor
 208:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15, 0.9, BM_NOPIN, 0, 0)
 209:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
 210:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef BattMonitorAutoDescent
 211:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef POWERED_BY_VIN        
 212:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 213:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 214:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldBaro
 215:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldRangeFinder
 216:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef CameraControl
 217:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef OSD
 218:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPS
 219:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPSNavigator
 220:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 221:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 222:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuad_v18 specific initialization need here
 223:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 224:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 225:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 226:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Red, OUTPUT);
 227:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Red, LOW);
 228:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Yellow, OUTPUT);
 229:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Yellow, LOW);
 230:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 231:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Wire.begin();
 232:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     TWBR = 12;
 233:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 234:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 235:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 236:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 237:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 238:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 239:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureGyroSum();
 240:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureAccelSum();
 241:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 242:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 243:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 244:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 245:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuad_Mini
 246:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
 247:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 12
 248:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 12
 249:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 250:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_I2C.h>
 251:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 252:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 253:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define ITG3200_ADDRESS_ALTERNATE
 254:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_ITG3200.h>
 255:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 256:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 257:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_ADXL345.h>
 258:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 259:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver declaration
 260:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_328P
 261:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 262:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 263:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(quadXConfig) || defined(quadPlusConfig) || defined(quadY4Config)
 264:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define MOTOR_PWM_Timer
 265:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
 266:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define MOTOR_PWM
 267:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif    
 268:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 269:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // heading mag hold declaration
 270:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef HeadingMagHold
 271:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define HMC5843
 272:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 273:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 274:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Battery Monitor declaration
 275:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef BattMonitor
 276:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0.53, BM_NOPIN, 0, 0)
 277:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
 278:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef BattMonitorAutoDescent
 279:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef POWERED_BY_VIN        
 280:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 281:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 282:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // unsupported in mini
 283:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldBaro
 284:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldRangeFinder  
 285:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef CameraControl
 286:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef OSD
 287:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPS
 288:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPSNavigator
 289:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 290:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 291:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuad_Mini specific initialization need here
 292:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 293:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 295:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Red, OUTPUT);
 296:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Red, LOW);
 297:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Yellow, OUTPUT);
 298:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Yellow, LOW);
 299:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 300:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Wire.begin();
 301:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     TWBR = 12;
 302:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 303:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 304:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 305:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 306:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 307:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 308:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureGyroSum();
 309:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureAccelSum();
 310:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 311:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 312:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 313:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuadMega_v1
 314:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
 315:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 4
 316:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 31
 317:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 318:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Special thanks to Wilafau for fixes for this setup
 319:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // http://aeroquad.com/showthread.php?991-AeroQuad-Flight-Software-v2.0&p=11466&viewfull=1#post11
 320:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 321:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_IDG_IDZ500.h>
 322:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 323:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 324:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_ADXL500.h>
 325:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 326:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Reveiver declaration
 327:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define OLD_RECEIVER_PIN_ORDER
 328:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_MEGA
 329:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 330:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 331:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_PWM
 332:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 333:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // unsupported on mega v1
 334:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldBaro
 335:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldRangeFinder  
 336:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef HeadingMagHold
 337:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef BattMonitor
 338:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef BattMonitorAutoDescent
 339:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef POWERED_BY_VIN        
 340:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef CameraControl
 341:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef OSD
 342:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 343:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 344:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuadMega_v1 specific initialization need here
 345:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 346:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 347:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     setGyroAref(aref);
 348:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 349:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 350:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 351:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 352:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 353:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 354:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     if (deltaTime >= 10000) {
 355:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureGyro();
 356:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureAccel();
 357:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
 358:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 359:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 360:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 361:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuadMega_v2
 362:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
 363:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 4
 364:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 31
 365:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 366:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_I2C.h>
 367:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 368:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 369:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_ITG3200.h>
 370:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 371:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 372:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_BMA180.h>
 373:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 374:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver Declaration
 375:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_MEGA
 376:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 377:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 378:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_PWM_Timer
 379:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 380:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // heading mag hold declaration
 381:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef HeadingMagHold
 382:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //    #define SPARKFUN_5883L_BOB
 383:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define HMC5843
 384:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 385:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 386:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Altitude declaration
 387:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldBaro    
 388:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BMP085 
 389:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 390:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
 391:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define XLMAXSONAR 
 392:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 393:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 394:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Battery Monitor declaration
 395:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef BattMonitor
 396:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #ifdef POWERED_BY_VIN
 397:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0, BM_NOPIN, 0, 0) // v2 shield powered 
 398:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #else
 399:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0.82, BM_NOPIN, 0, 0) // v2 shield power
 400:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
 401:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
 402:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef BattMonitorAutoDescent
 403:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef POWERED_BY_VIN        
 404:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 405:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 406:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef OSD
 407:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define MAX7456_OSD
 408:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif  
 409:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 410:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifndef UseGPS
 411:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef UseGPSNavigator
 412:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 413:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 414:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 415:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuadMega_v2 specific initialization need here
 416:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 417:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 418:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 419:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Red, OUTPUT);
 420:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Red, LOW);
 421:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Yellow, OUTPUT);
 422:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Yellow, LOW);
 423:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 424:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // pins set to INPUT for camera stabilization so won't interfere with new camera class
 425:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(33, INPUT); // disable SERVO 1, jumper D12 for roll
 426:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(34, INPUT); // disable SERVO 2, jumper D11 for pitch
 427:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(35, INPUT); // disable SERVO 3, jumper D13 for yaw
 428:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(43, OUTPUT); // LED 1
 429:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(44, OUTPUT); // LED 2
 430:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(45, OUTPUT); // LED 3
 431:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(46, OUTPUT); // LED 4
 432:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(43, HIGH); // LED 1 on
 433:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(44, HIGH); // LED 2 on
 434:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(45, HIGH); // LED 3 on
 435:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(46, HIGH); // LED 4 on
 436:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 437:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Wire.begin();
 438:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     TWBR = 12;
 439:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 440:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 441:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 442:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 443:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 444:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 445:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureGyroSum();
 446:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureAccelSum();
 447:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 448:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 449:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 450:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuadMega_v21
 451:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
 452:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 4
 453:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 31
 454:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 455:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_I2C.h>
 456:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 457:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 458:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define ITG3200_ADDRESS_ALTERNATE
 459:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_ITG3200_9DOF.h>
 460:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 461:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 462:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_ADXL345_9DOF.h>
 463:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 464:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver Declaration
 465:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_MEGA
 466:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 467:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 468:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_PWM_Timer
 469:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 470:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // heading mag hold declaration
 471:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef HeadingMagHold
 472:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define SPARKFUN_9DOF_5883L
 473:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 474:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 475:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Altitude declaration
 476:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldBaro
 477:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BMP085
 478:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 479:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
 480:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define XLMAXSONAR 
 481:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 482:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 483:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 484:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Battery Monitor declaration
 485:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef BattMonitor
 486:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #ifdef POWERED_BY_VIN
 487:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0, BM_NOPIN, 0, 0) // v2 shield powered 
 488:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #else
 489:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0.82, BM_NOPIN, 0, 0) // v2 shield power
 490:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
 491:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
 492:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef BattMonitorAutoDescent
 493:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef POWERED_BY_VIN        
 494:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 495:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 496:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef OSD
 497:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define MAX7456_OSD
 498:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif  
 499:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 500:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifndef UseGPS
 501:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef UseGPSNavigator
 502:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 503:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 504:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 505:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 506:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuadMega_v21 specific initialization need here
 507:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 508:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 509:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 510:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Red, OUTPUT);
 511:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Red, LOW);
 512:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Yellow, OUTPUT);
 513:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Yellow, LOW);
 514:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 515:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // pins set to INPUT for camera stabilization so won't interfere with new camera class
 516:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(33, INPUT); // disable SERVO 1, jumper D12 for roll
 517:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(34, INPUT); // disable SERVO 2, jumper D11 for pitch
 518:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(35, INPUT); // disable SERVO 3, jumper D13 for yaw
 519:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(43, OUTPUT); // LED 1
 520:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(44, OUTPUT); // LED 2
 521:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(45, OUTPUT); // LED 3
 522:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(46, OUTPUT); // LED 4
 523:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(43, HIGH); // LED 1 on
 524:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(44, HIGH); // LED 2 on
 525:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(45, HIGH); // LED 3 on
 526:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(46, HIGH); // LED 4 on
 527:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 528:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Wire.begin();
 529:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     TWBR = 12;
 530:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 531:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 532:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 533:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 534:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 535:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 536:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureGyroSum();
 537:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureAccelSum();
 538:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 539:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 540:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 541:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef ArduCopter
 542:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 37
 543:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 35
 544:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 36
 545:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 546:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <APM_ADC.h>
 547:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <APM_RC.h>
 548:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_I2C.h>
 549:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 550:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 551:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_APM.h>
 552:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 553:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer Declaration
 554:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_APM.h>
 555:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 556:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver Declaration
 557:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_APM
 558:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 559:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor Declaration
 560:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_APM
 561:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 562:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // heading mag hold declaration
 563:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef HeadingMagHold
 564:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define HMC5843
 565:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 566:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
 567:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define XLMAXSONAR 
 568:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 569:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 570:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 571:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Altitude declaration
 572:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldBaro
 573:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BMP085
 574:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 575:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 576:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Battery monitor declaration
 577:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef BattMonitor
 578:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BattDefaultConfig DEFINE_BATTERY(0, 0, 13.35, 0.31, BM_NOPIN, 0, 0)
 579:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
 580:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef BattMonitorAutoDescent
 581:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef POWERED_BY_VIN        
 582:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 583:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 584:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef CameraControl
 585:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef OSD
 586:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifndef UseGPS
 587:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef UseGPSNavigator
 588:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 589:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 590:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 591:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 592:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put ArduCopter specific initialization need here
 593:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 594:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 595:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Red, OUTPUT);
 596:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Yellow, OUTPUT);
 597:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Green, OUTPUT);
 598:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 599:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeADC();
 600:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initRC();
 601:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 602:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Wire.begin();
 603:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     TWBR = 12;
 604:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 605:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 606:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 607:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 608:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 609:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 610:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     evaluateADC();
 611:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureGyroSum();
 612:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureAccelSum();
 613:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 614:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 615:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 616:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuad_Wii
 617:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
 618:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 12
 619:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 12
 620:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 621:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_I2C.h>
 622:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 623:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Platform Wii declaration
 624:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Platform_Wii.h>
 625:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 626:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 627:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_Wii.h>
 628:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 629:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 630:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_WII.h>
 631:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 632:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver declaration
 633:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_328P
 634:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 635:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 636:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_PWM
 637:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 638:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // heading mag hold declaration
 639:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // unsupported on mega v1
 640:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldBaro
 641:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldRangeFinder  
 642:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef HeadingMagHold
 643:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef BattMonitor
 644:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef BattMonitorAutoDescent
 645:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef POWERED_BY_VIN        
 646:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef CameraControl
 647:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef OSD
 648:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPS
 649:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPSNavigator
 650:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 651:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 652:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 653:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuad_Wii specific initialization need here
 654:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 655:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 656:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****      Wire.begin();
 657:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 658:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****      #if defined(AeroQuad_Paris_v3)
 659:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****        initializeWiiSensors(true);
 660:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****      #else
 661:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****        initializeWiiSensors();
 662:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****      #endif
 663:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 664:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 665:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 666:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 667:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 668:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 669:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     if (deltaTime >= 10000) {
 670:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       readWiiSensors();
 671:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureGyro();
 672:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureAccel();
 673:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
 674:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 675:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 676:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 677:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuadMega_Wii
 678:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
 679:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 4
 680:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 31
 681:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 682:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_I2C.h>
 683:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 684:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Platform Wii declaration
 685:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Platform_Wii.h>
 686:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 687:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 688:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_Wii.h>
 689:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 690:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 691:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_WII.h>
 692:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 693:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver declaration
 694:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_MEGA
 695:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 696:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 697:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_PWM
 698:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 699:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // heading mag hold declaration
 700:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef HeadingMagHold
 701:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define HMC5843
 702:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 703:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 704:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Altitude declaration
 705:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldBaro
 706:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BMP085
 707:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 708:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
 709:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define XLMAXSONAR 
 710:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 711:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 712:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Battery monitor declaration
 713:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef BattMonitor
 714:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0.9, BM_NOPIN, 0, 0)
 715:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
 716:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef BattMonitorAutoDescent
 717:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef POWERED_BY_VIN        
 718:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 719:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 720:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef OSD
 721:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define MAX7456_OSD
 722:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 723:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 724:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPS        // Wii not enough stable to use gps
 725:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPSNavigator
 726:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 727:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 728:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 729:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuadMega_Wii specific initialization need here
 730:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 731:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 732:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Wire.begin();
 733:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 734:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeWiiSensors();
 735:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 736:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 737:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 738:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 739:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 740:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 741:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     if (deltaTime >= 10000) {
 742:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       readWiiSensors();
 743:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureGyro();
 744:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureAccel();
 745:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
 746:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 747:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 748:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 749:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuadMega_CHR6DM
 750:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
 751:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 4
 752:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 31
 753:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 754:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_I2C.h>
 755:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Platform_CHR6DM.h>
 756:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   CHR6DM chr6dm;
 757:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 758:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 759:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_CHR6DM.h>
 760:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 761:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 762:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_CHR6DM.h>
 763:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 764:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver declaration
 765:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_MEGA
 766:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 767:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 768:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_PWM
 769:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 770:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Kinematics declaration
 771:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "Kinematics_CHR6DM.h"
 772:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 773:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Compass declaration
 774:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define HeadingMagHold
 775:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define COMPASS_CHR6DM
 776:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Magnetometer_CHR6DM.h>
 777:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 778:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef OSD
 779:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define MAX7456_OSD
 780:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 781:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 782:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Altitude declaration
 783:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldBaro
 784:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BMP085
 785:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 786:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
 787:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define XLMAXSONAR 
 788:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 789:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 790:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Battery monitor declaration
 791:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef BattMonitor
 792:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BattDefaultConfig DEFINE_BATTERY(0, 0, 13.35, 0.9, BM_NOPIN, 0, 0)
 793:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
 794:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef BattMonitorAutoDescent
 795:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef POWERED_BY_VIN        
 796:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 797:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 798:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifndef UseGPS
 799:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef UseGPSNavigator
 800:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 801:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 802:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 803:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 804:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuadMega_CHR6DM specific initialization need here
 805:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 806:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 807:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Serial1.begin(BAUD);
 808:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     PORTD = B00000100;
 809:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 810:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Wire.begin();
 811:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 812:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     chr6dm.resetToFactory();
 813:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     chr6dm.setListenMode();
 814:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     chr6dm.setActiveChannels(CHANNEL_ALL_MASK);
 815:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     chr6dm.requestPacket();
 816:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 817:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     gyroChr6dm = &chr6dm;
 818:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     accelChr6dm = &chr6dm;
 819:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     kinematicsChr6dm = &chr6dm;
 820:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     compassChr6dm = &chr6dm;
 821:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 822:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 823:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 824:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 825:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 826:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 827:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     if (deltaTime >= 10000) {
 828:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       chr6dm.read();
 829:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureGyro();
 830:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureAccel();
 831:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
 832:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 833:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 834:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 835:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef APM_OP_CHR6DM
 836:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 37
 837:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 35
 838:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 36
 839:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 840:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_I2C.h>
 841:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Platform_CHR6DM.h>
 842:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   CHR6DM chr6dm;
 843:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 844:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 845:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_CHR6DM.h>
 846:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 847:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 848:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_CHR6DM.h>
 849:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 850:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver declaration
 851:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_APM
 852:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 853:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 854:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_APM
 855:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 856:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Kinematics declaration
 857:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "Kinematics_CHR6DM.h"
 858:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 859:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Compass declaration
 860:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define HeadingMagHold
 861:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define COMPASS_CHR6DM
 862:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Magnetometer_CHR6DM.h>
 863:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 864:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Altitude declaration
 865:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldBaro
 866:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BMP085
 867:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 868:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
 869:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define XLMAXSONAR 
 870:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 871:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 872:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 873:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Battery monitor declaration
 874:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef BattMonitor
 875:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BattDefaultConfig DEFINE_BATTERY(0, 0, 13.35, 0.31, BM_NOPIN, 0, 0)
 876:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
 877:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef BattMonitorAutoDescent
 878:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef POWERED_BY_VIN        
 879:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 880:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 881:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef CameraControl
 882:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef OSD
 883:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 884:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifndef UseGPS
 885:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef UseGPSNavigator
 886:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 887:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 888:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 889:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 890:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put APM_OP_CHR6DM specific initialization need here
 891:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 892:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 893:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Red, OUTPUT);
 894:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Yellow, OUTPUT);
 895:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Green, OUTPUT);
 896:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 897:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Serial1.begin(BAUD);
 898:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     PORTD = B00000100;
 899:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 900:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Wire.begin();
 901:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 902:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     chr6dm.resetToFactory();
 903:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     chr6dm.setListenMode();
 904:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     chr6dm.setActiveChannels(CHANNEL_ALL_MASK);
 905:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     chr6dm.requestPacket();
 906:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 907:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     gyroChr6dm = &chr6dm;
 908:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     accelChr6dm = &chr6dm;
 909:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     kinematicsChr6dm = &chr6dm;
 910:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //    tempKinematics.setGyroscope(&gyroSpecific);
 911:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     compassChr6dm = &chr6dm;
 912:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 913:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 914:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 915:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 916:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 917:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 918:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     if (deltaTime >= 10000) {
 919:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       chr6dm.read();
 920:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureGyro();
 921:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureAccel();
 922:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
 923:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 924:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 925:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 926:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 927:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 928:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********* HARDWARE GENERALIZATION SECTION **************
 929:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 930:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 931:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 932:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuadSTM32
 933:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "AeroQuad_STM32.h"
 934:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 935:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 936:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** // default to 10bit ADC (AVR)
 937:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifndef ADC_NUMBER_OF_BITS
 938:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #define ADC_NUMBER_OF_BITS 10
 939:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 940:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 941:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 942:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //****************** KINEMATICS DECLARATION **************
 943:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 944:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "Kinematics.h"
 945:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(AeroQuadMega_CHR6DM) || defined(APM_OP_CHR6DM)
 946:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // CHR6DM have it's own kinematics, so, initialize in it's scope
 947:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #else
 948:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "Kinematics_ARG.h"
 949:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 950:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 951:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 952:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //******************** RECEIVER DECLARATION **************
 953:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 954:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(ReceiverHWPPM)
 955:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_HWPPM.h>
 956:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(ReceiverPPM)
 957:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_PPM.h>
 958:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(AeroQuad_Mini) && (defined(hexPlusConfig) || defined(hexXConfig) || defined(hexY6Conf
 959:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_PPM.h>
 960:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(RemotePCReceiver)
 961:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_RemotePC.h>
 962:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(ReceiverSBUS)
 963:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_SBUS.h>
 964:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(RECEIVER_328P)
 965:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_328p.h>
 966:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(RECEIVER_MEGA)
 967:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_MEGA.h>
 968:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(RECEIVER_APM)
 969:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_APM.h>
 970:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(RECEIVER_STM32PPM)
 971:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_STM32PPM.h>  
 972:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(RECEIVER_STM32)
 973:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_STM32.h>  
 974:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 975:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 976:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(UseAnalogRSSIReader) 
 977:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <AnalogRSSIReader.h>
 978:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(UseEzUHFRSSIReader)
 979:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <EzUHFRSSIReader.h>
 980:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 981:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 982:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 983:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 984:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 985:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************** MOTORS DECLARATION **************
 986:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 987:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(triConfig)
 988:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Motors_Tri.h>
 989:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(MOTOR_PWM)
 990:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Motors_PWM.h>
 991:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(MOTOR_PWM_Timer)
 992:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Motors_PWM_Timer.h>
 993:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(MOTOR_APM)
 994:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Motors_APM.h>
 995:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(MOTOR_I2C)
 996:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Motors_I2C.h>
 997:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(MOTOR_STM32)
 998:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Motors_STM32.h>    
 999:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1000:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1001:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1002:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //******* HEADING HOLD MAGNETOMETER DECLARATION **********
1003:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1004:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(HMC5843)
1005:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <HeadingFusionProcessorCompFilter.h>
1006:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Magnetometer_HMC5843.h>
1007:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(SPARKFUN_9DOF_5883L) || defined(SPARKFUN_5883L_BOB) || defined(HMC5883L)
1008:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <HeadingFusionProcessorCompFilter.h>
1009:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Magnetometer_HMC5883L.h>
1010:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(COMPASS_CHR6DM)
1011:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1012:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1013:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1014:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //******* ALTITUDE HOLD BAROMETER DECLARATION ************
1015:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1016:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(BMP085)
1017:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <BarometricSensor_BMP085.h>
1018:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(MS5611)
1019:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****  #include <BarometricSensor_MS5611.h>
1020:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1021:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(XLMAXSONAR)
1022:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <MaxSonarRangeFinder.h>
1023:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif 
1024:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1025:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //*************** BATTERY MONITOR DECLARATION ************
1026:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1027:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef BattMonitor
1028:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <BatteryMonitor.h>
1029:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifndef BattCustomConfig
1030:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BattCustomConfig BattDefaultConfig
1031:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1032:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   struct BatteryData batteryData[] = {BattCustomConfig};
1033:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1034:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1035:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //************** CAMERA CONTROL DECLARATION **************
1036:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1037:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** // used only on mega for now
1038:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(CameraControl_STM32)
1039:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <CameraStabilizer_STM32.h>
1040:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(CameraControl)
1041:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****    #include <CameraStabilizer_Aeroquad.h>
1042:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1043:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1044:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1045:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //******** FLIGHT CONFIGURATION DECLARATION **************
1046:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1047:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(quadXConfig)
1048:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlQuadX.h"
1049:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(quadPlusConfig)
1050:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlQuadPlus.h"
1051:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(hexPlusConfig)
1052:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlHexPlus.h"
1053:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(hexXConfig)
1054:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlHexX.h"
1055:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(triConfig)
1056:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlTri.h"
1057:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(quadY4Config)
1058:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlQuadY4.h"
1059:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(hexY6Config)
1060:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlHexY6.h"
1061:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(octoX8Config)
1062:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlOctoX8.h"
1063:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(octoXConfig)
1064:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlOctoX.h"
1065:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(octoPlusConfig)
1066:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlOctoPlus.h"
1067:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1068:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1069:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1070:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //****************** GPS DECLARATION *********************
1071:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1072:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(UseGPS)
1073:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if !defined(HeadingMagHold)
1074:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #error We need the magnetometer to use the GPS
1075:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif 
1076:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //  #if defined LASTCHANNEL 6
1077:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //    #error We need 7 receiver channel to use GPS navigator
1078:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //  #endif
1079:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <GpsAdapter.h>
1080:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "GpsNavigator.h"
1081:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1082:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1083:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1084:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //****************** OSD DEVICE DECLARATION **************
1085:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1086:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef MAX7456_OSD     // only OSD supported for now is the MAX7456
1087:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_SPI.h>
1088:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "OSDDisplayController.h"
1089:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "MAX7456.h"
1090:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1091:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1092:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(SERIAL_LCD)
1093:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "SerialLCD.h"
1094:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1095:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1096:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef OSD_SYSTEM_MENU
1097:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if !defined(MAX7456_OSD) && !defined(SERIAL_LCD)
1098:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #error "Menu cannot be used without OSD or LCD"
1099:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1100:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "OSDMenu.h"
1101:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1102:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1103:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1104:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1105:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //****************** SERIAL PORT DECLARATION *************
1106:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
1107:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(WirelessTelemetry) 
1108:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
1109:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define SERIAL_PORT Serial3
1110:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else    // force 328p to use the normal port
1111:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define SERIAL_PORT Serial
1112:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1113:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #else  
1114:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(SERIAL_USES_USB)   // STM32 Maple
1115:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define SERIAL_PORT SerialUSB
1116:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef BAUD
1117:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BAUD
1118:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
1119:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define SERIAL_PORT Serial
1120:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1121:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif  
1122:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1123:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef SlowTelemetry
1124:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <AQ_RSCode.h>
1125:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1126:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1127:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1128:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** // Include this last as it contains objects from above declarations
1129:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "AltitudeControlProcessor.h"
1130:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "FlightControlProcessor.h"
1131:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "FlightCommandProcessor.h"
1132:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "HeadingHoldProcessor.h"
1133:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "DataStorage.h"
1134:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1135:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(UseGPS) || defined(BattMonitor)
1136:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "LedStatusProcessor.h"
1137:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif  
1138:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1139:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(MavLink)
1140:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "MavLink.h"
1141:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #else
1142:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "SerialCom.h"
1143:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1144:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1145:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef GraupnerHoTTTelemetry
1146:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <HoTT.h>
1147:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <HoTT_Telemetry.h>
1148:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1149:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1150:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1151:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1152:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** /**
1153:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****  * Main setup function, called one time at bootup
1154:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****  * initialize all system and sub system of the
1155:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****  * Aeroquad
1156:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****  */
1157:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** void setup() {
 12592              		.loc 36 1157 0
 12593              		.cfi_startproc
 12594              		@ args = 0, pretend = 0, frame = 0
 12595              		@ frame_needed = 0, uses_anonymous_args = 0
 12596 0000 10B5     		push	{r4, lr}
 12597              	.LCFI115:
 12598              		.cfi_def_cfa_offset 8
 12599              		.cfi_offset 14, -4
 12600              		.cfi_offset 4, -8
1158:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   SERIAL_BEGIN(BAUD);
 12601              		.loc 36 1158 0
 12602 0002 3148     		ldr	r0, .L800
 12603 0004 4FF4E131 		mov	r1, #115200
 12604 0008 FFF7FEFF 		bl	_ZN9USBSerial5beginEi
1159:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   pinMode(LED_Green, OUTPUT);
 12605              		.loc 36 1159 0
 12606 000c 4620     		movs	r0, #70
 12607 000e 0021     		movs	r1, #0
 12608 0010 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
1160:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   digitalWrite(LED_Green, LOW);
 12609              		.loc 36 1160 0
 12610 0014 4620     		movs	r0, #70
 12611 0016 0021     		movs	r1, #0
 12612 0018 FFF7FEFF 		bl	_Z12digitalWritehh
1161:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1162:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   initCommunication();
1163:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1164:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Read user values from EEPROM
1165:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   readEEPROM(); // defined in DataStorage.h
 12613              		.loc 36 1165 0
 12614 001c FFF7FEFF 		bl	_Z10readEEPROMv
1166:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   if (readFloat(SOFTWARE_VERSION_ADR) != SOFTWARE_VERSION) { // If we detect the wrong soft version
 12615              		.loc 36 1166 0
 12616 0020 FC20     		movs	r0, #252
 12617 0022 FFF7FEFF 		bl	_Z12nvrReadFloati
 12618 0026 DFED297A 		flds	s15, .L800+4
 12619 002a 07EE100A 		fmsr	s14, r0
 12620 002e B4EE677A 		fcmps	s14, s15
 12621 0032 F1EE10FA 		fmstat
 12622 0036 03D0     		beq	.L799
1167:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeEEPROM();
 12623              		.loc 36 1167 0
 12624 0038 FFF7FEFF 		bl	_Z16initializeEEPROMv
1168:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     writeEEPROM();
 12625              		.loc 36 1168 0
 12626 003c FFF7FEFF 		bl	_Z11writeEEPROMv
 12627              	.L799:
1169:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
1170:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1171:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   initPlatform();
 12628              		.loc 36 1171 0
 12629 0040 FFF7FEFF 		bl	_Z12initPlatformv
1172:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1173:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Configure motors
1174:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(quadXConfig) || defined(quadPlusConfig) || defined(quadY4Config) || defined(triConfig
1175:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****      initializeMotors(FOUR_Motors);
 12630              		.loc 36 1175 0
 12631 0044 0420     		movs	r0, #4
 12632 0046 FFF7FEFF 		bl	_Z16initializeMotors9NB_Motors
1176:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #elif defined(hexPlusConfig) || defined(hexXConfig) || defined(hexY6Config)
1177:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****      initializeMotors(SIX_Motors);
1178:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #elif defined(octoX8Config) || defined(octoXConfig) || defined(octoPlusConfig)
1179:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****      initializeMotors(EIGHT_Motors);
1180:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1181:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1182:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Setup receiver pins for pin change interrupts
1183:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   initializeReceiver(LASTCHANNEL);
 12633              		.loc 36 1183 0
 12634 004a 0820     		movs	r0, #8
 12635 004c FFF7FEFF 		bl	_Z18initializeReceiveri
1184:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   initReceiverFromEEPROM();
 12636              		.loc 36 1184 0
 12637 0050 FFF7FEFF 		bl	_Z22initReceiverFromEEPROMv
1185:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1186:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   initializeKinematics();
 12638              		.loc 36 1186 0
 12639 0054 FFF7FEFF 		bl	_Z20initializeKinematicsv
1187:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1188:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Integral Limit for attitude mode
1189:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // This overrides default set in readEEPROM()
1190:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Set for 1/2 max attitude command (+/-0.75 radians)
1191:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Rate integral not used for now
1192:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   PID[ATTITUDE_XAXIS_PID_IDX].windupGuard = 0.375;
 12640              		.loc 36 1192 0
 12641 0058 1D49     		ldr	r1, .L800+8
 12642 005a 4FF07B54 		mov	r4, #1052770304
 12643 005e CC66     		str	r4, [r1, #108]	@ float
1193:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   PID[ATTITUDE_YAXIS_PID_IDX].windupGuard = 0.375;
 12644              		.loc 36 1193 0
 12645 0060 C1F88840 		str	r4, [r1, #136]	@ float
1194:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
1195:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Optional Sensors
1196:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldBaro
1197:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeBaro();
1198:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     vehicleState |= ALTITUDEHOLD_ENABLED;
 12646              		.loc 36 1198 0
 12647 0064 1B4C     		ldr	r4, .L800+12
1197:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeBaro();
 12648              		.loc 36 1197 0
 12649 0066 FFF7FEFF 		bl	_Z14initializeBarov
 12650              		.loc 36 1198 0
 12651 006a 2368     		ldr	r3, [r4, #0]
1199:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1200:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
1201:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     inititalizeRangeFinders();
1202:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     vehicleState |= RANGE_ENABLED;
1203:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].P = PID[BARO_ALTITUDE_HOLD_PID_IDX].P*2;
1204:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].I = PID[BARO_ALTITUDE_HOLD_PID_IDX].I;
1205:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].D = PID[BARO_ALTITUDE_HOLD_PID_IDX].D;
1206:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].windupGuard = PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard;
1207:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1208:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1209:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Battery Monitor
1210:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef BattMonitor
1211:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // batteryMonitorAlarmVoltage updated in readEEPROM()
1212:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeBatteryMonitor(sizeof(batteryData) / sizeof(struct BatteryData), batteryMonitorAlarmV
 12652              		.loc 36 1212 0
 12653 006c 1A4A     		ldr	r2, .L800+16
1198:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     vehicleState |= ALTITUDEHOLD_ENABLED;
 12654              		.loc 36 1198 0
 12655 006e 43F02000 		orr	r0, r3, #32
 12656              		.loc 36 1212 0
 12657 0072 1168     		ldr	r1, [r2, #0]	@ float
1198:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     vehicleState |= ALTITUDEHOLD_ENABLED;
 12658              		.loc 36 1198 0
 12659 0074 2060     		str	r0, [r4, #0]
 12660              		.loc 36 1212 0
 12661 0076 0120     		movs	r0, #1
 12662 0078 FFF7FEFF 		bl	_Z24initializeBatteryMonitorhf
1213:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     vehicleState |= BATTMONITOR_ENABLED;
 12663              		.loc 36 1213 0
 12664 007c 2168     		ldr	r1, [r4, #0]
 12665 007e 41F04003 		orr	r3, r1, #64
 12666 0082 2360     		str	r3, [r4, #0]
1214:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1215:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
1216:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1217:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Camera stabilization setup
1218:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(CameraControl)
1219:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeCameraStabilization();
1220:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     vehicleState |= CAMERASTABLE_ENABLED;
1221:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1222:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1223:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(MAX7456_OSD)
1224:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeSPI();
1225:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeOSD();
1226:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1227:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
1228:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(SERIAL_LCD)
1229:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     InitSerialLCD();
1230:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1231:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1232:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(BinaryWrite) || defined(BinaryWritePID)
1233:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #ifdef OpenlogBinaryWrite
1234:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       binaryPort = &Serial1;
1235:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       binaryPort->begin(115200);
1236:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       delay(1000);
1237:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #else
1238:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****      binaryPort = &Serial;
1239:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
1240:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1241:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
1242:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(UseGPS)
1243:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeGps();
1244:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif 
1245:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1246:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef SlowTelemetry
1247:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****      initSlowTelemetry();
1248:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1249:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1250:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   setupFourthOrder();
 12667              		.loc 36 1250 0
 12668 0084 FFF7FEFF 		bl	_Z16setupFourthOrderv
1251:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
1252:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Initialize sensors
1253:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // If sensors have a common initialization routine
1254:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // insert it into the gyro class because it executes first
1255:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   initializeGyro(); // defined in Gyro.h
 12669              		.loc 36 1255 0
 12670 0088 FFF7FEFF 		bl	_Z14initializeGyrov
1256:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   initializeAccel(); // defined in Accel.h
 12671              		.loc 36 1256 0
 12672 008c FFF7FEFF 		bl	_Z15initializeAccelv
1257:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   initSensorsZeroFromEEPROM();
 12673              		.loc 36 1257 0
 12674 0090 FFF7FEFF 		bl	_Z25initSensorsZeroFromEEPROMv
1258:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1259:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Calibrate sensors
1260:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   calibrateGyro();
 12675              		.loc 36 1260 0
 12676 0094 FFF7FEFF 		bl	_Z13calibrateGyrov
1261:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** //  computeAccelBias();
1262:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Flight angle estimation
1263:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef HeadingMagHold
1264:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     vehicleState |= HEADINGHOLD_ENABLED;
 12677              		.loc 36 1264 0
 12678 0098 2268     		ldr	r2, [r4, #0]
 12679 009a 42F01000 		orr	r0, r2, #16
 12680 009e 2060     		str	r0, [r4, #0]
1265:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeMagnetometer();
 12681              		.loc 36 1265 0
 12682 00a0 FFF7FEFF 		bl	_Z22initializeMagnetometerv
1266:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeHeadingFusion();
 12683              		.loc 36 1266 0
 12684 00a4 FFF7FEFF 		bl	_Z23initializeHeadingFusionv
1267:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1268:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1269:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef GraupnerHoTTTelemetry
1270:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 	hottv4Init(&Serial3);
 12685              		.loc 36 1270 0
 12686 00a8 0C48     		ldr	r0, .L800+20
 12687 00aa FFF7FEFF 		bl	_Z10hottv4InitP14HardwareSerial
1271:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
1272:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1273:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1274:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
1275:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   previousTime = micros();
 12688              		.loc 36 1275 0
 12689 00ae FFF7FEFF 		bl	_ZL6microsv
 12690 00b2 0B49     		ldr	r1, .L800+24
 12691 00b4 0860     		str	r0, [r1, #0]
1276:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   digitalWrite(LED_Green, HIGH);
 12692              		.loc 36 1276 0
 12693 00b6 4620     		movs	r0, #70
 12694 00b8 0121     		movs	r1, #1
 12695 00ba FFF7FEFF 		bl	_Z12digitalWritehh
1277:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   safetyCheck = 0;
 12696              		.loc 36 1277 0
 12697 00be 094B     		ldr	r3, .L800+28
 12698 00c0 0022     		movs	r2, #0
 12699 00c2 1A70     		strb	r2, [r3, #0]
1278:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** }
 12700              		.loc 36 1278 0
 12701 00c4 10BD     		pop	{r4, pc}
 12702              	.L801:
 12703 00c6 00BF     		.align	2
 12704              	.L800:
 12705 00c8 00000000 		.word	SerialUSB
 12706 00cc 66664640 		.word	1078355558
 12707 00d0 00000000 		.word	.LANCHOR17
 12708 00d4 00000000 		.word	.LANCHOR21
 12709 00d8 00000000 		.word	.LANCHOR133
 12710 00dc 00000000 		.word	Serial3
 12711 00e0 00000000 		.word	.LANCHOR155
 12712 00e4 00000000 		.word	.LANCHOR119
 12713              		.cfi_endproc
 12714              	.LFE275:
 12716              		.section	.text._Z4loopv,"ax",%progbits
 12717              		.align	1
 12718              		.global	_Z4loopv
 12719              		.thumb
 12720              		.thumb_func
 12722              	_Z4loopv:
 12723              	.LFB276:
1279:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1280:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** /*******************************************************************
1281:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // tasks (microseconds of interval)
1282:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   ReadGyro        readGyro      (as fast as we can depending of the platform)
1283:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   ReadAccel       readAccel     (as fast as we can depending of the platform)
1284:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   RunDCM          runKinematics (  10000); // 100hz
1285:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   FlightControls  flightControls(  10000); // 100hz
1286:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   ReadBaro        readBaro      (  10000); // 100hz
1287:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   ReadReceiver    readReceiver  (  20000); //  50hz
1288:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   ReadCompass     readCompass   ( 100000); //  10Hz
1289:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   ProcessTelem    processTelem  ( 100000); //  10Hz
1290:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   ReadBattery     readBattery   ( 100000); //  10Hz
1291:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1292:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   Task *tasks[] = {&readGyro, &readAccel, &runDCM, &flightControls,   \
1293:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****                    &readReceiver, &readBaro, &readCompass,            \
1294:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****                    &processTelem, &readBattery};
1295:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1296:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   TaskScheduler sched(tasks, NUM_TASKS(tasks));
1297:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1298:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   sched.run();
1299:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** *******************************************************************/
1300:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** void loop () {
 12724              		.loc 36 1300 0
 12725              		.cfi_startproc
 12726              		@ args = 0, pretend = 0, frame = 0
 12727              		@ frame_needed = 0, uses_anonymous_args = 0
 12728 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, sl, lr}
 12729              	.LCFI116:
 12730              		.cfi_def_cfa_offset 32
 12731              		.cfi_offset 14, -4
 12732              		.cfi_offset 10, -8
 12733              		.cfi_offset 9, -12
 12734              		.cfi_offset 8, -16
 12735              		.cfi_offset 7, -20
 12736              		.cfi_offset 6, -24
 12737              		.cfi_offset 5, -28
 12738              		.cfi_offset 4, -32
 12739 0004 2DED028B 		fstmfdd	sp!, {d8}
 12740              	.LCFI117:
 12741              		.cfi_def_cfa_offset 40
 12742              		.cfi_offset 80, -40
 12743              	.LBB391:
1301:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
1302:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   currentTime = micros();
1303:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   deltaTime = currentTime - previousTime;
 12744              		.loc 36 1303 0
 12745 0008 624F     		ldr	r7, .L811
1302:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   currentTime = micros();
 12746              		.loc 36 1302 0
 12747 000a 634D     		ldr	r5, .L811+4
 12748              		.loc 36 1303 0
 12749 000c 634C     		ldr	r4, .L811+8
 12750              	.LBE391:
1300:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** void loop () {
 12751              		.loc 36 1300 0
 12752 000e 84B0     		sub	sp, sp, #16
 12753              	.LCFI118:
 12754              		.cfi_def_cfa_offset 56
 12755              	.LBB395:
1302:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   currentTime = micros();
 12756              		.loc 36 1302 0
 12757 0010 FFF7FEFF 		bl	_ZL6microsv
 12758              		.loc 36 1303 0
 12759 0014 3968     		ldr	r1, [r7, #0]
1302:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   currentTime = micros();
 12760              		.loc 36 1302 0
 12761 0016 2860     		str	r0, [r5, #0]
 12762              		.loc 36 1303 0
 12763 0018 401A     		subs	r0, r0, r1
 12764 001a 2060     		str	r0, [r4, #0]
1304:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1305:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   measureCriticalSensors();
 12765              		.loc 36 1305 0
 12766 001c FFF7FEFF 		bl	_Z22measureCriticalSensorsv
 12767              	.LBB392:
1306:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1307:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // ================================================================
1308:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // 100Hz task loop
1309:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // ================================================================
1310:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   if (deltaTime >= 10000) {
 12768              		.loc 36 1310 0
 12769 0020 2268     		ldr	r2, [r4, #0]
 12770 0022 5F4C     		ldr	r4, .L811+12
 12771 0024 42F20F73 		movw	r3, #9999
 12772 0028 9A42     		cmp	r2, r3
 12773 002a 40F2A580 		bls	.L803
 12774              	.LBB393:
1311:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     
1312:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     frameCounter++;
 12775              		.loc 36 1312 0
 12776 002e 2268     		ldr	r2, [r4, #0]
1313:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     
1314:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     G_Dt = (currentTime - hundredHZpreviousTime) / 1000000.0;
 12777              		.loc 36 1314 0
 12778 0030 5C4B     		ldr	r3, .L811+16
1315:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     hundredHZpreviousTime = currentTime;
1316:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     
1317:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     evaluateGyroRate();
1318:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     evaluateMetersPerSec();
 12779              		.loc 36 1318 0
 12780 0032 DFF8A4A1 		ldr	sl, .L811+68
1314:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     G_Dt = (currentTime - hundredHZpreviousTime) / 1000000.0;
 12781              		.loc 36 1314 0
 12782 0036 1968     		ldr	r1, [r3, #0]
 12783              		.loc 36 1318 0
 12784 0038 DFF8A091 		ldr	r9, .L811+72
1312:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     frameCounter++;
 12785              		.loc 36 1312 0
 12786 003c 561C     		adds	r6, r2, #1
1314:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     G_Dt = (currentTime - hundredHZpreviousTime) / 1000000.0;
 12787              		.loc 36 1314 0
 12788 003e 2A68     		ldr	r2, [r5, #0]
1312:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     frameCounter++;
 12789              		.loc 36 1312 0
 12790 0040 2660     		str	r6, [r4, #0]
1314:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     G_Dt = (currentTime - hundredHZpreviousTime) / 1000000.0;
 12791              		.loc 36 1314 0
 12792 0042 501A     		subs	r0, r2, r1
 12793 0044 07EE100A 		fmsr	s14, r0	@ int
 12794 0048 9FED578A 		flds	s16, .L811+20
 12795 004c F8EE477A 		fuitos	s15, s14
 12796 0050 564E     		ldr	r6, .L811+24
1315:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     hundredHZpreviousTime = currentTime;
 12797              		.loc 36 1315 0
 12798 0052 1A60     		str	r2, [r3, #0]
1314:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     G_Dt = (currentTime - hundredHZpreviousTime) / 1000000.0;
 12799              		.loc 36 1314 0
 12800 0054 C7EE887A 		fdivs	s15, s15, s16
1319:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1320:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     for (int axis = XAXIS; axis <= ZAXIS; axis++) {
 12801              		.loc 36 1320 0
 12802 0058 4FF00008 		mov	r8, #0
1314:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     G_Dt = (currentTime - hundredHZpreviousTime) / 1000000.0;
 12803              		.loc 36 1314 0
 12804 005c C6ED007A 		fsts	s15, [r6, #0]
1317:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     evaluateGyroRate();
 12805              		.loc 36 1317 0
 12806 0060 FFF7FEFF 		bl	_Z16evaluateGyroRatev
1318:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     evaluateMetersPerSec();
 12807              		.loc 36 1318 0
 12808 0064 FFF7FEFF 		bl	_Z20evaluateMetersPerSecv
 12809              	.LVL522:
 12810              	.L804:
 12811              	.LBB394:
1321:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       filteredAccel[axis] = computeFourthOrder(meterPerSecSec[axis], &fourthOrder[axis]);
 12812              		.loc 36 1321 0 discriminator 2
 12813 0068 5149     		ldr	r1, .L811+28
 12814 006a 5AF8040F 		ldr	r0, [sl, #4]!	@ float
 12815 006e 4FEA481C 		lsl	ip, r8, #5
 12816 0072 6144     		add	r1, r1, ip
 12817 0074 FFF7FEFF 		bl	_Z18computeFourthOrderfP15fourthOrderData
1320:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     for (int axis = XAXIS; axis <= ZAXIS; axis++) {
 12818              		.loc 36 1320 0 discriminator 2
 12819 0078 08F10108 		add	r8, r8, #1
 12820              	.LVL523:
 12821 007c B8F1030F 		cmp	r8, #3
 12822              		.loc 36 1321 0 discriminator 2
 12823 0080 49F8040F 		str	r0, [r9, #4]!	@ float
1320:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     for (int axis = XAXIS; axis <= ZAXIS; axis++) {
 12824              		.loc 36 1320 0 discriminator 2
 12825 0084 F0D1     		bne	.L804
 12826              	.LBE394:
1322:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
1323:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       
1324:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     /* calculate kinematics */
1325:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     calculateKinematics(gyroRate[XAXIS],
1326:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****                         gyroRate[YAXIS],
1327:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****                         gyroRate[ZAXIS],
1328:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****                         filteredAccel[XAXIS],
1329:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****                         filteredAccel[YAXIS],
1330:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****                         filteredAccel[ZAXIS],
1331:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****                         G_Dt);
 12827              		.loc 36 1331 0
 12828 0086 4B4B     		ldr	r3, .L811+32
 12829 0088 4B4A     		ldr	r2, .L811+36
 12830 008a 5968     		ldr	r1, [r3, #4]	@ float
 12831 008c 0091     		str	r1, [sp, #0]	@ float
 12832 008e D3F808E0 		ldr	lr, [r3, #8]	@ float
 12833 0092 CDF804E0 		str	lr, [sp, #4]	@ float
 12834 0096 3068     		ldr	r0, [r6, #0]	@ float
 12835 0098 0290     		str	r0, [sp, #8]	@ float
 12836 009a 5168     		ldr	r1, [r2, #4]	@ float
 12837 009c 1068     		ldr	r0, [r2, #0]	@ float
 12838 009e 1B68     		ldr	r3, [r3, #0]	@ float
 12839 00a0 9268     		ldr	r2, [r2, #8]	@ float
 12840 00a2 FFF7FEFF 		bl	_Z19calculateKinematicsfffffff
1332:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1333:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1334:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // Evaluate are here because we want it to be synchronized with the processFlightControl
1335:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #if defined(AltitudeHoldBaro)
1336:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureBaroSum(); 
 12841              		.loc 36 1336 0
 12842 00a6 FFF7FEFF 		bl	_Z14measureBaroSumv
1337:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
1338:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****           
1339:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // Combines external pilot commands and measured sensor data to generate motor commands
1340:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     processFlightControl();
 12843              		.loc 36 1340 0
 12844 00aa FFF7FEFF 		bl	_Z20processFlightControlv
1341:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     
1342:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #if defined(BinaryWrite)
1343:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         if (fastTransfer == ON) {
1344:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****           // write out fastTelemetry to Configurator or openLog
1345:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****           fastTelemetry();
1346:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         }
1347:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif      
1348:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     
1349:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #ifdef SlowTelemetry
1350:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       updateSlowTelemetry100Hz();
1351:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
1352:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1353:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // ================================================================
1354:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // 50Hz task loop
1355:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // ================================================================
1356:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     if (frameCounter % TASK_50HZ == 0) {  //  50 Hz tasks
 12845              		.loc 36 1356 0
 12846 00ae 2368     		ldr	r3, [r4, #0]
 12847 00b0 D907     		lsls	r1, r3, #31
 12848 00b2 12D4     		bmi	.L805
1357:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1358:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       G_Dt = (currentTime - fiftyHZpreviousTime) / 1000000.0;
 12849              		.loc 36 1358 0
 12850 00b4 414B     		ldr	r3, .L811+40
 12851 00b6 2A68     		ldr	r2, [r5, #0]
 12852 00b8 1968     		ldr	r1, [r3, #0]
 12853 00ba 3C48     		ldr	r0, .L811+24
1359:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       fiftyHZpreviousTime = currentTime;
 12854              		.loc 36 1359 0
 12855 00bc 1A60     		str	r2, [r3, #0]
1358:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       G_Dt = (currentTime - fiftyHZpreviousTime) / 1000000.0;
 12856              		.loc 36 1358 0
 12857 00be C1EB020C 		rsb	ip, r1, r2
 12858 00c2 00EE90CA 		fmsr	s1, ip	@ int
 12859 00c6 B8EE600A 		fuitos	s0, s1
 12860 00ca 80EE080A 		fdivs	s0, s0, s16
 12861 00ce 80ED000A 		fsts	s0, [r0, #0]
1360:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1361:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       // Reads external pilot commands and performs functions based on stick configuration
1362:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       readPilotCommands(); 
 12862              		.loc 36 1362 0
 12863 00d2 FFF7FEFF 		bl	_Z17readPilotCommandsv
1363:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       
1364:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #if defined(AltitudeHoldBaro)
1365:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         evaluateBaroAltitude();
 12864              		.loc 36 1365 0
 12865 00d6 FFF7FEFF 		bl	_Z20evaluateBaroAltitudev
 12866              	.L805:
1366:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #endif
1367:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       
1368:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #if defined(UseAnalogRSSIReader) || defined(UseEzUHFRSSIReader)
1369:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         readRSSI();
1370:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #endif
1371:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1372:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #ifdef AltitudeHoldRangeFinder
1373:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         updateRangeFinders();
1374:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #endif
1375:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1376:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #if defined(UseGPS)
1377:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         readGps();
1378:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         if (haveAGpsLock() && !isHomeBaseInitialized()) {
1379:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****           initHomeBase();
1380:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         }
1381:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #endif      
1382:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       
1383:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #if defined(CameraControl)
1384:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         moveCamera(kinematicsAngle[YAXIS],kinematicsAngle[XAXIS],kinematicsAngle[ZAXIS]);
1385:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #endif      
1386:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
1387:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1388:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // ================================================================
1389:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // 10Hz task loop
1390:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // ================================================================
1391:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     if (frameCounter % TASK_10HZ == 0) {  //   10 Hz tasks
 12867              		.loc 36 1391 0
 12868 00da 2168     		ldr	r1, [r4, #0]
 12869 00dc 0A23     		movs	r3, #10
 12870 00de B1FBF3F0 		udiv	r0, r1, r3
 12871 00e2 03FB1012 		mls	r2, r3, r0, r1
 12872 00e6 AAB9     		cbnz	r2, .L806
1392:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1393:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #if defined(HeadingMagHold)
1394:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         G_Dt = (currentTime - tenHZpreviousTime) / 1000000.0;
 12873              		.loc 36 1394 0
 12874 00e8 354B     		ldr	r3, .L811+44
 12875 00ea 2868     		ldr	r0, [r5, #0]
 12876 00ec 1968     		ldr	r1, [r3, #0]
1395:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         tenHZpreviousTime = currentTime;
1396:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****          
1397:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         measureMagnetometer(kinematicsAngle[XAXIS], kinematicsAngle[YAXIS]);
 12877              		.loc 36 1397 0
 12878 00ee 354A     		ldr	r2, .L811+48
1395:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         tenHZpreviousTime = currentTime;
 12879              		.loc 36 1395 0
 12880 00f0 1860     		str	r0, [r3, #0]
1394:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         G_Dt = (currentTime - tenHZpreviousTime) / 1000000.0;
 12881              		.loc 36 1394 0
 12882 00f2 C1EB000E 		rsb	lr, r1, r0
 12883 00f6 01EE90EA 		fmsr	s3, lr	@ int
 12884 00fa B8EE611A 		fuitos	s2, s3
 12885              		.loc 36 1397 0
 12886 00fe 1068     		ldr	r0, [r2, #0]	@ float
 12887 0100 5168     		ldr	r1, [r2, #4]	@ float
1394:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         G_Dt = (currentTime - tenHZpreviousTime) / 1000000.0;
 12888              		.loc 36 1394 0
 12889 0102 81EE081A 		fdivs	s2, s2, s16
 12890 0106 86ED001A 		fsts	s2, [r6, #0]
 12891              		.loc 36 1397 0
 12892 010a FFF7FEFF 		bl	_Z19measureMagnetometerff
1398:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         
1399:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         calculateHeading();
 12893              		.loc 36 1399 0
 12894 010e FFF7FEFF 		bl	_Z16calculateHeadingv
 12895 0112 2FE0     		b	.L807
 12896              	.L806:
1400:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         
1401:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #endif
1402:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
1403:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     else if ((currentTime - lowPriorityTenHZpreviousTime) > 100000) {
 12897              		.loc 36 1403 0
 12898 0114 2C4A     		ldr	r2, .L811+52
 12899 0116 2B68     		ldr	r3, [r5, #0]
 12900 0118 1068     		ldr	r0, [r2, #0]
 12901 011a 191A     		subs	r1, r3, r0
 12902 011c 2B48     		ldr	r0, .L811+56
 12903 011e 8142     		cmp	r1, r0
 12904 0120 18D9     		bls	.L808
1404:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1405:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       G_Dt = (currentTime - lowPriorityTenHZpreviousTime) / 1000000.0;
 12905              		.loc 36 1405 0
 12906 0122 03EE901A 		fmsr	s7, r1	@ int
 12907 0126 F8EE632A 		fuitos	s5, s7
1406:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       lowPriorityTenHZpreviousTime = currentTime;
1407:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       
1408:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #if defined(BattMonitor)
1409:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         measureBatteryVoltage(G_Dt*1000.0);
 12908              		.loc 36 1409 0
 12909 012a 9FED293A 		flds	s6, .L811+60
1405:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       G_Dt = (currentTime - lowPriorityTenHZpreviousTime) / 1000000.0;
 12910              		.loc 36 1405 0
 12911 012e C2EE882A 		fdivs	s5, s5, s16
1406:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       lowPriorityTenHZpreviousTime = currentTime;
 12912              		.loc 36 1406 0
 12913 0132 1360     		str	r3, [r2, #0]
1405:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       G_Dt = (currentTime - lowPriorityTenHZpreviousTime) / 1000000.0;
 12914              		.loc 36 1405 0
 12915 0134 C6ED002A 		fsts	s5, [r6, #0]
 12916              		.loc 36 1409 0
 12917 0138 62EE832A 		fmuls	s5, s5, s6
 12918 013c BCEEE22A 		ftouizs	s4, s5
 12919 0140 12EE102A 		fmrs	r2, s4	@ int
 12920 0144 90B2     		uxth	r0, r2
 12921 0146 FFF7FEFF 		bl	_Z21measureBatteryVoltaget
1410:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #endif
1411:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1412:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       // Listen for configuration commands and reports telemetry
1413:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       readSerialCommand();
 12922              		.loc 36 1413 0
 12923 014a FFF7FEFF 		bl	_Z17readSerialCommandv
1414:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       sendSerialTelemetry();
 12924              		.loc 36 1414 0
 12925 014e FFF7FEFF 		bl	_Z19sendSerialTelemetryv
 12926 0152 0FE0     		b	.L807
 12927              	.L808:
1415:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
1416:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     else if ((currentTime - lowPriorityTenHZpreviousTime2) > 100000) {
 12928              		.loc 36 1416 0
 12929 0154 1F4A     		ldr	r2, .L811+64
 12930 0156 1168     		ldr	r1, [r2, #0]
 12931 0158 591A     		subs	r1, r3, r1
 12932 015a 8142     		cmp	r1, r0
 12933 015c 0AD9     		bls	.L807
1417:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       
1418:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       G_Dt = (currentTime - lowPriorityTenHZpreviousTime2) / 1000000.0;
 12934              		.loc 36 1418 0
 12935 015e 04EE901A 		fmsr	s9, r1	@ int
 12936 0162 B8EE644A 		fuitos	s8, s9
1419:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       lowPriorityTenHZpreviousTime2 = currentTime;
 12937              		.loc 36 1419 0
 12938 0166 1360     		str	r3, [r2, #0]
1418:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       G_Dt = (currentTime - lowPriorityTenHZpreviousTime2) / 1000000.0;
 12939              		.loc 36 1418 0
 12940 0168 84EE084A 		fdivs	s8, s8, s16
 12941 016c 86ED004A 		fsts	s8, [r6, #0]
1420:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1421:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #ifdef OSD_SYSTEM_MENU
1422:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         updateOSDMenu();
1423:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #endif
1424:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1425:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #ifdef MAX7456_OSD
1426:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         updateOSD();
1427:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #endif
1428:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       
1429:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #if defined(UseGPS) || defined(BattMonitor)
1430:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         processLedStatus();
 12942              		.loc 36 1430 0
 12943 0170 FFF7FEFF 		bl	_Z16processLedStatusv
 12944              	.L807:
1431:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #endif
1432:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       
1433:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #ifdef SlowTelemetry
1434:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         updateSlowTelemetry10Hz();
1435:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #endif
1436:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
1437:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1438:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #ifdef MavLink
1439:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****      if (frameCounter % TASK_1HZ == 0) {  //  1 Hz tasks
1440:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1441:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         G_Dt = (currentTime - oneHZpreviousTime) / 1000000.0;
1442:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         oneHZpreviousTime = currentTime;
1443:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         
1444:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****         sendSerialHeartbeat();   
1445:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****      }
1446:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
1447:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****     previousTime = currentTime;
 12945              		.loc 36 1447 0
 12946 0174 2B68     		ldr	r3, [r5, #0]
 12947 0176 3B60     		str	r3, [r7, #0]
 12948              	.LVL524:
 12949              	.L803:
 12950              	.LBE393:
 12951              	.LBE392:
1448:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
1449:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
1450:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined (GraupnerHoTTTelemetry)
1451:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 	hottHandler();
 12952              		.loc 36 1451 0
 12953 0178 FFF7FEFF 		bl	_Z11hottHandlerv
1452:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1453:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1454:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   if (frameCounter >= 100) {
 12954              		.loc 36 1454 0
 12955 017c 2068     		ldr	r0, [r4, #0]
 12956 017e 6328     		cmp	r0, #99
 12957 0180 02D9     		bls	.L802
1455:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****       frameCounter = 0;
 12958              		.loc 36 1455 0
 12959 0182 0749     		ldr	r1, .L811+12
 12960 0184 0022     		movs	r2, #0
 12961 0186 0A60     		str	r2, [r1, #0]
 12962              	.L802:
 12963              	.LBE395:
1456:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
1457:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\AeroQuad.ino **** }
 12964              		.loc 36 1457 0
 12965 0188 04B0     		add	sp, sp, #16
 12966 018a BDEC028B 		fldmfdd	sp!, {d8}
 12967 018e BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, sl, pc}
 12968              	.L812:
 12969 0192 00BF     		.align	2
 12970              	.L811:
 12971 0194 00000000 		.word	.LANCHOR155
 12972 0198 00000000 		.word	.LANCHOR15
 12973 019c 00000000 		.word	.LANCHOR156
 12974 01a0 00000000 		.word	.LANCHOR41
 12975 01a4 00000000 		.word	.LANCHOR157
 12976 01a8 00247449 		.word	1232348160
 12977 01ac 00000000 		.word	.LANCHOR57
 12978 01b0 00000000 		.word	.LANCHOR18
 12979 01b4 00000000 		.word	.LANCHOR142
 12980 01b8 00000000 		.word	.LANCHOR27
 12981 01bc 00000000 		.word	.LANCHOR158
 12982 01c0 00000000 		.word	.LANCHOR159
 12983 01c4 00000000 		.word	.LANCHOR42
 12984 01c8 00000000 		.word	.LANCHOR160
 12985 01cc A0860100 		.word	100000
 12986 01d0 00007A44 		.word	1148846080
 12987 01d4 00000000 		.word	.LANCHOR161
 12988 01d8 FCFFFFFF 		.word	.LANCHOR34-4
 12989 01dc FCFFFFFF 		.word	.LANCHOR142-4
 12990              		.cfi_endproc
 12991              	.LFE276:
 12993              		.section	.text.startup.main,"ax",%progbits
 12994              		.align	1
 12995              		.global	main
 12996              		.thumb
 12997              		.thumb_func
 12999              	main:
 13000              	.LFB114:
   7:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp **** 
   8:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp **** int main(void)
   9:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp **** {
 13001              		.loc 6 9 0
 13002              		.cfi_startproc
 13003              		@ args = 0, pretend = 0, frame = 0
 13004              		@ frame_needed = 0, uses_anonymous_args = 0
 13005 0000 08B5     		push	{r3, lr}
 13006              	.LCFI119:
 13007              		.cfi_def_cfa_offset 8
 13008              		.cfi_offset 14, -4
 13009              		.cfi_offset 3, -8
  10:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp **** 	//init();
  11:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp ****   	setup();
 13010              		.loc 6 11 0
 13011 0002 FFF7FEFF 		bl	_Z5setupv
 13012              	.L814:
  12:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp **** 
  13:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp **** 	for (;;)
  14:C:/MinGW/msys/1.0/home/ang/AeroQuad32\AeroQuadMain.cpp **** 		loop();
 13013              		.loc 6 14 0 discriminator 1
 13014 0006 FFF7FEFF 		bl	_Z4loopv
 13015 000a FCE7     		b	.L814
 13016              		.cfi_endproc
 13017              	.LFE114:
 13019              		.section	.text.startup._GLOBAL__sub_I__Z7premainv,"ax",%progbits
 13020              		.align	1
 13021              		.thumb
 13022              		.thumb_func
 13024              	_GLOBAL__sub_I__Z7premainv:
 13025              	.LFB278:
 13026              		.loc 36 1457 0
 13027              		.cfi_startproc
 13028              		@ args = 0, pretend = 0, frame = 0
 13029              		@ frame_needed = 0, uses_anonymous_args = 0
 13030              	.LVL525:
 13031 0000 08B5     		push	{r3, lr}
 13032              	.LCFI120:
 13033              		.cfi_def_cfa_offset 8
 13034              		.cfi_offset 14, -4
 13035              		.cfi_offset 3, -8
 13036              	.LBB398:
 13037              	.LBB399:
 116:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	HardwareSPIExt spiMPU6000(4);
 13038              		.loc 11 116 0
 13039 0002 0421     		movs	r1, #4
 13040 0004 0848     		ldr	r0, .L816
 13041 0006 FFF7FEFF 		bl	_ZN14HardwareSPIExtC1Ej
  42:../Libraries/AQ_Kinematics/HeadingFusionProcessorCompFilter.h **** float filter2 = 1 - filter1;
 13042              		.loc 21 42 0
 13043 000a 0849     		ldr	r1, .L816+4
 13044 000c 0848     		ldr	r0, .L816+8
 13045 000e 91ED000A 		flds	s0, [r1, #0]
 13046 0012 B7EE007A 		fconsts	s14, #112
 13047 0016 77EE407A 		fsubs	s15, s14, s0
 13048 001a C0ED007A 		fsts	s15, [r0, #0]
  27:C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** unsigned long headingTime = micros();
 13049              		.loc 30 27 0
 13050 001e FFF7FEFF 		bl	_ZL6microsv
 13051 0022 044B     		ldr	r3, .L816+12
 13052 0024 1860     		str	r0, [r3, #0]
 13053              	.LBE399:
 13054              	.LBE398:
 13055              		.loc 36 1457 0
 13056 0026 08BD     		pop	{r3, pc}
 13057              	.L817:
 13058              		.align	2
 13059              	.L816:
 13060 0028 00000000 		.word	.LANCHOR19
 13061 002c 00000000 		.word	.LANCHOR72
 13062 0030 00000000 		.word	.LANCHOR73
 13063 0034 00000000 		.word	.LANCHOR129
 13064              		.cfi_endproc
 13065              	.LFE278:
 13067              		.section	.init_array,"aw",%init_array
 13068              		.align	2
 13069 0004 00000000 		.word	_GLOBAL__sub_I__Z7premainv(target1)
 13070              		.global	hottTime
 13071              		.global	hottState
 13072              		.global	isGPSOff
 13073              		.global	isHoldOn
 13074              		.global	isNavOn
 13075              		.global	isAHOn
 13076              		.global	isAHOff
 13077              		.global	CountMilliseconds
 13078              		.global	hottV4Serial
 13079              		.global	queryType
 13080              		.global	flashingLedState
 13081              		.global	headingTime
 13082              		.global	setHeading
 13083              		.global	motorConfiguratorCommand
 13084              		.global	motorMinCommand
 13085              		.global	motorMaxCommand
 13086              		.global	motorAxisCommandYaw
 13087              		.global	motorAxisCommandPitch
 13088              		.global	motorAxisCommandRoll
 13089              		.global	batteryData
 13090              		.global	batteryWarningCellVoltage
 13091              		.global	batteryAlarmCellVoltage
 13092              		.global	buzzerState
 13093              		.global	batteryWarning
 13094              		.global	batteryAlarm
 13095              		.global	numberOfBatteries
 13096              		.global	MS5611_first_read
 13097              		.global	baroStartTime
 13098              		.global	baroGroundUpdateDone
 13099              		.global	rawPressureSumCount
 13100              		.global	rawPressureSum
 13101              		.global	isReadPressure
 13102              		.global	pressureFactor
 13103              		.global	pressureCount
 13104              		.global	rawTemperature
 13105              		.global	rawPressure
 13106              		.global	pressure
 13107              		.global	MS5611_offset
 13108              		.global	MS5611_sens
 13109              		.global	MS5611lastRawPressure
 13110              		.global	MS5611lastRawTemperature
 13111              		.global	MS5611Prom
 13112              		.global	baroSmoothFactor
 13113              		.global	baroGroundAltitude
 13114              		.global	baroRawAltitude
 13115              		.global	baroAltitude
 13116              		.global	localHeading
 13117              		.global	headingGyroZero
 13118              		.global	filter2
 13119              		.global	filter1
 13120              		.global	compassDeclination
 13121              		.global	trueNorthHeading
 13122              		.global	magScale
 13123              		.global	magBias
 13124              		.global	rawMag
 13125              		.global	measuredMag
 13126              		.global	measuredMagZ
 13127              		.global	measuredMagY
 13128              		.global	measuredMagX
 13129              		.global	hdgY
 13130              		.global	hdgX
 13131              		.global	MotorInfo
 13132              		.global	motorCommand
 13133              		.global	numberOfMotors
 13134              		.global	FrqData
 13135              		.global	currentChannel
 13136              		.global	rawChannelValue
 13137              		.global	previousEz
 13138              		.global	previousEy
 13139              		.global	previousEx
 13140              		.global	ezInt
 13141              		.global	eyInt
 13142              		.global	exInt
 13143              		.global	q3
 13144              		.global	q2
 13145              		.global	q1
 13146              		.global	q0
 13147              		.global	halfT
 13148              		.global	Ki
 13149              		.global	Kp
 13150              		.global	accelCutoff
 13151              		.global	earthAccel
 13152              		.global	correctedRateVector
 13153              		.global	gyroAngle
 13154              		.global	kinematicsAngle
 13155              		.global	kinematicsType
 13156              		.global	previousMeasureCriticalSensorsTime
 13157              		.global	accelSampleCount
 13158              		.global	accelSample
 13159              		.global	meterPerSecSec
 13160              		.global	accelOneG
 13161              		.global	runTimeAccelBias
 13162              		.global	accelScaleFactor
 13163              		.global	gyroSampleCount
 13164              		.global	gyroLastMesuredTime
 13165              		.global	gyroHeading
 13166              		.global	gyroScaleFactor
 13167              		.global	gyroSample
 13168              		.global	gyroZero
 13169              		.global	gyroRate
 13170              		.global	readMPU6000GyroCount
 13171              		.global	readMPU6000AccelCount
 13172              		.global	readMPU6000Count
 13173              		.global	initializeMPU6000SensorsDone
 13174              		.global	spiMPU6000
 13175              		.global	MPU6000
 13176              		.global	vehicleState
 13177              		.global	gyroRaw
 13178              		.global	Serial
 13179              		.global	fourthOrder
 13180              		.global	windupGuard
 13181              		.global	PID
 13182              		.global	fastTransfer
 13183              		.global	baroAltitudeToHoldTarget
 13184              		.global	isStoreAltitudeNeeded
 13185              		.global	altitudeHoldThrottle
 13186              		.global	maxThrottleAdjust
 13187              		.global	minThrottleAdjust
 13188              		.global	altitudeHoldPanicStickMovement
 13189              		.global	altitudeHoldBump
 13190              		.global	altitudeHoldState
 13191              		.global	batteryMonitorGoingDownTime
 13192              		.global	batteryMonitorStartTime
 13193              		.global	batteryMonitorThrottleTarget
 13194              		.global	batteryMonitorStartThrottle
 13195              		.global	batteryMonitorAlarmVoltage
 13196              		.global	headingHoldState
 13197              		.global	relativeHeading
 13198              		.global	heading
 13199              		.global	headingHold
 13200              		.global	headingHoldConfig
 13201              		.global	aref
 13202              		.global	hundredHZpreviousTime
 13203              		.global	fiftyHZpreviousTime
 13204              		.global	lowPriorityTenHZpreviousTime2
 13205              		.global	lowPriorityTenHZpreviousTime
 13206              		.global	tenHZpreviousTime
 13207              		.global	oneHZpreviousTime
 13208              		.global	deltaTime
 13209              		.global	currentTime
 13210              		.global	previousTime
 13211              		.global	SpeakHoTT
 13212              		.global	rotationSpeedFactor
 13213              		.global	inFlight
 13214              		.global	filteredAccel
 13215              		.global	minLimit
 13216              		.global	maxLimit
 13217              		.global	safetyCheck
 13218              		.global	motorArmed
 13219              		.global	throttle
 13220              		.global	G_Dt
 13221              		.global	minArmedThrottle
 13222              		.global	frameCounter
 13223              		.global	flightMode
 13224              		.global	testCommand
 13225              		.global	calibrateESC
 13226              		.global	channelCal
 13227              		.global	receiverSmoothFactor
 13228              		.global	receiverOffset
 13229              		.global	receiverSlope
 13230              		.global	receiverCommandSmooth
 13231              		.global	receiverCommand
 13232              		.global	receiverZero
 13233              		.global	receiverData
 13234              		.global	receiverXmitFactor
 13235              		.global	lastReceiverChannel
 13236              		.weak	_ZN14HardwareSPIExtC1Ej
 13237              		.thumb_set _ZN14HardwareSPIExtC1Ej,_ZN14HardwareSPIExtC2Ej
 13238              		.section	.rodata
 13239              		.set	.LANCHOR152,. + 0
 13240              	.LC0:
 13241 0000 7C       		.byte	124
 13242 0001 89       		.byte	-119
 13243 0002 00       		.byte	0
 13244 0003 90       		.byte	-112
 13245 0004 00       		.byte	0
 13246 0005 F4       		.byte	-12
 13247 0006 01       		.byte	1
 13248 0007 F4       		.byte	-12
 13249 0008 01       		.byte	1
 13250 0009 F4       		.byte	-12
 13251 000a 01       		.byte	1
 13252 000b 30       		.byte	48
 13253 000c 75       		.byte	117
 13254 000d 30       		.byte	48
 13255 000e 75       		.byte	117
 13256 000f 30       		.byte	48
 13257 0010 75       		.byte	117
 13258 0011 00       		.byte	0
 13259 0012 00       		.byte	0
 13260 0013 00       		.byte	0
 13261 0014 00       		.byte	0
 13262 0015 00       		.byte	0
 13263 0016 00       		.byte	0
 13264 0017 00       		.byte	0
 13265 0018 00       		.byte	0
 13266 0019 00       		.byte	0
 13267 001a 00       		.byte	0
 13268 001b 00       		.byte	0
 13269 001c 00       		.byte	0
 13270 001d 00       		.byte	0
 13271 001e 00       		.byte	0
 13272 001f 00       		.byte	0
 13273 0020 00       		.byte	0
 13274 0021 00       		.byte	0
 13275 0022 00       		.byte	0
 13276 0023 00       		.byte	0
 13277 0024 00       		.byte	0
 13278 0025 00       		.byte	0
 13279 0026 00       		.byte	0
 13280 0027 00       		.byte	0
 13281 0028 00       		.byte	0
 13282 0029 00       		.byte	0
 13283 002a 00       		.byte	0
 13284 002b 7D       		.byte	125
 13285 002c 00       		.byte	0
 13286              		.section	.bss.CountMilliseconds,"aw",%nobits
 13287              		.align	2
 13288              		.set	.LANCHOR144,. + 0
 13291              	CountMilliseconds:
 13292 0000 00000000 		.space	4
 13293              		.section	.bss.receiverXmitFactor,"aw",%nobits
 13294              		.align	2
 13295              		.set	.LANCHOR61,. + 0
 13298              	receiverXmitFactor:
 13299 0000 00000000 		.space	4
 13300              		.section	.bss.receiverData,"aw",%nobits
 13301              		.align	2
 13302              		.set	.LANCHOR60,. + 0
 13305              	receiverData:
 13306 0000 00000000 		.space	32
 13306      00000000 
 13306      00000000 
 13306      00000000 
 13306      00000000 
 13307              		.section	.bss.MS5611_sens,"aw",%nobits
 13308              		.align	3
 13309              		.set	.LANCHOR87,. + 0
 13312              	MS5611_sens:
 13313 0000 00000000 		.space	8
 13313      00000000 
 13314              		.section	.bss.motorArmed,"aw",%nobits
 13315              		.set	.LANCHOR130,. + 0
 13318              	motorArmed:
 13319 0000 00       		.space	1
 13320              		.section	.bss.windupGuard,"aw",%nobits
 13321              		.align	2
 13322              		.set	.LANCHOR131,. + 0
 13325              	windupGuard:
 13326 0000 00000000 		.space	4
 13327              		.section	.data.baroSmoothFactor,"aw",%progbits
 13328              		.align	2
 13329              		.set	.LANCHOR97,. + 0
 13332              	baroSmoothFactor:
 13333 0000 0AD7A33C 		.word	1017370378
 13334              		.section	.bss._ZL26hottV4TelemetryBufferIndex,"aw",%nobits
 13335              		.set	.LANCHOR4,. + 0
 13338              	_ZL26hottV4TelemetryBufferIndex:
 13339 0000 00       		.space	1
 13340              		.section	.bss.pressureCount,"aw",%nobits
 13341              		.set	.LANCHOR92,. + 0
 13344              	pressureCount:
 13345 0000 00       		.space	1
 13346              		.section	.bss.motorMinCommand,"aw",%nobits
 13347              		.align	2
 13348              		.set	.LANCHOR121,. + 0
 13351              	motorMinCommand:
 13352 0000 00000000 		.space	16
 13352      00000000 
 13352      00000000 
 13352      00000000 
 13353              		.section	.bss.gyroHeading,"aw",%nobits
 13354              		.align	2
 13355              		.set	.LANCHOR28,. + 0
 13358              	gyroHeading:
 13359 0000 00000000 		.space	4
 13360              		.section	.bss.rawPressure,"aw",%nobits
 13361              		.align	2
 13364              	rawPressure:
 13365 0000 00000000 		.space	4
 13366              		.section	.bss.filteredAccel,"aw",%nobits
 13367              		.align	2
 13368              		.set	.LANCHOR142,. + 0
 13371              	filteredAccel:
 13372 0000 00000000 		.space	12
 13372      00000000 
 13372      00000000 
 13373              		.section	.data.altitudeHoldPanicStickMovement,"aw",%progbits
 13374              		.align	2
 13375              		.set	.LANCHOR113,. + 0
 13378              	altitudeHoldPanicStickMovement:
 13379 0000 FA000000 		.word	250
 13380              		.section	.bss.isNavOn,"aw",%nobits
 13383              	isNavOn:
 13384 0000 00       		.space	1
 13385              		.section	.bss.receiverSmoothFactor,"aw",%nobits
 13386              		.align	2
 13387              		.set	.LANCHOR14,. + 0
 13390              	receiverSmoothFactor:
 13391 0000 00000000 		.space	32
 13391      00000000 
 13391      00000000 
 13391      00000000 
 13391      00000000 
 13392              		.section	.bss.FrqData,"aw",%nobits
 13393              		.align	2
 13394              		.set	.LANCHOR0,. + 0
 13397              	FrqData:
 13398 0000 00000000 		.space	24
 13398      00000000 
 13398      00000000 
 13398      00000000 
 13398      00000000 
 13399              		.section	.bss.minLimit,"aw",%nobits
 13402              	minLimit:
 13403 0000 00       		.space	1
 13404              		.section	.bss.measuredMag,"aw",%nobits
 13405              		.align	2
 13406              		.set	.LANCHOR69,. + 0
 13409              	measuredMag:
 13410 0000 00000000 		.space	12
 13410      00000000 
 13410      00000000 
 13411              		.section	.bss.readMPU6000Count,"aw",%nobits
 13412              		.align	2
 13413              		.set	.LANCHOR24,. + 0
 13416              	readMPU6000Count:
 13417 0000 00000000 		.space	4
 13418              		.section	.bss.rawMag,"aw",%nobits
 13419              		.align	2
 13420              		.set	.LANCHOR68,. + 0
 13423              	rawMag:
 13424 0000 00000000 		.space	12
 13424      00000000 
 13424      00000000 
 13425              		.section	.bss.tenHZpreviousTime,"aw",%nobits
 13426              		.align	2
 13427              		.set	.LANCHOR159,. + 0
 13430              	tenHZpreviousTime:
 13431 0000 00000000 		.space	4
 13432              		.section	.bss.lowPriorityTenHZpreviousTime2,"aw",%nobits
 13433              		.align	2
 13434              		.set	.LANCHOR161,. + 0
 13437              	lowPriorityTenHZpreviousTime2:
 13438 0000 00000000 		.space	4
 13439              		.section	.bss.isAHOff,"aw",%nobits
 13440              		.set	.LANCHOR146,. + 0
 13443              	isAHOff:
 13444 0000 00       		.space	1
 13445              		.section	.bss.accelCutoff,"aw",%nobits
 13446              		.align	2
 13449              	accelCutoff:
 13450 0000 00000000 		.space	4
 13451              		.section	.bss.currentTime,"aw",%nobits
 13452              		.align	2
 13453              		.set	.LANCHOR15,. + 0
 13456              	currentTime:
 13457 0000 00000000 		.space	4
 13458              		.section	.data.batteryMonitorAlarmVoltage,"aw",%progbits
 13459              		.align	2
 13460              		.set	.LANCHOR133,. + 0
 13463              	batteryMonitorAlarmVoltage:
 13464 0000 00002041 		.word	1092616192
 13465              		.section	.bss.previousMeasureCriticalSensorsTime,"aw",%nobits
 13466              		.align	2
 13467              		.set	.LANCHOR40,. + 0
 13470              	previousMeasureCriticalSensorsTime:
 13471 0000 00000000 		.space	4
 13472              		.section	.data.queryType,"aw",%progbits
 13473              		.set	.LANCHOR139,. + 0
 13476              	queryType:
 13477 0000 58       		.byte	88
 13478              		.section	.bss.heading,"aw",%nobits
 13479              		.align	2
 13480              		.set	.LANCHOR124,. + 0
 13483              	heading:
 13484 0000 00000000 		.space	4
 13485              		.section	.bss.baroGroundAltitude,"aw",%nobits
 13486              		.align	2
 13487              		.set	.LANCHOR81,. + 0
 13490              	baroGroundAltitude:
 13491 0000 00000000 		.space	4
 13492              		.section	.bss.motorAxisCommandPitch,"aw",%nobits
 13493              		.align	2
 13494              		.set	.LANCHOR107,. + 0
 13497              	motorAxisCommandPitch:
 13498 0000 00000000 		.space	4
 13499              		.section	.bss.motorCommand,"aw",%nobits
 13500              		.align	2
 13501              		.set	.LANCHOR63,. + 0
 13504              	motorCommand:
 13505 0000 00000000 		.space	32
 13505      00000000 
 13505      00000000 
 13505      00000000 
 13505      00000000 
 13506              		.section	.bss._ZZL15hottVoiceOutputvE6repeat,"aw",%nobits
 13507              		.align	2
 13508              		.set	.LANCHOR148,. + 0
 13511              	_ZZL15hottVoiceOutputvE6repeat:
 13512 0000 00000000 		.space	4
 13513              		.section	.data.altitudeHoldBump,"aw",%progbits
 13514              		.align	2
 13515              		.set	.LANCHOR8,. + 0
 13518              	altitudeHoldBump:
 13519 0000 5A000000 		.word	90
 13520              		.section	.data.MS5611_first_read,"aw",%progbits
 13521              		.set	.LANCHOR96,. + 0
 13524              	MS5611_first_read:
 13525 0000 01       		.byte	1
 13526              		.section	.bss.headingHoldConfig,"aw",%nobits
 13527              		.set	.LANCHOR123,. + 0
 13530              	headingHoldConfig:
 13531 0000 00       		.space	1
 13532              		.section	.bss.ezInt,"aw",%nobits
 13533              		.align	2
 13534              		.set	.LANCHOR54,. + 0
 13537              	ezInt:
 13538 0000 00000000 		.space	4
 13539              		.section	.data.numberOfMotors,"aw",%progbits
 13542              	numberOfMotors:
 13543 0000 04       		.byte	4
 13544              		.section	.data.rotationSpeedFactor,"aw",%progbits
 13545              		.align	2
 13546              		.set	.LANCHOR115,. + 0
 13549              	rotationSpeedFactor:
 13550 0000 0000803F 		.word	1065353216
 13551              		.section	.bss.headingHoldState,"aw",%nobits
 13552              		.set	.LANCHOR128,. + 0
 13555              	headingHoldState:
 13556 0000 00       		.space	1
 13557              		.section	.bss.MotorInfo,"aw",%nobits
 13558              		.align	2
 13559              		.set	.LANCHOR62,. + 0
 13562              	MotorInfo:
 13563 0000 00000000 		.space	96
 13563      00000000 
 13563      00000000 
 13563      00000000 
 13563      00000000 
 13564              		.section	.rodata._ZL19stm32_motor_mapping,"a",%progbits
 13565              		.set	.LANCHOR65,. + 0
 13568              	_ZL19stm32_motor_mapping:
 13569 0000 29       		.byte	41
 13570 0001 28       		.byte	40
 13571 0002 27       		.byte	39
 13572 0003 26       		.byte	38
 13573 0004 0F       		.byte	15
 13574 0005 13       		.byte	19
 13575 0006 14       		.byte	20
 13576 0007 15       		.byte	21
 13577              		.section	.bss.numberOfBatteries,"aw",%nobits
 13578              		.set	.LANCHOR102,. + 0
 13581              	numberOfBatteries:
 13582 0000 00       		.space	1
 13583              		.section	.bss.rawPressureSumCount,"aw",%nobits
 13584              		.set	.LANCHOR91,. + 0
 13587              	rawPressureSumCount:
 13588 0000 00       		.space	1
 13589              		.section	.bss.accelSampleCount,"aw",%nobits
 13590              		.set	.LANCHOR38,. + 0
 13593              	accelSampleCount:
 13594 0000 00       		.space	1
 13595              		.section	.bss.trueNorthHeading,"aw",%nobits
 13596              		.align	2
 13597              		.set	.LANCHOR74,. + 0
 13600              	trueNorthHeading:
 13601 0000 00000000 		.space	4
 13602              		.section	.bss.eyInt,"aw",%nobits
 13603              		.align	2
 13604              		.set	.LANCHOR52,. + 0
 13607              	eyInt:
 13608 0000 00000000 		.space	4
 13609              		.section	.bss.previousEx,"aw",%nobits
 13610              		.align	2
 13611              		.set	.LANCHOR51,. + 0
 13614              	previousEx:
 13615 0000 00000000 		.space	4
 13616              		.section	.bss.previousEy,"aw",%nobits
 13617              		.align	2
 13618              		.set	.LANCHOR53,. + 0
 13621              	previousEy:
 13622 0000 00000000 		.space	4
 13623              		.section	.bss.previousEz,"aw",%nobits
 13624              		.align	2
 13625              		.set	.LANCHOR55,. + 0
 13628              	previousEz:
 13629 0000 00000000 		.space	4
 13630              		.section	.data.pressureFactor,"aw",%progbits
 13631              		.align	2
 13632              		.set	.LANCHOR94,. + 0
 13635              	pressureFactor:
 13636 0000 AEDC423E 		.word	1044569262
 13637              		.section	.data._ZL11minAltitude,"aw",%progbits
 13638              		.align	2
 13639              		.set	.LANCHOR83,. + 0
 13642              	_ZL11minAltitude:
 13643 0000 F4010000 		.word	500
 13644              		.section	.bss.readMPU6000GyroCount,"aw",%nobits
 13645              		.align	2
 13646              		.set	.LANCHOR25,. + 0
 13649              	readMPU6000GyroCount:
 13650 0000 00000000 		.space	4
 13651              		.section	.bss.isReadPressure,"aw",%nobits
 13652              		.set	.LANCHOR89,. + 0
 13655              	isReadPressure:
 13656 0000 00       		.space	1
 13657              		.section	.bss.fastTransfer,"aw",%nobits
 13658              		.set	.LANCHOR141,. + 0
 13661              	fastTransfer:
 13662 0000 00       		.space	1
 13663              		.section	.bss._ZZL22hottv4UpdateFlightTimePhE17previousEAMUpdate,"aw",%nobits
 13664              		.align	2
 13665              		.set	.LANCHOR149,. + 0
 13668              	_ZZL22hottv4UpdateFlightTimePhE17previousEAMUpdate:
 13669 0000 00000000 		.space	4
 13670              		.section	.bss.filter2,"aw",%nobits
 13671              		.align	2
 13672              		.set	.LANCHOR73,. + 0
 13675              	filter2:
 13676 0000 00000000 		.space	4
 13677              		.section	.bss.minArmedThrottle,"aw",%nobits
 13678              		.align	2
 13679              		.set	.LANCHOR120,. + 0
 13682              	minArmedThrottle:
 13683 0000 00000000 		.space	4
 13684              		.section	.bss.isHoldOn,"aw",%nobits
 13687              	isHoldOn:
 13688 0000 00       		.space	1
 13689              		.section	.data.batteryWarningCellVoltage,"aw",%progbits
 13690              		.align	1
 13691              		.set	.LANCHOR101,. + 0
 13694              	batteryWarningCellVoltage:
 13695 0000 6E01     		.short	366
 13696              		.section	.bss.isStoreAltitudeNeeded,"aw",%nobits
 13697              		.set	.LANCHOR137,. + 0
 13700              	isStoreAltitudeNeeded:
 13701 0000 00       		.space	1
 13702              		.section	.bss.deltaTime,"aw",%nobits
 13703              		.align	2
 13704              		.set	.LANCHOR156,. + 0
 13707              	deltaTime:
 13708 0000 00000000 		.space	4
 13709              		.section	.bss.flashingLedState,"aw",%nobits
 13710              		.set	.LANCHOR138,. + 0
 13713              	flashingLedState:
 13714 0000 00       		.space	1
 13715              		.section	.bss.setHeading,"aw",%nobits
 13716              		.align	2
 13717              		.set	.LANCHOR125,. + 0
 13720              	setHeading:
 13721 0000 00000000 		.space	4
 13722              		.section	.bss.inFlight,"aw",%nobits
 13723              		.set	.LANCHOR16,. + 0
 13726              	inFlight:
 13727 0000 00       		.space	1
 13728              		.section	.bss.motorConfiguratorCommand,"aw",%nobits
 13729              		.align	2
 13730              		.set	.LANCHOR118,. + 0
 13733              	motorConfiguratorCommand:
 13734 0000 00000000 		.space	16
 13734      00000000 
 13734      00000000 
 13734      00000000 
 13735              		.section	.bss.hdgX,"aw",%nobits
 13736              		.align	2
 13737              		.set	.LANCHOR66,. + 0
 13740              	hdgX:
 13741 0000 00000000 		.space	4
 13742              		.section	.bss.hdgY,"aw",%nobits
 13743              		.align	2
 13744              		.set	.LANCHOR67,. + 0
 13747              	hdgY:
 13748 0000 00000000 		.space	4
 13749              		.section	.bss.measuredMagX,"aw",%nobits
 13750              		.align	2
 13751              		.set	.LANCHOR77,. + 0
 13754              	measuredMagX:
 13755 0000 00000000 		.space	4
 13756              		.section	.bss.measuredMagY,"aw",%nobits
 13757              		.align	2
 13758              		.set	.LANCHOR78,. + 0
 13761              	measuredMagY:
 13762 0000 00000000 		.space	4
 13763              		.section	.bss.measuredMagZ,"aw",%nobits
 13764              		.align	2
 13765              		.set	.LANCHOR79,. + 0
 13768              	measuredMagZ:
 13769 0000 00000000 		.space	4
 13770              		.section	.bss.magBias,"aw",%nobits
 13771              		.align	2
 13772              		.set	.LANCHOR76,. + 0
 13775              	magBias:
 13776 0000 00000000 		.space	12
 13776      00000000 
 13776      00000000 
 13777              		.section	.data.testCommand,"aw",%progbits
 13778              		.align	2
 13779              		.set	.LANCHOR117,. + 0
 13782              	testCommand:
 13783 0000 E8030000 		.word	1000
 13784              		.section	.bss.MS5611lastRawPressure,"aw",%nobits
 13785              		.align	2
 13786              		.set	.LANCHOR88,. + 0
 13789              	MS5611lastRawPressure:
 13790 0000 00000000 		.space	4
 13791              		.section	.data.magScale,"aw",%progbits
 13792              		.align	2
 13793              		.set	.LANCHOR75,. + 0
 13796              	magScale:
 13797 0000 0000803F 		.word	1065353216
 13798 0004 0000803F 		.word	1065353216
 13799 0008 0000803F 		.word	1065353216
 13800              		.section	.bss.q0,"aw",%nobits
 13801              		.align	2
 13802              		.set	.LANCHOR47,. + 0
 13805              	q0:
 13806 0000 00000000 		.space	4
 13807              		.section	.bss.q1,"aw",%nobits
 13808              		.align	2
 13809              		.set	.LANCHOR45,. + 0
 13812              	q1:
 13813 0000 00000000 		.space	4
 13814              		.section	.bss.q2,"aw",%nobits
 13815              		.align	2
 13816              		.set	.LANCHOR48,. + 0
 13819              	q2:
 13820 0000 00000000 		.space	4
 13821              		.section	.bss.q3,"aw",%nobits
 13822              		.align	2
 13823              		.set	.LANCHOR46,. + 0
 13826              	q3:
 13827 0000 00000000 		.space	4
 13828              		.section	.bss.MS5611_offset,"aw",%nobits
 13829              		.align	3
 13830              		.set	.LANCHOR86,. + 0
 13833              	MS5611_offset:
 13834 0000 00000000 		.space	8
 13834      00000000 
 13835              		.section	.bss.accelSample,"aw",%nobits
 13836              		.align	2
 13837              		.set	.LANCHOR37,. + 0
 13840              	accelSample:
 13841 0000 00000000 		.space	12
 13841      00000000 
 13841      00000000 
 13842              		.section	.bss.aref,"aw",%nobits
 13843              		.align	2
 13844              		.set	.LANCHOR132,. + 0
 13847              	aref:
 13848 0000 00000000 		.space	4
 13849              		.section	.bss.receiverCommand,"aw",%nobits
 13850              		.align	2
 13851              		.set	.LANCHOR6,. + 0
 13854              	receiverCommand:
 13855 0000 00000000 		.space	32
 13855      00000000 
 13855      00000000 
 13855      00000000 
 13855      00000000 
 13856              		.section	.bss.currentChannel,"aw",%nobits
 13857              		.set	.LANCHOR1,. + 0
 13860              	currentChannel:
 13861 0000 00       		.space	1
 13862              		.section	.bss.accelScaleFactor,"aw",%nobits
 13863              		.align	2
 13864              		.set	.LANCHOR35,. + 0
 13867              	accelScaleFactor:
 13868 0000 00000000 		.space	12
 13868      00000000 
 13868      00000000 
 13869              		.section	.data.minThrottleAdjust,"aw",%progbits
 13870              		.align	2
 13871              		.set	.LANCHOR111,. + 0
 13874              	minThrottleAdjust:
 13875 0000 CEFFFFFF 		.word	-50
 13876              		.section	.bss.halfT,"aw",%nobits
 13877              		.align	2
 13878              		.set	.LANCHOR44,. + 0
 13881              	halfT:
 13882 0000 00000000 		.space	4
 13883              		.section	.bss.headingHold,"aw",%nobits
 13884              		.align	2
 13885              		.set	.LANCHOR127,. + 0
 13888              	headingHold:
 13889 0000 00000000 		.space	4
 13890              		.section	.bss.compassDeclination,"aw",%nobits
 13891              		.align	2
 13894              	compassDeclination:
 13895 0000 00000000 		.space	4
 13896              		.section	.bss.correctedRateVector,"aw",%nobits
 13897              		.align	2
 13898              		.set	.LANCHOR58,. + 0
 13901              	correctedRateVector:
 13902 0000 00000000 		.space	12
 13902      00000000 
 13902      00000000 
 13903              		.section	.bss._ZL12milliseconds,"aw",%nobits
 13904              		.align	1
 13905              		.set	.LANCHOR150,. + 0
 13908              	_ZL12milliseconds:
 13909 0000 0000     		.space	2
 13910              		.section	.bss.fiftyHZpreviousTime,"aw",%nobits
 13911              		.align	2
 13912              		.set	.LANCHOR158,. + 0
 13915              	fiftyHZpreviousTime:
 13916 0000 00000000 		.space	4
 13917              		.section	.bss.frameCounter,"aw",%nobits
 13918              		.align	2
 13919              		.set	.LANCHOR41,. + 0
 13922              	frameCounter:
 13923 0000 00000000 		.space	4
 13924              		.section	.bss.Ki,"aw",%nobits
 13925              		.align	2
 13926              		.set	.LANCHOR50,. + 0
 13929              	Ki:
 13930 0000 00000000 		.space	4
 13931              		.section	.bss.receiverCommandSmooth,"aw",%nobits
 13932              		.align	2
 13933              		.set	.LANCHOR10,. + 0
 13936              	receiverCommandSmooth:
 13937 0000 00000000 		.space	32
 13937      00000000 
 13937      00000000 
 13937      00000000 
 13937      00000000 
 13938              		.section	.bss._ZL21hottV4TelemetryBuffer,"aw",%nobits
 13939              		.set	.LANCHOR3,. + 0
 13942              	_ZL21hottV4TelemetryBuffer:
 13943 0000 00000000 		.space	45
 13943      00000000 
 13943      00000000 
 13943      00000000 
 13943      00000000 
 13944              		.section	.bss.oneHZpreviousTime,"aw",%nobits
 13945              		.align	2
 13948              	oneHZpreviousTime:
 13949 0000 00000000 		.space	4
 13950              		.section	.bss.Kp,"aw",%nobits
 13951              		.align	2
 13952              		.set	.LANCHOR56,. + 0
 13955              	Kp:
 13956 0000 00000000 		.space	4
 13957              		.section	.bss.baroAltitudeToHoldTarget,"aw",%nobits
 13958              		.align	2
 13959              		.set	.LANCHOR110,. + 0
 13962              	baroAltitudeToHoldTarget:
 13963 0000 00000000 		.space	4
 13964              		.section	.bss.readMPU6000AccelCount,"aw",%nobits
 13965              		.align	2
 13966              		.set	.LANCHOR23,. + 0
 13969              	readMPU6000AccelCount:
 13970 0000 00000000 		.space	4
 13971              		.section	.bss.headingTime,"aw",%nobits
 13972              		.align	2
 13973              		.set	.LANCHOR129,. + 0
 13976              	headingTime:
 13977 0000 00000000 		.space	4
 13978              		.section	.rodata.str1.1,"aMS",%progbits,1
 13979              	.LC1:
 13980 0000 696E6974 		.ascii	"initializeMPU6000Sensors\000"
 13980      69616C69 
 13980      7A654D50 
 13980      55363030 
 13980      3053656E 
 13981              	.LC2:
 13982 0019 4D505536 		.ascii	"MPU6000 found\000"
 13982      30303020 
 13982      666F756E 
 13982      6400
 13983              	.LC3:
 13984 0027 4D505536 		.ascii	"MPU6000 not found\000"
 13984      30303020 
 13984      6E6F7420 
 13984      666F756E 
 13984      6400
 13985              	.LC4:
 13986 0039 0D0A4165 		.ascii	"\015\012AeroQuad STM32, board type aeroquad32, buil"
 13986      726F5175 
 13986      61642053 
 13986      544D3332 
 13986      2C20626F 
 13987 0066 64206461 		.ascii	"d date Aug 15 2012 21:22:21\000"
 13987      74652041 
 13987      75672031 
 13987      35203230 
 13987      31322032 
 13988              	.LC5:
 13989 0082 53544D33 		.ascii	"STM32 init done\015\012\000"
 13989      3220696E 
 13989      69742064 
 13989      6F6E650D 
 13989      0A00
 13990              	.LC6:
 13991 0094 3A2000   		.ascii	": \000"
 13992              	.LC7:
 13993 0097 4E6F7420 		.ascii	"Not \000"
 13993      00
 13994              	.LC8:
 13995 009c 536F6674 		.ascii	"Software Version: \000"
 13995      77617265 
 13995      20566572 
 13995      73696F6E 
 13995      3A2000
 13996              	.LC9:
 13997 00af 426F6172 		.ascii	"Board Type: \000"
 13997      64205479 
 13997      70653A20 
 13997      00
 13998              	.LC10:
 13999 00bc 53544D33 		.ascii	"STM32\000"
 13999      3200
 14000              	.LC11:
 14001 00c2 466C6967 		.ascii	"Flight Config: \000"
 14001      68742043 
 14001      6F6E6669 
 14001      673A2000 
 14002              	.LC12:
 14003 00d2 51756164 		.ascii	"Quad X\000"
 14003      205800
 14004              	.LC13:
 14005 00d9 52656365 		.ascii	"Receiver Channels: \000"
 14005      69766572 
 14005      20436861 
 14005      6E6E656C 
 14005      733A2000 
 14006              	.LC14:
 14007 00ed 4D6F746F 		.ascii	"Motors: \000"
 14007      72733A20 
 14007      00
 14008              	.LC15:
 14009 00f6 4779726F 		.ascii	"Gyroscope\000"
 14009      73636F70 
 14009      6500
 14010              	.LC16:
 14011 0100 44657465 		.ascii	"Detected\000"
 14011      63746564 
 14011      00
 14012              	.LC17:
 14013 0109 41636365 		.ascii	"Accelerometer\000"
 14013      6C65726F 
 14013      6D657465 
 14013      7200
 14014              	.LC18:
 14015 0117 4261726F 		.ascii	"Barometer\000"
 14015      6D657465 
 14015      7200
 14016              	.LC19:
 14017 0121 4D61676E 		.ascii	"Magnetometer\000"
 14017      65746F6D 
 14017      65746572 
 14017      00
 14018              	.LC20:
 14019 012e 48656164 		.ascii	"Heading Hold\000"
 14019      696E6720 
 14019      486F6C64 
 14019      00
 14020              	.LC21:
 14021 013b 456E6162 		.ascii	"Enabled\000"
 14021      6C656400 
 14022              	.LC22:
 14023 0143 416C7469 		.ascii	"Altitude Hold\000"
 14023      74756465 
 14023      20486F6C 
 14023      6400
 14024              	.LC23:
 14025 0151 42617474 		.ascii	"Battery Monitor\000"
 14025      65727920 
 14025      4D6F6E69 
 14025      746F7200 
 14026              	.LC24:
 14027 0161 43616D65 		.ascii	"Camera Stability\000"
 14027      72612053 
 14027      74616269 
 14027      6C697479 
 14027      00
 14028              	.LC25:
 14029 0172 52616E67 		.ascii	"Range Detection\000"
 14029      65204465 
 14029      74656374 
 14029      696F6E00 
 14030              	.LC26:
 14031 0182 4165726F 		.ascii	"AeroQuad (Attitude)\000"
 14031      51756164 
 14031      20284174 
 14031      74697475 
 14031      64652900 
 14032              	.LC27:
 14033 0196 4165726F 		.ascii	"AeroQuad (Rate)\000"
 14033      51756164 
 14033      20285261 
 14033      74652900 
 14034              		.section	.bss.initializeMPU6000SensorsDone,"aw",%nobits
 14035              		.set	.LANCHOR20,. + 0
 14038              	initializeMPU6000SensorsDone:
 14039 0000 00       		.space	1
 14040              		.section	.bss.pressure,"aw",%nobits
 14041              		.align	2
 14042              		.set	.LANCHOR93,. + 0
 14045              	pressure:
 14046 0000 00000000 		.space	4
 14047              		.section	.bss.baroAltitude,"aw",%nobits
 14048              		.align	2
 14049              		.set	.LANCHOR80,. + 0
 14052              	baroAltitude:
 14053 0000 00000000 		.space	4
 14054              		.section	.bss.gyroRate,"aw",%nobits
 14055              		.align	2
 14056              		.set	.LANCHOR27,. + 0
 14059              	gyroRate:
 14060 0000 00000000 		.space	12
 14060      00000000 
 14060      00000000 
 14061              		.section	.bss.MS5611lastRawTemperature,"aw",%nobits
 14062              		.align	2
 14063              		.set	.LANCHOR85,. + 0
 14066              	MS5611lastRawTemperature:
 14067 0000 00000000 		.space	4
 14068              		.section	.bss.batteryMonitorStartThrottle,"aw",%nobits
 14069              		.align	2
 14072              	batteryMonitorStartThrottle:
 14073 0000 00000000 		.space	4
 14074              		.section	.bss.kinematicsAngle,"aw",%nobits
 14075              		.align	2
 14076              		.set	.LANCHOR42,. + 0
 14079              	kinematicsAngle:
 14080 0000 00000000 		.space	12
 14080      00000000 
 14080      00000000 
 14081              		.section	.data.maxThrottleAdjust,"aw",%progbits
 14082              		.align	2
 14083              		.set	.LANCHOR112,. + 0
 14086              	maxThrottleAdjust:
 14087 0000 32000000 		.word	50
 14088              		.section	.data.rawChannelValue,"aw",%progbits
 14089              		.align	1
 14090              		.set	.LANCHOR2,. + 0
 14093              	rawChannelValue:
 14094 0000 DC05     		.short	1500
 14095 0002 DC05     		.short	1500
 14096 0004 DC05     		.short	1500
 14097 0006 DC05     		.short	1500
 14098 0008 DC05     		.short	1500
 14099 000a DC05     		.short	1500
 14100 000c DC05     		.short	1500
 14101 000e DC05     		.short	1500
 14102              		.section	.bss.baroRawAltitude,"aw",%nobits
 14103              		.align	2
 14104              		.set	.LANCHOR95,. + 0
 14107              	baroRawAltitude:
 14108 0000 00000000 		.space	4
 14109              		.section	.bss.baroGroundUpdateDone,"aw",%nobits
 14110              		.set	.LANCHOR98,. + 0
 14113              	baroGroundUpdateDone:
 14114 0000 00       		.space	1
 14115              		.section	.bss.batteryMonitorStartTime,"aw",%nobits
 14116              		.align	2
 14119              	batteryMonitorStartTime:
 14120 0000 00000000 		.space	4
 14121              		.section	.bss.headingGyroZero,"aw",%nobits
 14122              		.align	2
 14123              		.set	.LANCHOR70,. + 0
 14126              	headingGyroZero:
 14127 0000 00000000 		.space	4
 14128              		.section	.bss.calibrateESC,"aw",%nobits
 14129              		.set	.LANCHOR116,. + 0
 14132              	calibrateESC:
 14133 0000 00       		.space	1
 14134              		.section	.bss.hottState,"aw",%nobits
 14135              		.set	.LANCHOR153,. + 0
 14138              	hottState:
 14139 0000 00       		.space	1
 14140              		.section	.bss.spiMPU6000,"aw",%nobits
 14141              		.align	2
 14142              		.set	.LANCHOR19,. + 0
 14145              	spiMPU6000:
 14146 0000 00000000 		.space	12
 14146      00000000 
 14146      00000000 
 14147              		.section	.bss.fourthOrder,"aw",%nobits
 14148              		.align	2
 14149              		.set	.LANCHOR18,. + 0
 14152              	fourthOrder:
 14153 0000 00000000 		.space	128
 14153      00000000 
 14153      00000000 
 14153      00000000 
 14153      00000000 
 14154              		.section	.data.throttle,"aw",%progbits
 14155              		.align	2
 14156              		.set	.LANCHOR106,. + 0
 14159              	throttle:
 14160 0000 E8030000 		.word	1000
 14161              		.section	.bss.gyroRaw,"aw",%nobits
 14162              		.align	2
 14163              		.set	.LANCHOR30,. + 0
 14166              	gyroRaw:
 14167 0000 00000000 		.space	12
 14167      00000000 
 14167      00000000 
 14168              		.section	.bss.rawTemperature,"aw",%nobits
 14169              		.align	2
 14172              	rawTemperature:
 14173 0000 00000000 		.space	4
 14174              		.section	.data.batteryData,"aw",%progbits
 14175              		.align	2
 14176              		.set	.LANCHOR103,. + 0
 14179              	batteryData:
 14180 0000 20       		.byte	32
 14181 0001 00       		.byte	0
 14182 0002 E209     		.short	2530
 14183 0004 0000     		.short	0
 14184 0006 0000     		.short	0
 14185 0008 0000     		.short	0
 14186 000a FF       		.byte	-1
 14187 000b 00       		.space	1
 14188 000c 0000     		.short	0
 14189 000e 0000     		.short	0
 14190 0010 0000     		.short	0
 14191 0012 0000     		.short	0
 14192 0014 00000000 		.word	0
 14193              		.section	.bss.exInt,"aw",%nobits
 14194              		.align	2
 14195              		.set	.LANCHOR49,. + 0
 14198              	exInt:
 14199 0000 00000000 		.space	4
 14200              		.section	.bss.altitudeHoldState,"aw",%nobits
 14201              		.set	.LANCHOR5,. + 0
 14204              	altitudeHoldState:
 14205 0000 00       		.space	1
 14206              		.section	.bss.gyroZero,"aw",%nobits
 14207              		.align	2
 14208              		.set	.LANCHOR31,. + 0
 14211              	gyroZero:
 14212 0000 00000000 		.space	12
 14212      00000000 
 14212      00000000 
 14213              		.section	.bss.accelOneG,"aw",%nobits
 14214              		.align	2
 14215              		.set	.LANCHOR39,. + 0
 14218              	accelOneG:
 14219 0000 00000000 		.space	4
 14220              		.section	.bss.earthAccel,"aw",%nobits
 14221              		.align	2
 14224              	earthAccel:
 14225 0000 00000000 		.space	12
 14225      00000000 
 14225      00000000 
 14226              		.section	.bss.batteryAlarm,"aw",%nobits
 14227              		.set	.LANCHOR104,. + 0
 14230              	batteryAlarm:
 14231 0000 00       		.space	1
 14232              		.section	.bss.batteryWarning,"aw",%nobits
 14233              		.set	.LANCHOR105,. + 0
 14236              	batteryWarning:
 14237 0000 00       		.space	1
 14238              		.section	.bss.gyroLastMesuredTime,"aw",%nobits
 14239              		.align	2
 14240              		.set	.LANCHOR29,. + 0
 14243              	gyroLastMesuredTime:
 14244 0000 00000000 		.space	4
 14245              		.section	.bss.gyroSampleCount,"aw",%nobits
 14246              		.set	.LANCHOR33,. + 0
 14249              	gyroSampleCount:
 14250 0000 00       		.space	1
 14251              		.section	.bss.isGPSOff,"aw",%nobits
 14254              	isGPSOff:
 14255 0000 00       		.space	1
 14256              		.section	.bss.lastReceiverChannel,"aw",%nobits
 14257              		.align	2
 14258              		.set	.LANCHOR9,. + 0
 14261              	lastReceiverChannel:
 14262 0000 00000000 		.space	4
 14263              		.section	.bss.MS5611Prom,"aw",%nobits
 14264              		.align	1
 14265              		.set	.LANCHOR84,. + 0
 14268              	MS5611Prom:
 14269 0000 00000000 		.space	16
 14269      00000000 
 14269      00000000 
 14269      00000000 
 14270              		.section	.bss.hottV4Serial,"aw",%nobits
 14271              		.align	2
 14272              		.set	.LANCHOR143,. + 0
 14275              	hottV4Serial:
 14276 0000 00000000 		.space	4
 14277              		.section	.data.batteryAlarmCellVoltage,"aw",%progbits
 14278              		.align	1
 14279              		.set	.LANCHOR100,. + 0
 14282              	batteryAlarmCellVoltage:
 14283 0000 4D01     		.short	333
 14284              		.section	.bss.motorMaxCommand,"aw",%nobits
 14285              		.align	2
 14286              		.set	.LANCHOR122,. + 0
 14289              	motorMaxCommand:
 14290 0000 00000000 		.space	16
 14290      00000000 
 14290      00000000 
 14290      00000000 
 14291              		.section	.bss.receiverZero,"aw",%nobits
 14292              		.align	2
 14293              		.set	.LANCHOR11,. + 0
 14296              	receiverZero:
 14297 0000 00000000 		.space	12
 14297      00000000 
 14297      00000000 
 14298              		.section	.bss.motorAxisCommandYaw,"aw",%nobits
 14299              		.align	2
 14300              		.set	.LANCHOR109,. + 0
 14303              	motorAxisCommandYaw:
 14304 0000 00000000 		.space	4
 14305              		.section	.bss._ZL7minutes,"aw",%nobits
 14306              		.set	.LANCHOR151,. + 0
 14309              	_ZL7minutes:
 14310 0000 00       		.space	1
 14311              		.section	.bss.lowPriorityTenHZpreviousTime,"aw",%nobits
 14312              		.align	2
 14313              		.set	.LANCHOR160,. + 0
 14316              	lowPriorityTenHZpreviousTime:
 14317 0000 00000000 		.space	4
 14318              		.section	.data.batteryMonitorThrottleTarget,"aw",%progbits
 14319              		.align	2
 14320              		.set	.LANCHOR134,. + 0
 14323              	batteryMonitorThrottleTarget:
 14324 0000 AA050000 		.word	1450
 14325              		.section	.data.SpeakHoTT,"aw",%progbits
 14326              		.set	.LANCHOR136,. + 0
 14329              	SpeakHoTT:
 14330 0000 15       		.byte	21
 14331              		.section	.bss.hottTime,"aw",%nobits
 14332              		.align	2
 14333              		.set	.LANCHOR154,. + 0
 14336              	hottTime:
 14337 0000 00000000 		.space	4
 14338              		.section	.rodata.Serial,"a",%progbits
 14339              		.align	2
 14342              	Serial:
 14343 0000 00000000 		.word	SerialUSB
 14344              		.section	.bss.relativeHeading,"aw",%nobits
 14345              		.align	2
 14346              		.set	.LANCHOR126,. + 0
 14349              	relativeHeading:
 14350 0000 00000000 		.space	4
 14351              		.section	.bss.gyroAngle,"aw",%nobits
 14352              		.align	2
 14353              		.set	.LANCHOR43,. + 0
 14356              	gyroAngle:
 14357 0000 00000000 		.space	8
 14357      00000000 
 14358              		.section	.bss.isAHOn,"aw",%nobits
 14359              		.set	.LANCHOR145,. + 0
 14362              	isAHOn:
 14363 0000 00       		.space	1
 14364              		.section	.bss.localHeading,"aw",%nobits
 14365              		.align	2
 14366              		.set	.LANCHOR71,. + 0
 14369              	localHeading:
 14370 0000 00000000 		.space	4
 14371              		.section	.bss.receiverOffset,"aw",%nobits
 14372              		.align	2
 14373              		.set	.LANCHOR13,. + 0
 14376              	receiverOffset:
 14377 0000 00000000 		.space	32
 14377      00000000 
 14377      00000000 
 14377      00000000 
 14377      00000000 
 14378              		.section	.bss.baroStartTime,"aw",%nobits
 14379              		.align	2
 14380              		.set	.LANCHOR99,. + 0
 14383              	baroStartTime:
 14384 0000 00000000 		.space	4
 14385              		.section	.bss._ZZL15hottVoiceOutputvE9oldStatus,"aw",%nobits
 14386              		.set	.LANCHOR147,. + 0
 14389              	_ZZL15hottVoiceOutputvE9oldStatus:
 14390 0000 00       		.space	1
 14391              		.section	.bss.kinematicsType,"aw",%nobits
 14394              	kinematicsType:
 14395 0000 00       		.space	1
 14396              		.section	.bss.PID,"aw",%nobits
 14397              		.align	2
 14398              		.set	.LANCHOR17,. + 0
 14401              	PID:
 14402 0000 00000000 		.space	280
 14402      00000000 
 14402      00000000 
 14402      00000000 
 14402      00000000 
 14403              		.section	.bss.meterPerSecSec,"aw",%nobits
 14404              		.align	2
 14405              		.set	.LANCHOR34,. + 0
 14408              	meterPerSecSec:
 14409 0000 00000000 		.space	12
 14409      00000000 
 14409      00000000 
 14410              		.section	.bss.MPU6000,"aw",%nobits
 14411              		.align	1
 14412              		.set	.LANCHOR22,. + 0
 14415              	MPU6000:
 14416 0000 00000000 		.space	14
 14416      00000000 
 14416      00000000 
 14416      0000
 14417              		.section	.data.filter1,"aw",%progbits
 14418              		.align	2
 14419              		.set	.LANCHOR72,. + 0
 14422              	filter1:
 14423 0000 317D7F3F 		.word	1065319729
 14424              		.section	.bss.receiverSlope,"aw",%nobits
 14425              		.align	2
 14426              		.set	.LANCHOR12,. + 0
 14429              	receiverSlope:
 14430 0000 00000000 		.space	32
 14430      00000000 
 14430      00000000 
 14430      00000000 
 14430      00000000 
 14431              		.section	.bss.flightMode,"aw",%nobits
 14432              		.set	.LANCHOR114,. + 0
 14435              	flightMode:
 14436 0000 00       		.space	1
 14437              		.section	.bss.vehicleState,"aw",%nobits
 14438              		.align	2
 14439              		.set	.LANCHOR21,. + 0
 14442              	vehicleState:
 14443 0000 00000000 		.space	4
 14444              		.section	.bss.motorAxisCommandRoll,"aw",%nobits
 14445              		.align	2
 14446              		.set	.LANCHOR108,. + 0
 14449              	motorAxisCommandRoll:
 14450 0000 00000000 		.space	4
 14451              		.section	.data.altitudeHoldThrottle,"aw",%progbits
 14452              		.align	2
 14453              		.set	.LANCHOR7,. + 0
 14456              	altitudeHoldThrottle:
 14457 0000 E8030000 		.word	1000
 14458              		.section	.bss.safetyCheck,"aw",%nobits
 14459              		.set	.LANCHOR119,. + 0
 14462              	safetyCheck:
 14463 0000 00       		.space	1
 14464              		.section	.data.batteryMonitorGoingDownTime,"aw",%progbits
 14465              		.align	2
 14466              		.set	.LANCHOR135,. + 0
 14469              	batteryMonitorGoingDownTime:
 14470 0000 60EA0000 		.word	60000
 14471              		.section	.bss.previousTime,"aw",%nobits
 14472              		.align	2
 14473              		.set	.LANCHOR155,. + 0
 14476              	previousTime:
 14477 0000 00000000 		.space	4
 14478              		.section	.data.G_Dt,"aw",%progbits
 14479              		.align	2
 14480              		.set	.LANCHOR57,. + 0
 14483              	G_Dt:
 14484 0000 6F12033B 		.word	990057071
 14485              		.section	.bss.hundredHZpreviousTime,"aw",%nobits
 14486              		.align	2
 14487              		.set	.LANCHOR157,. + 0
 14490              	hundredHZpreviousTime:
 14491 0000 00000000 		.space	4
 14492              		.section	.bss.maxLimit,"aw",%nobits
 14495              	maxLimit:
 14496 0000 00       		.space	1
 14497              		.section	.bss.gyroScaleFactor,"aw",%nobits
 14498              		.align	2
 14499              		.set	.LANCHOR26,. + 0
 14502              	gyroScaleFactor:
 14503 0000 00000000 		.space	4
 14504              		.section	.bss.rawPressureSum,"aw",%nobits
 14505              		.align	2
 14506              		.set	.LANCHOR90,. + 0
 14509              	rawPressureSum:
 14510 0000 00000000 		.space	4
 14511              		.section	.bss.buzzerState,"aw",%nobits
 14514              	buzzerState:
 14515 0000 00       		.space	1
 14516              		.section	.bss.gyroSample,"aw",%nobits
 14517              		.align	2
 14518              		.set	.LANCHOR32,. + 0
 14521              	gyroSample:
 14522 0000 00000000 		.space	12
 14522      00000000 
 14522      00000000 
 14523              		.section	.bss._ZL19_stm32_motor_number,"aw",%nobits
 14524              		.align	2
 14525              		.set	.LANCHOR64,. + 0
 14528              	_ZL19_stm32_motor_number:
 14529 0000 00000000 		.space	4
 14530              		.section	.bss.channelCal,"aw",%nobits
 14531              		.align	2
 14532              		.set	.LANCHOR140,. + 0
 14535              	channelCal:
 14536 0000 00000000 		.space	4
 14537              		.section	.data._ZL11maxAltitude,"aw",%progbits
 14538              		.align	2
 14539              		.set	.LANCHOR82,. + 0
 14542              	_ZL11maxAltitude:
 14543 0000 F4010000 		.word	500
 14544              		.section	.rodata._ZL18ReceiverChannelMap,"a",%progbits
 14545              		.set	.LANCHOR59,. + 0
 14548              	_ZL18ReceiverChannelMap:
 14549 0000 01       		.byte	1
 14550 0001 02       		.byte	2
 14551 0002 03       		.byte	3
 14552 0003 00       		.byte	0
 14553 0004 04       		.byte	4
 14554 0005 05       		.byte	5
 14555 0006 06       		.byte	6
 14556 0007 07       		.byte	7
 14557              		.section	.bss.runTimeAccelBias,"aw",%nobits
 14558              		.align	2
 14559              		.set	.LANCHOR36,. + 0
 14562              	runTimeAccelBias:
 14563 0000 00000000 		.space	12
 14563      00000000 
 14563      00000000 
 14564              		.text
 14565              	.Letext0:
 14566              		.file 37 "c:\\program files (x86)\\codesourcery\\sourcery_codebench_lite_for_arm_eabi\\bin\\../lib
 14567              		.file 38 "../Libmaple/libmaple/libmaple/libmaple_types.h"
 14568              		.file 39 "../Libmaple/libmaple/libmaple/rccF2.h"
 14569              		.file 40 "../Libmaple/libmaple/libmaple/gpioF2.h"
 14570              		.file 41 "../Libmaple/libmaple/libmaple/adc.h"
 14571              		.file 42 "../Libmaple/libmaple/wirish/wirish_types.h"
 14572              		.file 43 "../Libmaple/libmaple/wirish/io.h"
 14573              		.file 44 "../Libmaple/libmaple/libmaple/spi.h"
 14574              		.file 45 "../Libmaple/libmaple/wirish/comm/HardwareSPI.h"
 14575              		.file 46 "../Libmaple/libmaple/wirish/wirish.h"
 14576              		.file 47 "../AeroQuad32/MapleCompatibility/WProgram.h"
 14577              		.file 48 "../AeroQuad32/MapleCompatibility/flash_stm32.h"
 14578              		.file 49 "../AeroQuad32/MapleCompatibility/EEPROM.h"
 14579              		.file 50 "../Libmaple/libmaple/libraries/Wire/Wire.h"
 14580              		.file 51 "../Libraries/AQ_Gps/GpsDataType.h"
 14581              		.file 52 "C:/MinGW/msys/1.0/home/ang/AeroQuad32/../AeroQuad/AeroQuad.h"
 14582              		.file 53 "../Libmaple/libmaple/wirish/Print.h"
 14583              		.file 54 "../Libraries/AQ_BatteryMonitor/BatteryMonitorTypes.h"
 14584              		.file 55 "../Libmaple/libmaple/wirish/boards.h"
 14585              		.file 56 "../Libmaple/libmaple/wirish/comm/HardwareSerial.h"
 14586              		.file 57 "../Libraries/AQ_Defines/SensorsStatus.h"
 14587              		.file 58 "../Libraries/AQ_Gyroscope/Gyroscope.h"
 14588              		.file 59 "../Libraries/AQ_Accelerometer/Accelerometer.h"
 14589              		.file 60 "../Libraries/AQ_FlightControlProcessor/FlightControlVariable.h"
DEFINED SYMBOLS
                            *ABS*:00000000 AeroQuadMain.cpp
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:20     .text.timer_set_compare:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:24     .text.timer_set_compare:00000000 timer_set_compare
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:49     .text._ZL6millisv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:53     .text._ZL6millisv:00000000 _ZL6millisv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:74     .text._ZL6millisv:00000008 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:79     .text._ZL6microsv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:83     .text._ZL6microsv:00000000 _ZL6microsv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:136    .text._ZL6microsv:0000002c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:141    .text._Z9FrqChangev:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:146    .text._Z9FrqChangev:00000000 _Z9FrqChangev
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:238    .text._Z9FrqChangev:00000060 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:245    .text._ZL16hottV4SendBinaryPh:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:249    .text._ZL16hottV4SendBinaryPh:00000000 _ZL16hottV4SendBinaryPh
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:301    .text._ZL16hottV4SendBinaryPh:00000024 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:307    .text._ZL20hottv4UpdateAltVariov:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:311    .text._ZL20hottv4UpdateAltVariov:00000000 _ZL20hottv4UpdateAltVariov
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:362    .text._ZL20hottv4UpdateAltVariov:0000003c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:370    .text.startup._Z7premainv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:375    .text.startup._Z7premainv:00000000 _Z7premainv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:390    .init_array:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:393    .text._Z23initializeReceiverParami:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:398    .text._Z23initializeReceiverParami:00000000 _Z23initializeReceiverParami
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:544    .text._Z23initializeReceiverParami:00000094 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:555    .text._Z17getReceiverSIDatah:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:560    .text._Z17getReceiverSIDatah:00000000 _Z17getReceiverSIDatah
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:587    .text._Z17getReceiverSIDatah:00000024 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:594    .text._Z9updatePIDffP7PIDdata:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:599    .text._Z9updatePIDffP7PIDdata:00000000 _Z9updatePIDffP7PIDdata
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:696    .text._Z9updatePIDffP7PIDdata:000000ac $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:704    .text._Z17zeroIntegralErrorv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:709    .text._Z17zeroIntegralErrorv:00000000 _Z17zeroIntegralErrorv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:758    .text._Z17zeroIntegralErrorv:00000034 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:764    .text._Z18computeFourthOrderfP15fourthOrderData:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:769    .text._Z18computeFourthOrderfP15fourthOrderData:00000000 _Z18computeFourthOrderfP15fourthOrderData
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:834    .text._Z18computeFourthOrderfP15fourthOrderData:00000088 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:845    .text._Z16setupFourthOrderv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:850    .text._Z16setupFourthOrderv:00000000 _Z16setupFourthOrderv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:915    .text._Z16setupFourthOrderv:00000038 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:921    .text._ZN14HardwareSPIExt5SetCSEi:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:926    .text._ZN14HardwareSPIExt5SetCSEi:00000000 _ZN14HardwareSPIExt5SetCSEi
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:943    .text._ZN14HardwareSPIExtC2Ej:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:948    .text._ZN14HardwareSPIExtC2Ej:00000000 _ZN14HardwareSPIExtC2Ej
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:982    .text._ZN14HardwareSPIExt5beginE12SPIFrequencyjj:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:987    .text._ZN14HardwareSPIExt5beginE12SPIFrequencyjj:00000000 _ZN14HardwareSPIExt5beginE12SPIFrequencyjj
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1034   .text._ZN14HardwareSPIExt4ReadEiPhi:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1039   .text._ZN14HardwareSPIExt4ReadEiPhi:00000000 _ZN14HardwareSPIExt4ReadEiPhi
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1104   .text._ZN14HardwareSPIExt4ReadEi:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1109   .text._ZN14HardwareSPIExt4ReadEi:00000000 _ZN14HardwareSPIExt4ReadEi
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1137   .text._ZN14HardwareSPIExt5WriteEiPhi:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1142   .text._ZN14HardwareSPIExt5WriteEiPhi:00000000 _ZN14HardwareSPIExt5WriteEiPhi
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1206   .text._ZN14HardwareSPIExt5WriteEih:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1211   .text._ZN14HardwareSPIExt5WriteEih:00000000 _ZN14HardwareSPIExt5WriteEih
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1242   .text._Z19MPU6000_SpiLowSpeedv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1247   .text._Z19MPU6000_SpiLowSpeedv:00000000 _Z19MPU6000_SpiLowSpeedv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1270   .text._Z19MPU6000_SpiLowSpeedv:00000010 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1275   .text._Z20MPU6000_SpiHighSpeedv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1280   .text._Z20MPU6000_SpiHighSpeedv:00000000 _Z20MPU6000_SpiHighSpeedv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1306   .text._Z20MPU6000_SpiHighSpeedv:00000018 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1311   .text._Z16MPU6000_WriteRegih:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1316   .text._Z16MPU6000_WriteRegih:00000000 _Z16MPU6000_WriteRegih
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1347   .text._Z16MPU6000_WriteRegih:00000018 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1352   .text._Z15MPU6000_ReadRegi:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1357   .text._Z15MPU6000_ReadRegi:00000000 _Z15MPU6000_ReadRegi
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1390   .text._Z15MPU6000_ReadRegi:00000018 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1395   .text._Z24initializeMPU6000Sensorsv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1400   .text._Z24initializeMPU6000Sensorsv:00000000 _Z24initializeMPU6000Sensorsv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1504   .text._Z24initializeMPU6000Sensorsv:00000098 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1515   .text._Z15MPU6000SwapDataPhi:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1520   .text._Z15MPU6000SwapDataPhi:00000000 _Z15MPU6000SwapDataPhi
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1564   .text._Z18readMPU6000Sensorsv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1569   .text._Z18readMPU6000Sensorsv:00000000 _Z18readMPU6000Sensorsv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1597   .text._Z18readMPU6000Sensorsv:0000001c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1603   .text._Z16readMPU6000Accelv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1608   .text._Z16readMPU6000Accelv:00000000 _Z16readMPU6000Accelv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1647   .text._Z16readMPU6000Accelv:00000020 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1653   .text._Z15readMPU6000Gyrov:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1658   .text._Z15readMPU6000Gyrov:00000000 _Z15readMPU6000Gyrov
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1696   .text._Z15readMPU6000Gyrov:00000020 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1702   .text._Z14initializeGyrov:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1707   .text._Z14initializeGyrov:00000000 _Z14initializeGyrov
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1729   .text._Z14initializeGyrov:0000000c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1736   .text._Z17gyroUpdateHeadingv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1741   .text._Z17gyroUpdateHeadingv:00000000 _Z17gyroUpdateHeadingv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1790   .text._Z17gyroUpdateHeadingv:00000050 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1800   .text._Z11measureGyrov:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1805   .text._Z11measureGyrov:00000000 _Z11measureGyrov
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1889   .text._Z11measureGyrov:00000074 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1899   .text._Z14measureGyroSumv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1904   .text._Z14measureGyroSumv:00000000 _Z14measureGyroSumv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1950   .text._Z14measureGyroSumv:0000003c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1958   .text._Z16evaluateGyroRatev:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:1963   .text._Z16evaluateGyroRatev:00000000 _Z16evaluateGyroRatev
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2059   .text._Z16evaluateGyroRatev:00000080 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2069   .text._Z13calibrateGyrov:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2074   .text._Z13calibrateGyrov:00000000 _Z13calibrateGyrov
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2171   .text._Z13calibrateGyrov:0000004c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2177   .text._Z15initializeAccelv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2182   .text._Z15initializeAccelv:00000000 _Z15initializeAccelv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2197   .text._Z12measureAccelv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2202   .text._Z12measureAccelv:00000000 _Z12measureAccelv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2259   .text._Z12measureAccelv:00000064 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2267   .text._Z15measureAccelSumv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2272   .text._Z15measureAccelSumv:00000000 _Z15measureAccelSumv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2316   .text._Z15measureAccelSumv:00000038 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2323   .text._Z20evaluateMetersPerSecv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2328   .text._Z20evaluateMetersPerSecv:00000000 _Z20evaluateMetersPerSecv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2388   .text._Z20evaluateMetersPerSecv:00000048 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2397   .text._Z16computeAccelBiasv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2402   .text._Z16computeAccelBiasv:00000000 _Z16computeAccelBiasv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2506   .text._Z16computeAccelBiasv:000000a0 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2519   .text._Z24HardCodedAxisCalibrationv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2524   .text._Z24HardCodedAxisCalibrationv:00000000 _Z24HardCodedAxisCalibrationv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2581   .text._Z24HardCodedAxisCalibrationv:00000064 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2588   .text._Z12initPlatformv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2593   .text._Z12initPlatformv:00000000 _Z12initPlatformv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2707   .text._Z12initPlatformv:000000b0 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2716   .text._Z11SignalAlivei:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2721   .text._Z11SignalAlivei:00000000 _Z11SignalAlivei
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2742   .text._Z22measureCriticalSensorsv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2747   .text._Z22measureCriticalSensorsv:00000000 _Z22measureCriticalSensorsv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2784   .text._Z22measureCriticalSensorsv:00000028 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2791   .text._Z29initializeBaseKinematicsParamv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2796   .text._Z29initializeBaseKinematicsParamv:00000000 _Z29initializeBaseKinematicsParamv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2832   .text._Z29initializeBaseKinematicsParamv:00000014 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2838   .text._Z27kinematicsGetDegreesHeadingh:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2843   .text._Z27kinematicsGetDegreesHeadingh:00000000 _Z27kinematicsGetDegreesHeadingh
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2875   .text._Z27kinematicsGetDegreesHeadingh:0000002c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2884   .text._Z9argUpdatefffffff:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:2889   .text._Z9argUpdatefffffff:00000000 _Z9argUpdatefffffff
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3205   .text._Z9argUpdatefffffff:0000024c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3222   .text._Z11eulerAnglesv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3227   .text._Z11eulerAnglesv:00000000 _Z11eulerAnglesv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3332   .text._Z11eulerAnglesv:000000f8 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3341   .text._Z20initializeKinematicsv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3346   .text._Z20initializeKinematicsv:00000000 _Z20initializeKinematicsv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3416   .text._Z20initializeKinematicsv:00000044 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3434   .text._Z19calculateKinematicsfffffff:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3439   .text._Z19calculateKinematicsfffffff:00000000 _Z19calculateKinematicsfffffff
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3473   .text._Z19calculateKinematicsfffffff:00000028 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3478   .text._Z13getGyroUnbiash:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3483   .text._Z13getGyroUnbiash:00000000 _Z13getGyroUnbiash
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3501   .text._Z13getGyroUnbiash:0000000c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3506   .text._Z19calibrateKinematicsv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3511   .text._Z19calibrateKinematicsv:00000000 _Z19calibrateKinematicsv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3524   .text._Z7FrqInitiP9timer_devi:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3529   .text._Z7FrqInitiP9timer_devi:00000000 _Z7FrqInitiP9timer_devi
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3651   .text._Z7FrqInitiP9timer_devi:00000094 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3657   .text._Z18InitFrqMeasurementv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3662   .text._Z18InitFrqMeasurementv:00000000 _Z18InitFrqMeasurementv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3715   .text._Z18InitFrqMeasurementv:00000040 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3723   .text._Z18initializeReceiveri:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3728   .text._Z18initializeReceiveri:00000000 _Z18initializeReceiveri
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3751   .text._Z18getRawChannelValueh:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3756   .text._Z18getRawChannelValueh:00000000 _Z18getRawChannelValueh
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3777   .text._Z18getRawChannelValueh:0000000c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3783   .text._Z12readReceiverv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3788   .text._Z12readReceiverv:00000000 _Z12readReceiverv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3909   .text._Z12readReceiverv:000000c4 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3922   .text._Z15setChannelValuehi:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3927   .text._Z15setChannelValuehi:00000000 _Z15setChannelValuehi
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3941   .text._Z14_initMotorInfoii:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3946   .text._Z14_initMotorInfoii:00000000 _Z14_initMotorInfoii
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3982   .text._Z14_initMotorInfoii:0000001c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3988   .text._Z11writeMotorsv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:3993   .text._Z11writeMotorsv:00000000 _Z11writeMotorsv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4037   .text._Z11writeMotorsv:0000002c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4044   .text._Z16commandAllMotorsi:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4049   .text._Z16commandAllMotorsi:00000000 _Z16commandAllMotorsi
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4093   .text._Z16commandAllMotorsi:00000028 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4099   .text._Z16initializeMotors9NB_Motors:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4104   .text._Z16initializeMotors9NB_Motors:00000000 _Z16initializeMotors9NB_Motors
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4257   .text._Z16initializeMotors9NB_Motors:00000080 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4266   .text._Z11pulseMotorsh:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4271   .text._Z11pulseMotorsh:00000000 _Z11pulseMotorsh
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4322   .text._Z8getHdgXYh:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4327   .text._Z8getHdgXYh:00000000 _Z8getHdgXYh
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4354   .text._Z8getHdgXYh:00000010 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4360   .text._Z22getMagnetometerRawDatah:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4365   .text._Z22getMagnetometerRawDatah:00000000 _Z22getMagnetometerRawDatah
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4385   .text._Z22getMagnetometerRawDatah:00000014 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4390   .text._Z19getMagnetometerDatah:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4395   .text._Z19getMagnetometerDatah:00000000 _Z19getMagnetometerDatah
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4415   .text._Z19getMagnetometerDatah:00000014 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4420   .text._Z18getAbsoluteHeadingv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4425   .text._Z18getAbsoluteHeadingv:00000000 _Z18getAbsoluteHeadingv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4475   .text._Z18getAbsoluteHeadingv:00000044 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4482   .text._Z23initializeHeadingFusionv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4487   .text._Z23initializeHeadingFusionv:00000000 _Z23initializeHeadingFusionv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4515   .text._Z23initializeHeadingFusionv:00000014 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4524   .text._Z16calculateHeadingv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4529   .text._Z16calculateHeadingv:00000000 _Z16calculateHeadingv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4666   .text._Z16calculateHeadingv:00000108 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4682   .text._Z15readSpecificMagPf:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4687   .text._Z15readSpecificMagPf:00000000 _Z15readSpecificMagPf
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4725   .text._Z19measureMagnetometerff:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4730   .text._Z19measureMagnetometerff:00000000 _Z19measureMagnetometerff
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4912   .text._Z19measureMagnetometerff:0000012c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4926   .text._Z22initializeMagnetometerv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4931   .text._Z22initializeMagnetometerv:00000000 _Z22initializeMagnetometerv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4984   .text._Z22initializeMagnetometerv:00000048 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4989   .text._Z15getBaroAltitudev:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:4994   .text._Z15getBaroAltitudev:00000000 _Z15getBaroAltitudev
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5014   .text._Z15getBaroAltitudev:00000018 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5020   .text._ZL15hottv4UpdateAltv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5024   .text._ZL15hottv4UpdateAltv:00000000 _ZL15hottv4UpdateAltv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5069   .text._ZL15hottv4UpdateAltv:00000030 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5075   .text._Z10MS5611crc4Pt:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5080   .text._Z10MS5611crc4Pt:00000000 _Z10MS5611crc4Pt
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5168   .text._Z14MS5611readPROMi:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5173   .text._Z14MS5611readPROMi:00000000 _Z14MS5611readPROMi
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5247   .text._Z14MS5611readPROMi:0000004c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5254   .text._Z11MS5611reseti:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5259   .text._Z11MS5611reseti:00000000 _Z11MS5611reseti
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5277   .text._Z20MS5611readConversioni:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5282   .text._Z20MS5611readConversioni:00000000 _Z20MS5611readConversioni
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5336   .text._Z20MS5611readConversioni:0000003c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5341   .text._Z21requestRawTemperaturev:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5346   .text._Z21requestRawTemperaturev:00000000 _Z21requestRawTemperaturev
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5363   .text._Z18readRawTemperaturev:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5368   .text._Z18readRawTemperaturev:00000000 _Z18readRawTemperaturev
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5443   .text._Z18readRawTemperaturev:0000006c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5452   .text._Z15readTemperaturev:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5457   .text._Z15readTemperaturev:00000000 _Z15readTemperaturev
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5501   .text._Z15readTemperaturev:0000004c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5508   .text._Z18requestRawPressurev:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5513   .text._Z18requestRawPressurev:00000000 _Z18requestRawPressurev
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5530   .text._Z15readRawPressurev:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5535   .text._Z15readRawPressurev:00000000 _Z15readRawPressurev
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5584   .text._Z15readRawPressurev:00000054 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5592   .text._Z14measureBaroSumv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5597   .text._Z14measureBaroSumv:00000000 _Z14measureBaroSumv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5673   .text._Z14measureBaroSumv:0000005c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5682   .text._Z20evaluateBaroAltitudev:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5687   .text._Z20evaluateBaroAltitudev:00000000 _Z20evaluateBaroAltitudev
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5799   .text._Z20evaluateBaroAltitudev:000000b0 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5820   .text._Z11measureBarov:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5825   .text._Z11measureBarov:00000000 _Z11measureBarov
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5846   .text._Z17measureGroundBarov:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5851   .text._Z17measureGroundBarov:00000000 _Z17measureGroundBarov
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5903   .text._Z17measureGroundBarov:00000038 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5910   .text._Z14initializeBarov:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5915   .text._Z14initializeBarov:00000000 _Z14initializeBarov
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:5998   .text._Z14initializeBarov:00000070 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6011   .text._Z30setBatteryCellVoltageThresholdf:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6016   .text._Z30setBatteryCellVoltageThresholdf:00000000 _Z30setBatteryCellVoltageThresholdf
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6058   .text._Z30setBatteryCellVoltageThresholdf:00000034 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6066   .text._Z12resetBatteryh:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6071   .text._Z12resetBatteryh:00000000 _Z12resetBatteryh
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6110   .text._Z12resetBatteryh:00000028 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6116   .text._Z19batteryGetCellCounth:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6121   .text._Z19batteryGetCellCounth:00000000 _Z19batteryGetCellCounth
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6155   .text._Z19batteryGetCellCounth:00000024 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6160   .text._Z14batteryIsAlarmh:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6165   .text._Z14batteryIsAlarmh:00000000 _Z14batteryIsAlarmh
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6198   .text._Z14batteryIsAlarmh:00000024 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6204   .text._Z16batteryIsWarningh:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6209   .text._Z16batteryIsWarningh:00000000 _Z16batteryIsWarningh
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6242   .text._Z16batteryIsWarningh:00000024 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6248   .text._Z21measureBatteryVoltaget:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6253   .text._Z21measureBatteryVoltaget:00000000 _Z21measureBatteryVoltaget
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6391   .text._Z21measureBatteryVoltaget:000000c0 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6399   .text._Z24initializeBatteryMonitorhf:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6404   .text._Z24initializeBatteryMonitorhf:00000000 _Z24initializeBatteryMonitorhf
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6456   .text._Z24initializeBatteryMonitorhf:00000028 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6462   .text._Z17applyMotorCommandv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6467   .text._Z17applyMotorCommandv:00000000 _Z17applyMotorCommandv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6525   .text._Z17applyMotorCommandv:00000038 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6534   .text._Z19processAltitudeHoldv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6539   .text._Z19processAltitudeHoldv:00000000 _Z19processAltitudeHoldv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6651   .text._Z19processAltitudeHoldv:000000a4 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6667   .text._Z20calculateFlightErrorv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6672   .text._Z20calculateFlightErrorv:00000000 _Z20calculateFlightErrorv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6801   .text._Z20calculateFlightErrorv:00000100 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6820   .text._Z19processCalibrateESCv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6825   .text._Z19processCalibrateESCv:00000000 _Z19processCalibrateESCv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6927   .text._Z19processCalibrateESCv:00000070 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6937   .text._Z25processThrottleCorrectionv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6942   .text._Z25processThrottleCorrectionv:00000000 _Z25processThrottleCorrectionv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6974   .text._Z25processThrottleCorrectionv:00000020 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6979   .text._Z20processHardManueversv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:6984   .text._Z20processHardManueversv:00000000 _Z20processHardManueversv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7038   .text._Z20processHardManueversv:00000040 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7048   .text._Z20processMinMaxCommandv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7053   .text._Z20processMinMaxCommandv:00000000 _Z20processMinMaxCommandv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7141   .text._Z20processMinMaxCommandv:00000058 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7149   .text._Z14processHeadingv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7154   .text._Z14processHeadingv:00000000 _Z14processHeadingv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7369   .text._Z14processHeadingv:00000174 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7397   .text._Z20processFlightControlv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7402   .text._Z20processFlightControlv:00000000 _Z20processFlightControlv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7546   .text._Z20processFlightControlv:000000ac $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7561   .text._Z12nvrReadFloati:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7566   .text._Z12nvrReadFloati:00000000 _Z12nvrReadFloati
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7608   .text._Z12nvrReadFloati:00000024 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7613   .text._Z13nvrWriteFloatfi:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7618   .text._Z13nvrWriteFloatfi:00000000 _Z13nvrWriteFloatfi
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7661   .text._Z13nvrWriteFloatfi:00000020 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7668   .text._Z11nvrReadLongi:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7673   .text._Z11nvrReadLongi:00000000 _Z11nvrReadLongi
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7713   .text._Z11nvrReadLongi:00000024 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7718   .text._Z12nvrWriteLongli:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7723   .text._Z12nvrWriteLongli:00000000 _Z12nvrWriteLongli
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7765   .text._Z12nvrWriteLongli:00000020 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7772   .text._Z10nvrReadPIDhj:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7777   .text._Z10nvrReadPIDhj:00000000 _Z10nvrReadPIDhj
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7833   .text._Z10nvrReadPIDhj:00000030 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7838   .text._Z11nvrWritePIDhj:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7843   .text._Z11nvrWritePIDhj:00000000 _Z11nvrWritePIDhj
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7888   .text._Z11nvrWritePIDhj:00000028 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7894   .text._Z16initializeEEPROMv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:7899   .text._Z16initializeEEPROMv:00000000 _Z16initializeEEPROMv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:8172   .text._Z16initializeEEPROMv:00000148 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:8213   .text._Z10readEEPROMv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:8218   .text._Z10readEEPROMv:00000000 _Z10readEEPROMv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:8449   .text._Z10readEEPROMv:000001d0 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:8471   .text._Z11writeEEPROMv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:8476   .text._Z11writeEEPROMv:00000000 _Z11writeEEPROMv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:8745   .text._Z11writeEEPROMv:00000220 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:8772   .text._Z25initSensorsZeroFromEEPROMv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:8777   .text._Z25initSensorsZeroFromEEPROMv:00000000 _Z25initSensorsZeroFromEEPROMv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:8855   .text._Z25initSensorsZeroFromEEPROMv:00000090 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:8863   .text._Z24storeSensorsZeroToEEPROMv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:8868   .text._Z24storeSensorsZeroToEEPROMv:00000000 _Z24storeSensorsZeroToEEPROMv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:8942   .text._Z24storeSensorsZeroToEEPROMv:00000094 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:8950   .text._Z17readPilotCommandsv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:8955   .text._Z17readPilotCommandsv:00000000 _Z17readPilotCommandsv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9193   .text._Z17readPilotCommandsv:00000128 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9211   .text._Z22initReceiverFromEEPROMv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9216   .text._Z22initReceiverFromEEPROMv:00000000 _Z22initReceiverFromEEPROMv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9270   .text._Z22initReceiverFromEEPROMv:00000044 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9278   .text._Z16processLedStatusv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9283   .text._Z16processLedStatusv:00000000 _Z16processLedStatusv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9348   .text._Z16processLedStatusv:0000004c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9357   .text._Z17initCommunicationv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9362   .text._Z17initCommunicationv:00000000 _Z17initCommunicationv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9376   .text._Z15readValueSerialPch:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9381   .text._Z15readValueSerialPch:00000000 _Z15readValueSerialPch
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9466   .text._Z15readValueSerialPch:0000004c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9471   .text._Z15readFloatSerialv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9476   .text._Z15readFloatSerialv:00000000 _Z15readFloatSerialv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9514   .text._Z13readSerialPIDh:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9519   .text._Z13readSerialPIDh:00000000 _Z13readSerialPIDh
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9564   .text._Z13readSerialPIDh:00000024 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9569   .text._Z24validateCalibrateCommandh:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9574   .text._Z24validateCalibrateCommandh:00000000 _Z24validateCalibrateCommandh
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9619   .text._Z24validateCalibrateCommandh:00000038 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9627   .text._Z17readIntegerSerialv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9632   .text._Z17readIntegerSerialv:00000000 _Z17readIntegerSerialv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9669   .text._Z17readSerialCommandv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9674   .text._Z17readSerialCommandv:00000000 _Z17readSerialCommandv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9706   .text._Z17readSerialCommandv:00000024 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9751   .text._Z17readSerialCommandv:00000078 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:9996   .text._Z17readSerialCommandv:0000021c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10018  .text._Z17readSerialCommandv:0000026c $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10229  .text._Z17readSerialCommandv:00000380 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10244  .text._Z5commav:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10249  .text._Z5commav:00000000 _Z5commav
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10265  .text._Z5commav:00000008 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10270  .text._Z15PrintValueCommal:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10275  .text._Z15PrintValueCommal:00000000 _Z15PrintValueCommal
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10302  .text._Z15PrintValueCommal:00000014 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10307  .text._Z15PrintValueCommah:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10312  .text._Z15PrintValueCommah:00000000 _Z15PrintValueCommah
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10338  .text._Z15PrintValueCommah:00000014 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10343  .text._Z15PrintValueCommam:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10348  .text._Z15PrintValueCommam:00000000 _Z15PrintValueCommam
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10375  .text._Z15PrintValueCommam:00000014 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10380  .text._Z15PrintValueCommai:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10385  .text._Z15PrintValueCommai:00000000 _Z15PrintValueCommai
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10412  .text._Z15PrintValueCommai:00000014 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10417  .text._Z15PrintValueCommac:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10422  .text._Z15PrintValueCommac:00000000 _Z15PrintValueCommac
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10447  .text._Z15PrintValueCommac:00000014 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10452  .text._Z15PrintValueCommad:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10457  .text._Z15PrintValueCommad:00000000 _Z15PrintValueCommad
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10488  .text._Z15PrintValueCommad:0000001c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10493  .text._Z15PrintValueCommaf:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10498  .text._Z15PrintValueCommaf:00000000 _Z15PrintValueCommaf
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10529  .text._Z15PrintValueCommaf:00000020 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10534  .text._Z8PrintPIDh:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10539  .text._Z8PrintPIDh:00000000 _Z8PrintPIDh
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10572  .text._Z8PrintPIDh:00000020 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10577  .text._Z17printVehicleStatePKcmS0_:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10582  .text._Z17printVehicleStatePKcmS0_:00000000 _Z17printVehicleStatePKcmS0_
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10634  .text._Z17printVehicleStatePKcmS0_:00000034 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10642  .text._Z18reportVehicleStatev:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10647  .text._Z18reportVehicleStatev:00000000 _Z18reportVehicleStatev
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10762  .text._Z18reportVehicleStatev:000000d0 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10787  .text._Z19sendSerialTelemetryv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10792  .text._Z19sendSerialTelemetryv:00000000 _Z19sendSerialTelemetryv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:11133  .text._Z19sendSerialTelemetryv:0000023c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:11154  .text._Z19sendSerialTelemetryv:00000288 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:11543  .text._Z19sendSerialTelemetryv:00000500 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:11568  .text._Z22hottV4SerialClearInputv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:11573  .text._Z22hottV4SerialClearInputv:00000000 _Z22hottV4SerialClearInputv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:11602  .text._Z22hottV4SerialClearInputv:00000018 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:11607  .text._Z16hottV4SerialReadv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:11612  .text._Z16hottV4SerialReadv:00000000 _Z16hottV4SerialReadv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:11654  .text._Z16hottV4SerialReadv:0000002c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:11659  .text._Z8SetDelayj:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:11664  .text._Z8SetDelayj:00000000 _Z8SetDelayj
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:11683  .text._Z8SetDelayj:0000000c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:11688  .text._Z10CheckDelayj:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:11693  .text._Z10CheckDelayj:00000000 _Z10CheckDelayj
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:11714  .text._Z10CheckDelayj:00000014 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:11719  .text._Z10hottv4InitP14HardwareSerial:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:11724  .text._Z10hottv4InitP14HardwareSerial:00000000 _Z10hottv4InitP14HardwareSerial
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:11745  .text._Z10hottv4InitP14HardwareSerial:0000000c $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:11750  .text._Z10hottV4Hookh:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:11755  .text._Z10hottV4Hookh:00000000 _Z10hottV4Hookh
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:12309  .text._Z10hottV4Hookh:00000308 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:12334  .text._Z10hottV4Hookh:00000364 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:12409  .text._Z10hottV4Hookh:000003cc $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:12416  .text._Z11hottHandlerv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:12421  .text._Z11hottHandlerv:00000000 _Z11hottHandlerv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:12442  .text._Z11hottHandlerv:0000000e $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:12446  .text._Z11hottHandlerv:00000012 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:12573  .text._Z11hottHandlerv:000000ac $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:12584  .text._Z5setupv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:12589  .text._Z5setupv:00000000 _Z5setupv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:12705  .text._Z5setupv:000000c8 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:12717  .text._Z4loopv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:12722  .text._Z4loopv:00000000 _Z4loopv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:12971  .text._Z4loopv:00000194 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:12994  .text.startup.main:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:12999  .text.startup.main:00000000 main
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13020  .text.startup._GLOBAL__sub_I__Z7premainv:00000000 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13024  .text.startup._GLOBAL__sub_I__Z7premainv:00000000 _GLOBAL__sub_I__Z7premainv
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:948    .text._ZN14HardwareSPIExtC2Ej:00000000 _ZN14HardwareSPIExtC1Ej
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13060  .text.startup._GLOBAL__sub_I__Z7premainv:00000028 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14336  .bss.hottTime:00000000 hottTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14138  .bss.hottState:00000000 hottState
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14254  .bss.isGPSOff:00000000 isGPSOff
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13687  .bss.isHoldOn:00000000 isHoldOn
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13383  .bss.isNavOn:00000000 isNavOn
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14362  .bss.isAHOn:00000000 isAHOn
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13443  .bss.isAHOff:00000000 isAHOff
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13291  .bss.CountMilliseconds:00000000 CountMilliseconds
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14275  .bss.hottV4Serial:00000000 hottV4Serial
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13476  .data.queryType:00000000 queryType
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13713  .bss.flashingLedState:00000000 flashingLedState
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13976  .bss.headingTime:00000000 headingTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13720  .bss.setHeading:00000000 setHeading
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13733  .bss.motorConfiguratorCommand:00000000 motorConfiguratorCommand
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13351  .bss.motorMinCommand:00000000 motorMinCommand
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14289  .bss.motorMaxCommand:00000000 motorMaxCommand
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14303  .bss.motorAxisCommandYaw:00000000 motorAxisCommandYaw
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13497  .bss.motorAxisCommandPitch:00000000 motorAxisCommandPitch
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14449  .bss.motorAxisCommandRoll:00000000 motorAxisCommandRoll
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14179  .data.batteryData:00000000 batteryData
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13694  .data.batteryWarningCellVoltage:00000000 batteryWarningCellVoltage
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14282  .data.batteryAlarmCellVoltage:00000000 batteryAlarmCellVoltage
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14514  .bss.buzzerState:00000000 buzzerState
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14236  .bss.batteryWarning:00000000 batteryWarning
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14230  .bss.batteryAlarm:00000000 batteryAlarm
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13581  .bss.numberOfBatteries:00000000 numberOfBatteries
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13524  .data.MS5611_first_read:00000000 MS5611_first_read
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14383  .bss.baroStartTime:00000000 baroStartTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14113  .bss.baroGroundUpdateDone:00000000 baroGroundUpdateDone
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13587  .bss.rawPressureSumCount:00000000 rawPressureSumCount
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14509  .bss.rawPressureSum:00000000 rawPressureSum
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13655  .bss.isReadPressure:00000000 isReadPressure
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13635  .data.pressureFactor:00000000 pressureFactor
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13344  .bss.pressureCount:00000000 pressureCount
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14172  .bss.rawTemperature:00000000 rawTemperature
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13364  .bss.rawPressure:00000000 rawPressure
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14045  .bss.pressure:00000000 pressure
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13833  .bss.MS5611_offset:00000000 MS5611_offset
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13312  .bss.MS5611_sens:00000000 MS5611_sens
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13789  .bss.MS5611lastRawPressure:00000000 MS5611lastRawPressure
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14066  .bss.MS5611lastRawTemperature:00000000 MS5611lastRawTemperature
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14268  .bss.MS5611Prom:00000000 MS5611Prom
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13332  .data.baroSmoothFactor:00000000 baroSmoothFactor
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13490  .bss.baroGroundAltitude:00000000 baroGroundAltitude
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14107  .bss.baroRawAltitude:00000000 baroRawAltitude
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14052  .bss.baroAltitude:00000000 baroAltitude
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14369  .bss.localHeading:00000000 localHeading
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14126  .bss.headingGyroZero:00000000 headingGyroZero
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13675  .bss.filter2:00000000 filter2
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14422  .data.filter1:00000000 filter1
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13894  .bss.compassDeclination:00000000 compassDeclination
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13600  .bss.trueNorthHeading:00000000 trueNorthHeading
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13796  .data.magScale:00000000 magScale
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13775  .bss.magBias:00000000 magBias
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13423  .bss.rawMag:00000000 rawMag
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13409  .bss.measuredMag:00000000 measuredMag
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13768  .bss.measuredMagZ:00000000 measuredMagZ
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13761  .bss.measuredMagY:00000000 measuredMagY
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13754  .bss.measuredMagX:00000000 measuredMagX
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13747  .bss.hdgY:00000000 hdgY
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13740  .bss.hdgX:00000000 hdgX
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13562  .bss.MotorInfo:00000000 MotorInfo
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13504  .bss.motorCommand:00000000 motorCommand
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13542  .data.numberOfMotors:00000000 numberOfMotors
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13397  .bss.FrqData:00000000 FrqData
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13860  .bss.currentChannel:00000000 currentChannel
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14093  .data.rawChannelValue:00000000 rawChannelValue
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13628  .bss.previousEz:00000000 previousEz
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13621  .bss.previousEy:00000000 previousEy
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13614  .bss.previousEx:00000000 previousEx
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13537  .bss.ezInt:00000000 ezInt
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13607  .bss.eyInt:00000000 eyInt
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14198  .bss.exInt:00000000 exInt
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13826  .bss.q3:00000000 q3
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13819  .bss.q2:00000000 q2
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13812  .bss.q1:00000000 q1
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13805  .bss.q0:00000000 q0
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13881  .bss.halfT:00000000 halfT
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13929  .bss.Ki:00000000 Ki
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13955  .bss.Kp:00000000 Kp
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13449  .bss.accelCutoff:00000000 accelCutoff
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14224  .bss.earthAccel:00000000 earthAccel
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13901  .bss.correctedRateVector:00000000 correctedRateVector
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14356  .bss.gyroAngle:00000000 gyroAngle
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14079  .bss.kinematicsAngle:00000000 kinematicsAngle
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14394  .bss.kinematicsType:00000000 kinematicsType
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13470  .bss.previousMeasureCriticalSensorsTime:00000000 previousMeasureCriticalSensorsTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13593  .bss.accelSampleCount:00000000 accelSampleCount
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13840  .bss.accelSample:00000000 accelSample
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14408  .bss.meterPerSecSec:00000000 meterPerSecSec
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14218  .bss.accelOneG:00000000 accelOneG
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14562  .bss.runTimeAccelBias:00000000 runTimeAccelBias
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13867  .bss.accelScaleFactor:00000000 accelScaleFactor
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14249  .bss.gyroSampleCount:00000000 gyroSampleCount
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14243  .bss.gyroLastMesuredTime:00000000 gyroLastMesuredTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13358  .bss.gyroHeading:00000000 gyroHeading
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14502  .bss.gyroScaleFactor:00000000 gyroScaleFactor
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14521  .bss.gyroSample:00000000 gyroSample
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14211  .bss.gyroZero:00000000 gyroZero
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14059  .bss.gyroRate:00000000 gyroRate
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13649  .bss.readMPU6000GyroCount:00000000 readMPU6000GyroCount
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13969  .bss.readMPU6000AccelCount:00000000 readMPU6000AccelCount
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13416  .bss.readMPU6000Count:00000000 readMPU6000Count
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14038  .bss.initializeMPU6000SensorsDone:00000000 initializeMPU6000SensorsDone
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14145  .bss.spiMPU6000:00000000 spiMPU6000
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14415  .bss.MPU6000:00000000 MPU6000
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14442  .bss.vehicleState:00000000 vehicleState
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14166  .bss.gyroRaw:00000000 gyroRaw
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14342  .rodata.Serial:00000000 Serial
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14152  .bss.fourthOrder:00000000 fourthOrder
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13325  .bss.windupGuard:00000000 windupGuard
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14401  .bss.PID:00000000 PID
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13661  .bss.fastTransfer:00000000 fastTransfer
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13962  .bss.baroAltitudeToHoldTarget:00000000 baroAltitudeToHoldTarget
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13700  .bss.isStoreAltitudeNeeded:00000000 isStoreAltitudeNeeded
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14456  .data.altitudeHoldThrottle:00000000 altitudeHoldThrottle
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14086  .data.maxThrottleAdjust:00000000 maxThrottleAdjust
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13874  .data.minThrottleAdjust:00000000 minThrottleAdjust
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13378  .data.altitudeHoldPanicStickMovement:00000000 altitudeHoldPanicStickMovement
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13518  .data.altitudeHoldBump:00000000 altitudeHoldBump
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14204  .bss.altitudeHoldState:00000000 altitudeHoldState
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14469  .data.batteryMonitorGoingDownTime:00000000 batteryMonitorGoingDownTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14119  .bss.batteryMonitorStartTime:00000000 batteryMonitorStartTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14323  .data.batteryMonitorThrottleTarget:00000000 batteryMonitorThrottleTarget
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14072  .bss.batteryMonitorStartThrottle:00000000 batteryMonitorStartThrottle
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13463  .data.batteryMonitorAlarmVoltage:00000000 batteryMonitorAlarmVoltage
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13555  .bss.headingHoldState:00000000 headingHoldState
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14349  .bss.relativeHeading:00000000 relativeHeading
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13483  .bss.heading:00000000 heading
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13888  .bss.headingHold:00000000 headingHold
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13530  .bss.headingHoldConfig:00000000 headingHoldConfig
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13847  .bss.aref:00000000 aref
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14490  .bss.hundredHZpreviousTime:00000000 hundredHZpreviousTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13915  .bss.fiftyHZpreviousTime:00000000 fiftyHZpreviousTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13437  .bss.lowPriorityTenHZpreviousTime2:00000000 lowPriorityTenHZpreviousTime2
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14316  .bss.lowPriorityTenHZpreviousTime:00000000 lowPriorityTenHZpreviousTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13430  .bss.tenHZpreviousTime:00000000 tenHZpreviousTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13948  .bss.oneHZpreviousTime:00000000 oneHZpreviousTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13707  .bss.deltaTime:00000000 deltaTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13456  .bss.currentTime:00000000 currentTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14476  .bss.previousTime:00000000 previousTime
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14329  .data.SpeakHoTT:00000000 SpeakHoTT
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13549  .data.rotationSpeedFactor:00000000 rotationSpeedFactor
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13726  .bss.inFlight:00000000 inFlight
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13371  .bss.filteredAccel:00000000 filteredAccel
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13402  .bss.minLimit:00000000 minLimit
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14495  .bss.maxLimit:00000000 maxLimit
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14462  .bss.safetyCheck:00000000 safetyCheck
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13318  .bss.motorArmed:00000000 motorArmed
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14159  .data.throttle:00000000 throttle
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14483  .data.G_Dt:00000000 G_Dt
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13682  .bss.minArmedThrottle:00000000 minArmedThrottle
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13922  .bss.frameCounter:00000000 frameCounter
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14435  .bss.flightMode:00000000 flightMode
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13782  .data.testCommand:00000000 testCommand
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14132  .bss.calibrateESC:00000000 calibrateESC
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14535  .bss.channelCal:00000000 channelCal
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13390  .bss.receiverSmoothFactor:00000000 receiverSmoothFactor
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14376  .bss.receiverOffset:00000000 receiverOffset
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14429  .bss.receiverSlope:00000000 receiverSlope
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13936  .bss.receiverCommandSmooth:00000000 receiverCommandSmooth
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13854  .bss.receiverCommand:00000000 receiverCommand
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14296  .bss.receiverZero:00000000 receiverZero
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13305  .bss.receiverData:00000000 receiverData
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13298  .bss.receiverXmitFactor:00000000 receiverXmitFactor
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14261  .bss.lastReceiverChannel:00000000 lastReceiverChannel
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13287  .bss.CountMilliseconds:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13294  .bss.receiverXmitFactor:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13301  .bss.receiverData:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13308  .bss.MS5611_sens:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13319  .bss.motorArmed:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13321  .bss.windupGuard:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13328  .data.baroSmoothFactor:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13338  .bss._ZL26hottV4TelemetryBufferIndex:00000000 _ZL26hottV4TelemetryBufferIndex
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13339  .bss._ZL26hottV4TelemetryBufferIndex:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13345  .bss.pressureCount:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13347  .bss.motorMinCommand:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13354  .bss.gyroHeading:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13361  .bss.rawPressure:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13367  .bss.filteredAccel:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13374  .data.altitudeHoldPanicStickMovement:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13384  .bss.isNavOn:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13386  .bss.receiverSmoothFactor:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13393  .bss.FrqData:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13403  .bss.minLimit:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13405  .bss.measuredMag:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13412  .bss.readMPU6000Count:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13419  .bss.rawMag:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13426  .bss.tenHZpreviousTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13433  .bss.lowPriorityTenHZpreviousTime2:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13444  .bss.isAHOff:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13446  .bss.accelCutoff:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13452  .bss.currentTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13459  .data.batteryMonitorAlarmVoltage:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13466  .bss.previousMeasureCriticalSensorsTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13479  .bss.heading:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13486  .bss.baroGroundAltitude:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13493  .bss.motorAxisCommandPitch:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13500  .bss.motorCommand:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13507  .bss._ZZL15hottVoiceOutputvE6repeat:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13511  .bss._ZZL15hottVoiceOutputvE6repeat:00000000 _ZZL15hottVoiceOutputvE6repeat
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13514  .data.altitudeHoldBump:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13531  .bss.headingHoldConfig:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13533  .bss.ezInt:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13545  .data.rotationSpeedFactor:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13556  .bss.headingHoldState:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13558  .bss.MotorInfo:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13568  .rodata._ZL19stm32_motor_mapping:00000000 _ZL19stm32_motor_mapping
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13582  .bss.numberOfBatteries:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13588  .bss.rawPressureSumCount:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13594  .bss.accelSampleCount:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13596  .bss.trueNorthHeading:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13603  .bss.eyInt:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13610  .bss.previousEx:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13617  .bss.previousEy:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13624  .bss.previousEz:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13631  .data.pressureFactor:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13638  .data._ZL11minAltitude:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13642  .data._ZL11minAltitude:00000000 _ZL11minAltitude
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13645  .bss.readMPU6000GyroCount:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13656  .bss.isReadPressure:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13662  .bss.fastTransfer:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13664  .bss._ZZL22hottv4UpdateFlightTimePhE17previousEAMUpdate:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13668  .bss._ZZL22hottv4UpdateFlightTimePhE17previousEAMUpdate:00000000 _ZZL22hottv4UpdateFlightTimePhE17previousEAMUpdate
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13671  .bss.filter2:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13678  .bss.minArmedThrottle:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13688  .bss.isHoldOn:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13690  .data.batteryWarningCellVoltage:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13701  .bss.isStoreAltitudeNeeded:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13703  .bss.deltaTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13714  .bss.flashingLedState:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13716  .bss.setHeading:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13727  .bss.inFlight:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13729  .bss.motorConfiguratorCommand:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13736  .bss.hdgX:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13743  .bss.hdgY:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13750  .bss.measuredMagX:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13757  .bss.measuredMagY:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13764  .bss.measuredMagZ:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13771  .bss.magBias:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13778  .data.testCommand:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13785  .bss.MS5611lastRawPressure:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13792  .data.magScale:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13801  .bss.q0:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13808  .bss.q1:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13815  .bss.q2:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13822  .bss.q3:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13829  .bss.MS5611_offset:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13836  .bss.accelSample:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13843  .bss.aref:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13850  .bss.receiverCommand:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13861  .bss.currentChannel:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13863  .bss.accelScaleFactor:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13870  .data.minThrottleAdjust:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13877  .bss.halfT:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13884  .bss.headingHold:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13891  .bss.compassDeclination:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13897  .bss.correctedRateVector:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13904  .bss._ZL12milliseconds:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13908  .bss._ZL12milliseconds:00000000 _ZL12milliseconds
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13911  .bss.fiftyHZpreviousTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13918  .bss.frameCounter:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13925  .bss.Ki:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13932  .bss.receiverCommandSmooth:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13942  .bss._ZL21hottV4TelemetryBuffer:00000000 _ZL21hottV4TelemetryBuffer
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13943  .bss._ZL21hottV4TelemetryBuffer:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13945  .bss.oneHZpreviousTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13951  .bss.Kp:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13958  .bss.baroAltitudeToHoldTarget:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13965  .bss.readMPU6000AccelCount:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:13972  .bss.headingTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14039  .bss.initializeMPU6000SensorsDone:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14041  .bss.pressure:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14048  .bss.baroAltitude:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14055  .bss.gyroRate:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14062  .bss.MS5611lastRawTemperature:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14069  .bss.batteryMonitorStartThrottle:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14075  .bss.kinematicsAngle:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14082  .data.maxThrottleAdjust:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14089  .data.rawChannelValue:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14103  .bss.baroRawAltitude:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14114  .bss.baroGroundUpdateDone:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14116  .bss.batteryMonitorStartTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14122  .bss.headingGyroZero:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14133  .bss.calibrateESC:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14139  .bss.hottState:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14141  .bss.spiMPU6000:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14148  .bss.fourthOrder:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14155  .data.throttle:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14162  .bss.gyroRaw:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14169  .bss.rawTemperature:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14175  .data.batteryData:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14194  .bss.exInt:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14205  .bss.altitudeHoldState:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14207  .bss.gyroZero:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14214  .bss.accelOneG:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14221  .bss.earthAccel:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14231  .bss.batteryAlarm:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14237  .bss.batteryWarning:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14239  .bss.gyroLastMesuredTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14250  .bss.gyroSampleCount:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14255  .bss.isGPSOff:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14257  .bss.lastReceiverChannel:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14264  .bss.MS5611Prom:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14271  .bss.hottV4Serial:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14278  .data.batteryAlarmCellVoltage:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14285  .bss.motorMaxCommand:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14292  .bss.receiverZero:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14299  .bss.motorAxisCommandYaw:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14309  .bss._ZL7minutes:00000000 _ZL7minutes
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14310  .bss._ZL7minutes:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14312  .bss.lowPriorityTenHZpreviousTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14319  .data.batteryMonitorThrottleTarget:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14332  .bss.hottTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14339  .rodata.Serial:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14345  .bss.relativeHeading:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14352  .bss.gyroAngle:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14363  .bss.isAHOn:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14365  .bss.localHeading:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14372  .bss.receiverOffset:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14379  .bss.baroStartTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14389  .bss._ZZL15hottVoiceOutputvE9oldStatus:00000000 _ZZL15hottVoiceOutputvE9oldStatus
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14390  .bss._ZZL15hottVoiceOutputvE9oldStatus:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14395  .bss.kinematicsType:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14397  .bss.PID:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14404  .bss.meterPerSecSec:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14411  .bss.MPU6000:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14418  .data.filter1:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14425  .bss.receiverSlope:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14436  .bss.flightMode:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14438  .bss.vehicleState:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14445  .bss.motorAxisCommandRoll:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14452  .data.altitudeHoldThrottle:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14463  .bss.safetyCheck:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14465  .data.batteryMonitorGoingDownTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14472  .bss.previousTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14479  .data.G_Dt:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14486  .bss.hundredHZpreviousTime:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14496  .bss.maxLimit:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14498  .bss.gyroScaleFactor:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14505  .bss.rawPressureSum:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14515  .bss.buzzerState:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14517  .bss.gyroSample:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14524  .bss._ZL19_stm32_motor_number:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14528  .bss._ZL19_stm32_motor_number:00000000 _ZL19_stm32_motor_number
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14531  .bss.channelCal:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14538  .data._ZL11maxAltitude:00000000 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14542  .data._ZL11maxAltitude:00000000 _ZL11maxAltitude
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14548  .rodata._ZL18ReceiverChannelMap:00000000 _ZL18ReceiverChannelMap
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:14558  .bss.runTimeAccelBias:00000000 $d
                     .debug_frame:00000010 $d
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:10786  .text._Z18reportVehicleStatev:00000124 $t
C:\Users\LORDHA~1\AppData\Local\Temp\ccvUPXNM.s:11567  .text._Z19sendSerialTelemetryv:00000554 $t
                           .group:00000000 _ZN14HardwareSPIExtC5Ej

UNDEFINED SYMBOLS
systick_uptime_millis
_Z4initv
_ZN11HardwareSPIC2Ej
_ZN11HardwareSPI6nssPinEv
_Z12digitalWritehh
_Z7pinModeh13WiringPinMode
_ZN11HardwareSPI5beginE12SPIFrequencyjj
_ZN11HardwareSPI8transferEh
_ZN11HardwareSPI3endEv
_Z5delaym
_ZN5Print7printlnEPKc
SerialUSB
_Z13findMedianIntPii
_Z17delayMicrosecondsj
_ZN7TwoWire5beginEhh
Wire
__aeabi_f2d
__aeabi_d2f
sqrt
_Z10isSwitchedff
atan2
asin
rcc_dev_timer_clk_speed
gpio_set_mode
timer_attach_interrupt
PIN_MAP
_Z12filterSmoothfff
__aeabi_dsub
__aeabi_dadd
fmod
_Z12readShortI2Cv
_Z11sendByteI2Cih
_ZN7TwoWire11requestFromEii
_Z17updateRegisterI2Cihh
cos
sin
_Z10readWhoI2Ci
_Z11readWordI2Cv
_ZN7TwoWire9availableEv
_Z11readByteI2Cv
__aeabi_l2f
__aeabi_dmul
pow
_Z10analogReadh
_ZN11EEPROMClass4readEt
EEPROM
_ZN11EEPROMClass5writeEtt
_ZN9USBSerial9availableEv
_ZN9USBSerial4readEv
memset
atof
atol
_ZN5Print5printEc
_ZN5Print5printEli
_ZN5Print5printEhi
_ZN5Print5printEmi
_ZN5Print5printEii
_ZN5Print5printEdi
_ZN5Print5printEPKc
_ZN5Print7printlnEii
_ZN5Print7printlnEdi
_ZN5Print7printlnEv
_ZN5Print7printlnEmi
_ZN14HardwareSerial4readEv
_ZN14HardwareSerial9availableEv
_ZN14HardwareSerial5beginEj
snprintf
strlen
_ZN9USBSerial5beginEi
Serial3
